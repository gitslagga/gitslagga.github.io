<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="E1ct36DyjSpaeX5NMAVsyzCjDs8-dQxGThgvw2i1yg0">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"gitslagga.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.21.0","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/config.min.js"></script>

    <meta name="description" content="21 - 格式化输出在本章中，我们将继续探讨与文本相关的工具，重点关注用于格式化文本输出的程序，而不是改变文本本身。这些工具通常用于准备最终打印的文本，这是我们将在下一章中讨论的主题。我们将介绍以下程序：  nl - 编号行  fold - 将每行文本折叠到指定长度">
<meta property="og:type" content="article">
<meta property="og:title" content="格式化输出">
<meta property="og:url" content="https://gitslagga.github.io/2024/04/21-formatting-output/index.html">
<meta property="og:site_name" content="计算机那些事">
<meta property="og:description" content="21 - 格式化输出在本章中，我们将继续探讨与文本相关的工具，重点关注用于格式化文本输出的程序，而不是改变文本本身。这些工具通常用于准备最终打印的文本，这是我们将在下一章中讨论的主题。我们将介绍以下程序：  nl - 编号行  fold - 将每行文本折叠到指定长度">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitslagga.github.io/images/2024/Picture5.png">
<meta property="og:image" content="https://gitslagga.github.io/images/2024/Picture6.png">
<meta property="article:published_time" content="2024-04-26T07:55:30.000Z">
<meta property="article:modified_time" content="2025-06-06T06:13:40.953Z">
<meta property="article:author" content="Slagga">
<meta property="article:tag" content="TLCL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitslagga.github.io/images/2024/Picture5.png">


<link rel="canonical" href="https://gitslagga.github.io/2024/04/21-formatting-output/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://gitslagga.github.io/2024/04/21-formatting-output/","path":"2024/04/21-formatting-output/","title":"格式化输出"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>格式化输出 | 计算机那些事</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-0E2T2VNH5S"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-0E2T2VNH5S","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/analytics/google-analytics.min.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">计算机那些事</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">软件开发、维护和升级</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">229</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">78</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">28</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="nav-number">1.</span> <span class="nav-text">21 - 格式化输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="nav-number">1.1.</span> <span class="nav-text">简单格式化工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#nl-%E2%80%93-%E7%BC%96%E5%8F%B7%E8%A1%8C"><span class="nav-number">1.1.1.</span> <span class="nav-text">nl – 编号行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fold-%E5%B0%86%E6%AF%8F%E8%A1%8C%E6%96%87%E6%9C%AC%E6%8A%98%E5%8F%A0%E5%88%B0%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6"><span class="nav-number">1.1.2.</span> <span class="nav-text">fold - 将每行文本折叠到指定长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fmt-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="nav-number">1.1.3.</span> <span class="nav-text">fmt - 一个简单的文本格式化工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pr-%E4%B8%BA%E6%89%93%E5%8D%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC"><span class="nav-number">1.1.4.</span> <span class="nav-text">pr - 为打印格式化文本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#printf-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B9%B6%E6%89%93%E5%8D%B0%E6%95%B0%E6%8D%AE"><span class="nav-number">1.1.5.</span> <span class="nav-text">printf - 格式化并打印数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.2.</span> <span class="nav-text">文档格式化系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#groff"><span class="nav-number">1.2.1.</span> <span class="nav-text">groff</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%98%85%E8%AF%BB"><span class="nav-number">1.4.</span> <span class="nav-text">进一步阅读</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Slagga"
      src="https://avatars.githubusercontent.com/u/19620432">
  <p class="site-author-name" itemprop="name">Slagga</p>
  <div class="site-description" itemprop="description">Computer Things - Software Development, Maintenance and Upgrade</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">229</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdHNsYWdnYQ==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gitslagga"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnNsYWdnYUBkdWNrLmNvbQ==" title="E-Mail → mailto:slagga@duck.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gitslagga.github.io/2024/04/21-formatting-output/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/19620432">
      <meta itemprop="name" content="Slagga">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="计算机那些事">
      <meta itemprop="description" content="Computer Things - Software Development, Maintenance and Upgrade">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="格式化输出 | 计算机那些事">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          格式化输出
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-26 15:55:30" itemprop="dateCreated datePublished" datetime="2024-04-26T15:55:30+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-06 14:13:40" itemprop="dateModified" datetime="2025-06-06T14:13:40+08:00">2025-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="21-格式化输出"><a href="#21-格式化输出" class="headerlink" title="21 - 格式化输出"></a>21 - 格式化输出</h2><p>在本章中，我们将继续探讨与文本相关的工具，重点关注用于格式化文本输出的程序，而不是改变文本本身。这些工具通常用于准备最终打印的文本，这是我们将在下一章中讨论的主题。我们将介绍以下程序：</p>
<ul>
<li><p>nl - 编号行</p>
</li>
<li><p>fold - 将每行文本折叠到指定长度</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>fmt - 一个简单的文本格式化工具</p>
</li>
<li><p>pr - 准备文本以供打印</p>
</li>
<li><p>printf - 格式化并打印数据</p>
</li>
<li><p>groff - 一个文档格式化系统</p>
</li>
</ul>
<h3 id="简单格式化工具"><a href="#简单格式化工具" class="headerlink" title="简单格式化工具"></a>简单格式化工具</h3><p>我们首先来看一些简单的格式化工具。这些工具大多是单一用途的程序，在功能上比较简单，但它们可以用于小任务以及作为管道和脚本的一部分。</p>
<h4 id="nl-–-编号行"><a href="#nl-–-编号行" class="headerlink" title="nl – 编号行"></a>nl – 编号行</h4><p>nl 程序是一个用于执行简单任务的相当古老的工具。它对行进行编号。在最简单的用法中，它类似于 cat -n。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">nl</span> distros.txt | <span class="built_in">head</span></span><br><span class="line"> 1 SUSE 10.2 12/07/2006</span><br><span class="line"> 2 Fedora 10 11/25/2008</span><br><span class="line"> 3 SUSE 11.0 06/19/2008</span><br><span class="line"> 4 Ubuntu 8.04 04/24/2008</span><br><span class="line"> 5 Fedora 8 11/08/2007</span><br><span class="line"> 6 SUSE 10.3 10/04/2007</span><br><span class="line"> 7 Ubuntu 6.10 10/26/2006</span><br><span class="line"> 8 Fedora 7 05/31/2007</span><br><span class="line"> 9 Ubuntu 7.10 10/18/2007</span><br><span class="line"> 10 Ubuntu 7.04 04/19/2007</span><br></pre></td></tr></table></figure>

<p>就像 cat 一样，nl 可以接受多个文件作为命令行参数，或者接受标准输入。然而，nl 有许多选项，并支持一种原始形式的标记，以允许更复杂的编号方式。</p>
<p>nl 支持所谓的“逻辑页面”概念进行编号。这允许 nl 在编号时重置（重新开始）数字序列。使用选项，可以将起始数字设置为特定值，并且在有限的范围内，还可以设置其格式。逻辑页面进一步分为头部、主体和尾部。在这些部分中，行编号可能被重置和&#x2F;或被分配不同的样式。如果给 nl 提供多个文件，它将它们视为单一的文本流。文本流中的部分由一些相当奇怪的标记的存在来指示，如表 21-1 所述。</p>
<p><em>表 21-1: nl 标记</em></p>
<table>
<thead>
<tr>
<th><strong>标记</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>\:\:\:</td>
<td>开始逻辑页面头部</td>
</tr>
<tr>
<td>\:\:</td>
<td>开始逻辑页面主体</td>
</tr>
<tr>
<td>\:</td>
<td>开始逻辑页面尾部</td>
</tr>
</tbody></table>
<p>表 21-1 中列出的每个标记元素必须单独出现在其自己的行上。处理标记元素后，nl 会从文本流中删除它。</p>
<p>表 21-2 列出了 nl 的常用选项。</p>
<p><em>表 21-2: 常用 nl 选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-b <em>style</em></td>
<td>设置主体编号为 <em>style</em>，其中 <em>style</em> 可以是以下之一：a &#x3D; 编号所有行 t &#x3D; 仅编号非空白行。这是默认值。n &#x3D; 无p<em>regexp</em> &#x3D; 仅编号与基本正则表达式 <em>regexp</em> 匹配的行。</td>
</tr>
<tr>
<td>-f <em>style</em></td>
<td>设置尾部编号为 <em>style</em>。默认值为 n（无）。</td>
</tr>
<tr>
<td>-h <em>style</em></td>
<td>设置头部编号为 <em>style</em>。默认值为 n（无）。</td>
</tr>
<tr>
<td>-i <em>number</em></td>
<td>设置页面编号增量为 <em>number</em>。默认值为一。</td>
</tr>
<tr>
<td>-n <em>format</em></td>
<td>将编号格式设置为 <em>format</em>，其中 <em>format</em> 可以是以下之一：ln &#x3D; 左对齐，不带前导零。rn &#x3D; 右对齐，不带前导零。这是默认值。rz &#x3D; 右对齐，带前导零。</td>
</tr>
<tr>
<td>-p</td>
<td>不在每个逻辑页面的开始处重置页面编号。</td>
</tr>
<tr>
<td>-s <em>string</em></td>
<td>在每个行号后添加 <em>string</em> 以创建分隔符。默认值是一个制表符。</td>
</tr>
<tr>
<td>-v <em>number</em></td>
<td>将每个逻辑页面的第一行号设置为 <em>number</em>。默认值为一。</td>
</tr>
<tr>
<td>-w <em>width</em></td>
<td>将行号字段的宽度设置为 <em>width</em>。默认值为 6。</td>
</tr>
</tbody></table>
<p>虽然我们可能不会经常编号行，但我们可以使用 nl 来看看我们如何可以结合多个工具来执行更复杂的任务。我们将在上一章的工作基础上，生成一个 Linux 发行版报告。由于我们将使用 nl，因此将其头部&#x2F;主体&#x2F;尾部标记包含在内会很有用。为此，我们将把它添加到上一章的 sed 脚本中。使用文本编辑器，我们将脚本更改如下并将其保存为 distros-nl.sed：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sed 脚本生成 Linux 发行版报告</span></span><br><span class="line">1 i\</span><br><span class="line">\\:\\:\\:\</span><br><span class="line">\</span><br><span class="line">Linux 发行版报告\</span><br><span class="line">\</span><br><span class="line">名称 版本 发布日期\</span><br><span class="line">---- ---- --------\</span><br><span class="line">\\:\\:</span><br><span class="line">s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/</span><br><span class="line">$ a\</span><br><span class="line">\\:\</span><br><span class="line">\</span><br><span class="line">报告结束</span><br></pre></td></tr></table></figure>

<p>脚本现在插入了 nl 逻辑页面标记，并在报告的末尾添加了一个尾部。注意，我们必须在标记中加倍使用反斜杠，因为它们通常被 sed 解释为转义字符。</p>
<p>接下来，我们将通过结合 sort、sed 和 nl 来生成我们的增强报告。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> -k 1,1 -k 2n distros.txt | sed -f distros-nl.sed | <span class="built_in">nl</span></span><br><span class="line"></span><br><span class="line"> Linux 发行版报告</span><br><span class="line"></span><br><span class="line"> 名称 版本 发布日期</span><br><span class="line"> ---- ---- --------</span><br><span class="line"> 1 Fedora 5 2006-03-20</span><br><span class="line"> 2 Fedora 6 2006-10-24</span><br><span class="line"> 3 Fedora 7 2007-05-31</span><br><span class="line"> 4 Fedora 8 2007-11-08</span><br><span class="line"> 5 Fedora 9 2008-05-13</span><br><span class="line"> 6 Fedora 10 2008-11-25</span><br><span class="line"> 7 SUSE 10.1 2006-05-11</span><br><span class="line"> 8 SUSE 10.2 2006-12-07</span><br><span class="line"> 9 SUSE 10.3 2007-10-04</span><br><span class="line"> 10 SUSE 11.0 2008-06-19</span><br><span class="line"> 11 Ubuntu 6.06 2006-06-01</span><br><span class="line"> 12 Ubuntu 6.10 2006-10-26</span><br><span class="line"> 13 Ubuntu 7.04 2007-04-19</span><br><span class="line"> 14 Ubuntu 7.10 2007-10-18</span><br><span class="line"> 15 Ubuntu 8.04 2008-04-24</span><br><span class="line"> 16 Ubuntu 8.10 2008-10-30</span><br><span class="line"></span><br><span class="line"> 报告结束</span><br></pre></td></tr></table></figure>

<p>我们的报告是命令管道的结果。首先，我们按发行版名称和版本（字段 1 和 2）对列表进行排序，然后我们用 sed 处理结果，添加报告头部（包括逻辑页面标记以供 nl 使用）和尾部。最后，我们用 nl 处理结果，它默认只对文本流属于逻辑页面主体部分的行进行编号。</p>
<p>我们可以重复命令并尝试不同的 nl 选项。一些有趣的选项包括：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nl</span> -n rz</span><br></pre></td></tr></table></figure>

<p>以及以下选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nl</span> -w 3 -s <span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="fold-将每行文本折叠到指定长度"><a href="#fold-将每行文本折叠到指定长度" class="headerlink" title="fold - 将每行文本折叠到指定长度"></a>fold - 将每行文本折叠到指定长度</h4><p><em>折叠</em> 是指在指定宽度处断开文本行的过程。和我们的其他命令一样，fold 接受一个或多个文本文件或标准输入。如果我们向 fold 发送一个简单的文本流，我们可以看到它是如何工作的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;The quick brown fox jumped over the lazy dog.&quot;</span> | <span class="built_in">fold</span> -w 12</span><br><span class="line">The quick br</span><br><span class="line">own fox jump</span><br><span class="line">ed over the</span><br><span class="line">lazy dog.</span><br></pre></td></tr></table></figure>

<p>在这里我们看到 fold 的作用。由 echo 命令发送的文本被分成由 -w 选项指定的段。在这个例子中，我们指定了一个宽度为 12 个字符的行宽。如果没有指定宽度，默认为 80 个字符。注意无论单词边界如何，行都会被断开。添加 -s 选项将导致 fold 在达到行宽之前的最后一个可用空间处断开行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;The quick brown fox jumped over the lazy dog.&quot;</span> | <span class="built_in">fold</span> -w 12 -s</span><br><span class="line">The quick</span><br><span class="line">brown fox</span><br><span class="line">jumped over</span><br><span class="line">the lazy</span><br><span class="line">dog.</span><br></pre></td></tr></table></figure>

<h4 id="fmt-一个简单的文本格式化工具"><a href="#fmt-一个简单的文本格式化工具" class="headerlink" title="fmt - 一个简单的文本格式化工具"></a>fmt - 一个简单的文本格式化工具</h4><p>fmt 程序也会折叠文本，并且做得更多。它接受文件或标准输入，并对文本流执行段落格式化。基本上，它在保留空行和缩进的同时，填充和连接文本中的行。</p>
<p>为了演示，我们需要一些文本。让我们从 fmt 的信息页中提取一些内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> `<span class="built_in">fmt</span><span class="string">&#x27; 从指定的 FILE 参数（如果没有给出则从标准输入）读取，并写入到标准输出。</span></span><br><span class="line"><span class="string">默认情况下，空行、单词之间的空格和缩进在输出中被保留；不同缩进的连续输入行不会被连接；在输入时扩展制表符，在输出时引入制表符。</span></span><br><span class="line"><span class="string"> `fmt&#x27;</span> 更喜欢在句子的末尾断开行，并尝试避免在句子的第一个单词之后或最后一个单词之前断开行。<span class="string">&quot;句子断点&quot;</span>被定义为段落的末尾或以任何 `.?!<span class="string">&#x27; 结尾的单词，后跟两个空格或行尾，忽略任何介于两者之间的括号或引号。像 TeX 一样，`fmt&#x27;</span> 在选择断行前会读取整个<span class="string">&quot;段落&quot;</span>；该算法是 Donald E. Knuth 和 Michael F. Plass 在 <span class="string">&quot;Breaking Paragraphs Into Lines&quot;</span>，`Software--Practice &amp; Experience<span class="string">&#x27; 11, 11（1981 年 11 月），1119-1184 中给出的算法的一个变种。</span></span><br></pre></td></tr></table></figure>

<p>我们将把这段文本复制到文本编辑器中并将文件保存为 fmt-info.txt。现在，假设我们想要将这段文本重新格式化以适应 50 个字符宽的列。我们可以通过使用 fmt 和 -w 选项处理文件来实现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">fmt</span> -w 50 fmt-info.txt | <span class="built_in">head</span></span><br><span class="line"> `<span class="built_in">fmt</span><span class="string">&#x27; 从指定的 FILE 参数读取</span></span><br><span class="line"><span class="string"> (或标准输入如果</span></span><br><span class="line"><span class="string">没有给出)，并写入标准输出。</span></span><br><span class="line"><span class="string">默认情况下，空行、单词之间的空格，</span></span><br><span class="line"><span class="string"> 和缩进在输出中被保留；不同缩进的连续输入行</span></span><br><span class="line"><span class="string">没有被连接；在输入时扩展制表符并在输出时引入。</span></span><br></pre></td></tr></table></figure>

<p>好吧，这是一个尴尬的结果。也许我们应该实际阅读这段文本，因为它解释了发生了什么。</p>
<blockquote>
<p><em>默认情况下，空行、单词之间的空格和缩进在输出中被保留；不同缩进的连续输入行不会被连接；在输入时扩展制表符，在输出时引入制表符。</em></p>
</blockquote>
<p>所以，fmt 保留了第一行的缩进。幸运的是，fmt 提供了一个选项来纠正这个问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">fmt</span> -cw 50 fmt-info.txt</span><br><span class="line"> `<span class="built_in">fmt</span><span class="string">&#x27; 从指定的 FILE 参数读取</span></span><br><span class="line"><span class="string">(或标准输入如果没有给出)，并写入</span></span><br><span class="line"><span class="string">到标准输出。</span></span><br><span class="line"><span class="string">默认情况下，空行、单词之间的空格，</span></span><br><span class="line"><span class="string">和缩进在输出中被保留；</span></span><br><span class="line"><span class="string">连续输入行的不同缩进没有被连接；</span></span><br><span class="line"><span class="string">在输入时扩展制表符并在输出时引入。</span></span><br><span class="line"><span class="string"> `fmt&#x27;</span> 更喜欢在句子的末尾断开行，</span><br><span class="line">并尝试避免在句子的第一个单词之后</span><br><span class="line">或最后一个单词之前断开行。<span class="string">&quot;句子断点&quot;</span></span><br><span class="line">被定义为段落的末尾</span><br><span class="line">或以任何 `.?!<span class="string">&#x27; 结尾的单词，后跟</span></span><br><span class="line"><span class="string">两个空格或行尾，忽略任何</span></span><br><span class="line"><span class="string">介于两者之间的括号或引号。像 TeX，</span></span><br><span class="line"><span class="string">`fmt&#x27;</span> 在选择断行前会读取整个<span class="string">&quot;段落&quot;</span>；</span><br><span class="line">该算法是 Donald E. Knuth 和 Michael F.</span><br><span class="line">Plass 在 <span class="string">&quot;Breaking Paragraphs Into Lines&quot;</span>,</span><br><span class="line">`Software--Practice &amp; Experience<span class="string">&#x27; 11, 11</span></span><br><span class="line"><span class="string">（1981 年 11 月），1119-1184 中给出的算法的一个变种。</span></span><br></pre></td></tr></table></figure>

<p>这样好多了。通过添加 -c 选项，我们现在得到了期望的结果。fmt 有一些有趣的选项，如表 21-3 所述。</p>
<p><em>表 21-3: fmt 选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>在 <em>冠边距</em> 模式下操作。这保留了段落前两行的缩进。后续行与第二行的缩进对齐。</td>
</tr>
<tr>
<td>-p <em>string</em></td>
<td>仅格式化以前缀 <em>string</em> 开始的行。格式化后，将 <em>string</em> 的内容前缀添加到每个重新格式化的行。这个选项可以用来格式化源代码注释中的文本。例如，任何使用 “#” 字符来界定注释的编程语言或配置文件都可以通过指定 -p ‘# ‘ 来格式化，以便只有注释会被格式化。见下面的例子。</td>
</tr>
<tr>
<td>-s</td>
<td>仅分割模式。在这种模式下，行将只被分割以适应指定的列宽。短行不会被连接以填充行。当格式化像代码这样的文本时，这种模式很有用，因为不希望进行连接。</td>
</tr>
<tr>
<td>-u</td>
<td>执行均匀间距。这将对文本应用传统的“打字机风格”格式化。这意味着单词之间一个空格，句子之间两个空格。这种模式用于移除“对齐”，即文本已被填充空格以强制在左右两边对齐。</td>
</tr>
<tr>
<td>-w <em>width</em></td>
<td>格式化文本以适应列宽 <em>width</em> 个字符宽。默认为 75 个字符。注意：fmt 实际上格式化的行稍微短于指定的宽度，以允许行平衡。</td>
</tr>
</tbody></table>
<p>-p 选项特别有趣。有了它，我们可以格式化文件的选定部分，前提是要格式化的行都以相同的字符序列开始。许多编程语言使用井号 (#) 来表示注释的开头，因此可以使用这个选项来格式化注释，并保留代码不变。让我们创建一个模拟使用注释的程序的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; fmt-code.txt</span><br><span class="line"><span class="comment"># 这个文件包含带注释的代码。</span></span><br><span class="line"><span class="comment"># 这是一行注释。</span></span><br><span class="line"><span class="comment"># 后面是另一行注释。</span></span><br><span class="line"><span class="comment"># 还有一行。</span></span><br><span class="line">这，另一方面，是一行代码。</span><br><span class="line">又一行代码。</span><br><span class="line">还有一行。</span><br></pre></td></tr></table></figure>

<p>我们的示例文件包含以字符串 “# ”（一个 # 后跟一个空格）开头的注释和不以指定前缀开头的“代码”行。现在，使用 fmt，我们可以格式化注释并保留代码不变。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">fmt</span> -w 50 -p <span class="string">&#x27;# &#x27;</span> fmt-code.txt</span><br><span class="line"><span class="comment"># 这个文件包含带注释的代码。</span></span><br><span class="line"><span class="comment"># 这是一行注释。后面是另一行</span></span><br><span class="line"><span class="comment"># 注释。还有一行。</span></span><br><span class="line">这，另一方面，是一行代码。</span><br><span class="line">又一行代码。</span><br><span class="line">还有一行。</span><br></pre></td></tr></table></figure>

<p>注意，相邻的注释行被连接，而空行和不以指定前缀开头的行被保留。</p>
<h4 id="pr-为打印格式化文本"><a href="#pr-为打印格式化文本" class="headerlink" title="pr - 为打印格式化文本"></a>pr - 为打印格式化文本</h4><p>pr 程序用于 <em>分页</em> 文本。打印文本时，通常希望用几行空白分隔输出的每一页，为每一页提供上边距和下边距。此外，这些空白可以用来在每一页上插入页眉和页脚。</p>
<p>我们将通过将我们的 distros.txt 文件格式化为一系列短页来演示 pr（仅显示前两页）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">pr</span> -l 15 -w 65 distros.txt</span><br><span class="line">2016-12-11 18:27 distros.txt 第 1 页</span><br><span class="line">SUSE 10.2 12/07/2006</span><br><span class="line">Fedora 10 11/25/2008</span><br><span class="line">SUSE 11.0 06/19/2008</span><br><span class="line">Ubuntu 8.04 04/24/2008</span><br><span class="line">Fedora 8 11/08/2007</span><br><span class="line">2016-12-11 18:27 distros.txt 第 2 页</span><br><span class="line">SUSE 10.3 10/04/2007</span><br><span class="line">Ubuntu 6.10 10/26/2006</span><br><span class="line">Fedora 7 05/31/2007</span><br><span class="line">Ubuntu 7.10 10/18/2007</span><br><span class="line">Ubuntu 7.04 04/19/2007</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用 -l 选项（页长）和 -w 选项（页宽）来定义一个“页面”，它的宽度为 65 列，长度为 15 行。pr 将 distros.txt 文件的内容分页，用几行空白分隔每一页，并创建一个包含文件修改时间、文件名和页码的默认页眉。pr 程序提供了许多选项来控制页面布局。我们将在第 22 章，“打印”中再看看它们。</p>
<h4 id="printf-格式化并打印数据"><a href="#printf-格式化并打印数据" class="headerlink" title="printf - 格式化并打印数据"></a>printf - 格式化并打印数据</h4><p>与本章中的其他命令不同，printf命令不用于管道（它不接受标准输入），也不常直接在命令行中使用（它主要用于脚本中）。那为什么它还重要呢？因为它的使用非常广泛。</p>
<p>printf（来自“打印格式化”这个短语）最初是为C编程语言开发的，并已在包括shell在内的许多编程语言中实现。实际上，在bash中，printf是一个内建命令。printf的工作方式如下：</p>
<p>printf “<em>格式</em>” <em>参数</em></p>
<p>该命令被给予一个包含格式描述的字符串，然后将其应用于参数列表。格式化的结果发送到标准输出。这是一个简单的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printf</span> <span class="string">&quot;我格式化了字符串：%s\n&quot;</span> foo</span><br><span class="line">我格式化了字符串：foo</span><br></pre></td></tr></table></figure>

<p>格式字符串可能包含字面文本（如“我格式化了字符串：”）、转义序列（如\n，一个换行字符）和以%字符开头的序列，这些序列称为<em>转换说明符</em>。在上面的例子中，转换说明符%s用于格式化字符串“foo”并将其放置在命令的输出中。这里再次展示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printf</span> <span class="string">&quot;我将&#x27;%s&#x27;格式化为字符串。\n&quot;</span> foo</span><br><span class="line">我将<span class="string">&#x27;foo&#x27;</span>格式化为字符串。</span><br></pre></td></tr></table></figure>

<p>正如我们所见，%s转换说明符被替换为命令输出中的字符串“foo”。s转换用于格式化字符串数据。其他说明符用于其他种类的数据。表21-4列出了常用的数据类型说明符。</p>
<p><em>表21-4：常见的printf数据类型说明符</em></p>
<table>
<thead>
<tr>
<th><strong>说明符</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>d</td>
<td>将数字格式化为有符号十进制整数。</td>
</tr>
<tr>
<td>f</td>
<td>格式化并输出一个浮点数。</td>
</tr>
<tr>
<td>o</td>
<td>将整数格式化为八进制数。</td>
</tr>
<tr>
<td>s</td>
<td>格式化字符串。</td>
</tr>
<tr>
<td>x</td>
<td>将整数格式化为十六进制数，需要时使用小写字母a到f。</td>
</tr>
<tr>
<td>X</td>
<td>与x相同，但使用大写字母。</td>
</tr>
<tr>
<td>%</td>
<td>打印一个字面%符号（即，指定%%）</td>
</tr>
</tbody></table>
<p>我们将演示每个转换说明符对字符串380的效果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printf</span> <span class="string">&quot;%d, %f, %o, %s, %x, %X\n&quot;</span> 380 380 380 380</span><br><span class="line">380, 380.000000, 574, 380, 17c, 17C</span><br></pre></td></tr></table></figure>

<p>由于我们指定了六个转换说明符，我们也必须为printf提供六个参数来处理。六个结果显示了每个说明符的效果。</p>
<p>可以向转换说明符添加几个可选组件来调整其输出。一个完整的转换说明符可能包含以下内容：</p>
<blockquote>
<p>%[flags][width][.precision]conversion_specification</p>
</blockquote>
<p>使用时，多个可选组件必须按照早先指定的顺序出现，以便正确解释。表21-5描述了每个组件。</p>
<p><em>表21-5：printf转换说明符组件</em></p>
<table>
<thead>
<tr>
<th><strong>组件</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>flags</em></td>
<td>有五种不同的标志：</td>
</tr>
<tr>
<td></td>
<td># : 使用“备选格式”进行输出。这根据数据类型而有所不同。对于o（八进制数）转换，输出前缀为0。对于x和X（十六进制数）转换，输出前缀分别为0x或0X。</td>
</tr>
<tr>
<td></td>
<td>0（零）: 用零填充输出。这意味着字段将用前导零填充，如000380。</td>
</tr>
<tr>
<td></td>
<td>-（破折号）: 左对齐输出。默认情况下，printf右对齐输出。</td>
</tr>
<tr>
<td></td>
<td>‘ ’（空格）: 为正数生成一个前导空格。</td>
</tr>
<tr>
<td></td>
<td>+（加号）: 标记正数。默认情况下，printf只标记负数。</td>
</tr>
<tr>
<td><em>width</em></td>
<td>指定最小字段宽度的数字。</td>
</tr>
<tr>
<td><em>.precision</em></td>
<td>对于浮点数，指定小数点后要输出的精度位数。对于字符串转换，<em>精度</em>指定要输出的字符数。</td>
</tr>
</tbody></table>
<p>表21-6列出了不同格式的一些例子。</p>
<p><em>表21-6：printf转换说明符示例</em></p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>格式</strong></th>
<th><strong>结果</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>380</td>
<td>“%d”</td>
<td>380</td>
<td>整数的简单格式化。</td>
</tr>
<tr>
<td>380</td>
<td>“%#x”</td>
<td>0x17c</td>
<td>使用“备选格式”标志格式化为十六进制数的整数。</td>
</tr>
<tr>
<td>380</td>
<td>“%05d”</td>
<td>00380</td>
<td>用前导零（填充）和最小字段宽度为五个字符格式化的整数。</td>
</tr>
<tr>
<td>380</td>
<td>“%05.5f”</td>
<td>380.00000</td>
<td>将数字格式化为带有填充和五位小数精度的浮点数。由于指定的最小字段宽度（5）小于格式化数字的实际宽度，填充无效。</td>
</tr>
<tr>
<td>380</td>
<td>“%010.5f”</td>
<td>0380.00000</td>
<td>将最小字段宽度增加到10，现在可以看到填充效果。</td>
</tr>
<tr>
<td>380</td>
<td>“%+d”</td>
<td>+380</td>
<td>+标志为正数加上符号。</td>
</tr>
<tr>
<td>380</td>
<td>“%-d”</td>
<td>380</td>
<td>-标志左对齐格式化。</td>
</tr>
<tr>
<td>abcdefghijk</td>
<td>“%5s”</td>
<td>abcedfghijk</td>
<td>使用最小字段宽度格式化的字符串。</td>
</tr>
<tr>
<td>abcdefghijk</td>
<td>“%.5s”</td>
<td>abcde</td>
<td>通过对字符串应用精度，它被截断。</td>
</tr>
</tbody></table>
<p>再次强调，printf主要用于脚本中，其中它被用来格式化表格数据，而不是直接在命令行上使用。但我们仍然可以展示如何使用它来解决各种格式化问题。首先，让我们输出一些由制表符分隔的字段。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printf</span> <span class="string">&quot;%s\t%s\t%s\n&quot;</span> str1 str2 str3</span><br><span class="line">str1    str2    str3</span><br></pre></td></tr></table></figure>

<p>通过插入\t（制表符的转义序列），我们实现了预期的效果。接下来，这里有一些整齐格式化的数字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printf</span> <span class="string">&quot;行号：%05d %15.3f 结果：%+15d\n&quot;</span> 1071 3.14156295 32589</span><br><span class="line">行号：01071           3.142 结果：         +32589</span><br></pre></td></tr></table></figure>

<p>这显示了最小字段宽度对字段间距的影响。或者我们如何格式化一个小型网页？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printf</span> <span class="string">&quot;&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;title&gt;%s&lt;/title&gt;\n\t&lt;/head&gt;\n\t&lt;body&gt;\n\t\t&lt;p&gt;%s&lt;/p&gt;\n\t&lt;/body&gt;\n&lt;/html&gt;\n&quot;</span> <span class="string">&quot;页面标题&quot;</span> <span class="string">&quot;页面内容&quot;</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;title&gt;页面标题&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;页面内容&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="文档格式化系统"><a href="#文档格式化系统" class="headerlink" title="文档格式化系统"></a>文档格式化系统</h3><p>到目前为止，我们已经检查了简单的文本格式化工具。这些工具对于小型、简单的任务来说是好的，但对于更大的任务呢？Unix成为技术和科学用户（除了提供一个强大的多任务、多用户环境用于各种软件开发之外）喜爱的操作系统的原因之一是，它提供了可以用来制作多种类型文档的工具，特别是科学和学术出版物。实际上，正如GNU文档所描述的，文档准备对于Unix的开发起到了关键作用。</p>
<p><em>UNIX的第一个版本是在一个闲置的PDP-7上开发的。1971年，开发者们希望获得一台PDP-11来继续操作系统的开发。为了证明这个系统的成本，他们提出了为AT&amp;T专利部门实现一个文档格式化系统的计划。这个第一个格式化程序是J. F. Ossanna重写的McIllroy的<code>roff</code>。</em></p>
<p>两大主要的文档格式化系统占据了主导地位：那些源自原始的roff程序，包括nroff和troff，以及基于Donald Knuth的TEX（发音为“tek”）排版系统的那些。是的，中间掉落的“E”是它的名字的一部分。</p>
<p>“roff”的名字来源于“run off”，就像是，“我会给你复制一份。”nroff程序用于为使用等宽字体的设备格式化文档，如字符终端和打字机风格的打印机。在其引入时，这几乎包括了连接到计算机的所有打印设备。后来的troff程序格式化文档以便在<em>排版机</em>上输出，排版机是用于为商业印刷生产“相机就绪”类型的设备。今天的大多数计算机打印机能够模拟排版机的输出。roff家族还包括一些其他用于准备文档部分的程序。这些包括eqn（用于数学方程）和tbl（用于表格）。</p>
<p>TEX系统（在稳定形态下）首次出现在1989年，并在某种程度上取代了troff，成为排版输出工具的首选。我们不会在这里详细介绍TEX，部分是因为它的复杂性（有关它的整本书），部分是因为它并非默认安装在大多数现代Linux系统上。</p>
<p><strong>提示：</strong> 对于那些有兴趣安装TEX的人，请查看大多数发行版仓库中的texlive包，以及LyX图形内容编辑器。</p>
<h4 id="groff"><a href="#groff" class="headerlink" title="groff"></a>groff</h4><p>groff是一套包含GNU实现的troff的程序。它还包括一个脚本，用于模拟nroff和其他roff家族成员。</p>
<p>虽然roff及其后代用于制作格式化文档，但它们的方式对于现代用户来说相当陌生。今天，大多数文档是使用能够在单一步骤中执行文档的组合和布局的文字处理器产生的。在图形文字处理器出现之前，文档通常是通过使用文本编辑器进行组合和使用诸如troff之类的处理器应用格式化的两步过程产生的。通过使用标记语言将格式化程序的指令嵌入到组成的文本中。这样的过程的现代类比是网页，使用某种文本编辑器进行组合，然后使用HTML作为标记语言由Web浏览器渲染以描述最终页面布局。</p>
<p>我们不打算完整地介绍groff，因为其标记语言的许多元素涉及排版的相当古老的细节。相反，我们将集中讨论其<em>宏包</em>之一，这仍然广泛使用。这些宏包将其许多低级命令压缩成一小组高级命令，使得使用groff变得更加容易。</p>
<p>让我们暂时考虑一下谦逊的man页面。它存在于&#x2F;usr&#x2F;share&#x2F;man目录中，作为gzip压缩的文本文件。如果我们查看其解压缩内容，我们会看到以下内容（展示的是第1节的ls的man页面）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ zcat /usr/share/man/man1/ls.1.gz | <span class="built_in">head</span></span><br><span class="line">.\&quot; 不要修改这个文件！它是由help2man 1.47.3生成的。</span><br><span class="line">.TH LS <span class="string">&quot;1&quot;</span> <span class="string">&quot;2018年1月&quot;</span> <span class="string">&quot;GNU coreutils 8.28&quot;</span> <span class="string">&quot;用户命令&quot;</span></span><br><span class="line">.SH 名称</span><br><span class="line"><span class="built_in">ls</span> \- 列出目录内容</span><br><span class="line">.SH 摘要</span><br><span class="line">.B <span class="built_in">ls</span></span><br><span class="line">[\fI\,选项\/\fR]... [\fI\,文件\/\fR]...</span><br><span class="line">.SH 描述</span><br><span class="line">.\&quot; 在这里添加任何额外的描述</span><br><span class="line">.PP</span><br></pre></td></tr></table></figure>

<p>与正常呈现的man页面相比，我们可以开始看到标记语言与其结果之间的相关性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ man <span class="built_in">ls</span> | <span class="built_in">head</span></span><br><span class="line">LS(1) 用户命令 LS(1)</span><br><span class="line">名称</span><br><span class="line"> <span class="built_in">ls</span> - 列出目录内容</span><br><span class="line">摘要</span><br><span class="line"> <span class="built_in">ls</span> [选项]... [文件]...</span><br></pre></td></tr></table></figure>

<p>之所以感兴趣，是因为man页面是由groff渲染的，使用的是mandoc宏包。实际上，我们可以用以下管道模拟man命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ zcat /usr/share/man/man1/ls.1.gz | groff -mandoc -T ascii | <span class="built_in">head</span></span><br><span class="line">LS(1) 用户命令 LS(1)</span><br><span class="line">名称</span><br><span class="line"> <span class="built_in">ls</span> - 列出目录内容</span><br><span class="line">摘要</span><br><span class="line"> <span class="built_in">ls</span> [选项]... [文件]...</span><br></pre></td></tr></table></figure>

<p>在这里，我们使用groff程序，并设置选项以指定mandoc宏包和ASCII输出驱动程序。groff可以产生多种格式的输出。如果没有指定格式，默认输出为PostScript。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ zcat /usr/share/man/man1/ls.1.gz | groff -mandoc | <span class="built_in">head</span></span><br><span class="line">%!PS-Adobe-3.0</span><br><span class="line">%%Creator: groff version 1.18.1</span><br><span class="line">%%CreationDate: 2009年2月5日 13:44:37</span><br><span class="line">%%DocumentNeededResources: font Times-Roman</span><br><span class="line">%%+ font Times-Bold</span><br><span class="line">%%+ font Times-Italic</span><br><span class="line">%%DocumentSuppliedResources: procset grops 1.18 1</span><br><span class="line">%%Pages: 4</span><br><span class="line">%%PageOrder: Ascend</span><br><span class="line">%%Orientation: Portrait</span><br></pre></td></tr></table></figure>

<p>我们在前一章中简要提到了PostScript，并将在下一章中再次提到。PostScript是一种页面描述语言，用于向类似排版机的设备描述打印页面的内容。如果我们将命令的输出存储到文件中（假设我们正在使用带有桌面目录的图形桌面），则输出文件的图标应该会出现在桌面上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ zcat /usr/share/man/man1/ls.1.gz | groff -mandoc &gt; ~/Desktop/ls.ps</span><br></pre></td></tr></table></figure>

<p>通过双击图标，应该会启动一个页面查看器，并显示文件的渲染形式，如图5所示。</p>
<p><img src="/images/2024/Picture5.png"></p>
<p><em>图5：在GNOME中使用页面查看器查看PostScript输出</em></p>
<p>我们看到的是一个精美的排版man页面！事实上，可以使用以下命令将PostScript文件转换为<em>便携式文档格式</em>（PDF）文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ps2pdf ~/Desktop/foo.ps ~/Desktop/ls.pdf</span><br></pre></td></tr></table></figure>

<p>ps2pdf程序是ghostscript包的一部分，该包安装在大多数支持打印的Linux系统上。</p>
<p><strong>提示</strong>：Linux系统通常包括许多命令行程序用于文件格式转换。它们通常使用<em>格式</em>2<em>格式</em>的命名约定。尝试使用命令ls &#x2F;usr&#x2F;bin&#x2F;*[[:alpha:]]2[[:alpha:]]*来识别它们。</p>
<p>也尝试搜索名为<em>格式</em><strong>to</strong><em>格式</em>的程序。</p>
<p>对于我们最后一次使用groff的练习，我们将重新访问我们的老朋友distros.txt。这次，我们将使用tbl程序，它用于格式化表格，以排版我们的Linux发行版列表。为此，我们将使用我们早期的sed脚本向文本流添加标记（称为<em>请求</em>），然后将其提供给groff。</p>
<p>首先，我们需要修改我们的sed脚本以添加tbl所需的必要标记元素（请求）。使用文本编辑器，我们将distros.sed更改为以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sed脚本生成Linux发行版报告</span></span><br><span class="line">1 i\</span><br><span class="line">.TS\</span><br><span class="line">center box;\</span><br><span class="line">cb s s\</span><br><span class="line">cb cb cb\</span><br><span class="line">l n c.\</span><br><span class="line">Linux发行版报告\</span><br><span class="line">=\</span><br><span class="line">名称 版本 发布\</span><br><span class="line">_</span><br><span class="line">s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/</span><br><span class="line">$ a\</span><br><span class="line">.TE</span><br></pre></td></tr></table></figure>

<p>注意，为了使脚本正常工作，务必确保名称版本发布之间用制表符而不是空格分隔。我们将结果文件保存为distros-tbl.sed。tbl使用.TS和.TE请求来开始和结束表格。.TS请求之后的行定义表格的全局属性，对于我们的示例，是水平居中于页面并且周围有一个盒子。定义的剩余行描述了每个表格行的布局。现在，如果我们再次运行我们的报告生成管道，并使用新的sed脚本，我们将得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> -k 1,1 -k 2n distros.txt | sed -f distros-tbl.sed | groff -t -T ascii</span><br><span class="line"> +------------------------------+</span><br><span class="line"> | Linux发行版报告 |</span><br><span class="line"> +------------------------------+</span><br><span class="line"> | 名称 版本 发布 |</span><br><span class="line"> +------------------------------+</span><br><span class="line"> |Fedora 5 2006-03-20 |</span><br><span class="line"> |Fedora 6 2006-10-24 |</span><br><span class="line"> |Fedora 7 2007-05-31 |</span><br><span class="line"> |Fedora 8 2007-11-08 |</span><br><span class="line"> |Fedora 9 2008-05-13 |</span><br><span class="line"> |Fedora 10 2008-11-25 |</span><br><span class="line"> |SUSE 10.1 2006-05-11 |</span><br><span class="line"> |SUSE 10.2 2006-12-07 |</span><br><span class="line"> |SUSE 10.3 2007-10-04 |</span><br><span class="line"> |SUSE 11.0 2008-06-19 |</span><br><span class="line"> |Ubuntu 6.06 2006-06-01 |</span><br><span class="line"> |Ubuntu 6.10 2006-10-26 |</span><br><span class="line"> |Ubuntu 7.04 2007-04-19 |</span><br><span class="line"> |Ubuntu 7.10 2007-10-18 |</span><br><span class="line"> |Ubuntu 8.04 2008-04-24 |</span><br><span class="line"> |Ubuntu 8.10 2008-10-30 |</span><br><span class="line"> +------------------------------+</span><br></pre></td></tr></table></figure>

<p>添加-t选项到groff指示它使用tbl预处理文本流。同样，-T选项用于输出到ASCII而不是默认的输出介质，PostScript。</p>
<p>如果我们指定PostScript输出并以图形方式查看输出，我们将得到一个更令人满意的结果，如图6所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> -k 1,1 -k 2n distros.txt | sed -f distros-tbl.sed | groff -t &gt; ~/Desktop/foo.ps</span><br></pre></td></tr></table></figure>

<p><img src="/images/2024/Picture6.png"></p>
<p><em>图6：查看完成的表格</em></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>鉴于文本是Unix-like操作系统的核心特征，理所当然地会有许多用于操作和格式化文本的工具。正如我们所见，确实有！像fmt和pr这样的简单格式化工具将在产生短文档的脚本中找到许多用途，而groff（及其朋友们）可以用来写书。我们可能永远不会使用命令行工具写技术论文（尽管有很多人这么做！），但知道我们可以这样做是好的。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p>groff用户指南</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2dyb2ZmL21hbnVhbC8=">http://www.gnu.org/software/groff/manual/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><em>使用-me写论文</em>: <span class="exturl" data-url="aHR0cDovL2RvY3MuZnJlZWJzZC5vcmcvNDRkb2MvdXNkLzE5Lm1lbWFjcm9zL3BhcGVyLnBkZg==">http://docs.freebsd.org/44doc/usd/19.memacros/paper.pdf<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><em>-me参考手册</em>: <span class="exturl" data-url="aHR0cDovL2RvY3MuZnJlZWJzZC5vcmcvNDRkb2MvdXNkLzIwLm1lcmVmL3BhcGVyLnBkZg==">http://docs.freebsd.org/44doc/usd/20.meref/paper.pdf<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><em>Tbl – 一个格式化表格的程序</em>: <span class="exturl" data-url="aHR0cDovL3BsYW45LmJlbGwtbGFicy5jb20vMTB0aEVkTWFuL3RibC5wZGY=">http://plan9.bell-labs.com/10thEdMan/tbl.pdf<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>当然，还可以尝试以下维基百科文章：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UZVg=">http://en.wikipedia.org/wiki/TeX<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb25hbGRfS251dGg=">http://en.wikipedia.org/wiki/Donald_Knuth<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UeXBlc2V0dGluZw==">http://en.wikipedia.org/wiki/Typesetting<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/TLCL/" rel="tag"># TLCL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/04/20-text-processing/" rel="prev" title="文本处理">
                  <i class="fa fa-angle-left"></i> 文本处理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/04/22-printing/" rel="next" title="打印">
                  打印 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Slagga</span>
  </div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdHNsYWdnYQ==" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/sidebar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/search/local-search.min.js"></script>




  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/fancybox.min.js"></script>



  




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"gitslagga","repo":"gitslagga.github.io","client_id":"8b03c773267690e6d402","client_secret":"7b2ef82f50c632cdb14c98b7e5928357974cad97","admin_user":"gitslagga","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"ad0b689dcc7641ba183ec98ed5e8045c"}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/comments/gitalk.min.js"></script>

</body>
</html>
