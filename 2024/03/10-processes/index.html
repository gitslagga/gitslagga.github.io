<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="E1ct36DyjSpaeX5NMAVsyzCjDs8-dQxGThgvw2i1yg0">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"gitslagga.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.21.0","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/config.min.js"></script>

    <meta name="description" content="10 – 进程现代操作系统通常是多任务的，这意味着它们通过快速地从一个正在执行的程序切换到另一个程序来创造做多于一件事的假象。Linux 内核通过使用进程来管理这个。进程是 Linux 如何组织等待在 CPU 上执行的不同程序的方法。 有时，计算机可能会变得迟缓，或者某个应用程序会停止响应。在本章中，我们将查看命令行中可用的一些工具，让我们检查程序正在做什么以及如何终止表现不佳的进程。">
<meta property="og:type" content="article">
<meta property="og:title" content="进程">
<meta property="og:url" content="https://gitslagga.github.io/2024/03/10-processes/index.html">
<meta property="og:site_name" content="计算机那些事">
<meta property="og:description" content="10 – 进程现代操作系统通常是多任务的，这意味着它们通过快速地从一个正在执行的程序切换到另一个程序来创造做多于一件事的假象。Linux 内核通过使用进程来管理这个。进程是 Linux 如何组织等待在 CPU 上执行的不同程序的方法。 有时，计算机可能会变得迟缓，或者某个应用程序会停止响应。在本章中，我们将查看命令行中可用的一些工具，让我们检查程序正在做什么以及如何终止表现不佳的进程。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitslagga.github.io/images/2024/Picture4.png">
<meta property="article:published_time" content="2024-03-11T14:25:30.000Z">
<meta property="article:modified_time" content="2025-06-06T06:13:40.944Z">
<meta property="article:author" content="Slagga">
<meta property="article:tag" content="TLCL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitslagga.github.io/images/2024/Picture4.png">


<link rel="canonical" href="https://gitslagga.github.io/2024/03/10-processes/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://gitslagga.github.io/2024/03/10-processes/","path":"2024/03/10-processes/","title":"进程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>进程 | 计算机那些事</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-0E2T2VNH5S"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-0E2T2VNH5S","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/analytics/google-analytics.min.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">计算机那些事</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">软件开发、维护和升级</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">229</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">78</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">28</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E2%80%93-%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">10 – 进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">进程的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">查看进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-top-%E5%8A%A8%E6%80%81%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">使用 top 动态查看进程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">控制进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">中断进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E8%BF%9B%E7%A8%8B%E6%94%BE%E5%85%A5%E5%90%8E%E5%8F%B0"><span class="nav-number">1.3.2.</span> <span class="nav-text">将进程放入后台</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E8%BF%9B%E7%A8%8B%E8%BF%94%E5%9B%9E%E5%88%B0%E5%89%8D%E5%8F%B0"><span class="nav-number">1.3.3.</span> <span class="nav-text">将进程返回到前台</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9A%82%E5%81%9C%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.3.4.</span> <span class="nav-text">暂停进程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.4.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8kill%E5%90%91%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.4.1.</span> <span class="nav-text">使用kill向进程发送信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8killall%E5%90%91%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.4.2.</span> <span class="nav-text">使用killall向多个进程发送信号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.5.</span> <span class="nav-text">关闭系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="nav-number">1.6.</span> <span class="nav-text">更多与进程相关的命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Slagga"
      src="https://avatars.githubusercontent.com/u/19620432">
  <p class="site-author-name" itemprop="name">Slagga</p>
  <div class="site-description" itemprop="description">Computer Things - Software Development, Maintenance and Upgrade</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">229</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdHNsYWdnYQ==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gitslagga"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnNsYWdnYUBkdWNrLmNvbQ==" title="E-Mail → mailto:slagga@duck.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gitslagga.github.io/2024/03/10-processes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/19620432">
      <meta itemprop="name" content="Slagga">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="计算机那些事">
      <meta itemprop="description" content="Computer Things - Software Development, Maintenance and Upgrade">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="进程 | 计算机那些事">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          进程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-11 22:25:30" itemprop="dateCreated datePublished" datetime="2024-03-11T22:25:30+08:00">2024-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-06 14:13:40" itemprop="dateModified" datetime="2025-06-06T14:13:40+08:00">2025-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="10-–-进程"><a href="#10-–-进程" class="headerlink" title="10 – 进程"></a>10 – 进程</h2><p>现代操作系统通常是<em>多任务</em>的，这意味着它们通过快速地从一个正在执行的程序切换到另一个程序来创造做多于一件事的假象。Linux 内核通过使用<em>进程</em>来管理这个。进程是 Linux 如何组织等待在 CPU 上执行的不同程序的方法。</p>
<p>有时，计算机可能会变得迟缓，或者某个应用程序会停止响应。在本章中，我们将查看命令行中可用的一些工具，让我们检查程序正在做什么以及如何终止表现不佳的进程。</p>
<span id="more"></span>

<p>本章将介绍以下命令：</p>
<ul>
<li><code>ps</code> – 报告当前进程的快照</li>
<li><code>top</code> – 显示任务</li>
<li><code>jobs</code> – 列出活动作业</li>
<li><code>bg</code> – 将作业放入后台</li>
<li><code>fg</code> – 将作业放入前台</li>
<li><code>kill</code> – 向进程发送信号</li>
<li><code>killall</code> – 按名称终止进程</li>
<li><code>shutdown</code> – 关闭或重新启动系统</li>
</ul>
<h3 id="进程的工作原理"><a href="#进程的工作原理" class="headerlink" title="进程的工作原理"></a>进程的工作原理</h3><p>当系统启动时，内核会启动一些自己的活动作为进程，并启动一个名为 init 的程序。init 反过来运行一系列称为<em>init 脚本</em>的 shell 脚本（位于 &#x2F;etc），这些脚本启动所有系统服务。这些服务中的许多都是作为<em>守护进程程序</em>实现的，这些程序只是在后台执行它们的任务，没有任何用户界面。因此，即使我们没有登录，系统也至少会忙于执行常规任务。</p>
<p>一个程序可以启动其他程序的事实在进程方案中表达为<em>父进程</em>产生一个<em>子进程</em>。</p>
<p>内核维护有关每个进程的信息，以帮助维持组织。例如，每个进程都被分配一个称为<em>进程 ID</em>（<em>PID</em>）的数字。PID 以升序分配，初始化始终获得 PID 1。内核还跟踪分配给每个进程的内存，以及进程恢复执行的准备情况。与文件一样，进程也有所有者、用户 ID、有效用户 ID 等。</p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>查看进程的最常用命令（有几个命令可以使用）是 <code>ps</code>。<code>ps</code> 程序有很多选项，但在其最简单的形式中，它的使用方式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ps</span><br><span class="line"> PID TTY TIME CMD</span><br><span class="line"> 5198 pts/1 00:00:00 bash</span><br><span class="line">10129 pts/1 00:00:00 ps</span><br></pre></td></tr></table></figure>

<p>在此示例中的结果列出了两个进程，进程 5198 和进程 10129，分别是 <code>bash</code> 和 <code>ps</code>。如我们所见，默认情况下，<code>ps</code> 不会显示太多信息，只显示与当前终端会话相关的进程。要查看更多信息，我们需要添加一些选项，但在这样做之前，让我们查看 <code>ps</code> 产生的其他字段。TTY 是“电传打字机”的缩写，指的是进程的<em>控制终端</em>。Unix 在此显示了其年龄。TIME 字段是进程消耗的 CPU 时间。如我们所见，没有进程使计算机工作得很辛苦。</p>
<p>如果我们添加一个选项，可以更全面地了解系统正在做什么。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ps x</span><br><span class="line"> PID TTY STAT TIME COMMAND</span><br><span class="line"> 2799 ? Ssl 0:00 /usr/libexec/bonobo-activation-server –ac</span><br><span class="line"> 2820 ? Sl 0:01 /usr/libexec/evolution-data-server-1.10 --</span><br><span class="line">15647 ? Ss 0:00 /bin/sh /usr/bin/startkde</span><br><span class="line">15751 ? Ss 0:00 /usr/bin/ssh-agent /usr/bin/dbus-launch --</span><br><span class="line">15754 ? S 0:00 /usr/bin/dbus-launch --exit-with-session</span><br><span class="line">15755 ? Ss 0:01 /bin/dbus-daemon --fork --print-pid 4 –pr</span><br><span class="line">15774 ? Ss 0:02 /usr/bin/gpg-agent -s –daemon</span><br><span class="line">15793 ? S 0:00 start_kdeinit --new-startup +kcminit_start</span><br><span class="line">15794 ? Ss 0:00 kdeinit Running...</span><br><span class="line">15797 ? S 0:00 dcopserver –nosid</span><br><span class="line">and many more...</span><br></pre></td></tr></table></figure>

<p>添加“x”选项（注意没有前导破折号）告诉 <code>ps</code> 显示我们所有的进程，无论它们由哪个终端（如果有的话）控制。TTY 列中的“?”表示没有控制终端。使用此选项，我们看到了我们拥有的每个进程的列表。</p>
<p>由于系统运行了很多进程，<code>ps</code> 会产生一个长列表。通常可以将 <code>ps</code> 的输出导入到 <code>less</code> 中以便更容易查看。某些选项组合也会产生长输出行，因此最大化终端模拟器窗口可能也是个好主意。</p>
<p>输出中还添加了一个名为 STAT 的新列。STAT 是“状态”的缩写，显示进程的当前状态，如表 10-1 所示。</p>
<p><em>表 10-1：进程状态</em></p>
<table>
<thead>
<tr>
<th><strong>状态</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>运行中。这意味着进程正在运行或准备运行。</td>
</tr>
<tr>
<td>S</td>
<td>睡眠中。进程没有运行；相反，它正在等待事件，如按键或网络数据包。</td>
</tr>
<tr>
<td>D</td>
<td>无法中断的睡眠。进程正在等待如磁盘驱动器等的 I&#x2F;O。</td>
</tr>
<tr>
<td>T</td>
<td>已停止。进程已被指示停止。本章后面会进一步介绍。</td>
</tr>
<tr>
<td>Z</td>
<td>僵尸进程。这是一个已终止但尚未被其父进程清理的子进程。</td>
</tr>
<tr>
<td>&lt;</td>
<td>高优先级进程。可以赋予进程更高的重要性，使其在 CPU 上获得更多的时间。这种进程的特性称为<em>优先级</em>。具有高优先级的进程被认为不太<em>友好</em>，因为它占用了更多的 CPU 时间，为其他人留下的时间较少。</td>
</tr>
<tr>
<td>N</td>
<td>低优先级进程。具有低优先级（一个“友好”的进程）的进程只有在其他具有更高优先级的进程被服务后才会获得处理器时间。</td>
</tr>
</tbody></table>
<p>进程状态后面可能跟随其他字符。这些表示各种特殊的进程特性。有关更多详细信息，请参阅 <code>ps</code> 的 man 页面。</p>
<p>另一个流行的选项集是“aux”（没有前导破折号）。这将为我们提供更多信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ps aux</span><br><span class="line">USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</span><br><span class="line">root 1 0.0 0.0 2136 644 ? Ss Mar05 0:31 init</span><br><span class="line">root 2 0.0 0.0 0 0 ? S&lt; Mar05 0:00 [kt]</span><br><span class="line">root 3 0.0 0.0 0 0 ? S&lt; Mar05 0:00 [mi]</span><br><span class="line">root 4 0.0 0.0 0 0 ? S&lt; Mar05 0:00 [ks]</span><br><span class="line">root 5 0.0 0.0 0 0 ? S&lt; Mar05 0:06 [wa]</span><br><span class="line">root 6 0.0 0.0 0 0 ? S&lt; Mar05 0:36 [ev]</span><br><span class="line">root 7 0.0 0.0 0 0 ? S&lt; Mar05 0:00 [kh]</span><br><span class="line">and many more...</span><br></pre></td></tr></table></figure>

<p>这组选项显示属于每个用户的进程。使用没有前导破折号的选项会以“BSD风格”行为调用该命令。Linux 版的 <code>ps</code> 可以模拟几种不同 Unix 实现中 <code>ps</code> 程序的行为。使用这些选项，我们得到了表 10-2 中显示的额外列。</p>
<p><em>表 10-2：BSD风格的 <code>ps</code> 列标题</em></p>
<table>
<thead>
<tr>
<th><strong>标题</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>USER</td>
<td>用户ID。这是进程的所有者。</td>
</tr>
<tr>
<td>%CPU</td>
<td>CPU使用率（百分比）。</td>
</tr>
<tr>
<td>%MEM</td>
<td>内存使用率（百分比）。</td>
</tr>
<tr>
<td>VSZ</td>
<td>虚拟内存大小。</td>
</tr>
<tr>
<td>RSS</td>
<td>驻留集大小。这是进程使用的物理内存（RAM）量，单位为千字节。</td>
</tr>
<tr>
<td>START</td>
<td>进程启动时间。对于超过24小时的值，会使用日期。</td>
</tr>
</tbody></table>
<h4 id="使用-top-动态查看进程"><a href="#使用-top-动态查看进程" class="headerlink" title="使用 top 动态查看进程"></a>使用 top 动态查看进程</h4><p>虽然 <code>ps</code> 命令可以显示机器正在执行的很多内容，但它只提供执行 <code>ps</code> 命令时机器状态的快照。为了看到机器活动的更动态视图，我们使用 <code>top</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ top</span><br></pre></td></tr></table></figure>

<p><code>top</code> 程序会持续更新（默认每三秒）地显示系统进程，按进程活动排序。名称 <em>top</em> 来源于这样一个事实，即 <code>top</code> 程序用于查看系统上的“顶部”进程。<code>top</code> 显示包含两部分：显示顶部的系统摘要，后跟按CPU活动排序的进程表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">top - 14:59:20 up 6:30, 2 users, load average: 0.07, 0.02, 0.00</span><br><span class="line">Tasks: 109 total, 1 running, 106 sleeping, 0 stopped, 2 zombie</span><br><span class="line">Cpu(s): 0.7%us, 1.0%sy, 0.0%ni, 98.3%id, 0.0%wa, 0.0%hi, 0.0%si</span><br><span class="line">Mem: 319496k total, 314860k used, 4636k free, 19392k buff</span><br><span class="line">Swap: 875500k total, 149128k used, 726372k free, 114676k cach</span><br><span class="line"> PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND</span><br><span class="line"> 6244 me 39 19 31752 3124 2188 S 6.3 1.0 16:24.42 trackerd</span><br><span class="line">11071 me 20 0 2304 1092 840 R 1.3 0.3 0:00.14 top</span><br><span class="line"> 6180 me 20 0 2700 1100 772 S 0.7 0.3 0:03.66 dbus-dae</span><br><span class="line"> 6321 me 20 0 20944 7248 6560 S 0.7 2.3 2:51.38 multiloa</span><br><span class="line"> 4955 root 20 0 104m 9668 5776 S 0.3 3.0 2:19.39 Xorg</span><br><span class="line"> 1 root 20 0 2976 528 476 S 0.0 0.2 0:03.14 init</span><br><span class="line"> 2 root 15 -5 0 0 0 S 0.0 0.0 0:00.00 kthreadd</span><br><span class="line"> 3 root RT -5 0 0 0 S 0.0 0.0 0:00.00 migratio</span><br><span class="line"> 4 root 15 -5 0 0 0 S 0.0 0.0 0:00.72 ksoftirq</span><br><span class="line"> 5 root RT -5 0 0 0 S 0.0 0.0 0:00.04 watchdog</span><br><span class="line"> 6 root 15 -5 0 0 0 S 0.0 0.0 0:00.42 events/0</span><br><span class="line"> 7 root 15 -5 0 0 0 S 0.0 0.0 0:00.06 khelper</span><br><span class="line"> 41 root 15 -5 0 0 0 S 0.0 0.0 0:01.08 kblockd/</span><br><span class="line"> 67 root 15 -5 0 0 0 S 0.0 0.0 0:00.00 kseriod</span><br><span class="line"> 114 root 20 0 0 0 0 S 0.0 0.0 0:01.62 pdflush</span><br><span class="line"> 116 root 15 -5 0 0 0 S 0.0 0.0 0:02.44 kswapd0</span><br></pre></td></tr></table></figure>

<p>系统摘要包含了很多有用的信息。以下是一些概述：</p>
<p><em>表 10-3：top 信息字段</em></p>
<table>
<thead>
<tr>
<th><strong>行数</strong></th>
<th><strong>字段</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>top</td>
<td>程序的名称。</td>
</tr>
<tr>
<td></td>
<td>14:59:20</td>
<td>当前的时间。</td>
</tr>
<tr>
<td></td>
<td>up 6:30</td>
<td>这称为 <em>运行时间</em>（uptime）。这是自上次启动机器以来的时间。在此示例中，系统已经运行了六个半小时。</td>
</tr>
<tr>
<td>2 个用户</td>
<td>有两个用户登录。</td>
<td></td>
</tr>
<tr>
<td>负载平均值：</td>
<td><em>负载平均值</em> 是指等待运行的进程数，即处于可运行状态并共享 CPU 的进程数。显示三个值，每个值对应不同的时间段。第一个是过去60秒的平均值，接下来是过去5分钟和过去15分钟的平均值。小于1.0的值表示机器不忙。</td>
<td></td>
</tr>
<tr>
<td>2        任务：</td>
<td>这总结了进程的数量及其各种进程状态。</td>
<td></td>
</tr>
<tr>
<td>3        CPU(s)：</td>
<td>这一行描述了 CPU 正在执行的活动的性质。</td>
<td></td>
</tr>
<tr>
<td>0.7%us</td>
<td>0.7% 的 CPU 用于 <em>用户进程</em>，意味着内核外的进程。</td>
<td></td>
</tr>
<tr>
<td>1.0%sy</td>
<td>1.0% 的 CPU 用于 <em>系统</em>（内核）进程。</td>
<td></td>
</tr>
<tr>
<td>0.0%ni</td>
<td>0.0% 的 CPU 由“nice”（低优先级）进程使用。</td>
<td></td>
</tr>
<tr>
<td>98.3%id</td>
<td>98.3% 的 CPU 空闲。</td>
<td></td>
</tr>
<tr>
<td>0.0%wa</td>
<td>0.0% 的 CPU 等待 I&#x2F;O。</td>
<td></td>
</tr>
<tr>
<td>4        内存：</td>
<td>显示物理 RAM 的使用情况。</td>
<td></td>
</tr>
<tr>
<td>5        交换：</td>
<td>显示交换空间（虚拟内存）的使用情况。</td>
<td></td>
</tr>
</tbody></table>
<p>top程序接受许多键盘命令。最有趣的两个命令是h，它显示程序的帮助屏幕，和q，它退出top。</p>
<p>所有主要的桌面环境都提供了类似于top的图形应用程序（就像Windows中的任务管理器的工作方式），但top比图形版本更好，因为它更快，消耗的系统资源也少得多。毕竟，我们的系统监视程序不应该是我们试图跟踪的系统减速的来源。</p>
<h3 id="控制进程"><a href="#控制进程" class="headerlink" title="控制进程"></a>控制进程</h3><p>既然我们可以看到并监控进程，让我们对它们进行一些控制。对于我们的实验，我们将使用一个名为xlogo的小程序作为我们的实验对象。xlogo程序是X窗口系统（使我们显示屏上的图形动起来的底层引擎）提供的一个示例程序，它简单地显示一个包含X标志的可调整大小的窗口。首先，我们来了解一下我们的测试对象。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo</span><br></pre></td></tr></table></figure>

<p>在输入命令后，屏幕上应该会出现一个包含标志的小窗口。在某些系统上，xlogo可能会打印一个警告消息，但可以安全地忽略。</p>
<p><strong>提示：</strong> 如果您的系统没有包含xlogo程序，可以尝试使用gedit或kwrite代替。</p>
<p>我们可以通过调整其窗口大小来验证xlogo是否正在运行。如果标志以新的大小重新绘制，那么程序正在运行。</p>
<p>注意，我们的shell提示符还没有返回吗？这是因为shell正在等待程序完成，就像我们到目前为止使用的所有其他程序一样。如果我们关闭xlogo窗口，提示符将返回。</p>
<p><img src="/images/2024/Picture4.png"></p>
<p><em>图 4：xlogo程序</em></p>
<h4 id="中断进程"><a href="#中断进程" class="headerlink" title="中断进程"></a>中断进程</h4><p>让我们观察再次运行xlogo时会发生什么。首先，输入xlogo命令并验证程序正在运行。接下来，返回到终端窗口并按下Ctrl-c。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>在终端中，按下Ctrl-c会<em>中断</em>一个程序。这意味着我们礼貌地请求程序终止。按下Ctrl-c后，xlogo窗口关闭，shell提示符返回。</p>
<p>许多（但不是所有）命令行程序可以使用这种技术中断。</p>
<h4 id="将进程放入后台"><a href="#将进程放入后台" class="headerlink" title="将进程放入后台"></a>将进程放入后台</h4><p>假设我们想要在不终止xlogo程序的情况下恢复shell提示符。我们可以通过将程序放入<em>后台</em>来实现这一点。可以将终端视为具有<em>前台</em>（在表面上可见，如shell提示符）和<em>后台</em>（在表面后隐藏的内容）。为了启动一个程序并立即将其放入后台，我们在命令后加上一个&amp;符号。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[1] 28236</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>输入命令后，xlogo窗口出现，shell提示符返回，但也打印了一些奇怪的数字。这条消息是shell功能中的一部分，称为<em>作业控制</em>。通过此消息，shell告诉我们已启动作业编号为1([1])，其进程ID为28236。如果我们运行ps，我们可以看到我们的进程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ps</span><br><span class="line"> PID TTY TIME CMD</span><br><span class="line">10603 pts/1 00:00:00 bash</span><br><span class="line">28236 pts/1 00:00:00 xlogo</span><br><span class="line">28239 pts/1 00:00:00 ps</span><br></pre></td></tr></table></figure>

<p>shell的作业控制功能还为我们提供了一种列出从我们的终端启动的作业的方法。使用jobs命令，我们可以看到此列表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ jobs</span><br><span class="line">[1]+ Running xlogo &amp;</span><br></pre></td></tr></table></figure>

<p>结果显示我们有一个作业，编号为1，它正在运行，命令是xlogo &amp;。</p>
<h4 id="将进程返回到前台"><a href="#将进程返回到前台" class="headerlink" title="将进程返回到前台"></a>将进程返回到前台</h4><p>后台中的进程不受终端键盘输入的影响，包括使用Ctrl-c中断它的任何尝试。要将进程返回到前台，请使用以下方式的fg命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ jobs</span><br><span class="line">[1]+ Running xlogo &amp;</span><br><span class="line">[me@linuxbox ~]$ fg %1</span><br><span class="line">xlogo</span><br></pre></td></tr></table></figure>

<p>fg命令后跟一个百分号和作业编号（称为<em>jobspec</em>）就可以完成这个操作。如果我们只有一个后台作业，那么jobspec是可选的。要终止xlogo，按下Ctrl-c。</p>
<h4 id="暂停进程"><a href="#暂停进程" class="headerlink" title="暂停进程"></a>暂停进程</h4><p>有时，我们会想要暂停一个进程而不终止它。这通常是为了允许将前台进程移到后台。要暂停一个前台进程并将其放入后台，请按下Ctrl-z。让我们试一试。在命令提示符处，输入xlogo，按Enter键，然后按Ctrl-z：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo</span><br><span class="line">[1]+ Stopped xlogo</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>暂停xlogo后，我们可以通过尝试调整xlogo窗口的大小来验证该程序已停止。我们会看到它似乎已经停止了。我们可以使用fg命令在前台继续程序的执行，或者使用bg命令在后台恢复程序的执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ bg %1</span><br><span class="line">[1]+ xlogo &amp;</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>与fg命令一样，如果只有一个作业，则jobspec是可选的。</p>
<p>将进程从前台移到后台非常有用，如果我们从命令行启动一个图形程序，但忘记通过附加尾部的&amp;将其放入后台。</p>
<p>为什么我们要从命令行启动一个图形程序呢？有两个原因。</p>
<ul>
<li>我们想要运行的程序可能没有列在窗口管理器的菜单上（例如xlogo）。</li>
<li>通过从命令行启动程序，我们可能能够看到通常在图形启动时隐藏的错误消息。有时，从图形菜单启动时，程序可能无法启动。通过从命令行启动它，我们可能会看到一个错误消息，从而揭示问题。此外，一些图形程序具有有趣且有用的命令行选项。</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>kill命令用于“终止”进程。这使我们可以终止需要终止的程序。以下是一个示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[1] 28401</span><br><span class="line">[me@linuxbox ~]$ kill 28401</span><br><span class="line">[1]+ Terminated xlogo</span><br></pre></td></tr></table></figure>

<p>首先，我们在后台启动xlogo。Shell会打印jobspec和后台进程的PID。接下来，我们使用kill命令并指定我们想要终止的进程的PID。我们也可以使用jobspec（例如%1）而不是PID来指定进程。</p>
<p>虽然这都很直接明了，但事实并非如此简单。kill命令并不完全“杀死”进程：它实际上是发送给它们<em>信号</em>。信号是操作系统与程序通信的几种方式之一。我们已经通过使用Ctrl-c和Ctrl-z看到了信号的效果。当终端接收到这些按键时，它会向前台程序发送一个信号。对于Ctrl-c，会发送一个名为INT（中断）的信号；对于Ctrl-z，会发送一个名为TSTP（终端停止）的信号。程序反过来会“监听”这些信号，并可能在接收到它们时采取行动。程序能够监听并根据信号采取行动的事实允许程序在收到终止信号时执行保存工作的操作。</p>
<h4 id="使用kill向进程发送信号"><a href="#使用kill向进程发送信号" class="headerlink" title="使用kill向进程发送信号"></a>使用kill向进程发送信号</h4><p>kill命令用于向程序发送信号。其最常见的语法看起来像这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [-signal] PID...</span><br></pre></td></tr></table></figure>

<p>如果在命令行上没有指定信号，则默认发送TERM（终止）信号。kill命令最常用于发送以下信号：</p>
<p><em>Table 10-4: 常见信号</em></p>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>名称</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>HUP</td>
<td>挂断。这是早期终端连接到远程计算机的好日子的遗留。该信号用于指示控制终端已“挂断”。此信号的效果可以通过关闭终端会话来演示。运行在终端上的前台程序将收到该信号并终止。许多守护程序也使用此信号进行重新初始化，例如Apache Web服务器。</td>
</tr>
<tr>
<td>2</td>
<td>INT</td>
<td>中断。这与从终端发送的Ctrl-c执行相同的功能。它通常会终止一个程序。</td>
</tr>
<tr>
<td>9</td>
<td>KILL</td>
<td>杀死。这个信号是特殊的。当一个进程以这种方式被终止时，它不会有机会“清理”自己或保存其工作。因此，KILL信号只应作为其他终止信号失败时的最后手段。</td>
</tr>
<tr>
<td>15</td>
<td>TERM</td>
<td>终止。这是kill命令默认发送的信号。如果一个程序仍然“活跃”到可以接收信号，它将终止。</td>
</tr>
<tr>
<td>18</td>
<td>CONT</td>
<td>继续。这将在STOP或TSTP信号后恢复一个进程。这个信号由bg和fg命令发送。</td>
</tr>
<tr>
<td>19</td>
<td>STOP</td>
<td>停止。这个信号使进程暂停而不终止。</td>
</tr>
<tr>
<td>20</td>
<td>TSTP</td>
<td>终端停止。这是当按下Ctrl-z时终端发送的信号。与STOP信号不同，TSTP信号由程序接收，但程序可能选择忽略它。</td>
</tr>
</tbody></table>
<p>让我们尝试使用kill命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[1] 13546</span><br><span class="line">[me@linuxbox ~]$ kill -1 13546</span><br><span class="line">[1]+ Hangup xlogo</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们在后台启动了xlogo程序，然后使用kill发送了一个HUP信号给它。xlogo程序终止了，并且shell指示后台进程已接收到一个挂断信号。在消息出现之前，我们可能需要按几次Enter键。请注意，信号可以通过数字或名称指定，包括以SIG开头的名称。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[1] 13601</span><br><span class="line">[me@linuxbox ~]$ kill -INT 13601</span><br><span class="line">[1]+ Interrupt xlogo</span><br><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[1] 13608</span><br><span class="line">[me@linuxbox ~]$ kill -SIGINT 13608</span><br><span class="line">[1]+ Interrupt xlogo</span><br></pre></td></tr></table></figure>

<p>重复上面的示例，并尝试其他信号。记住，我们也可以使用jobspecs代替PID。</p>
<p>与文件一样，进程也有所有者，您必须是进程的所有者（或超级用户）才能使用kill向其发送信号。</p>
<p>除了上面列出的与kill一起最常使用的信号外，系统还经常使用如下表10-5所列的其他信号。</p>
<p><em>Table 10-5: 其他常见信号</em></p>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>名称</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>QUIT</td>
<td>退出。</td>
</tr>
<tr>
<td>11</td>
<td>SEGV</td>
<td>分段违规。如果程序非法使用内存，也就是说，它尝试写入它不被允许写入的地方，将发送此信号。</td>
</tr>
<tr>
<td>28</td>
<td>WINCH</td>
<td>窗口改变。这是当窗口改变大小时系统发送的信号。一些程序，如top和less，将响应此信号，以适应新的窗口尺寸进行重绘。</td>
</tr>
</tbody></table>
<p>对于好奇的人，可以使用以下命令显示完整的信号列表：</p>
<h4 id="使用killall向多个进程发送信号"><a href="#使用killall向多个进程发送信号" class="headerlink" title="使用killall向多个进程发送信号"></a>使用killall向多个进程发送信号</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ kill -l</span><br></pre></td></tr></table></figure>

<p>使用killall命令，还可以向匹配指定程序或用户名的多个进程发送信号。以下是语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall [-u user] [-signal] name...</span><br></pre></td></tr></table></figure>

<p>为了演示，我们将启动几个xlogo程序的实例，然后终止它们。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[1] 18801</span><br><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[2] 18802</span><br><span class="line">[me@linuxbox ~]$ killall xlogo</span><br><span class="line">[1]- Terminated xlogo</span><br><span class="line">[2]+ Terminated xlogo</span><br></pre></td></tr></table></figure>

<p>请记住，与kill一样，我们必须具有超级用户权限，才能向不属于我们的进程发送信号。</p>
<h3 id="关闭系统"><a href="#关闭系统" class="headerlink" title="关闭系统"></a>关闭系统</h3><p>关闭系统的过程涉及有序终止系统上的所有进程，并在系统关机前执行一些重要的维护任务（例如同步所有挂载的文件系统）。有四个命令可以执行此功能。它们是halt、poweroff、reboot和shutdown。前三个命令相当直观，并且通常不使用任何命令行选项。以下是一个示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo reboot</span><br></pre></td></tr></table></figure>

<p>shutdown命令稍微有点有趣。使用它，我们可以指定要执行的操作（halt、power down或reboot），并为关闭事件提供时间延迟。最常用的方式是这样来停止系统：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo shutdown -h now</span><br></pre></td></tr></table></figure>

<p>或者像这样重新启动系统：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo shutdown -r now</span><br></pre></td></tr></table></figure>

<p>延迟可以以多种方式指定。有关详细信息，请参阅shutdown的man页面。执行shutdown命令后，会向所有登录用户“广播”一个消息，警告他们即将发生的事件。</p>
<h3 id="更多与进程相关的命令"><a href="#更多与进程相关的命令" class="headerlink" title="更多与进程相关的命令"></a>更多与进程相关的命令</h3><p>由于监控进程是一个重要的系统管理任务，因此有很多相关的命令。表10-6列出了一些可以尝试的命令：</p>
<p><em>表10-6：其他与进程相关的命令</em></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>pstree</td>
<td>输出一个按树状模式排列的进程列表，显示进程之间的父子关系。</td>
</tr>
<tr>
<td>vmstat</td>
<td>输出包括内存、交换和磁盘I&#x2F;O在内的系统资源使用的快照。要看到持续的显示，请在命令后跟一个时间延迟（以秒为单位）来更新。例如：vmstat 5。使用Ctrl-c终止输出。</td>
</tr>
<tr>
<td>xload</td>
<td>一个绘制系统负载随时间变化的图形的图形程序。</td>
</tr>
<tr>
<td>tload</td>
<td>类似于xload程序，但在终端中绘制图形。使用Ctrl-c终止输出。</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大多数现代系统都具有管理多个进程的机制。Linux为此提供了丰富的工具集。鉴于Linux是全球部署最多的服务器操作系统，这是非常合理的。然而，与某些其他系统不同，Linux主要依赖命令行工具进行进程管理。虽然Linux有图形进程工具，但由于其速度和轻量级占用，命令行工具受到了极大的青睐。尽管GUI工具看起来很漂亮，但它们经常会增加系统负载，这在某种程度上有悖于初衷。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/TLCL/" rel="tag"># TLCL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/03/9-permissions/" rel="prev" title="权限">
                  <i class="fa fa-angle-left"></i> 权限
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/03/11-the-environment/" rel="next" title="环境">
                  环境 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Slagga</span>
  </div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdHNsYWdnYQ==" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/sidebar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/search/local-search.min.js"></script>




  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/fancybox.min.js"></script>



  




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"gitslagga","repo":"gitslagga.github.io","client_id":"8b03c773267690e6d402","client_secret":"7b2ef82f50c632cdb14c98b7e5928357974cad97","admin_user":"gitslagga","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"d70e3fa48a8e4f2b8b2618147de638de"}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/comments/gitalk.min.js"></script>

</body>
</html>
