<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="E1ct36DyjSpaeX5NMAVsyzCjDs8-dQxGThgvw2i1yg0">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"slagga.top","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.21.0","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/config.min.js"></script>

    <meta name="description" content="19章 - 正则表达式在接下来的几章中，我们将探讨用于处理文本的工具。正如我们所见，文本数据在所有类 Unix 系统（如 Linux）上扮演着重要角色。但在我们能充分欣赏这些工具提供的所有功能之前，我们首先需要研究一个与这些工具的最复杂用途经常相关的技术——正则表达式。 当我们浏览命令行提供的许多功能和设施时，我们遇到了一些真正晦涩的 shell 特性和命令，比如 shell 扩展和引用、键盘快捷">
<meta property="og:type" content="article">
<meta property="og:title" content="正则表达式">
<meta property="og:url" content="https://slagga.top/2024/04/19-regular-expressions/index.html">
<meta property="og:site_name" content="计算机那些事">
<meta property="og:description" content="19章 - 正则表达式在接下来的几章中，我们将探讨用于处理文本的工具。正如我们所见，文本数据在所有类 Unix 系统（如 Linux）上扮演着重要角色。但在我们能充分欣赏这些工具提供的所有功能之前，我们首先需要研究一个与这些工具的最复杂用途经常相关的技术——正则表达式。 当我们浏览命令行提供的许多功能和设施时，我们遇到了一些真正晦涩的 shell 特性和命令，比如 shell 扩展和引用、键盘快捷">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-24T13:14:30.000Z">
<meta property="article:modified_time" content="2025-06-06T06:13:40.952Z">
<meta property="article:author" content="Slagga">
<meta property="article:tag" content="TLCL">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://slagga.top/2024/04/19-regular-expressions/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://slagga.top/2024/04/19-regular-expressions/","path":"2024/04/19-regular-expressions/","title":"正则表达式"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>正则表达式 | 计算机那些事</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-0E2T2VNH5S"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-0E2T2VNH5S","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/analytics/google-analytics.min.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">计算机那些事</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">软件开发、定制和合作。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">229</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">78</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">28</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#19%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">19章 - 正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#grep"><span class="nav-number">1.1.</span> <span class="nav-text">grep</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">元字符和字面量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E5%AD%97%E7%AC%A6"><span class="nav-number">1.1.2.</span> <span class="nav-text">任意字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%9A%E7%82%B9"><span class="nav-number">1.1.3.</span> <span class="nav-text">锚点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%AC%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E7%B1%BB"><span class="nav-number">1.1.4.</span> <span class="nav-text">括号表达式和字符类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%A6%E5%AE%9A"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">否定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E5%AD%97%E7%AC%A6%E8%8C%83%E5%9B%B4"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">传统字符范围</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#POSIX-%E5%AD%97%E7%AC%A6%E7%B1%BB"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">POSIX 字符类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E5%88%B0%E4%BC%A0%E7%BB%9F%E6%8E%92%E5%BA%8F%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.1.5.</span> <span class="nav-text">恢复到传统排序顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#POSIX-%E5%9F%BA%E6%9C%AC%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.1.6.</span> <span class="nav-text">POSIX 基本与扩展正则表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#POSIX"><span class="nav-number">1.1.7.</span> <span class="nav-text">POSIX</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E6%9B%BF"><span class="nav-number">1.1.8.</span> <span class="nav-text">交替</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8F%E8%AF%8D"><span class="nav-number">1.1.9.</span> <span class="nav-text">量词</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E9%9B%B6%E6%AC%A1%E6%88%96%E4%B8%80%E6%AC%A1"><span class="nav-number">1.1.9.1.</span> <span class="nav-text">? - 匹配一个元素零次或一次</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E9%9B%B6%E6%AC%A1%E6%88%96%E5%A4%9A%E6%AC%A1"><span class="nav-number">1.1.9.2.</span> <span class="nav-text">* - 匹配一个元素零次或多次</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%80%E6%AC%A1%E6%88%96%E5%A4%9A%E6%AC%A1"><span class="nav-number">1.1.9.3.</span> <span class="nav-text">+ - 匹配一个元素一次或多次</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%89%B9%E5%AE%9A%E6%AC%A1%E6%95%B0"><span class="nav-number">1.1.9.4.</span> <span class="nav-text">{ } - 匹配一个元素特定次数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.1.10.</span> <span class="nav-text">应用正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-grep-%E9%AA%8C%E8%AF%81%E7%94%B5%E8%AF%9D%E5%88%97%E8%A1%A8"><span class="nav-number">1.1.10.1.</span> <span class="nav-text">使用 grep 验证电话列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-find-%E6%9F%A5%E6%89%BE%E4%B8%91%E9%99%8B%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D"><span class="nav-number">1.1.10.2.</span> <span class="nav-text">使用 find 查找丑陋的文件名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-locate-%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.10.3.</span> <span class="nav-text">使用 locate 搜索文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-less-%E5%92%8C-vim-%E6%90%9C%E7%B4%A2%E6%96%87%E6%9C%AC"><span class="nav-number">1.1.10.4.</span> <span class="nav-text">使用 less 和 vim 搜索文本</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.11.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%98%85%E8%AF%BB"><span class="nav-number">1.1.12.</span> <span class="nav-text">进一步阅读</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Slagga"
      src="https://avatars.githubusercontent.com/u/19620432">
  <p class="site-author-name" itemprop="name">Slagga</p>
  <div class="site-description" itemprop="description">计算机那些事 - 个人博客网站，涉及的领域包括IT技术、区块链行业、产品思维、运营能力、个人观点等</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">229</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdHNsYWdnYQ==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gitslagga"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnNsYWdnYUBkdWNrLmNvbQ==" title="E-Mail → mailto:slagga@duck.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://slagga.top/2024/04/19-regular-expressions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/19620432">
      <meta itemprop="name" content="Slagga">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="计算机那些事">
      <meta itemprop="description" content="计算机那些事 - 个人博客网站，涉及的领域包括IT技术、区块链行业、产品思维、运营能力、个人观点等">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="正则表达式 | 计算机那些事">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          正则表达式
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-24 21:14:30" itemprop="dateCreated datePublished" datetime="2024-04-24T21:14:30+08:00">2024-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-06 14:13:40" itemprop="dateModified" datetime="2025-06-06T14:13:40+08:00">2025-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="19章-正则表达式"><a href="#19章-正则表达式" class="headerlink" title="19章 - 正则表达式"></a>19章 - 正则表达式</h2><p>在接下来的几章中，我们将探讨用于处理文本的工具。正如我们所见，文本数据在所有类 Unix 系统（如 Linux）上扮演着重要角色。但在我们能充分欣赏这些工具提供的所有功能之前，我们首先需要研究一个与这些工具的最复杂用途经常相关的技术——<em>正则表达式</em>。</p>
<p>当我们浏览命令行提供的许多功能和设施时，我们遇到了一些真正晦涩的 shell 特性和命令，比如 shell 扩展和引用、键盘快捷键和命令历史记录，更不用说 vi 编辑器了。正则表达式继续这个“传统”，可以说是它们中最晦涩的特性。这并不是说学习它们所花费的时间不值得。恰恰相反，良好的理解将使我们能够执行惊人的技巧，尽管它们的全部价值可能不会立即显现。</p>
<span id="more"></span>

<p>什么是正则表达式？</p>
<p>简单地说，正则表达式是用来识别文本中模式的符号表示。在某些方面，它们类似于 shell 的通配符匹配文件和路径名的方法，但规模更大。正则表达式被许多命令行工具和大多数编程语言支持，以便解决文本操作问题。然而，为了进一步增加混乱，不是所有的正则表达式都是相同的；它们在不同工具和编程语言之间略有差异。对于我们的讨论，我们将限制自己在 POSIX 标准中描述的正则表达式（这将涵盖大多数命令行工具），而不是许多编程语言（尤其是 <em>Perl</em>），它们使用略微更大、更丰富的符号集。</p>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>我们将用来处理正则表达式的主要程序是我们的老朋友 grep。”grep” 这个名字实际上源自 “global regular expression print” 这个短语，所以我们可以看出 grep 与正则表达式有某种关系。本质上，grep 在文本文件中搜索匹配指定正则表达式的文本出现，并将包含匹配的任何行输出到标准输出。</p>
<p>到目前为止，我们使用 grep 来处理固定字符串，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/bin | grep zip</span><br></pre></td></tr></table></figure>

<p>这将列出 &#x2F;usr&#x2F;bin 目录中名称包含子字符串 zip 的所有文件。</p>
<p>grep 程序接受选项和参数的方式如下，其中 <em>regex</em> 是一个正则表达式：</p>
<p><strong>grep [</strong><em><strong>options</strong></em>] <em><strong>regex</strong></em> [<em><strong>file…</strong></em>]</p>
<p>表 19-1 描述了常用的 grep 选项。</p>
<p><em>表 19-1:</em> <em>grep 选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>长选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>–ignore-case</td>
<td>忽略大小写。不区分大写和小写字符。</td>
</tr>
<tr>
<td>-v</td>
<td>–invert-match</td>
<td>反向匹配。通常，grep 打印包含匹配项的行。此选项使 grep 打印不包含匹配项的每一行。</td>
</tr>
<tr>
<td>-c</td>
<td>–count</td>
<td>打印匹配数（如果也指定了 -v 选项，则打印非匹配数）而不是行本身。</td>
</tr>
<tr>
<td>-l</td>
<td>–files-with-matches</td>
<td>打印包含匹配项的每个文件的名称，而不是行本身。</td>
</tr>
<tr>
<td>-L</td>
<td>–files-without-match</td>
<td>类似于 -l 选项，但仅打印不包含匹配项的文件名称。</td>
</tr>
<tr>
<td>-n</td>
<td>–line-number</td>
<td>在每个匹配行前加上该行在文件中的行号。</td>
</tr>
<tr>
<td>-h</td>
<td>–no-filename</td>
<td>对于多文件搜索，抑制文件名的输出。</td>
</tr>
</tbody></table>
<p>为了更全面地探索 grep，让我们创建一些文本文件来搜索。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /bin &gt; dirlist-bin.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/bin &gt; dirlist-usr-bin.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /sbin &gt; dirlist-sbin.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/sbin &gt; dirlist-usr-sbin.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> dirlist*.txt</span><br><span class="line">dirlist-bin.txt dirlist-sbin.txt dirlist-usr-sbin.txt</span><br><span class="line">dirlist-usr-bin.txt</span><br></pre></td></tr></table></figure>

<p>我们可以像这样执行文件列表的简单搜索：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep bzip dirlist*.txt</span><br><span class="line">dirlist-bin.txt:bzip2</span><br><span class="line">dirlist-bin.txt:bzip2recover</span><br></pre></td></tr></table></figure>

<p>在这个例子中，grep 搜索所有列出的文件以查找字符串 bzip，并在文件 dirlist-bin.txt 中找到两个匹配项。如果我们只对包含匹配项的文件列表感兴趣，而不是匹配项本身，我们可以指定 -l 选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -l bzip dirlist*.txt</span><br><span class="line">dirlist-bin.txt</span><br></pre></td></tr></table></figure>

<p>相反，如果我们只想看到不包含匹配项的文件列表，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -L bzip dirlist*.txt</span><br><span class="line">dirlist-sbin.txt</span><br><span class="line">dirlist-usr-bin.txt</span><br><span class="line">dirlist-usr-sbin.txt</span><br></pre></td></tr></table></figure>

<h4 id="元字符和字面量"><a href="#元字符和字面量" class="headerlink" title="元字符和字面量"></a>元字符和字面量</h4><p>虽然可能不太明显，但我们的 grep 搜索一直在使用正则表达式，尽管非常简单。正则表达式 bzip 被理解为只有当文件中的行包含至少四个字符，并且在某处按顺序找到字符 b、z、i 和 p，中间没有其他字符时，才会发生匹配。字符串 bzip 中的字符都是<em>字面量字符</em>，它们与自身匹配。除了字面量之外，正则表达式还可能包含用于指定更复杂匹配的<em>元字符</em>。正则表达式的元字符包括以下内容：</p>
<p><strong>^ $ . [ ] { } - ? * + ( ) | \</strong></p>
<p>所有其他字符都被视为字面量，尽管反斜杠字符在一些情况下用于创建<em>元序列</em>，以及允许元字符被转义并作为字面量处理，而不是被解释为元字符。</p>
<p><strong>注意：</strong> 如我们所见，许多正则表达式元字符也是在进行扩展时对 shell 有意义的字符。当我们在命令行上传递包含元字符的正则表达式时，将它们用引号括起来以防止 shell 尝试扩展它们是至关重要的。</p>
<h4 id="任意字符"><a href="#任意字符" class="headerlink" title="任意字符"></a>任意字符</h4><p>我们将要看的第一个元字符是点或句点字符，用于匹配任意字符。如果我们在正则表达式中包含它，它将匹配该字符位置的任何字符。这里有一个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;.zip&#x27;</span> dirlist*.txt</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line">bzip2recover</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">funzip</span><br><span class="line">gpg-zip</span><br><span class="line">preunzip</span><br><span class="line">prezip</span><br><span class="line">prezip-bin</span><br><span class="line">unzip</span><br><span class="line">unzipsfx</span><br></pre></td></tr></table></figure>

<p>我们搜索了所有文件中与正则表达式 .zip 匹配的任何行。关于结果有几点值得注意。注意 zip 程序没有被找到。这是因为我们在正则表达式中包含了点元字符，将所需匹配的长度增加到四个字符，而由于名称 zip 只包含三个字符，因此不匹配。此外，如果我们的列表中的任何文件包含了文件扩展名 .zip，它们也会被匹配，因为文件扩展名中的句点字符也会被“任意字符”匹配。</p>
<h4 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h4><p>在正则表达式中，插入符号 (^) 和美元符号 (<code>$) 被视为*锚点*。这意味着它们会导致匹配仅在行的开头 (^) 或行的结尾 ($</code>) 发生。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^zip&#x27;</span> dirlist*.txt</span><br><span class="line">zip</span><br><span class="line">zipcloak</span><br><span class="line">zipgrep</span><br><span class="line">zipinfo</span><br><span class="line">zipnote</span><br><span class="line">zipsplit</span><br><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;zip$&#x27;</span> dirlist*.txt</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">funzip</span><br><span class="line">gpg-zip</span><br><span class="line">preunzip</span><br><span class="line">prezip</span><br><span class="line">unzip</span><br><span class="line">zip</span><br><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^zip$&#x27;</span> dirlist*.txt</span><br><span class="line">zip</span><br></pre></td></tr></table></figure>

<p>这里我们搜索了文件列表中位于行开头、行尾、以及行的开头和结尾（即，独自位于行上）的字符串 zip。请注意，正则表达式 ^$（一个开头和一个结尾之间没有任何东西）将匹配空行。</p>
<p><strong>填字游戏助手</strong></p>
<p>即使到目前为止，我们对正则表达式的了解有限，我们也可以做一些有用的事情。</p>
<p>我的妻子喜欢填字游戏，有时她会问我某个特定问题的帮助。比如，“什么是第三个字母是‘j’，最后一个字母是‘r’的五个字母的</p>
<p>单词，意思是……？” 这种问题让我开始思考。</p>
<p>你知道你的 Linux 系统中包含了一个字典吗？确实如此。看看 &#x2F;usr&#x2F;share&#x2F;dict 目录，你可能会发现一个或几个。那里的字典文件只是按字母顺序排列的长单词列表，每行一个。在我的系统上，words 文件包含了超过 98,500 个单词。为了找到上述填字游戏问题的可能答案，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -i <span class="string">&#x27;^..j.r$&#x27;</span> /usr/share/dict/words</span><br><span class="line">Major</span><br><span class="line">major</span><br></pre></td></tr></table></figure>

<p>使用这个正则表达式，我们可以在字典文件中找到所有长度为五个字母的单词，其中第三个位置是 j，最后一个位置是 r。</p>
<h4 id="括号表达式和字符类"><a href="#括号表达式和字符类" class="headerlink" title="括号表达式和字符类"></a>括号表达式和字符类</h4><p>除了在正则表达式的给定位置匹配任意字符外，我们还可以使用<em>括号表达式</em>从指定的字符集中匹配单个字符。通过括号表达式，我们可以指定一组字符（包括那些否则会被解释为元字符的字符）来进行匹配。在这个例子中，使用两个字符的集合，我们匹配包含字符串 bzip 或 gzip 的任何行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;[bg]zip&#x27;</span> dirlist*.txt</span><br><span class="line">bzip2</span><br><span class="line">bzip2recover</span><br><span class="line">gzip </span><br></pre></td></tr></table></figure>

<p>一个集合可以包含任意数量的字符，当放在括号中时，元字符会失去其特殊含义。然而，在括号表达式中有两种情况会使用元字符，并且有不同的含义。第一种情况是插入符号 (^)，用来表示否定；第二种是破折号 (-)，用来表示字符范围。</p>
<h5 id="否定"><a href="#否定" class="headerlink" title="否定"></a>否定</h5><p>如果括号表达式中的第一个字符是插入符号 (^)，则其余字符将被视为一组不得出现在给定字符位置的字符。我们可以通过修改我们之前的例子来做到这一点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;[^bg]zip&#x27;</span> dirlist*.txt</span><br><span class="line">bunzip2</span><br><span class="line">gunzip</span><br><span class="line">funzip</span><br><span class="line">gpg-zip</span><br><span class="line">preunzip</span><br><span class="line">prezip</span><br><span class="line">prezip-bin</span><br><span class="line">unzip</span><br><span class="line">unzipsfx</span><br></pre></td></tr></table></figure>

<p>启用否定后，我们得到了一系列文件列表，其中包含字符串 zip，其前面有除 b 或 g 以外的任何字符。请注意，文件 zip 没有被找到。否定的字符集仍然需要在给定位置有一个字符，但该字符不能是否定集中的成员。</p>
<p>如果插入符号是括号表达式中的第一个字符，它才会激发否定；否则，它失去其特殊含义，成为集合中的普通字符。</p>
<h5 id="传统字符范围"><a href="#传统字符范围" class="headerlink" title="传统字符范围"></a>传统字符范围</h5><p>如果我们想构建一个正则表达式，以找到我们列表中所有以大写字母开头的文件，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^[ABCDEFGHIJKLMNOPQRSTUVWXZY]&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure>

<p>只需在括号表达式中放置所有 26 个大写字母。但这么多打字的想法令人深感困扰，所以还有另一种方式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^[A-Z]&#x27;</span> dirlist*.txt</span><br><span class="line">MAKEDEV</span><br><span class="line">ControlPanel</span><br><span class="line">GET </span><br><span class="line">HEAD</span><br><span class="line">POST</span><br><span class="line">X</span><br><span class="line">X11</span><br><span class="line">Xorg</span><br><span class="line">MAKEFLOPPIES</span><br><span class="line">NetworkManager</span><br><span class="line">NetworkManagerDispatcher</span><br></pre></td></tr></table></figure>

<p>通过使用三个字符的范围，我们可以缩写 26 个字母。任何字符范围都可以这样表示，包括多个范围，比如这个匹配所有以字母和数字开头的文件名的表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^[A-Za-z0-9]&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure>

<p>在字符范围中，我们看到破折号字符被特殊处理，那么我们如何实际在括号表达式中包含破折号字符呢？通过将其作为表达式中的第一个字符。考虑以下两个示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;[A-Z]&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure>

<p>这将匹配每个文件名中包含大写字母的文件。以下将匹配每个文件名中包含破折号、大写 A 或大写 Z 的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;[-AZ]&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure>

<h5 id="POSIX-字符类"><a href="#POSIX-字符类" class="headerlink" title="POSIX 字符类"></a>POSIX 字符类</h5><p>传统字符范围是处理快速指定字符集的问题的一</p>
<p>种容易理解且有效的方式。不幸的是，它们并不总是有效。尽管到目前为止我们在使用 grep 时没有遇到任何问题，但我们可能在使用其他程序时遇到问题。</p>
<p>在第 4 章中，我们研究了如何使用通配符进行路径名扩展。在那次讨论中，我们说字符范围可以以几乎与正则表达式中相同的方式使用，但这里有个问题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/sbin/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]*</span><br><span class="line">/usr/sbin/MAKEFLOPPIES</span><br><span class="line">/usr/sbin/NetworkManagerDispatcher</span><br><span class="line">/usr/sbin/NetworkManager</span><br></pre></td></tr></table></figure>

<p>（根据 Linux 发行版的不同，我们将得到不同的文件列表，可能是空列表。这个示例来自 Ubuntu）。这个命令产生了预期的结果 - 只列出了以大写字母开头的文件，但使用这个命令我们得到了完全不同的结果（只显示了结果的一部分）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/sbin/[A-Z]*</span><br><span class="line">/usr/sbin/biosdecode</span><br><span class="line">/usr/sbin/chat</span><br><span class="line">/usr/sbin/chgpasswd</span><br><span class="line">/usr/sbin/chpasswd</span><br><span class="line">/usr/sbin/chroot</span><br><span class="line">/usr/sbin/cleanup-info</span><br><span class="line">/usr/sbin/complain</span><br><span class="line">/usr/sbin/console-kit-daemon </span><br></pre></td></tr></table></figure>

<p>为什么会这样？这是个漫长的故事，但这里有个简短的版本：</p>
<p>早在 Unix 最初开发时，它只知道 ASCII 字符，这个特性反映了这个事实。在 ASCII 中，前 32 个字符（编号 0-31）是控制代码（比如制表符、退格符和回车）。接下来的 32 个字符（编号 32-63）包含可打印字符，包括大多数标点符号和数字 0-9。接下来的 32 个字符（编号 64-95）包含大写字母和更多标点符号。最后的 31 个字符（编号 96-126）包含小写字母和更多标点符号。基于这种排列，使用 ASCII 的系统使用了一个<em>排序顺序</em>，看起来像这样：</p>
<p><strong>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</strong></p>
<p>这与标准字典排序不同，标准字典排序是这样的：</p>
<p><strong>aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ</strong></p>
<p>随着 Unix 的普及超出美国范围，出现了对非美式英语中未出现的字符的支持需求。ASCII 表被扩展为使用完整的八位位元，添加了 128-255 号字符，这容纳了更多语言。为了支持这种能力，POSIX 标准引入了一个称为*地域设置（locale）*的概念，可以调整它来选择特定位置所需的字符集。我们可以使用这个命令查看系统的语言设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$LANG</span></span><br><span class="line">en_US.UTF-8</span><br></pre></td></tr></table></figure>

<p>在这个设置下，符合 POSIX 标准的应用程序将使用字典排序顺序而不是 ASCII 排序。这解释了前面命令的行为。当以字典排序解释时，字符范围 [A-Z] 包括了所有字母字符，除了小写的 a，因此我们得到了这样的结果。</p>
<p>为了部分解决这个问题，POSIX 标准包括了一些字符类，它们提供了如表 19-2 中描述的有用字符范围。</p>
<p>表 19-2: POSIX 字符类</p>
<table>
<thead>
<tr>
<th><strong>字符类</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>[:alnum:]</td>
<td>字母数字字符。在 ASCII 中，相当于 [A-Za-z0-9]。</td>
</tr>
<tr>
<td>[:word:]</td>
<td>与 [:alnum:] 相同，但添加了下划线 (_) 字符。</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>字母字符。在 ASCII 中，相当于 [A-Za-z]。</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>包括空格和制表符字符。</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>ASCII 控制代码。包括 ASCII 字符 0 到 31 和 127。</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>数字 0 到 9。</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>可见字符。在 ASCII 中，包括字符 33 到 126。</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>小写字母。</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>标点字符。在 ASCII 中，相当于 [-!”#$%&amp;’()*+,.&#x2F;:;&lt;&#x3D;&gt;?@[\]_`{|}~]。</td>
</tr>
<tr>
<td>[:print:]</td>
<td>可打印字符。[:graph:] 中的所有字符加上空格字符。</td>
</tr>
<tr>
<td>[:space:]</td>
<td>空白字符，包括空格、制表符、回车、换行、垂直制表符和换页符。在 ASCII 中，相当于 [ \t\r\n\v\f]。</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>大写字符。</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>用于表示十六进制数字的字符。在 ASCII 中，相当于 [0-9A-Fa-f]。</td>
</tr>
</tbody></table>
<p>即使有了字符类，仍然没有方便的方法来表达部分范围，比如 [A-M]。</p>
<p>使用字符类，我们可以重复我们的目录列表，并看到改进的结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/sbin/[[:upper:]]*</span><br><span class="line">/usr/sbin/MAKEFLOPPIES</span><br><span class="line">/usr/sbin/NetworkManagerDispatcher</span><br><span class="line">/usr/sbin/NetworkManager</span><br></pre></td></tr></table></figure>

<p>然而，请记住，这不是正则表达式的示例；相反，它是 shell 执行路径名扩展。我们在这里展示它是因为 POSIX 字符类可以用于这两种情况。</p>
<h4 id="恢复到传统排序顺序"><a href="#恢复到传统排序顺序" class="headerlink" title="恢复到传统排序顺序"></a><strong>恢复到传统排序顺序</strong></h4><p>您可以选择让您的系统使用传统的（ASCII）排序顺序，方法是更改 LANG 环境变量的值。正如我们之前看到的，LANG 变量包含了您所在地区使用的语言和字符集的名称</p>
<p>。这个值最初是在您安装 Linux 版本时选择了安装语言时确定的。</p>
<p>要查看地区设置，请使用 locale 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ locale</span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">LC_CTYPE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_NUMERIC=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_TIME=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_COLLATE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MONETARY=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MESSAGES=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_PAPER=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_NAME=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_ADDRESS=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_TELEPHONE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MEASUREMENT=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_IDENTIFICATION=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure>

<p>要更改地区设置以使用传统的 Unix 行为，请将 LANG 变量设置为 POSIX。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">export</span> LANG=POSIX</span><br></pre></td></tr></table></figure>

<p>请注意，此更改会将系统转换为使用美式英语（更具体地说，是 ASCII）作为其字符集，因此请确保这确实是您想要的。</p>
<p>您可以通过将以下行添加到 .bashrc 文件中来使此更改永久生效。</p>
<p><strong>export LANG&#x3D;POSIX</strong></p>
<h4 id="POSIX-基本与扩展正则表达式"><a href="#POSIX-基本与扩展正则表达式" class="headerlink" title="POSIX 基本与扩展正则表达式"></a>POSIX 基本与扩展正则表达式</h4><p>就在我们以为情况不可能变得更加混乱时，我们发现 POSIX 还将正则表达式的实现分为两种类型：<em>基本正则表达式（BRE）</em> 和 <em>扩展正则表达式（ERE）</em>。我们到目前为止所涉及的功能是任何符合 POSIX 标准并实现了 BRE 的应用程序所支持的。我们的 grep 程序就是这样一个程序。</p>
<p>BRE 和 ERE 之间的区别是什么？这是关于元字符的问题。在 BRE 中，以下元字符被识别：</p>
<p>**^ $ . [ ] ***</p>
<p>所有其他字符都被视为字面量。在 ERE 中，添加了以下元字符（及其相关功能）：</p>
<p><strong>( ) { } ? + |</strong></p>
<p>然而（这是有趣的部分），在 BRE 中，如果 (, ), {, 和 } 字符用反斜杠转义，则它们被视为元字符，而在 ERE 中，用反斜杠前置任何元字符会导致它被视为字面量。任何随之而来的怪异性都将在后面的讨论中涵盖。</p>
<p>由于我们接下来要讨论的功能是 ERE 的一部分，我们将需要使用不同的 grep。传统上，这是通过 egrep 程序完成的，但 GNU 版本的 grep 也支持使用 -E 选项时的扩展正则表达式。</p>
<h4 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h4><p>在 1980 年代，Unix 成为了一个非常流行的商业操作系统，但到了 1988 年，Unix 世界陷入了混乱。许多计算机制造商从其创造者 AT&amp;T 获得了 Unix 源代码的许可，并随其系统提供了各种版本的操作系统。然而，为了创造产品差异化，每个制造商都添加了专有的更改和扩展。这开始限制了软件的兼容性。一如既往，每个专有供应商都试图用他们的客户玩“锁定”游戏的获胜牌。今天，Unix 历史上的这段黑暗时期被称为“<em>巴尔干化</em>”。</p>
<p>电气和电子工程师学会（IEEE）出场了。在 20 世纪 80 年代中期，IEEE 开始制定一套标准，定义 Unix（和类 Unix）系统的性能。这些标准，正式称为 IEEE 1003，定义了标准类 Unix 系统上要找到的<em>应用程序接口</em>(API)、shell 和实用程序。POSIX（Portable Operating System Interface，可移植操作系统接口）这个名称是由理查德·斯托曼（没错，就是<em>那个</em>理查德·斯托曼）提出的，并被 IEEE 采纳。</p>
<h4 id="交替"><a href="#交替" class="headerlink" title="交替"></a>交替</h4><p>我们将讨论的第一个扩展正则表达式特性称为<em>交替</em>，它是允许从一组表达式中进行匹配的功能。就像括号表达式允许从指定的字符集中匹配单个字符一样，交替允许从一组字符串或其他正则表达式中进行匹配。</p>
<p>为了演示，我们将结合 echo 使用 grep。首先，让我们尝试一个普通的字符串匹配。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;AAA&quot;</span> | grep AAA</span><br><span class="line">AAA</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;BBB&quot;</span> | grep AAA</span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>这是一个非常直接的例子，我们将 echo 的输出管道传输到 grep 并看到结果。当匹配发生时，我们会看到它被打印出来；当没有</p>
<p>匹配发生时，我们看不到任何结果。</p>
<p>现在我们加入交替，用竖线元字符表示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;AAA&quot;</span> | grep -E <span class="string">&#x27;AAA|BBB&#x27;</span></span><br><span class="line">AAA</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;BBB&quot;</span> | grep -E <span class="string">&#x27;AAA|BBB&#x27;</span></span><br><span class="line">BBB</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;CCC&quot;</span> | grep -E <span class="string">&#x27;AAA|BBB&#x27;</span></span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>这里我们看到了正则表达式 ‘AAA|BBB’，意思是“匹配字符串 AAA 或字符串 BBB”。注意，由于这是一个扩展功能，我们添加了 -E 选项到 grep（虽然我们也可以只使用 egrep 程序），并将正则表达式用引号括起来以防止 shell 将竖线元字符解释为管道操作符。交替不限于两个选择。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;AAA&quot;</span> | grep -E <span class="string">&#x27;AAA|BBB|CCC&#x27;</span></span><br><span class="line">AAA</span><br></pre></td></tr></table></figure>

<p>要将交替与其他正则表达式元素结合起来，我们可以使用 () 来分隔交替。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -Eh <span class="string">&#x27;^(bz|gz|zip)&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure>

<p>这个表达式将匹配我们列表中以 bz、gz 或 zip 开头的文件名。如果我们没有加上括号，这个正则表达式的含义就会变成匹配任何以 bz 开头<em>或包含</em> gz <em>或包含</em> zip 的文件名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -Eh <span class="string">&#x27;^bz|gz|zip&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure>

<h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><p>扩展正则表达式支持几种指定元素匹配次数的方式，如下节所述。</p>
<h5 id="匹配一个元素零次或一次"><a href="#匹配一个元素零次或一次" class="headerlink" title="? - 匹配一个元素零次或一次"></a>? - 匹配一个元素零次或一次</h5><p>这个量词实际上意味着“使前面的元素变成可选的”。假设我们想检查一个电话号码的有效性，并且我们认为电话号码有效，如果它符合以下两种形式之一，其中 <em>n</em> 是一个数字：</p>
<p>(<em>nnn</em>) <em>nnn</em>-<em>nnnn 或 nnn</em> <em>nnn</em>-<em>nnnn</em></p>
<p>我们可以构造如下正则表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$</span><br></pre></td></tr></table></figure>

<p>在这个表达式中，我们在括号字符后面加上问号，表示它们应该匹配零次或一次。再次强调，由于括号通常是 ERE 中的元字符，我们在它们前面加上反斜杠，使它们被视为字面量而不是元字符。</p>
<p>让我们试一试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;(555) 123-4567&quot;</span> | grep -E <span class="string">&#x27;^\(?[0-9][0-9][0-9]</span></span><br><span class="line"><span class="string">\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$&#x27;</span></span><br><span class="line">(555) 123-4567</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;555 123-4567&quot;</span> | grep -E <span class="string">&#x27;^\(?[0-9][0-9][0-9]\)</span></span><br><span class="line"><span class="string">? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$&#x27;</span></span><br><span class="line">555 123-4567</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;AAA 123-4567&quot;</span> | grep -E <span class="string">&#x27;^\(?[0-9][0-9][0-9]\)</span></span><br><span class="line"><span class="string">? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$&#x27;</span></span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>我们看到，这个表达式匹配了电话号码的两种形式，但不匹配包含非数字字符的号码。这个表达式并不完美，因为它仍然允许区号周围的括号不匹配，但它可以执行验证的第一阶段。</p>
<h5 id="匹配一个元素零次或多次"><a href="#匹配一个元素零次或多次" class="headerlink" title="* - 匹配一个元素零次或多次"></a>* - 匹配一个元素零次或多次</h5><p>就像 ? 元字符一样，* 用于表示可选项；然而，不像 ?, 该项可以出现任意次数。假设我们想知道一个字符串是否是一个句子；也就是说，它以一个大写字母开头，然后包含任意数量的大写和小写字母以及空格，并以句号结尾。为了匹配这个（粗略的）句子定义，我们可以使用这样的正则表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[:upper:]][[:upper:][:lower:] ]*\.</span><br></pre></td></tr></table></figure>

<p>这个表达式由三个部分组成：一个包含 [:upper:] 字符类的括号表达式，一个包含 [:upper:]、[:lower:] 字符类和一个空格的括号表达式，以及一个用反斜杠转义的句号。第二个元素后面跟着一个 * 元字符，这样在我们句子中的首字母大写字母之后，任何数量的大写和小写字母以及空格都可以跟随，并且仍然匹配。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;This works.&quot;</span> | grep -E <span class="string">&#x27;[[:upper:]][[:upper:][</span></span><br><span class="line"><span class="string">:lower:] ]*\.&#x27;</span></span><br><span class="line">This works.</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;This Works.&quot;</span> | grep -E <span class="string">&#x27;[[:upper:]][[:upper:][</span></span><br><span class="line"><span class="string">:lower:] ]*\.&#x27;</span></span><br><span class="line">This Works.</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;this does</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> not&quot;</span> | grep -E <span class="string">&#x27;[[:upper:]][[:upper:</span></span><br><span class="line"><span class="string">][:lower:] ]*\.&#x27;</span></span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>这个表达式匹配了前两个测试，但不匹配第三个，因为它缺乏所需的首字母大写字符和末尾句号。</p>
<h5 id="匹配一个元素一次或多次"><a href="#匹配一个元素一次或多次" class="headerlink" title="+ - 匹配一个元素一次或多次"></a>+ - 匹配一个元素一次或多次</h5><ul>
<li>元字符的工作原理与 * 类似，但它要求至少有一个前面的元素实例才能进行匹配。这里有一个正则表达式，它只会匹配由单个空格分隔的一个或多个字母字符组成的行：</li>
</ul>
<p>^([[:alpha:]]+ ?)+$</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;This that&quot;</span> | grep -E <span class="string">&#x27;^([[:alpha:]]+ ?)+$&#x27;</span></span><br><span class="line">This that</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;a b c&quot;</span> | grep -E <span class="string">&#x27;^([[:alpha:]]+ ?)+$&#x27;</span></span><br><span class="line">a b c</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;a b 9&quot;</span> | grep -E <span class="string">&#x27;^([[:alpha:]]+ ?)+$&#x27;</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;abc d&quot;</span> | grep -E <span class="string">&#x27;^([[:alpha:]]+ ?)+$&#x27;</span></span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>我们看到，这个表达式不匹配行 a b 9，因为它包含一个非字母字符；也不匹配 abc d，因为字符 c 和 d 之间用了多于一个的空格字符分隔。</p>
<h5 id="匹配一个元素特定次数"><a href="#匹配一个元素特定次数" class="headerlink" title="{ } - 匹配一个元素特定次数"></a>{ } - 匹配一个元素特定次数</h5><p>{ 和 } 元字符用于表示所需匹配次数的最小值和最大值。它们可以用四种可能的方式指定，如表 19-3 所述。</p>
<p><em>表 19-3: 指定匹配次数</em></p>
<table>
<thead>
<tr>
<th><strong>指定方式</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>{<em>n</em>}</td>
<td>如果前面的元素出现了确切的 <em>n</em> 次，则匹配该元素。</td>
</tr>
<tr>
<td>{<em>n</em>,<em>m</em>}</td>
<td>如果前面的元素出现了至少 <em>n</em> 次但不超过 <em>m</em> 次，则匹配该元素。</td>
</tr>
<tr>
<td>{<em>n</em>,}</td>
<td>如果前面的元素出现了 <em>n</em> 次或更多次，则匹配该元素。</td>
</tr>
<tr>
<td>{,<em>m</em>}</td>
<td>如果前面的元素出现不超过 <em>m</em> 次，则匹配该元素。</td>
</tr>
</tbody></table>
<p>回到我们之前的电话号码示例中，我们可以使用这种指定重复的方法来简化我们原来的正则表达式，从以下形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$</span><br></pre></td></tr></table></figure>

<p>变为以下形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\(?[0-9]&#123;3&#125;\)? [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$</span><br></pre></td></tr></table></figure>

<p>让我们试一试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;(555) 123-4567&quot;</span> | grep -E <span class="string">&#x27;^\(?[0-9]&#123;3&#125;\)? [0-</span></span><br><span class="line"><span class="string">9]&#123;3&#125;-[0-9]&#123;4&#125;$&#x27;</span></span><br><span class="line">(555) 123-4567</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;555 123-4567&quot;</span> | grep -E <span class="string">&#x27;^\(?[0-9]&#123;3&#125;\)? [0-9]</span></span><br><span class="line"><span class="string">&#123;3&#125;-[0-9]&#123;4&#125;$&#x27;</span></span><br><span class="line">555 123-4567</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;5555 123-4567&quot;</span> | grep -E <span class="string">&#x27;^\(?[0-9]&#123;3&#125;\)? [0-9</span></span><br><span class="line"><span class="string">]&#123;3&#125;-[0-9]&#123;4&#125;$&#x27;</span></span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>正如我们所见，我们修改后的表达式可以成功验证有括号和没有括号的号码，同时拒绝那些格式不正确的号码。</p>
<h4 id="应用正则表达式"><a href="#应用正则表达式" class="headerlink" title="应用正则表达式"></a><strong>应用正则表达式</strong></h4><p>让我们看看一些我们已经熟悉的命令，以及如何将它们与正则表达式结合使用。</p>
<h5 id="使用-grep-验证电话列表"><a href="#使用-grep-验证电话列表" class="headerlink" title="使用 grep 验证电话列表"></a>使用 grep 验证电话列表</h5><p>在之前的例子中，我们检查了单个电话号码的格式是否正确。一个更现实的场景是检查一系列号码，因此让我们制作一个列表。我们通过对命令行念出一个神奇的咒语来做到这一点。这是因为我们还没有涉及大多数相关命令，但不用担心。我们将在未来的章节中了解它们。这是咒语：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..10&#125;; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">&quot;(<span class="variable">$&#123;RANDOM:0:3&#125;</span>) <span class="variable">$&#123;RANDOM:0:3&#125;</span>-<span class="variable">$&#123;RANDOM:0:4&#125;</span>&quot;</span> &gt;&gt; phonelist.txt; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这个命令将生成一个名为 phonelist.txt 的文件，包含十个电话号码。每次重复该命令时，另外十个号码将被添加到列表中。我们还可以更改命令开头附近的值 10，以产生更多或更少的电话号码。但是，如果我们检查文件的内容，我们会发现有一个问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> phonelist.txt</span><br><span class="line">(232) 298-2265</span><br><span class="line">(624) 381-1078</span><br><span class="line">(540) 126-1980</span><br><span class="line">(874) 163-2885</span><br><span class="line">(286) 254-2860</span><br><span class="line">(292) 108-518</span><br><span class="line">(129) 44-1379</span><br><span class="line">(458) 273-1642</span><br><span class="line">(686) 299-8268</span><br><span class="line">(198) 307-2440</span><br></pre></td></tr></table></figure>

<p>有些号码格式不正确，这正好适合我们的目的，因为我们将使用 grep 来验证它们。</p>
<p>一种有用的验证方法是扫描文件中的无效号码并显示结果列表。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -Ev <span class="string">&#x27;^\([0-9]&#123;3&#125;\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$&#x27;</span> phonelist.txt</span><br><span class="line">(292) 108-518</span><br><span class="line">(129) 44-1379</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>在这里，我们使用 -v 选项产生反向匹配，以便仅输出列表中不匹配指定表达式的行。表达式本身包括两端的锚点元字符，以确保号码两端没有额外的字符。与我们之前的电话号码示例不同，这个表达式还要求有效号码中必须有括号。</p>
<h5 id="使用-find-查找丑陋的文件名"><a href="#使用-find-查找丑陋的文件名" class="headerlink" title="使用 find 查找丑陋的文件名"></a>使用 find 查找丑陋的文件名</h5><p>find 命令支持基于正则表达式的测试。在使用正则表达式与 find 相对于 grep 时，需要牢记一个重要的考虑。虽然 grep 会在行<em>包含</em>匹配表达式的字符串时打印该行，find 则要求路径名<em>完全匹配</em>正则表达式。在下面的例子中，我们将使用 find 和一个正则表达式来查找包含以下任何不属于以下集合的字符的每个路径名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-_./0-9a-zA-Z]</span><br></pre></td></tr></table></figure>

<p>这样的扫描将揭示包含嵌入空格和其他潜在攻击性字符的路径名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ find . -regex <span class="string">&#x27;.*[^-_./0-9a-zA-Z].*&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于完全匹配整个路径名的要求，我们在表达式的两端使用 .* 来匹配任意字符的零个或多个实例。在表达式中间，我们使用一个否定的括号表达式，其中包含我们可以接受的路径名字符集。</p>
<h5 id="使用-locate-搜索文件"><a href="#使用-locate-搜索文件" class="headerlink" title="使用 locate 搜索文件"></a>使用 locate 搜索文件</h5><p>locate 程序支持基本（–regexp 选项）和扩展（-regex 选项）正则表达式。使用它，我们可以执行许多我们之前使用 dir</p>
<p>list 文件进行的相同操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ locate --regex <span class="string">&#x27;bin/(bz|gz|zip)&#x27;</span></span><br><span class="line">/bin/bzcat</span><br><span class="line">/bin/bzcmp</span><br><span class="line">/bin/bzdiff</span><br><span class="line">/bin/bzegrep</span><br><span class="line">/bin/bzexe</span><br><span class="line">/bin/bzfgrep</span><br><span class="line">/bin/bzgrep</span><br><span class="line">/bin/bzip2</span><br><span class="line">/bin/bzip2recover</span><br><span class="line">/bin/bzless</span><br><span class="line">/bin/bzmore</span><br><span class="line">/bin/gzexe</span><br><span class="line">/bin/gzip</span><br><span class="line">/usr/bin/zip </span><br><span class="line">/usr/bin/zipcloak</span><br><span class="line">/usr/bin/zipgrep</span><br><span class="line">/usr/bin/zipinfo</span><br><span class="line">/usr/bin/zipnote</span><br><span class="line">/usr/bin/zipsplit </span><br></pre></td></tr></table></figure>

<p>使用交替，我们执行了对包含 bin&#x2F;bz、bin&#x2F;gz 或 &#x2F;bin&#x2F;zip 的路径名的搜索。</p>
<h5 id="使用-less-和-vim-搜索文本"><a href="#使用-less-和-vim-搜索文本" class="headerlink" title="使用 less 和 vim 搜索文本"></a>使用 less 和 vim 搜索文本</h5><p>less 和 vim 共享相同的搜索文本方法。按下 &#x2F; 键后跟一个正则表达式将执行搜索。如果我们使用 less 查看我们的 phonelist.txt 文件，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ less phonelist.txt</span><br></pre></td></tr></table></figure>

<p>然后搜索我们的验证表达式，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(232) 298-2265</span><br><span class="line">(624) 381-1078</span><br><span class="line">(540) 126-1980</span><br><span class="line">(874) 163-2885</span><br><span class="line">(286) 254-2860</span><br><span class="line">(292) 108-518</span><br><span class="line">(129) 44-1379</span><br><span class="line">(458) 273-1642</span><br><span class="line">(686) 299-8268</span><br><span class="line">(198) 307-2440</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">/^\([0-9]&#123;3&#125;\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$</span><br></pre></td></tr></table></figure>

<p>less 将高亮显示匹配的字符串，使无效的号码容易辨认。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(232) 298-2265</span><br><span class="line">(624) 381-1078</span><br><span class="line">(540) 126-1980 </span><br><span class="line">(874) 163-2885</span><br><span class="line">(286) 254-2860</span><br><span class="line">(292) 108-518</span><br><span class="line">(129) 44-1379</span><br><span class="line">(458) 273-1642</span><br><span class="line">(686) 299-8268</span><br><span class="line">(198) 307-2440</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<p>另一方面，vim 支持基本正则表达式，因此我们的搜索表达式看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/([0-9]\&#123;3\&#125;) [0-9]\&#123;3\&#125;-[0-9]\&#123;4\&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，表达式大体相同；然而，许多在扩展表达式中被视为元字符的字符在基本表达式中被视为字面量。只有在用反斜杠转义时，它们才被视为元字符。根据我们系统上 vim 的特定配置，匹配可能会被高亮显示。如果没有，尝试这个命令模式命令来激活高亮显示：</p>
<p><strong>:hlsearch</strong></p>
<p><strong>注意：</strong> 根据您的发行版，vim 可能支持或不支持文本搜索高亮显示。特别是 Ubuntu，默认提供了 vim 的精简版本。在这样的系统上，您可能想使用包管理器安装更完整的 vim 版本。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在这一章中，我们看到了正则表达式的一些用途。如果我们使用正则表达式搜索更多使用它们的应用程序，我们可以找到更多用途。我们可以通过搜索手册页来做到这一点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> /usr/share/man/man1</span><br><span class="line">[me@linuxbox man1]$ zgrep -El <span class="string">&#x27;regex|regular expression&#x27;</span> *.gz</span><br></pre></td></tr></table></figure>

<p>zgrep 程序为 grep 提供了一个前端，允许它读取压缩文件。</p>
<p>在我们的示例中，我们搜索通常位置的压缩第 1 部分手册页文件。这个命令的结果是包含字符串 regex 或字符串 regular expression 的文件列表。正如我们所见，正则表达式出现在许多程序中。</p>
<p>基本正则表达式中有一个我们没有涵盖的功能。称为<em>反向引用</em>，这个功能将在下一章中讨论。</p>
<h4 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h4><p>有许多在线资源可以学习正则表达式，包括各种教程和速查表。</p>
<p>此外，维基百科有关于以下背景主题的良好文章：</p>
<ul>
<li>POSIX：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qb3NpeA==">http://en.wikipedia.org/wiki/Posix<i class="fa fa-external-link-alt"></i></span></li>
<li>ASCII：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Bc2NpaQ==">http://en.wikipedia.org/wiki/Ascii<i class="fa fa-external-link-alt"></i></span></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/TLCL/" rel="tag"># TLCL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/04/18-archiving-and-backup/" rel="prev" title="归档与备份">
                  <i class="fa fa-angle-left"></i> 归档与备份
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/04/20-text-processing/" rel="next" title="文本处理">
                  文本处理 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Slagga</span>
  </div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdHNsYWdnYQ==" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/sidebar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/search/local-search.min.js"></script>




  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/fancybox.min.js"></script>



  




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"gitslagga","repo":"gitslagga.github.io","client_id":"8b03c773267690e6d402","client_secret":"7b2ef82f50c632cdb14c98b7e5928357974cad97","admin_user":"gitslagga","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"e4f5a74461bdb550f1ebfd52b10d50fa"}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/comments/gitalk.min.js"></script>

</body>
</html>
