<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="E1ct36DyjSpaeX5NMAVsyzCjDs8-dQxGThgvw2i1yg0">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"gitslagga.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.21.0","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/config.min.js"></script>

    <meta name="description" content="15 – 存储媒体在前几章中，我们研究了文件级别的数据操作。在本章中，我们将考虑设备级别的数据。Linux在处理存储设备方面具有惊人的能力，无论是物理存储（如硬盘）、网络存储，还是虚拟存储设备，如 RAID（独立磁盘冗余阵列）和 LVM（逻辑卷管理器）。 但是，由于这不是一本关于系统管理的书，我们不会深入探讨这个主题。我们要做的是介绍一些概念和用于管理存储设备的关键命令。">
<meta property="og:type" content="article">
<meta property="og:title" content="存储媒体">
<meta property="og:url" content="https://gitslagga.github.io/2024/04/15-storage-media/index.html">
<meta property="og:site_name" content="计算机那些事">
<meta property="og:description" content="15 – 存储媒体在前几章中，我们研究了文件级别的数据操作。在本章中，我们将考虑设备级别的数据。Linux在处理存储设备方面具有惊人的能力，无论是物理存储（如硬盘）、网络存储，还是虚拟存储设备，如 RAID（独立磁盘冗余阵列）和 LVM（逻辑卷管理器）。 但是，由于这不是一本关于系统管理的书，我们不会深入探讨这个主题。我们要做的是介绍一些概念和用于管理存储设备的关键命令。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-20T03:30:30.000Z">
<meta property="article:modified_time" content="2025-06-06T06:13:40.951Z">
<meta property="article:author" content="Slagga">
<meta property="article:tag" content="TLCL">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://gitslagga.github.io/2024/04/15-storage-media/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://gitslagga.github.io/2024/04/15-storage-media/","path":"2024/04/15-storage-media/","title":"存储媒体"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>存储媒体 | 计算机那些事</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-0E2T2VNH5S"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-0E2T2VNH5S","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/analytics/google-analytics.min.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">计算机那些事</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">软件开发、维护和升级</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">229</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">78</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">28</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E2%80%93-%E5%AD%98%E5%82%A8%E5%AA%92%E4%BD%93"><span class="nav-number">1.</span> <span class="nav-text">15 – 存储媒体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%82%E8%BD%BD%E5%92%8C%E5%8D%B8%E8%BD%BD%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87"><span class="nav-number">1.1.</span> <span class="nav-text">挂载和卸载存储设备</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%B7%B2%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%97%E8%A1%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">查看已挂载文件系统列表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%B8%E8%BD%BD%E5%BE%88%E9%87%8D%E8%A6%81"><span class="nav-number">1.2.</span> <span class="nav-text">为什么卸载很重要</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text">确定设备名称</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.3.</span> <span class="nav-text">创建新的文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-fdisk-%E6%93%8D%E4%BD%9C%E5%88%86%E5%8C%BA"><span class="nav-number">1.3.1.</span> <span class="nav-text">使用 fdisk 操作分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-mkfs-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.3.2.</span> <span class="nav-text">使用 mkfs 创建新的文件系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%92%8C%E4%BF%AE%E5%A4%8D%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.4.</span> <span class="nav-text">测试和修复文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%90%91%E8%AE%BE%E5%A4%87%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE"><span class="nav-number">1.5.</span> <span class="nav-text">直接向设备传输数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-CD-ROM-%E9%95%9C%E5%83%8F"><span class="nav-number">1.6.</span> <span class="nav-text">创建 CD-ROM 镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-CD-ROM-%E7%9A%84%E9%95%9C%E5%83%8F%E5%89%AF%E6%9C%AC"><span class="nav-number">1.6.1.</span> <span class="nav-text">创建 CD-ROM 的镜像副本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88%E4%B8%AD%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="nav-number">1.6.2.</span> <span class="nav-text">从文件集合中创建镜像</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%85%A5-CD-ROM-%E9%95%9C%E5%83%8F"><span class="nav-number">1.7.</span> <span class="nav-text">写入 CD-ROM 镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8C%82%E8%BD%BD-ISO-%E9%95%9C%E5%83%8F"><span class="nav-number">1.7.1.</span> <span class="nav-text">直接挂载 ISO 镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%A6%E9%99%A4%E5%8F%AF%E9%87%8D%E5%86%99-CD-ROM"><span class="nav-number">1.7.2.</span> <span class="nav-text">擦除可重写 CD-ROM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E9%95%9C%E5%83%8F"><span class="nav-number">1.7.3.</span> <span class="nav-text">写入镜像</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.8.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%98%85%E8%AF%BB"><span class="nav-number">1.9.</span> <span class="nav-text">进一步阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%9D%E5%A4%96%E5%AD%A6%E5%88%86"><span class="nav-number">1.10.</span> <span class="nav-text">额外学分</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Slagga"
      src="https://avatars.githubusercontent.com/u/19620432">
  <p class="site-author-name" itemprop="name">Slagga</p>
  <div class="site-description" itemprop="description">Computer Things - Software Development, Maintenance and Upgrade</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">229</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdHNsYWdnYQ==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gitslagga"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnNsYWdnYUBkdWNrLmNvbQ==" title="E-Mail → mailto:slagga@duck.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gitslagga.github.io/2024/04/15-storage-media/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/19620432">
      <meta itemprop="name" content="Slagga">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="计算机那些事">
      <meta itemprop="description" content="Computer Things - Software Development, Maintenance and Upgrade">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="存储媒体 | 计算机那些事">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          存储媒体
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-20 11:30:30" itemprop="dateCreated datePublished" datetime="2024-04-20T11:30:30+08:00">2024-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-06 14:13:40" itemprop="dateModified" datetime="2025-06-06T14:13:40+08:00">2025-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="15-–-存储媒体"><a href="#15-–-存储媒体" class="headerlink" title="15 – 存储媒体"></a>15 – 存储媒体</h2><p>在前几章中，我们研究了文件级别的数据操作。在本章中，我们将考虑设备级别的数据。Linux在处理存储设备方面具有惊人的能力，无论是物理存储（如硬盘）、网络存储，还是虚拟存储设备，如 RAID（独立磁盘冗余阵列）和 LVM（逻辑卷管理器）。</p>
<p>但是，由于这不是一本关于系统管理的书，我们不会深入探讨这个主题。我们要做的是介绍一些概念和用于管理存储设备的关键命令。</p>
<span id="more"></span>

<p>为了进行本章的练习，我们将使用 USB 闪存盘和 CD-RW 光盘（对于配备有 CD-ROM 刻录机的系统）。</p>
<p>我们将查看以下命令：</p>
<ul>
<li>mount - 挂载文件系统</li>
<li>umount - 卸载文件系统</li>
<li>fsck - 检查和修复文件系统</li>
<li>fdisk - 操作磁盘分区表</li>
<li>mkfs - 创建文件系统</li>
<li>dd - 转换和复制文件</li>
<li>genisoimage (mkisofs) - 创建 ISO 9660 镜像文件</li>
<li>wodim (cdrecord) - 将数据写入光存储媒介</li>
<li>md5sum - 计算 MD5 校验和</li>
</ul>
<h3 id="挂载和卸载存储设备"><a href="#挂载和卸载存储设备" class="headerlink" title="挂载和卸载存储设备"></a>挂载和卸载存储设备</h3><p>最近的 Linux 桌面进展使得桌面用户的存储设备管理变得极为简单。大多数情况下，我们连接一个设备到我们的系统，它就“可以正常工作”。在过去的时代（比如 2004 年），这些事情必须手动完成。在非桌面系统（即服务器）上，这仍然是一个主要的手动过程，因为服务器通常有极端的存储需求和复杂的配置要求。</p>
<p>管理存储设备的第一步是将设备连接到文件系统树。这个过程，称为<em>挂载</em>，允许设备与操作系统进行交互。正如我们在第 2 章回忆的，类 Unix 操作系统（如 Linux）维护一个单一的文件系统树，设备在不同点进行连接。这与 MS-DOS 和 Windows 等其他操作系统形成对比，它们为每个设备维护单独的文件系统树（例如 C:, D:\ 等）。</p>
<p>一个名为 &#x2F;etc&#x2F;fstab 的文件（简称“文件系统表”）列出了要在启动时挂载的设备（通常是硬盘分区）。以下是来自早期 Fedora 系统的示例 &#x2F;etc&#x2F;fstab 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LABEL=/12 / ext4 defaults 1 1</span><br><span class="line">LABEL=/home /home ext4 defaults 1 2</span><br><span class="line">LABEL=/boot /boot ext4 defaults 1 2</span><br><span class="line">tmpfs /dev/shm tmpfs defaults 0 0</span><br><span class="line">devpts /dev/pts devpts gid=5,mode=620 0 0</span><br><span class="line">sysfs /sys sysfs defaults 0 0</span><br><span class="line">proc /proc proc defaults 0 0</span><br><span class="line">LABEL=SWAP-sda3 swap swap defaults 0 0</span><br></pre></td></tr></table></figure>

<p>此示例文件中列出的大多数文件系统是虚拟的，与我们的讨论无关。对我们来说，有趣的是前三个：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LABEL=/12 / ext4 defaults 1 1</span><br><span class="line">LABEL=/home /home ext4 defaults 1 2</span><br><span class="line">LABEL=/boot /boot ext4 defaults 1 2</span><br></pre></td></tr></table></figure>

<p>这些是硬盘分区。文件中的每一行由六个字段组成，如表 15-1 所述。</p>
<p><em>表 15-1:</em> <em>&#x2F;etc&#x2F;fstab 字段</em></p>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>内容</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Device</td>
<td>传统上，此字段包含与物理设备相关联的实际设备文件的名称，例如 &#x2F;dev&#x2F;sda1（第一检测到的硬盘的第一分区）。但在今天的计算机中，由于有许多可以热插拔的设备（如 USB 驱动器），许多现代 Linux 发行版将设备与文本标签关联。这个标签（在格式化存储媒体时添加）可以是简单的文本标签，也可以是随机生成的 UUID（通用唯一标识符）。该标签在设备连接到系统时由操作系统读取。这样，无论实际物理设备分配了哪个设备文件，它仍然可以被正确识别。</td>
</tr>
<tr>
<td>2</td>
<td>Mount point</td>
<td>设备连接到文件系统树的目录。</td>
</tr>
<tr>
<td>3</td>
<td>File system type</td>
<td>Linux 允许许多文件系统类型被挂载。大多数本地 Linux 文件系统是第四扩展文件系统（ext4），但还支持许多其他文件系统，如 FAT16 (msdos)，FAT32 (vfat)，NTFS (ntfs)，CD-ROM (iso9660) 等。</td>
</tr>
<tr>
<td>4</td>
<td>Options</td>
<td>文件系统可以以各种选项挂载。例如，可以将文件系统挂载为只读，或防止从中执行任何程序（可移动媒体的有用安全特性）。</td>
</tr>
<tr>
<td>5</td>
<td>Frequency</td>
<td>一个数字，指定文件系统要使用 dump 命令备份的频率。</td>
</tr>
<tr>
<td>6</td>
<td>Order</td>
<td>一个数字，指定文件系统应以什么顺序使用 fsck 命令检查。</td>
</tr>
</tbody></table>
<h4 id="查看已挂载文件系统列表"><a href="#查看已挂载文件系统列表" class="headerlink" title="查看已挂载文件系统列表"></a>查看已挂载文件系统列表</h4><p>mount 命令用于挂载文件系统。输入没有参数的命令将显示当前已挂载的文件系统列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ mount</span><br><span class="line">/dev/sda2 on / <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw)</span><br><span class="line">sysfs on /sys <span class="built_in">type</span> sysfs (rw)</span><br><span class="line">devpts on /dev/pts <span class="built_in">type</span> devpts (rw,gid=5,mode=620)</span><br><span class="line">/dev/sda5 on /home <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">/dev/sda1 on /boot <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">tmpfs on /dev/shm <span class="built_in">type</span> tmpfs (rw)</span><br><span class="line">none on /proc/sys/fs/binfmt_misc <span class="built_in">type</span> binfmt_misc (rw)</span><br><span class="line">sunrpc on /var/lib/nfs/rpc_pipefs <span class="built_in">type</span> rpc_pipefs (rw)</span><br><span class="line">fusectl on /sys/fs/fuse/connections <span class="built_in">type</span> fusectl (rw)</span><br><span class="line">/dev/sdd1 on /media/disk <span class="built_in">type</span> vfat (rw,nosuid,nodev,noatime,</span><br><span class="line">uhelper=hal,uid=500,utf8,shortname=lower)</span><br><span class="line">twin4:/musicbox on /misc/musicbox <span class="built_in">type</span> nfs4 (rw,addr=192.168.1.4)</span><br></pre></td></tr></table></figure>

<p>列表的格式如下：<em>device</em> on <em>mount_point</em> type <em>file_system_type</em> (<em>options</em>)。例如，第一行显示设备 &#x2F;dev&#x2F;sda2 挂载为根文件系统，类型为 ext4，并且可读写（选项“rw”）。此列表还在底部有两个有趣的条目。倒数第二个条目显示了一个 2GB 的 SD 存储卡在读卡器中挂载在 &#x2F;media&#x2F;disk 上，最后一个条目是一个挂载在 &#x2F;misc&#x2F;musicbox 上的网络驱动器。</p>
<p>在我们的第一个实验中，我们将使用 CD-ROM。首先，让我们看看在插入 CD-ROM 之前的系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ mount</span><br><span class="line">/dev/mapper/VolGroup00-LogVol00 on / <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw)</span><br><span class="line">sysfs on /sys <span class="built_in">type</span> sysfs (rw)</span><br><span class="line">devpts on /dev/pts <span class="built_in">type</span> devpts (rw,gid=5,mode=620)</span><br><span class="line">/dev/sda1 on /boot <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">tmpfs on /dev/shm <span class="built_in">type</span> tmpfs (rw)</span><br><span class="line">none on /proc/sys/fs/binfmt_misc <span class="built_in">type</span> binfmt_misc (rw)</span><br><span class="line">sunrpc on /var/lib/nfs/rpc_pipefs <span class="built_in">type</span> rpc_pipefs (rw)</span><br></pre></td></tr></table></figure>

<p>这个列表来自一个使用 LVM（逻辑卷管理器）创建其根文件系统的 CentOS 系统。像许多现代 Linux 发行版一样，该系统在插入 CD-ROM 后会尝试自动挂载它。插入光盘后，我们看到以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ mount</span><br><span class="line">/dev/mapper/VolGroup00-LogVol00 on / <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw)</span><br><span class="line">sysfs on /sys <span class="built_in">type</span> sysfs (rw)</span><br><span class="line">devpts on /dev/pts <span class="built_in">type</span> devpts (rw,gid=5,mode=620)</span><br><span class="line">/dev/hda1 on /boot <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">tmpfs on /dev/shm <span class="built_in">type</span> tmpfs (rw)</span><br><span class="line">none on /proc/sys/fs/binfmt_misc <span class="built_in">type</span> binfmt_misc (rw)</span><br><span class="line">sunrpc on /var/lib/nfs/rpc_pipefs <span class="built_in">type</span> rpc_pipefs (rw)</span><br><span class="line">/dev/sdc on /media/live-1.0.10-8 <span class="built_in">type</span> iso9660 (ro,noexec,nosuid,</span><br><span class="line">nodev,uid=500)</span><br></pre></td></tr></table></figure>

<p>插入光盘后，我们看到与之前相同的列表，但增加了一个条目。列表的末尾显示 CD-ROM（在此系统上为设备 &#x2F;dev&#x2F;sdc）已挂载在 &#x2F;media&#x2F;live-1.0.10-8 上，类型为 iso9660（CDROM）。对于我们的实验来说，我们感兴趣的是设备的名称。当您自己进行这个实验时，设备名称可能会有所不同。</p>
<p><strong>警告：</strong> 在接下来的示例中，至关重要的是您要密切关注您系统中使用的实际设备名称，并且<strong>不要使用文中的名称！</strong></p>
<p>另请注意，音频 CD 与 CD-ROM 不同。音频 CD 不包含文件系统，因此不能以通常的方式挂载。</p>
<p>既然我们有了 CD-ROM 驱动器的设备名称，让我们卸载光盘并在文件系统树的另一个位置重新挂载它。为此，我们成为超级用户（使用适合我们系统的命令）并用 umount 命令卸载光盘。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ su -</span><br><span class="line">Password:</span><br><span class="line">[root@linuxbox ~]<span class="comment"># umount /dev/sdc</span></span><br></pre></td></tr></table></figure>

<p>下一步是为磁盘创建一个新的<em>挂载点</em>。挂载点只是文件系统树上的一个目录。它没有什么特别的。它甚至不必是一个空目录，不过如果你在一个非空目录上挂载设备，你将无法看到卸载设备之前该目录的先前内容。为了我们的目的，我们将创建一个新目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxbox ~]<span class="comment"># mkdir /mnt/cdrom</span></span><br></pre></td></tr></table></figure>

<p>最后，我们在新的挂载点挂载 CD-ROM。使用 -t 选项来指定文件系统类型。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxbox ~]<span class="comment"># mount -t iso9660 /dev/sdc /mnt/cdrom</span></span><br></pre></td></tr></table></figure>

<p>之后，我们可以通过新的挂载点查看 CD-ROM 的内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxbox ~]<span class="comment"># cd /mnt/cdrom</span></span><br><span class="line">[root@linuxbox cdrom]<span class="comment"># ls</span></span><br></pre></td></tr></table></figure>

<p>注意当我们尝试卸载 CD-ROM 时会发生什么。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxbox cdrom]<span class="comment"># umount /dev/sdc</span></span><br><span class="line">umount: /mnt/cdrom: device is busy</span><br></pre></td></tr></table></figure>

<p>这是为什么呢？原因是如果设备正在被某人或某个进程使用，我们无法卸载它。在这种情况下，我们将工作目录更改为 CD-ROM 的挂载点，这导致设备正忙。我们可以通过将工作目录更改为挂载点以外的其他位置来轻松解决这个问题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxbox cdrom]<span class="comment"># cd</span></span><br><span class="line">[root@linuxbox ~]<span class="comment"># umount /dev/sdc</span></span><br></pre></td></tr></table></figure>

<p>现在设备成功卸载了。</p>
<h3 id="为什么卸载很重要"><a href="#为什么卸载很重要" class="headerlink" title="为什么卸载很重要"></a>为什么卸载很重要</h3><p>如果你查看显示内存使用情况的 free 命令的输出，你会看到一个名为 <em>buffers</em> 的统计数据。计算机系统的设计目的是尽可能快地运行。系统速度的一个障碍是慢速设备。打印机是一个很好的例子。即使是最快的打印机，按计算机标准来看也极其缓慢。如果计算机必须停下来等待打印机完成打印一页，那么计算机的速度会非常慢。在个人电脑早期（在多任务处理之前），这是一个真正的问题。如果你正在处理电子表格或文本文档，每次打印时计算机都会停止并变得无法使用。计算机会以打印机能接受的最快速度发送数据，但这非常缓慢，因为打印机打印速度不快。这个问题通过 <em>打印机缓冲器</em> 的出现得到解决，这是一种包含一些 RAM 内存的设备，位于计算机和打印机之间。有了打印机缓冲器，计算机会将打印输出发送到缓冲器，然后快速存储在快速 RAM 中，使计算机可以在不等待的情况下返回工作。同时，打印机缓冲器会以打印机能接受的速度慢慢地从缓冲器的内存中 <em>缓冲</em> 数据到打印机。</p>
<p>这种缓冲的想法在计算机中被广泛使用，以提高速度。不要让偶尔需要从慢速设备读取或写入数据的需求阻碍系统的速度。操作系统会尽可能长时间地将从存储设备读取的数据和将写入存储设备的数据存储在内存中，直到实际需要与慢速设备进行交互。例如，在 Linux 系统上，你会注意到，系统使用时间越长，内存似乎就越满。这并不意味着 Linux 正在“使用”所有内存；这意味着 Linux 正在利用所有可用的内存尽可能多地进行缓冲。</p>
<p>这种缓冲使得向存储设备的写入可以非常快速地完成，因为写入物理设备被推迟到将来的某个时间。与此同时，注定要写入设备的数据正在内存中堆积。不时地，操作系统会将这些数据写入物理设备。</p>
<p>卸载设备涉及将所有剩余数据写入设备，以便可以安全地移除它。如果在首先卸载设备之前移除它，可能存在并非所有注定要传输到设备的数据都已被传输的可能性。在某些情况下，这些数据可能包括重要的目录更新，这将导致 <em>文件系统损坏</em>，这是计算机上可能发生的最糟糕的事情之一。</p>
<h4 id="确定设备名称"><a href="#确定设备名称" class="headerlink" title="确定设备名称"></a>确定设备名称</h4><p>有时候确定设备的名称有点困难。在过去，这并不难。设备总是在同一个位置，不会改变。类 Unix 系统喜欢这样。当 Unix 被开发时，“更换磁盘驱动器”涉及使用叉车从计算机房间移除洗衣机大小的设备。近年来，典型的桌面硬件配置变得相当动态，Linux 已经比其祖先更加灵活。</p>
<p>在上面的例子中，我们利用了现代 Linux</p>
<p>桌面自动挂载设备的能力，然后事后确定名称。但是，如果我们正在管理服务器或其他不会发生这种情况的环境，我们该如何确定呢？</p>
<p>首先，让我们看看系统如何命名设备。如果我们列出 &#x2F;dev 目录（所有设备所在的位置）的内容，我们可以看到有很多设备。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /dev</span><br></pre></td></tr></table></figure>

<p>这个列表的内容揭示了一些设备命名的模式。表 15-2 概述了其中的一些模式。</p>
<p><em>表 15-2: Linux 存储设备名称</em></p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>设备</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;dev&#x2F;fd*</td>
<td>软盘驱动器。</td>
</tr>
<tr>
<td>&#x2F;dev&#x2F;hd*</td>
<td>旧系统上的 IDE (PATA) 磁盘。典型的主板包含两个 IDE 连接器或 <em>通道</em>，每个通道有一个带有两个驱动器连接点的电缆。电缆上的第一个驱动器称为 <em>主设备</em>，第二个称为 <em>从设备</em>。设备名称的排序方式是，&#x2F;dev&#x2F;hda 指的是第一个通道上的主设备，&#x2F;dev&#x2F;hdb 是第一个通道上的从设备；&#x2F;dev&#x2F;hdc 是第二个通道上的主设备，依此类推。尾随数字表示设备上的分区号。例如，&#x2F;dev&#x2F;hda1 指的是系统上第一个硬盘的第一个分区，而 &#x2F;dev&#x2F;hda 指的是整个驱动器。</td>
</tr>
<tr>
<td>&#x2F;dev&#x2F;lp*</td>
<td>打印机。</td>
</tr>
<tr>
<td>&#x2F;dev&#x2F;sd*</td>
<td>SCSI 磁盘。在现代 Linux 系统中，内核将所有类似磁盘的设备（包括 PATA&#x2F;SATA 硬盘、闪存驱动器和 USB 大容量存储设备，如便携音乐播放器和数码相机）视为 SCSI 磁盘。其余的命名系统与上面描述的旧 &#x2F;dev&#x2F;hd* 命名方案类似。</td>
</tr>
<tr>
<td>&#x2F;dev&#x2F;sr*</td>
<td>光驱（CD&#x2F;DVD 读取器和刻录器）。</td>
</tr>
</tbody></table>
<p>此外，我们经常看到如 &#x2F;dev&#x2F;cdrom、&#x2F;dev&#x2F;dvd 和 &#x2F;dev&#x2F;floppy 这样的符号链接，它们指向实际的设备文件，提供方便。</p>
<p>如果你正在使用的系统不会自动挂载可移除设备，你可以使用以下技术来确定附加设备时可移除设备的命名方式。首先，开始实时查看 &#x2F;var&#x2F;log&#x2F;messages 或 &#x2F;var&#x2F;log&#x2F;syslog 文件（你可能需要超级用户权限）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo <span class="built_in">tail</span> -f /var/log/messages</span><br></pre></td></tr></table></figure>

<p>文件的最后几行将被显示，然后暂停。接下来，插入可移动设备。在这个示例中，我们将使用一个 16MB 的闪存驱动器。几乎立即，内核就会注意到该设备并对其进行探测。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Jul 23 10:07:53 linuxbox kernel: usb 3-2: new full speed USB device</span><br><span class="line">using uhci_hcd and address 2</span><br><span class="line">Jul 23 10:07:53 linuxbox kernel: usb 3-2: configuration <span class="comment">#1 chosen</span></span><br><span class="line">from 1 choice</span><br><span class="line">Jul 23 10:07:53 linuxbox kernel: scsi3 : SCSI emulation <span class="keyword">for</span> USB Mass</span><br><span class="line">Storage devices</span><br><span class="line">Jul 23 10:07:58 linuxbox kernel: scsi scan: INQUIRY result too short</span><br><span class="line">(5), using 36</span><br><span class="line">Jul 23 10:07:58 linuxbox kernel: scsi 3:0:0:0: Direct-Access Easy</span><br><span class="line">Disk 1.00 PQ: 0 ANSI: 2</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] 31263 512-byte</span><br><span class="line">hardware sectors (16 MB)</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Write Protect is</span><br><span class="line">off</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Assuming drive</span><br><span class="line">cache: write through</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] 31263 512-byte</span><br><span class="line">hardware sectors (16 MB)</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Write Protect is</span><br><span class="line">off</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Assuming drive</span><br><span class="line">cache: write through</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sdb: sdb1</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI</span><br><span class="line">removable disk</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: Attached scsi generic</span><br><span class="line">sg3 <span class="built_in">type</span> 0</span><br></pre></td></tr></table></figure>

<p>当显示再次暂停后，按 Ctrl-c 返回命令提示符。输出中有趣的部分是对 [sdb] 的重复提及，这符合我们对 SCSI 磁盘设备名称的预期。了解这一点后，下面这两行尤其具有启发性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Jul 23 10:07:59 linuxbox kernel: sdb: sdb1</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI</span><br></pre></td></tr></table></figure>

<p>这告诉我们整个设备的设备名称是 &#x2F;dev&#x2F;sdb，第一个分区的设备名称是 &#x2F;dev&#x2F;sdb1。正如我们所见，使用 Linux 充满了有趣的侦探工作！</p>
<p><strong>提示：</strong> 使用 tail -f &#x2F;var&#x2F;log&#x2F;messages 技术是实时观察系统正在做什么的好方法。</p>
<p>掌握了设备名称，我们现在可以挂载闪存盘了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo <span class="built_in">mkdir</span> /mnt/flash</span><br><span class="line">[me@linuxbox ~]$ sudo mount /dev/sdb1 /mnt/flash</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">df</span></span><br><span class="line">Filesystem 1K-blocks Used Available Use% Mounted on</span><br><span class="line">/dev/sda2 15115452 5186944 9775164 35% /</span><br><span class="line">/dev/sda5 59631908 31777376 24776480 57% /home</span><br><span class="line">/dev/sda1 147764 17277 122858 13% /boot</span><br><span class="line">tmpfs 776808 0 776808 0% /dev/shm</span><br><span class="line">/dev/sdb1 15560 0 15560 0% /mnt/flash</span><br></pre></td></tr></table></figure>

<p>只要设备物理连接到计算机并且计算机没有重启，设备名称将保持不变。</p>
<h3 id="创建新的文件系统"><a href="#创建新的文件系统" class="headerlink" title="创建新的文件系统"></a>创建新的文件系统</h3><p>假设我们想要使用本地 Linux 文件系统重新格式化闪存盘，而不是现在的 FAT32 系统。这涉及两个步骤。</p>
<ol>
<li>（可选）如果现有的分区布局不符合我们的喜好，创建新的分区布局。</li>
<li>在驱动器上创建一个新的、空的文件系统。</li>
</ol>
<p><strong>警告！</strong> 在接下来的练习中，我们将格式化一个闪存盘。使用一个你不在乎的驱动器，因为它将被擦除！再次提醒，<strong>一定要确保你指定的是系统中正确的设备名称，而不是文本中显示的那个。不注意这个警告可能会导致你格式化（即擦除）错误的驱动器！</strong></p>
<h4 id="使用-fdisk-操作分区"><a href="#使用-fdisk-操作分区" class="headerlink" title="使用 fdisk 操作分区"></a>使用 fdisk 操作分区</h4><p>fdisk 是众多程序（命令行和图形界面）之一，允许我们直接与磁盘类设备（如硬盘驱动器和闪存盘）进行非常低级别的交互。使用这个工具，我们可以编辑、删除和创建设备上的分区。要处理我们的闪存盘，我们必须先卸载它（如果需要），然后如下调用 fdisk 程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo umount /dev/sdb1</span><br><span class="line">[me@linuxbox ~]$ sudo fdisk /dev/sdb</span><br></pre></td></tr></table></figure>

<p>请注意，我们必须以整个设备的形式指定设备，而不是通过分区号。程序启动后，我们将看到以下提示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>):</span><br></pre></td></tr></table></figure>

<p>输入“m”将显示程序菜单。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Command action</span><br><span class="line"> a toggle a bootable flag</span><br><span class="line"> b edit bsd disklabel</span><br><span class="line"> c toggle the dos compatibility flag</span><br><span class="line"> d delete a partition</span><br><span class="line"> l list known partition types</span><br><span class="line"> m <span class="built_in">print</span> this menu</span><br><span class="line"> n add a new partition</span><br><span class="line"> o create a new empty DOS partition table</span><br><span class="line"> p <span class="built_in">print</span> the partition table</span><br><span class="line"> q quit without saving changes</span><br><span class="line"> s create a new empty Sun disklabel</span><br><span class="line"> t change a partition<span class="string">&#x27;s system id</span></span><br><span class="line"><span class="string"> u change display/entry units</span></span><br><span class="line"><span class="string"> v verify the partition table</span></span><br><span class="line"><span class="string"> w write table to disk and exit</span></span><br><span class="line"><span class="string"> x extra functionality (experts only)</span></span><br><span class="line"><span class="string">Command (m for help): </span></span><br></pre></td></tr></table></figure>

<p>我们要做的第一件事是检查现有的分区布局。我们通过输入“p”来打印设备的分区表。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line">Disk /dev/sdb: 16 MB, 16006656 bytes</span><br><span class="line">1 heads, 31 sectors/track, 1008 cylinders</span><br><span class="line">Units = cylinders of 31 * 512 = 15872 bytes</span><br><span class="line"> Device Boot Start End Blocks Id System</span><br><span class="line">/dev/sdb1 2 1008 15608+ b W95 FAT32 </span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们看到一个 16 MB 的设备，有一个分区（1），使用了设备上可用的 1,008 个柱面中的 1,006 个。该分区被标识为 Windows 95 FAT32 分区。有些程序会使用这个标识符来限制可以对磁盘执行的操作类型，但大多数时候更改它并不重要。然而，为了本次演示，我们将其更改为指示 Linux 分区。为此，我们首先需要找出用于标识 Linux 分区的 ID。在前面的列表中，我们看到 ID b 被用来指定现有分区。要查看可用分区类型的列表，我们参考程序菜单。在那里我们可以看到以下选择：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l list known partition types</span><br></pre></td></tr></table></figure>

<p>如果我们在提示符下输入 l，则会显示一长串可能的类型。其中我们看到 b 用于我们现有的分区类型和 83 用于 Linux。</p>
<p>回到菜单，我们看到这个选择来更改分区 ID：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t change a partition<span class="string">&#x27;s system id</span></span><br></pre></td></tr></table></figure>

<p>我们在提示符下输入 t 并输入新的 ID：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Selected partition 1</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list codes): 83</span><br><span class="line">Changed system <span class="built_in">type</span> of partition 1 to 83 (Linux)</span><br></pre></td></tr></table></figure>

<p>这完成了我们需要做的所有更改。到目前为止，设备尚未被触及（所有更改都存储在内存中，而不是在物理设备上），所以我们将修改后的分区表写入设备并退出。为此，我们在提示符下输入 w。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">WARNING: If you have created or modified any DOS 6.x</span><br><span class="line">partitions, please see the fdisk manual page <span class="keyword">for</span> additional</span><br><span class="line">information.</span><br><span class="line">Syncing disks.</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>如果我们决定保持设备不变，我们可以在提示符下输入 q，这将退出程序而不写入更改。我们可以安全地忽略这个听起来不祥的警告信息。</p>
<h4 id="使用-mkfs-创建新的文件系统"><a href="#使用-mkfs-创建新的文件系统" class="headerlink" title="使用 mkfs 创建新的文件系统"></a>使用 mkfs 创建新的文件系统</h4><p>完成了我们的分区编辑（尽管可能很简单），现在是时候在我们的闪存驱动器上创建一个新的文件系统了。为此，我们将使用 mkfs（代表“制作文件系统”），它可以创建多种格式的文件系统。要在设备上创建一个 ext4 文件系统，我们使用 -t 选项来指定 ext4 系统类型，然后是包含我们想要格式化的分区的设备名称。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo mkfs -t ext4 /dev/sdb1</span><br><span class="line">mke2fs 2.23.2 (12-Jul-2011)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">Block size=1024 (<span class="built_in">log</span>=0)</span><br><span class="line">Fragment size=1024 (<span class="built_in">log</span>=0)</span><br><span class="line">3904 inodes, 15608 blocks</span><br><span class="line">780 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">First data block=1</span><br><span class="line">Maximum filesystem blocks=15990784</span><br><span class="line">2 block <span class="built_in">groups</span></span><br><span class="line">8192 blocks per group, 8192 fragments per group</span><br><span class="line">1952 inodes per group</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">	8193</span><br><span class="line">Writing inode tables: <span class="keyword">done</span></span><br><span class="line">Creating journal (1024 blocks): <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br><span class="line">This filesystem will be automatically checked every 34 mounts or</span><br><span class="line">180 days, whichever comes first. Use tune2fs -c or -i to override.</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>程序运行时会显示很多信息，当选择的文件系统类型为 ext4 时。要将设备重新格式化为原来的 FAT32 文件系统，请指定 vfat 作为文件系统类型。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo mkfs -t vfat /dev/sdb1</span><br></pre></td></tr></table></figure>

<p>这种分区和格式化的过程可以在系统添加额外存储设备时使用。虽然我们处理的是一个小闪存驱动器，但同样的过程也可以应用于内部硬盘和其他可移动存储设备，如 USB 硬盘。</p>
<h3 id="测试和修复文件系统"><a href="#测试和修复文件系统" class="headerlink" title="测试和修复文件系统"></a>测试和修复文件系统</h3><p>在我们之前关于 &#x2F;etc&#x2F;fstab 文件的讨论中，我们看到每行末尾有一些神秘的数字。每次系统启动时，它会在挂载它们之前例行检查文件系统的完整性。这是通过 fsck 程序（代表“文件系统检查”）完成的。fstab 条目中的最后一个数字指定了设备检查的顺序。在我们之前的例子中，我们看到根文件系统首先被检查，然后是 home 和 boot 文件系统。最后一位数字为零的设备不会例行检查。</p>
<p>除了检查文件系统的完整性，fsck 还可以修复不同程度的成功损坏的文件系统，这取决于损坏的程度。在类 Unix 文件系统上，恢复的文件部分会被放置在每个文件系统根目录下的 lost+found 目录中。</p>
<p>要检查我们的闪存驱动器（应该首先卸载），我们可以执行以下操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo fsck /dev/sdb1</span><br><span class="line">fsck 1.40.8 (13-Mar-2016)</span><br><span class="line">e2fsck 1.40.8 (13-Mar-2016) </span><br><span class="line">/dev/sdb1: clean, 11/3904 files, 1661/15608 blocks</span><br></pre></td></tr></table></figure>

<p>如今，除非存在硬件问题，如磁盘驱动器故障，否则文件系统损坏是非常罕见的。在大多数系统中，启动时检测到的文件系统损坏将导致系统停止，并指示您在继续之前运行 fsck。</p>
<p><strong>什么是 fsck？</strong></p>
<p>在 Unix 文化中，<em>fsck</em> 这个词经常被用来替代一个与它共享三个字母的流行词汇。这尤其恰当，因为如果你发现自己被迫运行 fsck，你可能会说出前面提到的那个词。</p>
<h3 id="直接向设备传输数据"><a href="#直接向设备传输数据" class="headerlink" title="直接向设备传输数据"></a>直接向设备传输数据</h3><p>虽然我们通常认为计算机上的数据是组织成文件的，但也可以将数据视为“原始”形式。例如，如果我们看一下磁盘驱动器，我们会看到它由操作系统视为目录和文件的大量“数据块”组成。然而，如果我们能将磁盘驱动器仅仅当作大量数据块的集合，我们就能执行一些有用的任务，比如克隆设备。</p>
<p>dd 程序执行这个任务。它将数据块从一个地方复制到另一个地方。它使用一个独特的语法（出于历史原因）并且通常这样使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=input_file of=output_file [bs=block_size [count=blocks]]</span><br></pre></td></tr></table></figure>

<p><strong>警告！</strong> dd 命令非常强大。尽管它的名称来自于“数据定义”，但它有时被称为“破坏磁盘”，因为用户经常错误地输入 if 或 of 规范。<strong>始终在按下回车键之前仔细检查您的输入和输出规范！</strong></p>
<p>假设我们有两个大小相同的USB闪存驱动器，我们想将第一个驱动器的内容完全复制到第二个驱动器。如果我们将两个驱动器连接到计算机，并分别分配给 &#x2F;dev&#x2F;sdb 和 &#x2F;dev&#x2F;sdc 设备，我们可以使用以下方式将第一个驱动器上的所有内容复制到第二个驱动器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdb of=/dev/sdc</span><br></pre></td></tr></table></figure>

<p>或者，如果只有第一个设备连接到计算机，我们可以将其内容复制到一个普通文件中，以便以后恢复或复制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdb of=flash_drive.img</span><br></pre></td></tr></table></figure>

<h3 id="创建-CD-ROM-镜像"><a href="#创建-CD-ROM-镜像" class="headerlink" title="创建 CD-ROM 镜像"></a>创建 CD-ROM 镜像</h3><p>写入可记录 CD-ROM（CD-R 或 CD-RW）包括两个步骤。</p>
<ol>
<li>构建一个 <em>iso 镜像文件</em>，它是 CD-ROM 的确切文件系统镜像</li>
<li>将镜像文件写入 CD-ROM 媒体</li>
</ol>
<h4 id="创建-CD-ROM-的镜像副本"><a href="#创建-CD-ROM-的镜像副本" class="headerlink" title="创建 CD-ROM 的镜像副本"></a>创建 CD-ROM 的镜像副本</h4><p>如果我们想制作现有 CD-ROM 的 ISO 镜像，我们可以使用 dd 从 CD-ROM 读取所有数据块，并将它们复制到本地文件。假设我们有一张 Ubuntu CD，并且我们想制作一个 ISO 文件，以便以后用来制作更多副本。在插入 CD 并确定其设备名称（我们假设为 &#x2F;dev&#x2F;cdrom）后，我们可以这样制作 ISO 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/cdrom of=ubuntu.iso</span><br></pre></td></tr></table></figure>

<p>此技术适用于数据 DVD，但不适用于音频 CD，因为它们不使用文件系统进行存储。对于音频 CD，请查看 cdrdao 命令。</p>
<h4 id="从文件集合中创建镜像"><a href="#从文件集合中创建镜像" class="headerlink" title="从文件集合中创建镜像"></a>从文件集合中创建镜像</h4><p>要创建一个包含目录内容的 ISO 镜像文件，我们使用 genisoimage 程序。为此，我们首先创建一个包含我们想要包含在镜像中的所有文件的目录，然后执行 genisoimage 命令来创建镜像文件。例如，如果我们创建了一个名为 ~&#x2F;cd-rom-files 的目录，并用我们的 CD-ROM 文件填满了它，我们可以使用以下命令创建名为 cdrom.iso 的镜像文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genisoimage -o cd-rom.iso -R -J ~/cd-rom-files</span><br></pre></td></tr></table></figure>

<p>-R 选项添加了用于 <em>Rock Ridge 扩展</em> 的元数据，允许使用长文件名和 POSIX 风格的文件权限。同样，-J 选项启用了 <em>Joliet 扩展</em>，允许 Windows 使用长文件名。</p>
<p><strong>另一个名字的程序…</strong></p>
<p>如果你查看在线教程，了解如何创建和刻录像 CDROM 和 DVD 这样的光学媒体，你会经常遇到两个程序，分别叫做 mkisofs 和 cdrecord。这些程序是 Jörg Schilling 编写的一个受欢迎的软件包 cdrtools 的一部分。2006 年夏天，Schilling 先生对 cdrtools 包的部分内容进行了许可更改，依据许多 Linux 社区的意见，这导致了与 GNU GPL 的许可不兼容。结果，cdrtools 项目的一个 <em>分支</em> 开始，现在包括了 cdrecord 和 mkisofs 的替代程序，分别叫做 wodim 和 genisoimage。</p>
<h3 id="写入-CD-ROM-镜像"><a href="#写入-CD-ROM-镜像" class="headerlink" title="写入 CD-ROM 镜像"></a>写入 CD-ROM 镜像</h3><p>在我们有了镜像文件之后，我们可以将其刻录到光学媒体上。下面我们将讨论的大多数命令可以应用于可记录的 CD-ROM 和 DVD 媒体。</p>
<h4 id="直接挂载-ISO-镜像"><a href="#直接挂载-ISO-镜像" class="headerlink" title="直接挂载 ISO 镜像"></a>直接挂载 ISO 镜像</h4><p>有一个技巧，我们可以使用它在硬盘上挂载 ISO 镜像，并将其视为已经在光学媒体上。通过在挂载时添加“-o loop”选项（以及所需的“-t iso9660”文件系统类型），我们可以将镜像文件挂载为设备并将其附加到文件系统树上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /mnt/iso_image</span><br><span class="line">mount -t iso9660 -o loop image.iso /mnt/iso_image</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们创建了一个名为 &#x2F;mnt&#x2F;iso_image 的挂载点，然后在该挂载点挂载了镜像文件 image.iso。镜像挂载后，就可以像真正的 CD-ROM 或 DVD 一样处理。<em>记得在不再需要时卸载镜像。</em></p>
<h4 id="擦除可重写-CD-ROM"><a href="#擦除可重写-CD-ROM" class="headerlink" title="擦除可重写 CD-ROM"></a>擦除可重写 CD-ROM</h4><p>可重写的 CD-RW 媒体需要被擦除或<em>清空</em>才能被重复使用。为此，我们可以使用 wodim，指定 CD 写入器的设备名称和要执行的擦除类型。wodim 程序提供了几种擦除类型。最简单（也是最快）的是“快速”类型。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wodim dev=/dev/cdrw blank=fast</span><br></pre></td></tr></table></figure>

<h4 id="写入镜像"><a href="#写入镜像" class="headerlink" title="写入镜像"></a>写入镜像</h4><p>为了写入镜像，我们再次使用 wodim，指定光媒体写入器设备的名称和镜像文件的名称。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wodim dev=/dev/cdrw image.iso</span><br></pre></td></tr></table></figure>

<p>除了设备名称和镜像文件，wodim 还支持大量的选项。两个常见的选项是“-v”用于详细输出，和“-dao”，用于以<em>一次性写入</em>模式写入光盘。如果你准备将光盘用于商业复制，应该使用这种模式。wodim 的默认模式是<em>逐轨道写入</em>，适用于录制音乐轨道。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这一章中，我们研究了基本的存储管理任务。当然，还有更多。Linux 支持广泛的存储设备和文件系统方案。它还提供了许多与其他系统互操作的功能。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>查看我们所涉及命令的 man 页面。其中一些支持大量的选项和操作。另外，寻找在线教程，了解如何向你的 Linux 系统添加硬盘（有很多）和处理光媒体。</p>
<h3 id="额外学分"><a href="#额外学分" class="headerlink" title="额外学分"></a>额外学分</h3><p>验证我们下载的 ISO 镜像的完整性通常是有用的。在大多数情况下，ISO 镜像的分发者也会提供一个<em>校验和文件</em>。校验和是通过一种奇特的数学计算得出的，代表目标文件内容的一个数字。如果文件的内容哪怕改变一位，得出的校验和将会大不相同。校验和生成最常用的方法是使用 md5sum 程序。当你使用 md5sum 时，它会产生一个独特的十六进制数字。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">md5sum</span> image.iso</span><br><span class="line">34e354760f9bb7fbf85c96f6a3f94ece image.iso</span><br></pre></td></tr></table></figure>

<p>下载镜像后，你应该对其运行 md5sum 并将结果与发布者提供的 md5sum 值进行比较。</p>
<p>除了检查下载文件的完整性，我们还可以使用 md5sum 来验证新写入的光媒体。为此，我们首先计算镜像文件的校验和，然后为媒体计算校验和。验证媒体的诀窍是将计算限制在仅包含镜像的光媒体部分。我们通过确定镜像包含的 2048 字节块的数量（光媒体总是以 2048 字节块写入）并从媒体中读取那么多块来做到这一点。在某些类型的媒体上，这不是必需的。以一次性写入模式写入的 CD-R 和 CD-RW 磁盘可以通过这种方式进行检查。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">md5sum</span> /dev/cdrom</span><br><span class="line">34e354760f9bb7fbf85c96f6a3</span><br><span class="line"></span><br><span class="line">f94ece /dev/cdrom</span><br></pre></td></tr></table></figure>

<p>许多类型的媒体，如 DVD，需要准确计算块的数量。在下面的例子中，我们检查了 DVD 镜像文件 dvd-image.iso 和 DVD 读取器 &#x2F;dev&#x2F;dvd 中的光盘的完整性。你能弄清楚这是如何工作的吗？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">md5sum</span> dvd-image.iso; <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/dvd bs=2048 count=$(( $(stat -c &quot;%s&quot;</span><br><span class="line">dvd-image.iso) / <span class="number">2048</span> )) | <span class="built_in">md5sum</span></span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/TLCL/" rel="tag"># TLCL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/04/14-package-management/" rel="prev" title="包管理">
                  <i class="fa fa-angle-left"></i> 包管理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/04/16-networking/" rel="next" title="网络">
                  网络 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Slagga</span>
  </div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdHNsYWdnYQ==" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/sidebar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/search/local-search.min.js"></script>




  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/fancybox.min.js"></script>



  




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"gitslagga","repo":"gitslagga.github.io","client_id":"8b03c773267690e6d402","client_secret":"7b2ef82f50c632cdb14c98b7e5928357974cad97","admin_user":"gitslagga","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"990c7a6f36dbc329e71db5a9dcc3f54e"}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/comments/gitalk.min.js"></script>

</body>
</html>
