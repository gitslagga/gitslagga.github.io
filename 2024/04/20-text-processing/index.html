<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="E1ct36DyjSpaeX5NMAVsyzCjDs8-dQxGThgvw2i1yg0">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"slagga.top","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.21.0","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/config.min.js"></script>

    <meta name="description" content="20 - 文本处理所有类Unix操作系统都严重依赖文本文件进行数据存储。因此，存在许多用于操作文本的工具是有道理的。在本章中，我们将看看用于“切割和处理”文本的程序。在下一章中，我们将继续探讨文本处理，重点是用于格式化文本以供打印和其他类型人类消费的程序。 本章将重温一些老朋友，并向我们介绍一些新朋友：">
<meta property="og:type" content="article">
<meta property="og:title" content="文本处理">
<meta property="og:url" content="https://slagga.top/2024/04/20-text-processing/index.html">
<meta property="og:site_name" content="计算机那些事">
<meta property="og:description" content="20 - 文本处理所有类Unix操作系统都严重依赖文本文件进行数据存储。因此，存在许多用于操作文本的工具是有道理的。在本章中，我们将看看用于“切割和处理”文本的程序。在下一章中，我们将继续探讨文本处理，重点是用于格式化文本以供打印和其他类型人类消费的程序。 本章将重温一些老朋友，并向我们介绍一些新朋友：">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-25T07:54:30.000Z">
<meta property="article:modified_time" content="2025-06-06T06:13:40.953Z">
<meta property="article:author" content="Slagga">
<meta property="article:tag" content="TLCL">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://slagga.top/2024/04/20-text-processing/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://slagga.top/2024/04/20-text-processing/","path":"2024/04/20-text-processing/","title":"文本处理"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>文本处理 | 计算机那些事</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-0E2T2VNH5S"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-0E2T2VNH5S","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/analytics/google-analytics.min.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">计算机那些事</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">软件开发、维护和升级</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">229</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">78</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">28</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">20 - 文本处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">文本的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%A1%A3"><span class="nav-number">1.1.1.</span> <span class="nav-text">文档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E9%A1%B5"><span class="nav-number">1.1.2.</span> <span class="nav-text">网页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6"><span class="nav-number">1.1.3.</span> <span class="nav-text">电子邮件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E6%9C%BA%E8%BE%93%E5%87%BA"><span class="nav-number">1.1.4.</span> <span class="nav-text">打印机输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.5.</span> <span class="nav-text">程序源代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%AE%BF%E4%B8%80%E4%BA%9B%E8%80%81%E6%9C%8B%E5%8F%8B"><span class="nav-number">1.2.</span> <span class="nav-text">重访一些老朋友</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cat"><span class="nav-number">1.2.1.</span> <span class="nav-text">cat</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MS-DOS%E6%96%87%E6%9C%AC%E4%B8%8EUnix%E6%96%87%E6%9C%AC"><span class="nav-number">1.3.</span> <span class="nav-text">MS-DOS文本与Unix文本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sort"><span class="nav-number">1.3.1.</span> <span class="nav-text">sort</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#uniq"><span class="nav-number">1.3.2.</span> <span class="nav-text">uniq</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E5%89%B2%E4%B8%8E%E7%BB%84%E5%90%88"><span class="nav-number">1.4.</span> <span class="nav-text">切割与组合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cut"><span class="nav-number">1.4.1.</span> <span class="nav-text">cut</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%95%E5%BC%80%E5%88%B6%E8%A1%A8%E7%AC%A6"><span class="nav-number">1.5.</span> <span class="nav-text">展开制表符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#paste"><span class="nav-number">1.5.1.</span> <span class="nav-text">paste</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#join"><span class="nav-number">1.5.2.</span> <span class="nav-text">join</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E6%96%87%E6%9C%AC"><span class="nav-number">1.6.</span> <span class="nav-text">比较文本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#comm"><span class="nav-number">1.6.1.</span> <span class="nav-text">comm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#diff"><span class="nav-number">1.6.2.</span> <span class="nav-text">diff</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#patch"><span class="nav-number">1.6.3.</span> <span class="nav-text">patch</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B3%E6%97%B6%E7%BC%96%E8%BE%91"><span class="nav-number">1.7.</span> <span class="nav-text">即时编辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tr"><span class="nav-number">1.7.1.</span> <span class="nav-text">tr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sed"><span class="nav-number">1.7.2.</span> <span class="nav-text">sed</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#aspell"><span class="nav-number">1.7.3.</span> <span class="nav-text">aspell</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.8.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%98%85%E8%AF%BB"><span class="nav-number">1.9.</span> <span class="nav-text">进一步阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%9D%E5%A4%96%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.10.</span> <span class="nav-text">额外学习</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Slagga"
      src="https://avatars.githubusercontent.com/u/19620432">
  <p class="site-author-name" itemprop="name">Slagga</p>
  <div class="site-description" itemprop="description">Computer Things - Software Development, Maintenance and Upgrade</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">229</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdHNsYWdnYQ==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gitslagga"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnNsYWdnYUBkdWNrLmNvbQ==" title="E-Mail → mailto:slagga@duck.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://slagga.top/2024/04/20-text-processing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/19620432">
      <meta itemprop="name" content="Slagga">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="计算机那些事">
      <meta itemprop="description" content="Computer Things - Software Development, Maintenance and Upgrade">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="文本处理 | 计算机那些事">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          文本处理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-25 15:54:30" itemprop="dateCreated datePublished" datetime="2024-04-25T15:54:30+08:00">2024-04-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-06 14:13:40" itemprop="dateModified" datetime="2025-06-06T14:13:40+08:00">2025-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="20-文本处理"><a href="#20-文本处理" class="headerlink" title="20 - 文本处理"></a>20 - 文本处理</h2><p>所有类Unix操作系统都严重依赖文本文件进行数据存储。因此，存在许多用于操作文本的工具是有道理的。在本章中，我们将看看用于“切割和处理”文本的程序。在下一章中，我们将继续探讨文本处理，重点是用于格式化文本以供打印和其他类型人类消费的程序。</p>
<p>本章将重温一些老朋友，并向我们介绍一些新朋友：</p>
<span id="more"></span>

<ul>
<li>cat - 连接文件并在标准输出上打印</li>
<li>sort - 对文本文件的行进行排序</li>
<li>uniq - 报告或忽略重复的行</li>
<li>cut - 从文件的每一行中删除部分</li>
<li>paste - 合并文件的行</li>
<li>join - 在一个公共字段上连接两个文件的行</li>
<li>comm - 逐行比较两个排序的文件</li>
<li>diff - 逐行比较文件</li>
<li>patch - 将差异文件应用于原始文件</li>
<li>tr - 转换或删除字符</li>
<li>sed - 用于过滤和转换文本的流编辑器</li>
<li>aspell - 交互式拼写检查器</li>
</ul>
<h3 id="文本的应用"><a href="#文本的应用" class="headerlink" title="文本的应用"></a>文本的应用</h3><p>到目前为止，我们已经学习了一些文本编辑器（nano和vim），查看了许多配置文件，并且见证了数十个命令的输出，全部以文本形式。但是文本还用于什么呢？事实证明，用途非常多。</p>
<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>许多人使用纯文本格式编写文档。虽然很容易看出一个小文本文件对于保留简单笔记是有用的，但也完全可能以文本格式编写大型文档。一种流行的方法是以文本格式编写大型文档，然后嵌入<em>标记语言</em>来描述最终文档的格式。许多科学论文都是使用这种方法编写的，因为基于Unix的文本处理系统是最早支持技术领域作家所需的高级排版布局的系统之一。</p>
<h4 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h4><p>世界上最流行的电子文档类型可能是网页。网页是使用<em>超文本标记语言</em>（<em>HTML</em>）或<em>可扩展标记语言</em>（<em>XML</em>）作为标记语言的文本文档，用来描述文档的视觉格式。</p>
<h4 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h4><p>电子邮件是一种本质上基于文本的媒介。即使是非文本附件也会被转换为文本表示形式进行传输。我们可以通过下载一封电子邮件消息然后在less中查看它来亲自看到。我们会看到消息以描述消息来源和它在传输过程中接收到的处理的<em>头部</em>开始，然后是包含其内容的消息<em>正文</em>。</p>
<h4 id="打印机输出"><a href="#打印机输出" class="headerlink" title="打印机输出"></a>打印机输出</h4><p>在类Unix系统上，发送给打印机的输出以纯文本发送，或者，如果页面包含图形，则转换为称为<em>PostScript</em>的文本格式<em>页面描述语言</em>，然后发送给生成要打印的图形点的程序。</p>
<h4 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h4><p>许多在类Unix系统上找到的命令行程序是为了支持系统管理和软件开发而创建的，文本处理程序也不例外。它们中的许多都是为了解决软件开发问题而设计的。文本处理对软件开发人员很重要的原因是所有软件都是以文本开始的。<em>源代码</em>，程序员实际编写的部分，始终是文本格式的。</p>
<h3 id="重访一些老朋友"><a href="#重访一些老朋友" class="headerlink" title="重访一些老朋友"></a>重访一些老朋友</h3><p>回到第6章，“重定向”，我们学习了一些能够接受标准输入以及</p>
<p>命令行参数的命令。那时我们只是简单地触及它们，但现在我们将更仔细地看看它们如何用于进行文本处理。</p>
<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>cat程序有许多有趣的选项。其中许多用于帮助更好地可视化文本内容。一个例子是-A选项，用于显示文本中的不可打印字符。有时我们想知道控制字符是否嵌入在我们的可见文本中。最常见的是制表符（与空格相对）和回车符，通常作为MS-DOS样式文本文件中的行尾字符出现。另一个常见情况是包含尾随空格的文本行中的文本文件。</p>
<p>让我们使用cat作为原始文字处理器来创建一个测试文件。为此，我们只需输入cat命令（连同指定用于重定向输出的文件）并键入我们的文本，然后按Enter以正确结束该行，然后Ctrl-d，以指示给cat我们已达到文件末尾。在这个例子中，我们输入一个前导制表符，然后在行后跟一些尾随空格：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; foo.txt</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>接下来，我们将使用cat的-A选项来显示文本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> -A foo.txt</span><br><span class="line">^IThe quick brown fox jumped over the lazy dog. $</span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>如我们在结果中看到的，我们文本中的制表符由^I表示。这是一个常见的表示方法，意思是Ctrl-i，正如事实证明，与制表符相同。我们还看到行的真正结束处出现了一个$，表明我们的文本包含尾随空格。</p>
<h3 id="MS-DOS文本与Unix文本"><a href="#MS-DOS文本与Unix文本" class="headerlink" title="MS-DOS文本与Unix文本"></a>MS-DOS文本与Unix文本</h3><p>您可能想使用cat来查找文本中的不可打印字符的原因之一是要发现隐藏的回车符。隐藏的回车符从哪里来的？DOS和Windows！Unix和DOS在文本文件中不以相同的方式定义行的结束。Unix以换行符（ASCII 10）结束一行，而MSDOS及其衍生物使用回车符（ASCII 13）和换行符的序列来终止每一行文本。</p>
<p>有几种方法可以将文件从DOS转换为Unix格式。在许多Linux系统上，有名为dos2unix和unix2dos的程序，可以将文本文件转换为DOS格式及其反向转换。然而，如果你的系统上没有dos2unix，也不用担心。将文本从DOS转换为Unix格式的过程很简单；它涉及到删除冒犯的回车符。这很容易通过本章后面讨论的几个程序来完成。</p>
<p>cat还有一些用于修改文本的选项。两个最主要的是-n，它为行编号，和-s，它抑制多个空行的输出。我们可以这样演示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; foo.txt</span><br><span class="line">The quick brown fox</span><br><span class="line">jumped over the lazy dog.</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> -ns foo.txt</span><br><span class="line"> 1 The quick brown fox</span><br><span class="line"> 2</span><br><span class="line"> 3 jumped over the lazy dog.</span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了我们的foo.txt测试文件的新版本，其中包含两行文本，由两个空行分隔。经过带有-ns选项的cat处理后，多余的空行被移除，剩下的行被编号。虽然这对文本进行的处理不多，但它确实是一个过程。</p>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>sort程序对标准输入的内容或命令行上指定的一个或多个文件进行排序，并将结果发送到标准输出。使用我们之前与cat一起使用的技术，我们可以按如下方式直接从键盘演示标准输入的处理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> &gt; foo.txt</span><br><span class="line">c</span><br><span class="line">b</span><br><span class="line">a</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> foo.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>输入命令后，我们键入字母c、b和a，然后按Ctrl-d表示文件结束。然后我们查看结果文件，看到行现在以排序顺序出现。</p>
<p>由于sort可以在命令行上接受多个文件作为参数，因此可以将多个文件<em>合并</em>成一个单一排序的整体。例如，如果我们有三个文本文件并希望将它们合并成一个单一的排序文件，我们可以这样做：</p>
<blockquote>
<p>sort file1.txt file2.txt file3.txt &gt; final_sorted_list.txt</p>
</blockquote>
<p>sort有几个有趣的选项。表20-1包含了一个部分列表：</p>
<p><em>表20-1: 常见的</em> <em>sort选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>长选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>–ignore-leading-blanks</td>
<td>默认情况下，排序是基于整行进行的，从行中的第一个字符开始。此选项使sort忽略行首的空格，并基于行中的第一个非空白字符计算排序。</td>
</tr>
<tr>
<td>-f</td>
<td>–ignore-case</td>
<td>使排序不区分大小写。</td>
</tr>
<tr>
<td>-n</td>
<td>–numeric-sort</td>
<td>基于字符串的数值评估执行排序。使用此选项允许根据数值而不是字母值进行排序。</td>
</tr>
<tr>
<td>-r</td>
<td>–reverse</td>
<td>以相反的顺序排序。结果是降序而不是升序。</td>
</tr>
<tr>
<td>-k</td>
<td>–key&#x3D;<em>field1</em>[,<em>field2</em>]</td>
<td>基于位于<em>field1</em>到<em>field2</em>的关键字段排序，而不是整行。见下文讨论。</td>
</tr>
<tr>
<td>-m</td>
<td>–merge</td>
<td>将每个参数视为预排序文件的名称。合并多个文件到一个排序结果中，而不执行任何额外排序。</td>
</tr>
<tr>
<td>-o</td>
<td>–output&#x3D;<em>file</em></td>
<td>将排序输出发送到<em>file</em>而不是标准输出。</td>
</tr>
<tr>
<td>-t</td>
<td>–field-separator&#x3D;<em>char</em></td>
<td>定义字段分隔符字符。默认情况下，字段由空格或制表符分隔。</td>
</tr>
</tbody></table>
<p>尽管这些选项中的大多数都是不言自明的，但有些则不是。首先，让我们看看用于数值排序的-n选项。使用这个选项，可以根据数值对值进行排序。我们可以通过对du命令的结果进行排序来演示这一点，以确定磁盘空间的最大使用者。通常，du命令以路径名顺序列出摘要结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">du</span> -s /usr/share/* | <span class="built_in">head</span></span><br><span class="line">252 /usr/share/aclocal</span><br><span class="line">96 /usr/share/acpi-support</span><br><span class="line">8 /usr/share/adduser</span><br><span class="line">196 /usr/share/alacarte</span><br><span class="line">344 /usr/share/alsa</span><br><span class="line">8 /usr/share/alsa-base</span><br><span class="line">12488 /usr/share/anthy</span><br><span class="line">8 /usr/share/apmd</span><br><span class="line">21440 /usr/share/app-install</span><br><span class="line">48 /usr/share/application-registry</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们将结果通过管道传递给head来限制结果为前10行。我们可以用这种方式产生一个数值排序的列表，显示前10个空间消耗者。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">du</span> -s /usr/share/* | <span class="built_in">sort</span> -nr | <span class="built_in">head</span></span><br><span class="line">509940 /usr/share/locale-langpack</span><br><span class="line">242660 /usr/share/doc</span><br><span class="line">197560 /usr/share/fonts</span><br><span class="line">179144 /usr/share/gnome</span><br><span class="line">146764 /usr/share/myspell</span><br><span class="line">144304 /usr/share/gimp</span><br><span class="line">135880 /usr/share/dict</span><br><span class="line">76508 /usr/share/icons</span><br><span class="line">68072 /usr/share/apps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">62844 /usr/share/foomatic</span><br></pre></td></tr></table></figure>

<p>通过使用n和r选项，我们生成了一个反向数值排序，最大值首先出现在结果中。这种排序有效是因为数值位于每行的开始。但是如果我们想根据某个位于行内的值进行排序呢？例如，这是ls -l的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin | <span class="built_in">head</span></span><br><span class="line">total 152948</span><br><span class="line">-rwxr-xr-x 1 root root 34824 2016-04-04 02:42 [</span><br><span class="line">-rwxr-xr-x 1 root root 101556 2007-11-27 06:08 a2p</span><br><span class="line">-rwxr-xr-x 1 root root 13036 2016-02-27 08:22 aconnect</span><br><span class="line">-rwxr-xr-x 1 root root 10552 2007-08-15 10:34 acpi</span><br><span class="line">-rwxr-xr-x 1 root root 3800 2016-04-14 03:51 acpi_fakekey</span><br><span class="line">-rwxr-xr-x 1 root root 7536 2016-04-19 00:19 acpi_listen</span><br><span class="line">-rwxr-xr-x 1 root root 3576 2016-04-29 07:57 addpart</span><br><span class="line">-rwxr-xr-x 1 root root 20808 2016-01-03 18:02 addr2line</span><br><span class="line">-rwxr-xr-x 1 root root 489704 2016-10-09 17:02 adept_batch</span><br></pre></td></tr></table></figure>

<p>暂时忽略ls可以按大小对其结果进行排序的事实，我们也可以使用sort来按文件大小对这个列表进行排序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin | <span class="built_in">sort</span> -nrk 5 | <span class="built_in">head</span></span><br><span class="line">-rwxr-xr-x 1 root root 8234216 2016-04-07 17:42 inkscape</span><br><span class="line">-rwxr-xr-x 1 root root 8222692 2016-04-07 17:42 inkview</span><br><span class="line">-rwxr-xr-x 1 root root 3746508 2016-03-07 23:45 gimp-2.4</span><br><span class="line">-rwxr-xr-x 1 root root 3654020 2016-08-26 16:16 quanta</span><br><span class="line">-rwxr-xr-x 1 root root 2928760 2016-09-10 14:31 gdbtui</span><br><span class="line">-rwxr-xr-x 1 root root 2928756 2016-09-10 14:31 gdb</span><br><span class="line">-rwxr-xr-x 1 root root 2602236 2016-10-10 12:56 net</span><br><span class="line">-rwxr-xr-x 1 root root 2304684 2016-10-10 12:56 rpcclient</span><br><span class="line">-rwxr-xr-x 1 root root 2241832 2016-04-04 05:56 aptitude</span><br><span class="line">-rwxr-xr-x 1 root root 2202476 2016-10-10 12:56 smbcacls</span><br></pre></td></tr></table></figure>

<p>sort的许多用途涉及<em>表格数据</em>的处理，如前面ls命令的结果。如果我们将数据库术语应用于前面的表格，我们会说每行是一条<em>记录</em>，每条记录由多个<em>字段</em>组成，如文件属性、链接计数、文件名、文件大小等。sort能够处理单独的字段。用数据库术语来说，我们能够指定一个或多个<em>关键字段</em>作为<em>排序键</em>。在前面的例子中，我们指定了n和r选项来执行反向数值排序，并指定-k 5使sort使用第五个字段作为排序键。</p>
<p>k选项很有趣，有许多特性，但首先我们需要讨论sort如何定义字段。让我们考虑下面的简单文本文件，它由一行包含作者名字的文本组成：</p>
<blockquote>
<p>William Shotts</p>
</blockquote>
<p>默认情况下，sort将这行视为有两个字段。第一个字段包含以下字符：</p>
<blockquote>
<p>“William”</p>
</blockquote>
<p>第二个字段包含以下字符：</p>
<blockquote>
<p>“Shotts”</p>
</blockquote>
<p>这意味着空白字符（空格和制表符）被用作字段之间的分隔符，并且在执行排序时，分隔符被包含在字段中。</p>
<p>再看一下我们的ls输出中的一行，如下所示，我们可以看到一行包含八个字段，第五个字段是文件大小：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root 8234216 2016-04-07 17:42 inkscape</span><br></pre></td></tr></table></figure>

<p>让我们考虑以下文件，它包含了从2006年到2008年发布的三个流行的Linux发行版的历史。文件中的每一行有三个字段：发行版名称、版本号和发布日期，格式为MM&#x2F;DD&#x2F;YYYY。</p>
<table>
<thead>
<tr>
<th>发行版名称</th>
<th>版本号</th>
<th>发布日期</th>
</tr>
</thead>
<tbody><tr>
<td>SUSE</td>
<td>10.2</td>
<td>12&#x2F;07&#x2F;2006</td>
</tr>
<tr>
<td>Fedora</td>
<td>10</td>
<td>11&#x2F;25&#x2F;2008</td>
</tr>
<tr>
<td>SUSE</td>
<td>11.0</td>
<td>06&#x2F;19&#x2F;2008</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>8.04</td>
<td>04&#x2F;24&#x2F;2008</td>
</tr>
<tr>
<td>Fedora</td>
<td>8</td>
<td>11&#x2F;08&#x2F;2007</td>
</tr>
<tr>
<td>SUSE</td>
<td>10.3</td>
<td>10&#x2F;04&#x2F;2007</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>6.10</td>
<td>10&#x2F;26&#x2F;2006</td>
</tr>
<tr>
<td>Fedora</td>
<td>7</td>
<td>05&#x2F;31&#x2F;2007</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>7.10</td>
<td>10&#x2F;18&#x2F;2007</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>7.04</td>
<td>04&#x2F;19&#x2F;2007</td>
</tr>
<tr>
<td>SUSE</td>
<td>10.1</td>
<td>05&#x2F;11&#x2F;2006</td>
</tr>
<tr>
<td>Fedora</td>
<td>6</td>
<td>10&#x2F;24&#x2F;2006</td>
</tr>
<tr>
<td>Fedora</td>
<td>9</td>
<td>05&#x2F;13&#x2F;2008</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>6.06</td>
<td>06&#x2F;01&#x2F;2006</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>8.10</td>
<td>10&#x2F;30&#x2F;2008</td>
</tr>
<tr>
<td>Fedora</td>
<td>5</td>
<td>03&#x2F;20&#x2F;2006</td>
</tr>
</tbody></table>
<p>使用文本编辑器（也许是vim），我们将输入这些数据并将结果文件命名为distros.txt。</p>
<p>接下来，我们尝试对文件进行排序并观察这些结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> distros.txt</span><br><span class="line">Fedora 10 11/25/2008</span><br><span class="line">Fedora 5 03/20/2006</span><br><span class="line">Fedora 6 10/24/2006</span><br><span class="line">Fedora 7 05/31/2007</span><br><span class="line">Fedora 8 11/08/2007</span><br><span class="line">Fedora 9 05/13/2008</span><br><span class="line">SUSE 10.1 05/11/2006</span><br><span class="line">SUSE 10.2 12/07/2006</span><br><span class="line">SUSE 10.3 10/04/2007</span><br><span class="line">SUSE 11.0 06/19/2008</span><br><span class="line">Ubuntu 6.06 06/01/2006</span><br><span class="line">Ubuntu 6.10 10/26/2006</span><br><span class="line">Ubuntu 7.04 04/19/2007</span><br><span class="line">Ubuntu 7.10 10/18/2007</span><br><span class="line">Ubuntu 8.04 04/24/2008</span><br><span class="line">Ubuntu 8.10 10/30/2008</span><br></pre></td></tr></table></figure>

<p>这基本上起作用了。问题出现在对Fedora版本号的排序上。由于字符集中1在5之前，版本10最终位于顶部，而版本9则掉到底部。</p>
<p>为了解决这个问题，我们将不得不对多个键进行排序。我们想要对第一个字段执行字母排序，然后对第二个字段执行数值排序。sort允许-k选项的多个实例，以便可以指定多个排序键。实际上，一个键可以包括字段范围。如果没有指定范围（就像我们之前的例子那样），sort使用从指定字段开始并扩展到行尾的键。下面是我们多键排序的语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> --key=1,1 --key=2n distros.txt</span><br><span class="line">Fedora 5 03/20/2006</span><br><span class="line">Fedora 6 10/24/2006</span><br><span class="line">Fedora 7 05/31/2007</span><br><span class="line">Fedora 8 11/08/2007</span><br><span class="line">Fedora 9 05/13/2008</span><br><span class="line">Fedora 10 11/25/2008</span><br><span class="line">SUSE 10.1 05/11/2006</span><br><span class="line">SUSE 10.2 12/07/2006</span><br><span class="line">SUSE 10.3 10/04/2007</span><br><span class="line">SUSE 11.0 06/19/2008</span><br><span class="line">Ubuntu 6.06 06/01/2006</span><br><span class="line">Ubuntu 6.10 10/26/2006</span><br><span class="line">Ubuntu 7.04 04/19/2007</span><br><span class="line">Ubuntu 7.10 10/18/2007</span><br><span class="line">Ubuntu 8.04 04/24/2008</span><br><span class="line">Ubuntu 8.10 10/30/2008</span><br></pre></td></tr></table></figure>

<p>尽管我们为了清晰使用了选项的长形式，-k 1,1 -k 2n将是完全等效的。在第一个键选项中，我们指定了要包括在第一个键中的字段范围。由于我们想要将排序限制在仅第一个字段，我们指定了1,1，这意味着“从字段1开始，结束于字段1”。在第二个实例中，我们指定了2n，这意味着字段2是排序键，并且排序应该是数值的。一个选项字母可以包含在键指定符的末尾，以指示要执行的排序类型。这些选项字母与sort程序的全局选项相同：b（忽略开头的空格）、n（数值排序）、r（反向排序）等。</p>
<p>我们列表中的第三个字段包含一个对排序不方便的日期格式。在计算机上，日期通常以YYYY-MM-DD的顺序格式化，以便易于进行时间顺序排序，但我们的是美国格式MM&#x2F;DD&#x2F;YYYY。我们如何按时间顺序对这个列表进行排序？</p>
<p>幸运的是，sort提供了一种方法。键选项允许指定字段内的<em>偏移量</em>，因此我们可以在字段内定义键。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt</span><br><span class="line">Fedora 10 11/25/2008</span><br><span class="line">Ubuntu 8.10 10/30/2008</span><br><span class="line">SUSE 11.0 06/19/2008</span><br><span class="line">Fedora 9 05/13/2008</span><br><span class="line">Ubuntu 8.04 04/24/2008</span><br><span class="line">Fedora 8 11/08/2007</span><br><span class="line">Ubuntu 7.10 10/18/2007</span><br><span class="line">SUSE 10.3 10/04/2007</span><br><span class="line">Fedora 7 05/31/2007</span><br><span class="line">Ubuntu 7.04 04/19/2007</span><br><span class="line">SUSE 10.2 12/07/2006</span><br><span class="line">Ubuntu 6.10 10/26/2006</span><br><span class="line">Fedora 6 10/24/2006</span><br><span class="line">Ubuntu 6.06 06/01/2006</span><br><span class="line">SUSE 10.1 05/11/2006</span><br><span class="line">Fedora 5 03/20/2006</span><br></pre></td></tr></table></figure>

<p>通过指定-k 3.7，我们指示sort使用从第三个字段内的第七个字符开始的排序键，这对应于年份的开始。同样，我们指定-k 3.1和-k 3.4来隔离日期的月份和日份部分。我们还添加了n和r选项来实现反向数值排序。b选项包含在内以抑制日期字段中的开头空格（其数量从行到行不同，因此影响排序结果）。</p>
<p>一些文件不使用制表符和空格作为字段分隔符；例如，这是&#x2F;etc&#x2F;passwd文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br><span class="line">bin:x:2:2:bin:/bin:/bin/sh</span><br><span class="line">sys:x:3:3:sys:/dev:/bin/sh</span><br><span class="line"><span class="built_in">sync</span>:x:4:65534:<span class="built_in">sync</span>:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/bin/sh</span><br><span class="line">man:x:6:12:man:/var/cache/man:/bin/sh</span><br><span class="line">lp:x:7:7:lp:/var/spool/lpd:/bin/sh</span><br><span class="line">mail:x:8:8:mail:/var/mail:/bin</span><br><span class="line"></span><br><span class="line">/sh</span><br><span class="line">news:x:9:9:news:/var/spool/news:/bin/sh</span><br></pre></td></tr></table></figure>

<p>这个文件中的字段用冒号(:)分隔，那么我们如何使用键字段对这个文件进行排序呢？sort提供了-t选项来定义字段分隔符字符。要按第七个字段（账户的默认shell）对passwd文件进行排序，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> -t <span class="string">&#x27;:&#x27;</span> -k 7 /etc/passwd | <span class="built_in">head</span></span><br><span class="line">me:x:1001:1001:Myself,,,:/home/me:/bin/bash</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">dhcp:x:101:102::/nonexistent:/bin/false</span><br><span class="line">gdm:x:106:114:Gnome Display Manager:/var/lib/gdm:/bin/false</span><br><span class="line">hplip:x:104:7:HPLIP system user,,,:/var/run/hplip:/bin/false</span><br><span class="line">klog:x:103:104::/home/klog:/bin/false</span><br><span class="line">messagebus:x:108:119::/var/run/dbus:/bin/false</span><br><span class="line">polkituser:x:110:122:PolicyKit,,,:/var/run/PolicyKit:/bin/false</span><br><span class="line">pulse:x:107:116:PulseAudio daemon,,,:/var/run/pulse:/bin/false</span><br></pre></td></tr></table></figure>

<p>通过指定冒号字符作为字段分隔符，我们可以按第七个字段进行排序。</p>
<h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>与sort相比，uniq程序相对简单。uniq执行一个看似微不足道的任务。当给定一个排序过的文件（或标准输入）时，它会删除任何重复的行，并将结果发送到标准输出。它经常与sort一起使用，以清除输出中的重复项。</p>
<p><strong>提示：</strong> 虽然uniq是一个传统的Unix工具，经常与sort一起使用，但GNU版本的sort支持-u选项，该选项可以从排序输出中删除重复项。</p>
<p>让我们创建一个文本文件来尝试，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; foo.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>记得输入Ctrl-d来终止标准输入。现在，如果我们对我们的文本文件运行uniq，我们得到这个：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">uniq</span> foo.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>结果与我们原始文件没有区别；重复项没有被删除。为了让uniq完成它的工作，输入必须首先被排序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> foo.txt | <span class="built_in">uniq</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>这是因为uniq只删除与其相邻的重复行。uniq有几个选项。表20-2列出了常见的选项。</p>
<p><em>表20-2: 常见的</em> <em>uniq选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>长选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>–count</td>
<td>输出重复行的列表，每行前面带有该行出现的次数。</td>
</tr>
<tr>
<td>-d</td>
<td>–repeated</td>
<td>只输出重复的行，而不是唯一的行。</td>
</tr>
<tr>
<td>-f <em>n</em></td>
<td>–skip-fields&#x3D;<em>n</em></td>
<td>忽略每行中的前<em>n</em>个字段。字段由空格分隔，就像在sort中一样；然而，与sort不同，uniq没有设置另一个字段分隔符的选项。</td>
</tr>
<tr>
<td>-i</td>
<td>–ignore-case</td>
<td>在行比较中忽略大小写。</td>
</tr>
<tr>
<td>-s <em>n</em></td>
<td>–skip-chars&#x3D;<em>n</em></td>
<td>跳过（忽略）每行开头的<em>n</em>个字符。</td>
</tr>
<tr>
<td>-u</td>
<td>–unique</td>
<td>只输出唯一的行。有重复项的行被忽略。</td>
</tr>
</tbody></table>
<p>这里我们看到uniq被用来报告我们文本文件中发现的重复项数量，使用-c选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> foo.txt | <span class="built_in">uniq</span> -c</span><br><span class="line"> 2 a</span><br><span class="line"> 2 b</span><br><span class="line"> 2 c</span><br></pre></td></tr></table></figure>

<h3 id="切割与组合"><a href="#切割与组合" class="headerlink" title="切割与组合"></a>切割与组合</h3><p>接下来我们将讨论的三个程序用于从文件中提取文本列并以有用的方式重新组合它们。</p>
<h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>cut 程序用于从一行中提取文本段并将提取的部分输出到标准输出。它可以接受多个文件参数或来自标准输入的输入。</p>
<p>指定要提取的行的部分有些笨拙，使用表20-3中列出的选项来指定。<em>表20-3:</em> <em>cut 选择选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>长选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-c <em>列表</em></td>
<td>–characters&#x3D;<em>列表</em></td>
<td>提取由<em>列表</em>定义的行的部分。列表可能包含一个或多个逗号分隔的数字范围。</td>
</tr>
<tr>
<td>-f <em>列表</em></td>
<td>–fields&#x3D;<em>列表</em></td>
<td>从行中提取一个或多个字段，由<em>列表</em>定义。列表可能包含一个或多个字段或字段范围，用逗号分隔。</td>
</tr>
<tr>
<td>-d <em>定界符</em></td>
<td>–delimiter&#x3D;<em>定界符</em></td>
<td>当指定-f时，使用<em>定界符</em>作为字段分隔字符。默认情况下，字段必须由单个制表符分隔。</td>
</tr>
<tr>
<td></td>
<td>–complement</td>
<td>提取整行文本，除了那些由-c和&#x2F;或-f指定的部分之外。</td>
</tr>
</tbody></table>
<p>正如我们所见，cut提取文本的方式相当不灵活。cut最适合用于提取由其他程序生成的文件中的文本，而不是直接由人类键入的文本。我们将查看我们的distros.txt文件，看看它是否“干净”到足以成为我们cut示例的好样本。如果我们使用带-A选项的cat，我们可以看到文件是否满足我们的要求，即字段由制表符分隔：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> -A distros.txt</span><br><span class="line">SUSE^I10.2^I12/07/2006$</span><br><span class="line">Fedora^I10^I11/25/2008$</span><br><span class="line">SUSE^I11.0^I06/19/2008$</span><br><span class="line">Ubuntu^I8.04^I04/24/2008$</span><br><span class="line">Fedora^I8^I11/08/2007$</span><br><span class="line">SUSE^I10.3^I10/04/2007$</span><br><span class="line">Ubuntu^I6.10^I10/26/2006$</span><br><span class="line">Fedora^I7^I05/31/2007$</span><br><span class="line">Ubuntu^I7.10^I10/18/2007$</span><br><span class="line">Ubuntu^I7.04^I04/19/2007$</span><br><span class="line">SUSE^I10.1^I05/11/2006$</span><br><span class="line">Fedora^I6^I10/24/2006$</span><br><span class="line">Fedora^I9^I05/13/2008$</span><br><span class="line">Ubuntu^I6.06^I06/01/2006$</span><br><span class="line">Ubuntu^I8.10^I10/30/2008$</span><br><span class="line">Fedora^I5^I03/20/2006$</span><br></pre></td></tr></table></figure>

<p>看起来不错。没有嵌入的空格，字段之间只有单个制表符。由于文件使用制表符而不是空格分隔，我们将使用-f选项来提取一个字段。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 3 distros.txt</span><br><span class="line">12/07/2006</span><br><span class="line">11/25/2008</span><br><span class="line">06/19/2008</span><br><span class="line">04/24/2008</span><br><span class="line">11/08/2007</span><br><span class="line">10/04/2007</span><br><span class="line">10/26/2006</span><br><span class="line">05/31/2007</span><br><span class="line">10/18/2007</span><br><span class="line">04/19/2007</span><br><span class="line">05/11/2006</span><br><span class="line">10/24/2006</span><br><span class="line">05/13/2008</span><br><span class="line">06/01/2006</span><br><span class="line">10/30/2008</span><br><span class="line">03/20/2006</span><br></pre></td></tr></table></figure>

<p>因为我们的distros文件是制表符分隔的，最好使用cut来提取字段而不是字符。这是因为当文件是制表符分隔的时，每行包含的字符数不太可能相同，这使得计算行内字符位置变得困难或不可能。然而，在我们之前的示</p>
<p>例中，我们现在已经提取了一个幸运地包含相同长度数据的字段，因此我们可以展示字符提取是如何工作的，通过提取每行中的年份。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 3 distros.txt | <span class="built_in">cut</span> -c 7-10</span><br><span class="line">2006</span><br><span class="line">2008</span><br><span class="line">2008</span><br><span class="line">2008</span><br><span class="line">2007</span><br><span class="line">2007</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2007</span><br><span class="line">2007</span><br><span class="line">2006</span><br><span class="line">2006</span><br><span class="line">2008</span><br><span class="line">2006</span><br><span class="line">2008</span><br><span class="line">2006</span><br></pre></td></tr></table></figure>

<p>通过对我们的列表运行cut第二次，我们能够提取字符位置7到10，这对应于我们日期字段中的年份。7-10表示法是范围的一个例子。cut手册页包含了如何指定范围的完整描述。</p>
<h3 id="展开制表符"><a href="#展开制表符" class="headerlink" title="展开制表符"></a>展开制表符</h3><p>我们的 distros.txt 文件的格式非常适合使用 cut 来提取字段。但是，如果我们想要一个可以完全通过字符而不是字段来用 cut 操作的文件怎么办？这将需要我们将文件中的制表符字符替换为相应数量的空格。幸运的是，GNU Coreutils 包中包括了一个用于此目的的工具。名为 expand，这个程序接受一个或多个文件参数或标准输入，并将修改后的文本输出到标准输出。</p>
<p>如果我们用 expand 处理我们的 distros.txt 文件，我们可以使用 cut -c 从文件中提取任何字符范围。例如，我们可以使用以下命令通过展开文件并使用 cut 提取从第 23 个位置到行尾的每个字符来提取我们列表中的发布年份：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">expand</span> distros.txt | <span class="built_in">cut</span> -c 23-</span><br></pre></td></tr></table></figure>

<p>Coreutils 还提供了 unexpand 程序来用空格替换制表符。</p>
<p>在处理字段时，可以指定不同的字段分隔符，而不仅仅是制表符。这里我们将从 &#x2F;etc&#x2F;passwd 文件中提取第一个字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -d <span class="string">&#x27;:&#x27;</span> -f 1 /etc/passwd | <span class="built_in">head</span></span><br><span class="line">root</span><br><span class="line">daemon</span><br><span class="line">bin</span><br><span class="line">sys</span><br><span class="line"><span class="built_in">sync</span></span><br><span class="line">games</span><br><span class="line">man</span><br><span class="line">lp</span><br><span class="line">mail</span><br><span class="line">news</span><br></pre></td></tr></table></figure>

<p>使用 -d 选项，我们能够指定冒号字符作为字段分隔符。</p>
<h4 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h4><p>paste 命令与 cut 相反。它不是从文件中提取文本列，而是向文件中添加一个或多个文本列。它通过读取多个文件并将每个文件中发现的字段组合成一个在标准输出上的单个流来实现这一点。像 cut 一样，paste 接受多个文件参数和&#x2F;或标准输入。为了演示 paste 的操作方式，我们将对我们的 distros.txt 文件进行一些操作，以产生一个按时间顺序排列的发布列表。</p>
<p>根据我们之前使用 sort 的工作，我们将首先生成一个按日期排序的 distros 列表，并将结果存储在名为 distros-by-date.txt 的文件中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt &gt; distros-by-date.txt</span><br></pre></td></tr></table></figure>

<p>接下来，我们将使用 cut 从文件中提取前两个字段（发行版名称和版本）并将该结果存储在名为 distro-versions.txt 的文件中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 1,2 distros-by-date.txt &gt; distros-versions.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> distros-versions.txt</span><br><span class="line">Fedora 10</span><br><span class="line">Ubuntu 8.10</span><br><span class="line">SUSE 11.0</span><br><span class="line">Fedora 9</span><br><span class="line">Ubuntu 8.04</span><br><span class="line">Fedora 8</span><br><span class="line">Ubuntu 7.10</span><br><span class="line">SUSE 10.3</span><br><span class="line">Fedora 7</span><br><span class="line">Ubuntu 7.04</span><br></pre></td></tr></table></figure>

<p>最后一步准备是提取发布日期并将它们存储在一个名为 distro-dates.txt 的文件中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 3 distros-by-date.txt &gt; distros-dates.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> distros-dates.txt</span><br><span class="line">11/25/2008</span><br><span class="line">10/30/2008</span><br><span class="line">06/19/2008</span><br><span class="line">05/13/2008</span><br><span class="line">04/24/2008</span><br><span class="line">11/08/2007</span><br><span class="line">10/18/2007</span><br><span class="line">10/04/2007</span><br><span class="line">05/31/2007</span><br><span class="line">04/19/2007</span><br></pre></td></tr></table></figure>

<p>我们现在拥有了我们需要的部件。为了完成这个过程，使用 paste 将日期列放在发行版名称和版本前面，从而创建一个按时间顺序排列的列表。这仅仅通过使用 paste 并以所需的排列顺序对其参数进行排序来完成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">paste</span> distros-dates.txt distros-versions.txt</span><br><span class="line">11/25/2008 Fedora 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10/30/2008 Ubuntu 8.10</span><br><span class="line">06/19/2008 SUSE 11.0</span><br><span class="line">05/13/2008 Fedora 9</span><br><span class="line">04/24/2008 Ubuntu 8.04</span><br><span class="line">11/08/2007 Fedora 8</span><br><span class="line">10/18/2007 Ubuntu 7.10</span><br><span class="line">10/04/2007 SUSE 10.3</span><br><span class="line">05/31/2007 Fedora 7</span><br><span class="line">04/19/2007 Ubuntu 7.04</span><br><span class="line">12/07/2006 SUSE 10.2</span><br><span class="line">10/26/2006 Ubuntu 6.10</span><br><span class="line">10/24/2006 Fedora 6</span><br><span class="line">06/01/2006 Ubuntu 6.06</span><br><span class="line">05/11/2006 SUSE 10.1</span><br><span class="line">03/20/2006 Fedora 5</span><br></pre></td></tr></table></figure>

<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>在某些方面，join 类似于 paste，因为它也是向文件中添加列，但它采用了独特的方式来实现。<em>join</em> 操作通常与 <em>关系数据库</em> 关联，在那里，基于共享键字段的多个 <em>表</em> 中的数据被组合以形成所需结果。join 程序执行相同的操作。它根据共享键字段将多个文件中的数据连接起来。</p>
<p>为了看到 join 操作在关系数据库中的使用方式，让我们想象一个包含两个表的小型数据库，每个表都包含单一记录。第一个表，称为 CUSTOMERS，有三个字段：客户编号（CUSTNUM）、客户的名字（FNAME）和客户的姓氏（LNAME）：</p>
<table>
<thead>
<tr>
<th>CUSTNUM</th>
<th>FNAME</th>
<th>LNAME</th>
</tr>
</thead>
<tbody><tr>
<td>4681934</td>
<td>John</td>
<td>Smith</td>
</tr>
</tbody></table>
<p>第二个表称为 ORDERS，包含四个字段：订单号（ORDERNUM）、客户编号（CUSTNUM）、数量（QUAN）和订购的项目（ITEM）。</p>
<table>
<thead>
<tr>
<th>ORDERNUM</th>
<th>CUSTNUM</th>
<th>QUAN</th>
<th>ITEM</th>
</tr>
</thead>
<tbody><tr>
<td>3014953305</td>
<td>4681934</td>
<td>1</td>
<td>Blue Widget</td>
</tr>
</tbody></table>
<p>注意，两个表都共享字段 CUSTNUM。这很重要，因为它允许两个表之间建立关系。</p>
<p>执行 join 操作将允许我们组合两个表中的字段以实现有用的结果，例如准备发票。使用两个表中 CUSTNUM 字段的匹配值，join 操作可以产生以下结果：</p>
<table>
<thead>
<tr>
<th>FNAME</th>
<th>LNAME</th>
<th>QUAN</th>
<th>ITEM</th>
</tr>
</thead>
<tbody><tr>
<td>John</td>
<td>Smith</td>
<td>1</td>
<td>Blue Widget</td>
</tr>
</tbody></table>
<p>为了演示 join 程序，我们需要制作一对具有共享键的文件。为此，我们将使用我们的 distros-by-date.txt 文件。从这个文件中，我们将构造两个附加文件。一个包含发布日期（这将是我们这次演示的共享键）和发行名称，如下所示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 1,1 distros-by-date.txt &gt; distros-names.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">paste</span> distros-dates.txt distros-names.txt &gt; distros-key-names.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> distros-key-names.txt</span><br><span class="line">11/25/2008 Fedora</span><br><span class="line">10/30/2008 Ubuntu</span><br><span class="line">06/19/2008 SUSE</span><br><span class="line">05/13/2008 Fedora</span><br><span class="line">04/24/2008 Ubuntu</span><br><span class="line">11/08/2007 Fedora</span><br><span class="line">10/18/2007 Ubuntu</span><br><span class="line">10/04/2007 SUSE</span><br><span class="line">05/31/2007 Fedora</span><br><span class="line">04/19/2007 Ubuntu</span><br></pre></td></tr></table></figure>

<p>第二个文件包含发布日期和版本号，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 2,2 distros-by-date.txt &gt; distros-vernums.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">paste</span> distros-dates.txt distros-vernums.txt &gt; distros-key-vernums.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> distros-key-vernums.txt</span><br><span class="line">11/25/2008 10</span><br><span class="line">10/30/2008 8.10</span><br><span class="line">06/19/2008 11.0</span><br><span class="line">05/13/2008 9</span><br><span class="line">04/24/2008 8.04</span><br><span class="line">11/08/2007 8</span><br><span class="line">10/18/2007 7.10</span><br><span class="line">10/04/2007 10.3</span><br><span class="line">05/31/2007 7</span><br><span class="line">04/19/2007 7.04</span><br></pre></td></tr></table></figure>

<p>我们现在有了两个具有共享键（“发布日期”字段）的文件。重要的是要指出，为了 join 能够正确工作，文件必须在键字段上进行排序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">join</span> distros-key-names.txt distros-key-vernums.txt | <span class="built_in">head</span></span><br><span class="line">11/25/2008 Fedora 10</span><br><span class="line">10/30/2008 Ubuntu 8.10</span><br><span class="line">06/19/2008 SUSE 11.0</span><br><span class="line">05/13/2008 Fedora 9</span><br><span class="line">04/24/2008 Ubuntu 8.04</span><br><span class="line">11/08/2007 Fedora 8</span><br><span class="line">10/18/2007 Ubuntu 7.10</span><br><span class="line">10/04/2007 SUSE 10.3</span><br><span class="line">05/31/2007 Fedora 7</span><br><span class="line">04/19/2007 Ubuntu 7.04</span><br></pre></td></tr></table></figure>

<p>还要注意，默认情况下，join 使用空格作为输入字段分隔符和单个空格作为输出字段分隔符。可以通过指定选项来修改这种行为。详情请参见 join 手册页。</p>
<h3 id="比较文本"><a href="#比较文本" class="headerlink" title="比较文本"></a>比较文本</h3><p>比较文本文件的版本经常是非常有用的。对于系统管理员和软件开发人员来说，这尤其重要。例如，系统管理员可能需要比较现有配置文件与以前的版本，以诊断系统问题。同样，程序员经常需要看到随时间变化程序所做的更改。</p>
<h4 id="comm"><a href="#comm" class="headerlink" title="comm"></a>comm</h4><p>comm 程序比较两个文本文件，并显示它们各自独有的行和它们共有的行。为了演示，我们将使用 cat 创建两个几乎相同的文本文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; file1.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; file2.txt</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<p>接下来，我们将使用 comm 比较这两个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">comm</span> file1.txt file2.txt</span><br><span class="line">a</span><br><span class="line">        b</span><br><span class="line">        c</span><br><span class="line">        d</span><br><span class="line">    e</span><br></pre></td></tr></table></figure>

<p>如我们所见，comm 产生三列输出。第一列包含第一个文件参数独有的行，第二列包含第二个文件参数独有的行，第三列包含两个文件共有的行。comm 支持以 -<em>n</em> 的形式的选项，其中 <em>n</em> 可以是 1、2 或 3。使用这些选项时，可以指定要抑制的列。例如，如果我们只想输出两个文件共有的行，我们将抑制第一列和第二列的输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">comm</span> -12 file1.txt file2.txt</span><br><span class="line">        b</span><br><span class="line">        c</span><br><span class="line">        d</span><br></pre></td></tr></table></figure>

<h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>像 comm 程序一样，diff 用于检测文件之间的差异。然而，diff 是一个更复杂的工具，支持多种输出格式，并且能够一次处理大量文本文件。diff 经常被软件开发人员用来检查程序源代码不同版本之间的变化，因此它能够递归地检查源代码目录，这些目录经常被称为<em>源代码树</em>。diff 的一个常见用途是创建<em>diff 文件</em>或<em>补丁</em>，这些补丁被诸如 patch（我们很快就会讨论）之类的程序使用，以将一个文件（或多个文件）的一个版本转换为另一个版本。</p>
<p>如果我们使用 diff 来查看我们之前的示例文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ diff file1.txt file2.txt</span><br><span class="line">1d0</span><br><span class="line">&lt; a</span><br><span class="line">4a4</span><br><span class="line">&gt; e</span><br></pre></td></tr></table></figure>

<p>我们看到它的默认输出风格：两个文件之间差异的简洁描述。在默认格式中，每组变化前都有一个<em>变更命令</em>，以 <em>范围</em> <em>操作</em> <em>范围</em> 的形式描述将第一个文件转换为第二个文件所需的位置和变化类型，如表 20-4 所示。</p>
<p><em>表 20-4:</em> <em>diff 变更命令</em></p>
<table>
<thead>
<tr>
<th><strong>变更</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>r1</em>a<em>r2</em></td>
<td>在第二个文件的位置 <em>r2</em> 处添加行到第一个文件的位置 <em>r1</em>。</td>
</tr>
<tr>
<td><em>r1</em>c<em>r2</em></td>
<td>用第二个文件位置 <em>r2</em> 处的行替换（更改）第一个文件位置 <em>r1</em> 处的行。</td>
</tr>
<tr>
<td><em>r1</em>d<em>r2</em></td>
<td>删除第一个文件位置 <em>r1</em> 处的行，这些行在第二个文件的范围 <em>r2</em> 中出现</td>
</tr>
</tbody></table>
<p>在这种格式中，范围是起始行和结束行的逗号分隔列表。虽然这是默认格式（主要是为了符合 POSIX 兼容性和与传统 Unix 版本的 diff 向后兼容），但它不像其他可选格式那样广泛使用。两种更受欢迎的格式是<em>上下文格式</em>和<em>统一格式</em>。</p>
<p>使用上下文格式查看时（-c 选项），我们会看到这样的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ diff -c file1.txt file2.txt</span><br><span class="line">*** file1.txt 2008-12-23 06:40:13.000000000 -0500</span><br><span class="line">--- file2.txt 2008-12-23 06:40:34.000000000 -0500</span><br><span class="line">***************</span><br><span class="line">*** 1,4 ****</span><br><span class="line">- a</span><br><span class="line"> b</span><br><span class="line"> c</span><br><span class="line"> d</span><br><span class="line">--- 1,4 ----</span><br><span class="line"> b</span><br><span class="line"> c</span><br><span class="line"> d</span><br><span class="line">+ e</span><br></pre></td></tr></table></figure>

<p>输出开始于两个文件及其时间戳的名称。第一个文件用星号标记，第二个文件用破折号标记。在余下的列表中，这些标记将表示它们各自的文件。接下来，我们看到变更组，包括默认数量的上下文行。在第一组中，我们看到这样的内容：</p>
<p><code>*** 1,4 ***</code></p>
<p>这表示第一个文件中的第 1 行到第 4 行。后来我们看到这样的内容：</p>
<p><code>--- 1,4 ---</code></p>
<p>这表示第二个文件中的第 1 行到第 4 行。在一个变更组内，行以表 20-5 中显示的四个指示器之一开始。</p>
<p><em>表 20-5:</em> <em>diff 上下文格式变更指示器</em></p>
<table>
<thead>
<tr>
<th><strong>指示器</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>空白</td>
<td>用于上下文显示的行。它不表明两个文件之间的差异。</td>
</tr>
<tr>
<td>-</td>
<td>已删除的行。这行在第一个文件中出现，但在第二个文件中没有。</td>
</tr>
<tr>
<td>+</td>
<td>添加的行。这行在第二个文件中出现，但在第一个文件中没有。</td>
</tr>
<tr>
<td>!</td>
<td>已更改的行。两个版本的行将分别在变更组的相应部分显示。</td>
</tr>
</tbody></table>
<p>统一格式类似于上下文格式，但更简洁。它用 -u 选项指定。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ diff -u file1.txt file2.txt</span><br><span class="line">--- file1.txt 2008-12-23 06:40:13.000000000 -0500</span><br><span class="line">+++ file2.txt 2008-12-23 06:40:34.000000000 -0500</span><br><span class="line">@@ -1,4 +1,4 @@</span><br><span class="line">-a</span><br><span class="line"> b</span><br><span class="line"> c</span><br><span class="line"> d</span><br><span class="line">+e</span><br></pre></td></tr></table></figure>

<p>上下文格式和统一格式之间最显著的区别是消除了重复的上下文行，使统一格式的结果比上下文格式的结果短。在我们之前的示例中，我们看到像上下文格式那样的文件时间戳，接着是字符串 @@ -1,4 +1,4 @@。这表示在变更组中描述的第一个文件和第二个文件的行。接下来是行本身，包括默认的三行上下文。每行以表 20-6 中列出的三个可能字符之一开始。</p>
<p><em>表 20-6:</em> <em>diff 统一格式变更指示器</em></p>
<table>
<thead>
<tr>
<th><strong>字符</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>空白</td>
<td>这行由两个文件共享。</td>
</tr>
<tr>
<td>-</td>
<td>这行从第一个文件中移除。</td>
</tr>
<tr>
<td>+</td>
<td>这行被添加到第一个文件中。</td>
</tr>
</tbody></table>
<h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>patch 程序用于对文本文件应用更改。它接受来自 diff 的输出，通常用于将旧版本文件转换为新版本。让我们考虑一个著名的示例。Linux 内核是由一个庞大、松散组织的贡献者团队开发的，他们提交了一连串小的源代码更改。Linux 内核由几百万行代码组成，而一次一个贡献者所做的更改相当小。对于贡献者来说，每次做出小更改时都向每个开发者发送整个内核源代码树是没有意义的。相反，提交一个 diff 文件。diff 文件包含从内核的上一个版本到包含贡献者更改的新版本的变更。接收者然后使用 patch 程序将更改应用于他自己的源代码树。使用 diff&#x2F;patch 提供两个显著优势。</p>
<ol>
<li>diff 文件小，与源代码树的完整大小相比。</li>
<li>diff 文件简洁地显示了正在进行的更改，允许补丁的审阅者快速评估它。</li>
</ol>
<p>当然，diff&#x2F;patch 不仅适用于源代码文件，也适用于任何文本文件，如配置文件或任何其他文本。</p>
<p>为了准备与 patch 一起使用的 diff 文件，GNU 文档（见下面的进一步阅读）建议如下使用 diff：</p>
<blockquote>
<p>diff -Naur <em>old_file</em> <em>new_file</em> &gt; <em>diff_file</em></p>
</blockquote>
<p>其中 <em>old_file</em> 和 <em>new_file</em> 要么是单个文件，要么是包含文件的目录。r 选项支持目录树的递归。</p>
<p>一旦创建了 diff 文件，我们就可以应用它来将旧文件修补为新文件。</p>
<blockquote>
<p>patch &lt; <em>diff_file</em></p>
</blockquote>
<p>我们将通过我们的测试文件来演示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ diff -Naur file1.txt file2.txt &gt; patchfile.txt</span><br><span class="line">[me@linuxbox ~]$ patch &lt; patchfile.txt</span><br><span class="line">patching file file1.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个名为 patchfile.txt 的 diff 文件，然后使用 patch 程序应用了补丁。注意，我们不必指定要修补的目标文件，因为 diff 文件（以统一格式）已经在头部包含了文件名。一旦应用了补丁，我们可以看到 file1.txt 现在与 file2.txt 匹配。</p>
<p>patch 有大量的选项，还有其他一些实用程序可以用来分析和编辑补丁。</p>
<h3 id="即时编辑"><a href="#即时编辑" class="headerlink" title="即时编辑"></a>即时编辑</h3><p>我们对文本编辑器的体验主要是<em>交互式</em>的，意味着我们手动移动光标然后输入我们的更改。然而，还有<em>非交互式</em>的文本编辑方式。例如，有可能使用单个命令对多个文件应用一套更改。</p>
<h4 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h4><p>tr 程序用于<em>转换</em>字符。我们可以将其视为一种基于字符的查找和替换操作。转换是将一个字母表中的字符更改为另一个字母表中的字符的过程。例如，将字符从小写转换为大写就是转换。我们可以如下使用 tr 来执行这样的转换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;lowercase letters&quot;</span> | <span class="built_in">tr</span> a-z A-Z</span><br><span class="line">LOWERCASE LETTERS</span><br></pre></td></tr></table></figure>

<p>如我们所见，tr 操作标准输入，并在标准输出上输出其结果。tr 接受两个参数：要转换的一组字符和相应的要转换成的一组字符。字符集可以以三种方式之一表示。</p>
<ol>
<li>枚举列表。例如，ABCDEFGHIJKLMNOPQRSTUVWXYZ</li>
<li>字符范围。例如，A-Z。注意，这种方法有时会因为区域设置的排序顺序而出现问题，因此应谨慎使用。</li>
<li>POSIX 字符类。例如，[:upper:]。</li>
</ol>
<p>在大多数情况下，两个字符集应该等长；然而，如果我们想将多个字符转换为单个字符，第一个集合可以比第二个大。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;lowercase letters&quot;</span> | <span class="built_in">tr</span> [:lower:] A</span><br><span class="line">AAAAAAAAA AAAAAAA</span><br></pre></td></tr></table></figure>

<p>除了转换外，tr 还允许从输入流中简单地删除字符。在本章早些时候，我们讨论了将 MS-DOS 文本文件转换为 Unix 风格文本的问题。要执行此转换，需要从每行的末尾删除回车字符。这可以如下使用 tr 来执行：</p>
<blockquote>
<p>tr -d ‘\r’ &lt; *dos_file* &gt; <em>unix_file</em></p>
</blockquote>
<p>其中 <em>dos_file</em> 是要转换的文件，<em>unix_file</em> 是结果。此命令形式使用转义序列 \r 来表示回车字符。要查看 tr 支持的序列和字符类的完整列表，请尝试以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">tr</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p><strong>ROT13：不那么秘密的解码器</strong></p>
<p>tr 的一个有趣用途是执行文本的 <em>ROT13 编码</em>。ROT13 是基于简单替换密码的一种琐碎加密类型。称 ROT13 为“加密”是在宽容；“文本混淆”更准确。有时在文本上使用它是为了掩盖潜在的冒犯内容。该方法简单地将每个字符上移字母表中的 13 个位置。由于这是可能的 26 个字符的一半，对文本执行第二次算法会将其恢复到原始形式。使用以下命令与 tr 执行此编码：</p>
<blockquote>
<p><strong>echo “secret text” | tr a-zA-Z n-za-mN-ZA-M</strong></p>
</blockquote>
<p>frperg grkg</p>
<p>第二次执行相同程序会得到以下翻译：</p>
<blockquote>
<p><strong>echo “frperg grkg” | tr a-zA-Z n-za-mN-ZA-M</strong></p>
</blockquote>
<p>secret text</p>
<p>许多电子邮件程序和 Usenet 新闻阅读器支持 ROT13 编码。Wikipedia 包含关于该主题的好文章：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9ST1QxMw==">http://en.wikipedia.org/wiki/ROT13<i class="fa fa-external-link-alt"></i></span></p>
<p>tr 还可以执行另一个技巧。使用 -s 选项，tr 可以“挤压”（删除）重复出现的字符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;aaabbbccc&quot;</span> | <span class="built_in">tr</span> -s ab</span><br><span class="line">abccc</span><br></pre></td></tr></table></figure>

<p>这里我们有一个包含重复字符的字符串。通过指定集合“ab”给 tr，我们消除了集合中</p>
<p>字母的重复实例，同时保留未出现在集合中的字符（“c”）不变。注意，重复的字符必须是相邻的。如果不是，挤压将不会生效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;abcabcabc&quot;</span> | <span class="built_in">tr</span> -s ab</span><br><span class="line">abcabcabc</span><br></pre></td></tr></table></figure>

<h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>sed 的名称代表 <em>流编辑器</em>。它对文本流进行文本编辑，可以是一组指定的文件或标准输入。sed 是一个强大且有些复杂的程序（有关它的完整书籍），因此我们在这里不会完全涵盖它。</p>
<p>一般来说，sed 的工作方式是给它一个单个编辑命令（在命令行上）或一个包含多个命令的脚本文件的名称，然后它在文本流的每一行上执行这些命令。这里是一个 sed 动作的简单示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;front&quot;</span> | sed <span class="string">&#x27;s/front/back/&#x27;</span></span><br><span class="line">back</span><br></pre></td></tr></table></figure>

<p>在此示例中，我们使用 echo 产生一个单词流并将其通过管道输送给 sed。sed 反过来，在流中的文本上执行指令 s&#x2F;front&#x2F;back&#x2F; 并产生“back”作为结果。我们也可以识别这个命令，类似于 vi 中的“替换”（搜索并替换）命令。</p>
<p>sed 命令以单个字母开始。在前面的示例中，替换命令由字母 s 表示，并跟随搜索和替换字符串，用斜杠字符作为分隔符。分隔符字符的选择是任意的。按照惯例，经常使用斜杠字符，但 sed 将接受紧跟在命令后的任何字符作为分隔符。我们可以这样执行相同的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;front&quot;</span> | sed <span class="string">&#x27;s_front_back_&#x27;</span></span><br><span class="line">back</span><br></pre></td></tr></table></figure>

<p>通过在命令后立即使用下划线字符，它成为分隔符。设置分隔符的能力可用于使命令更易读，正如我们将看到的。</p>
<p>大多数 sed 命令可能会被 <em>地址</em> 前置，这用于指定哪些输入流的行将被编辑。如果省略地址，则编辑命令在输入流的每一行上执行。地址的最简单形式是行号。我们可以在我们的示例中添加一个地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;front&quot;</span> | sed <span class="string">&#x27;1s/front/back/&#x27;</span></span><br><span class="line">back</span><br></pre></td></tr></table></figure>

<p>在我们的命令中添加地址 1 会导致我们的替换在我们一行输入流的第一行上执行。如果我们指定另一个数字，我们会看到编辑未执行，因为我们的输入流没有第二行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;front&quot;</span> | sed <span class="string">&#x27;2s/front/back/&#x27;</span></span><br><span class="line">front</span><br></pre></td></tr></table></figure>

<p>地址可以以多种方式表示。表 20-7 列出了最常见的形式。</p>
<p><em>表 20-7:</em> <em>sed 地址表示法</em></p>
<table>
<thead>
<tr>
<th><strong>地址</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>n</em></td>
<td>行号，其中 <em>n</em> 是一个正整数。</td>
</tr>
<tr>
<td>$</td>
<td>最后一行。</td>
</tr>
<tr>
<td>&#x2F;<em>regexp</em>&#x2F;</td>
<td>匹配 POSIX 基本正则表达式的行。注意正则表达式由斜杠字符分隔。可选地，正则表达式可以由替代字符分隔，通过指定表达式 *cregexpc*，其中 <em>c</em> 是替代字符。</td>
</tr>
<tr>
<td><em>addr1</em>,<em>addr2</em></td>
<td>从 <em>addr1</em> 到 <em>addr2</em> 的范围内的行，包含两者。地址可以是前面列出的任何单个地址形式。</td>
</tr>
<tr>
<td><em>first</em>~<em>step</em></td>
<td>匹配由数字 <em>first</em> 表示的行，然后是每隔 <em>step</em> 间隔的每个后续行。例如，1<del>2 指的是每个奇数行，5</del>5 指的是第五行以及之后每隔五行的行。</td>
</tr>
<tr>
<td><em>addr1</em>,+n</td>
<td>匹配 <em>addr1</em> 和随后的 <em>n</em> 行。</td>
</tr>
<tr>
<td><em>addr</em>!</td>
<td>匹配除 <em>addr</em> 之外的所有行，<em>addr</em> 可以是前面列出的任何形式。</td>
</tr>
</tbody></table>
<p>我们将使用本章前面的 distros.txt 文件演示不同类型的地址。首先，这里是一系列行号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -n <span class="string">&#x27;1,5p&#x27;</span> distros.txt</span><br><span class="line">SUSE 10.2 12/07/2006</span><br><span class="line">Fedora 10 11/25/2008</span><br><span class="line">SUSE 11.0 06/19/2008</span><br><span class="line">Ubuntu 8.04 04/24/2008</span><br><span class="line">Fedora 8 11/08/2007</span><br></pre></td></tr></table></figure>

<p>在此示例中，我们打印从第 1 行开始到第 5 行的一系列行。为此，我们使用 p 命令，它简单地导致匹配行被打印。然而，要使其有效，我们必须包含选项 -n（“不自动打印”选项）以使 sed 不默认打印每一行。</p>
<p>接下来，我们将尝试一个正则表达式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -n <span class="string">&#x27;/SUSE/p&#x27;</span> distros.txt</span><br><span class="line">SUSE 10.2 12/07/2006</span><br><span class="line">SUSE 11.0 06/19/2008</span><br><span class="line">SUSE 10.3 10/04/2007</span><br><span class="line">SUSE 10.1 05/11/2006</span><br></pre></td></tr></table></figure>

<p>通过包含斜杠分隔的正则表达式 &#x2F;SUSE&#x2F;，我们能够以与 grep 类似的方式隔离包含它的行。</p>
<p>最后，我们将尝试通过在地址后添加感叹号 (!) 来进行否定。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -n <span class="string">&#x27;/SUSE/!p&#x27;</span> distros.txt</span><br><span class="line">Fedora 10 11/25/2008</span><br><span class="line">Ubuntu 8.04 04/24/2008</span><br><span class="line">Fedora 8 11/08/2007</span><br><span class="line">Ubuntu 6.10 10/26/2006</span><br><span class="line">Fedora 7 05/31/2007</span><br><span class="line">Ubuntu 7.10 10/18/2007</span><br><span class="line">Ubuntu 7.04 04/19/2007</span><br><span class="line">Fedora 6 10/24/2006</span><br><span class="line">Fedora 9 05/13/2008</span><br><span class="line">Ubuntu 6.06 06/01/2006</span><br><span class="line">Ubuntu 8.10 10/30/2008</span><br><span class="line">Fedora 5 03/20/2006</span><br></pre></td></tr></table></figure>

<p>这里我们看到了预期的结果：文件中除了与正则表达式匹配的行之外的所有行。</p>
<p>到目前为止，我们已经看过两个 sed 编辑命令，s 和 p。表 20-8 提供了更完整的基本编辑命令列表。</p>
<p><em>表 20-8:</em> <em>sed 基本编辑命令</em></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>输出当前行号。</td>
</tr>
<tr>
<td>a</td>
<td>在当前行之后追加文本。</td>
</tr>
<tr>
<td>d</td>
<td>删除当前行。</td>
</tr>
<tr>
<td>i</td>
<td>在当前行前插入文本。</td>
</tr>
<tr>
<td>p</td>
<td>打印当前行。默认情况下，sed 打印每一行，并且只编辑文件中指定地址的行。通过指定 -n 选项可以覆盖默认行为。</td>
</tr>
<tr>
<td>q</td>
<td>退出 sed，不再处理更多行。如果没有指定 -n 选项，输出当前行。</td>
</tr>
<tr>
<td>Q</td>
<td>退出 sed，不再处理更多行。</td>
</tr>
<tr>
<td>s&#x2F;<em>regexp</em>&#x2F;<em>replacement</em>&#x2F;</td>
<td>在找到 <em>regexp</em> 的地方用 <em>replacement</em> 的内容替换。<em>replacement</em> 可以包含特殊字符 &amp;，等同于匹配 <em>regexp</em> 的文本。此外，<em>replacement</em> 可以包含序列 \1 到 \9，这是 <em>regexp</em> 中相应子表达式的内容。关于这个的更多信息，见下面的<em>反向引用</em>讨论。在 <em>replacement</em> 后面的尾随斜杠后，可以指定一个可选标志来修改 s 命令的行为。</td>
</tr>
<tr>
<td>y&#x2F;<em>set1</em>&#x2F;<em>set2</em></td>
<td>通过将 <em>set1</em> 中的字符转换为 <em>set2</em> 中的相应字符来执行转换。注意与 tr 不同，sed 要求两个集合等长。</td>
</tr>
</tbody></table>
<p>s 命令是迄今为止最常用的编辑命令。我们将通过在我们的 distros.txt 文件上执行编辑来演示它的一些功能。我们之前讨论了 distros.txt 中的日期字段不是以“计算机友好”格式排列的。虽然日期格式为 MM&#x2F;DD&#x2F;YYYY，但如果格式为 YYYY-MM-DD（为了便于排序）会更好。手动对文件进行此更改既耗时又容易出错，但使用 sed，这种更改可以一步完成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed <span class="string">&#x27;s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/&#x27;</span> distros.txt</span><br><span class="line">SUSE 10.2 2006-12-07</span><br><span class="line">Fedora 10 2008-11-25</span><br><span class="line">SUSE 11.0 2008-06-19</span><br><span class="line">Ubuntu 8.04 2008-04-24</span><br><span class="line">Fedora 8 2007-11-08</span><br><span class="line">SUSE 10.3 2007-10-04</span><br><span class="line">Ubuntu 6.10 2006-10-26</span><br><span class="line">Fedora 7 2007-05-31</span><br><span class="line">Ubuntu 7.10 2007-10-18</span><br><span class="line">Ubuntu 7.04 2007-04-19</span><br><span class="line">SUSE 10.1 2006-05-11</span><br><span class="line">Fedora 6 2006-10-24</span><br><span class="line">Fedora 9 2008-05-13</span><br><span class="line">Ubuntu 6.06 2006-06-01</span><br><span class="line">Ubuntu 8.10 2008-10-30</span><br><span class="line">Fedora 5 2006-03-20</span><br></pre></td></tr></table></figure>

<p>哇！这是一个看起来很复杂的命令。但它有效。仅一步，我们就改变了文件中的日期格式。这也是为什么正则表达式有时被戏称为“只写”媒介的一个完美例子。我们可以写它们，但有时我们无法读懂它们。在我们被这个命令吓跑之前，让我们看看它是如何构建的。首先，我们知道命令将具有这种基本结构。</p>
<blockquote>
<p><strong>sed ‘s&#x2F;regexp&#x2F;replacement&#x2F;‘ distros.txt</strong></p>
</blockquote>
<p>我们的下一步是找出一个正则表达式，它将隔离日期。因为它以 MM&#x2F;DD&#x2F;YYYY 格式出现并且位于行尾，我们可以使用这样的表达式：</p>
<blockquote>
<p><strong>[0-9]{2}&#x2F;[0-9]{2}&#x2F;[0-9]{4}$</strong></p>
</blockquote>
<p>这匹配两个数字、一个斜杠、两个数字、一个斜杠、四个数字和行尾。所以这就解决了 <em>regexp</em>，但 <em>replacement</em> 呢？为了处理这个，我们必须引入 BRE 中某些应用程序出现的新正则表达式特性。这个特性叫做<em>反向引用</em>，其工作原理如下：如果在 <em>replacement</em> 中出现序列 *n*，其中 <em>n</em> 是 1 到 9 之间的数字，该序列将引用前面正则表达式中的相应子表达式。要创建子表达式，我们只需这样用括号括起来：</p>
<blockquote>
<p><strong>([0-9]{2})&#x2F;([0-9]{2})&#x2F;([0-9]{4})$</strong></p>
</blockquote>
<p>我们现在有了三个子表达式。第一个包含月份，第二个包含月份的日子，第三个包含年份。现在我们可以这样构造 <em>replacement</em>：</p>
<blockquote>
<p><strong>\3-\1-\2</strong></p>
</blockquote>
<p>这给我们年份、一个破折号、月份、一个破折号和日子。</p>
<p>现在，我们的命令看起来像这样：</p>
<blockquote>
<p><strong>sed ‘s&#x2F;([0-9]{2})&#x2F;([0-9]{2})&#x2F;([0-9]{4})$&#x2F;\3-\1-\2&#x2F;‘ distros.txt</strong></p>
</blockquote>
<p>我们还有两个剩余问题。第一个是我们的正则表达式中额外的斜杠会在 sed 尝试解释 s 命令时造成混淆。第二个是由于 sed 默认只接受基本正则表达式，我们正则表达式中的几个字符将被视为字面量，而不是元字符。我们可以通过大量使用反斜杠来转义冒犯字符来解决这两个问题。</p>
<blockquote>
<p><strong>sed ‘s&#x2F;([0-9]{2})&#x2F;([0-9]{2})&#x2F;([0-9]{4})$&#x2F;\3-\1-\2&#x2F;‘ distros.txt</strong></p>
</blockquote>
<p>就是这样！</p>
<p>s 命令的另一个特性是在替换字符串后面可以使用可选标志。其中最重要的是 g 标志，它指示 sed 对一行应用全局搜索和替换，而不仅仅是第一个实例，这是默认行为。这里是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;aaabbbccc&quot;</span> | sed <span class="string">&#x27;s/b/B/&#x27;</span></span><br><span class="line">aaaBbbccc</span><br></pre></td></tr></table></figure>

<p>我们看到替换执行了，但只对字母 b 的第一个实例，而剩余的实例保持不变。通过添加 g 标志，我们能够更改所有的实例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;aaabbbccc&quot;</span> | sed <span class="string">&#x27;s/b/B/g&#x27;</span></span><br><span class="line">aaaBBBccc</span><br></pre></td></tr></table></figure>

<p>到目前为止，我们只通过命令行给 sed 提供了单个命令。通过使用 -f 选项，也可以在脚本文件中构建更复杂的命令。为了演示，我们将使用 sed 和我们的 distros.txt 文件来构建一个报告。我们的报告将在顶部有一个标题，我们修改过的日期，以及所有发行版名称转换为大写。为此，我们需要编写一个脚本，所以我们将启动文本编辑器并输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sed 脚本来生成 Linux 发行版报告</span></span><br><span class="line">1 i\</span><br><span class="line">\</span><br><span class="line">Linux Distributions Report\</span><br><span class="line">s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/</span><br><span class="line">y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/</span><br></pre></td></tr></table></figure>

<p>我们将把 sed 脚本保存为 distros.sed 并这样运行它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -f distros.sed distros.txt</span><br><span class="line">Linux Distributions Report</span><br><span class="line">SUSE 10.2 2006-12-07</span><br><span class="line">FEDORA 10 2008-11-25</span><br><span class="line">SUSE 11.0 2008-06-19</span><br><span class="line">UBUNTU 8.04 2008-04-24</span><br><span class="line">FEDORA 8 2007-11-08</span><br><span class="line">SUSE 10.3 2007-10-04</span><br><span class="line">UBUNTU 6.10 2006-10-26</span><br><span class="line">FEDORA 7 2007-05-31</span><br><span class="line">UBUNTU 7.10 2007-10-18</span><br><span class="line">UBUNTU 7.04 2007-04-19</span><br><span class="line">SUSE 10.1 2006-05-11</span><br><span class="line">FEDORA 6 2006-10-24</span><br><span class="line">FEDORA 9 2008-05-13</span><br><span class="line">UBUNTU 6.06 2006-06-01</span><br><span class="line">UBUNTU 8.10 2008-10-30</span><br><span class="line">FEDORA 5 2006-03-20</span><br></pre></td></tr></table></figure>

<p>正如我们所看到的，我们的脚本产生了期望的结果，但它是如何做到的？让我们再看一下我们的脚本。我们将使用 cat 来编号行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> -n distros.sed</span><br><span class="line"> 1 <span class="comment"># sed 脚本来生成 Linux 发行版报告</span></span><br><span class="line"> 2</span><br><span class="line"> 3 1 i\</span><br><span class="line"> 4 \</span><br><span class="line"> 5 Linux Distributions Report\</span><br><span class="line"> 6</span><br><span class="line"> 7 s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/</span><br><span class="line"> 8 y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/</span><br></pre></td></tr></table></figure>

<p>我们脚本的第一行是一个<em>注释</em>。像许多 Linux 系统上的配置文件和编程语言一样，注释以 # 字符开始，后跟人类可读的文本。注释可以放在脚本的任何地方（尽管不在命令本身内部）并对任何可能需要识别和&#x2F;或维护脚本的人类有所帮助。</p>
<p>第 2 行是一个空行。像注释一样，空行可以添加以提高可读性。</p>
<p>许多 sed 命令支持行地址。这些用于指定要对哪些输入行进行操作。行地址可以表示为单个行号、行号范围，以及表示输入最后一行的特殊行号 $。</p>
<p>第 3、4、5 和 6 行包含要在地址 1，输入的第一行处插入的文本。i 命令后跟一个反斜杠然后是回车符的序列，以产生一个转义的回车符，或所谓的<em>行续字符</em>。这个序列可以在许多情况下使用，包括 shell 脚本，允许在文本流中嵌入回车符而不会向解释器（在这种情况下是 sed）发出行结束的信号。i 和 a（它追加文本，而不是插入）以及 c（它替换文本）命令允许多行文本，只要每行（最后一行除外）都以行续字符结束。我们脚本的第六行实际上是我们插入文本的结尾，并以普通的回车符而不是行续字符结束，标志着 i 命令的结束。</p>
<p>**注意：**行续字符由反斜杠后<em>紧接着</em>一个回车符形成。不允许中间有空格。</p>
<p>第 7 行是我们的搜索和替换命令。由于它没有被地址前置，输入流中的每一行都受到其作用。</p>
<p>第 8 行执行将小写字母转换为大写字母的转换。注意与 tr 不同，sed 中的 y 命令不支持字符范围（例如，[az]），也不支持 POSIX 字符类。再次，由于 y 命令没有被地址前置，它适用于输入流中的每一行。</p>
<p><strong>喜欢 sed 的人也喜欢…</strong></p>
<p>sed 是一个能够执行相当复杂的编辑任务的强大程序。它最常用于简单的一行任务而不是长脚本。许多用户更喜欢其他工具来处理较大的任务。其中最受欢迎的是 awk 和 perl。这些不仅仅是像这里讨论的程序那样的简单工具，而是扩展到完整编程语言的领域。特别是 perl，它经常用来替代 shell 脚本进行许多系统管理和管理任务，也是 web 开发的受欢迎媒介。awk 更加专门化。它的特定优势是能够操纵表格数据。它与 sed 类似，awk 程序通常逐行处理文本文件，使用类似于 sed 地址后跟动作的概念。尽管 awk 和 perl 超出了本书的范围，但它们是 Linux 命令行用户学习的好技能。</p>
<h4 id="aspell"><a href="#aspell" class="headerlink" title="aspell"></a>aspell</h4><p>我们将要看的最后一个工具是 aspell，一个交互式拼写检查器。aspell 程序是早期名为 ispell 程序的继承者，大多数情况下，可以作为替代品使用。虽然 aspell 程序主要被需要拼写检查功能的其他程序使用，但它也可以作为一个独立工具从命令行有效使用。它能够智能检查各种类型的文本文件，包括 HTML 文档、C&#x2F;C++ 程序、电子邮件消息和其他类型的专业文本。</p>
<p>要对包含简单散文的文本文件进行拼写检查，可以这样使用：</p>
<blockquote>
<p>aspell check <em>textfile</em></p>
</blockquote>
<p>其中 <em>textfile</em> 是要检查的文件名。作为一个实际示例，让我们创建一个名为 foo.txt 的简单文本文件，其中包含一些故意的拼写错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; foo.txt</span><br><span class="line">The quick brown fox jimped over the laxy dog.</span><br></pre></td></tr></table></figure>

<p>接下来我们将使用 aspell 检查文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ aspell check foo.txt</span><br></pre></td></tr></table></figure>

<p>由于 aspell 在检查模式下是交互式的，我们将看到这样的屏幕：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jimped over the laxy dog.</span><br><span class="line">1) jumped 6) wimped</span><br><span class="line">2) gimped 7) camped</span><br><span class="line">3) comped 8) humped</span><br><span class="line">4) limped 9) impede</span><br><span class="line">5) pimped 0) umped</span><br><span class="line">i) Ignore I) Ignore all</span><br><span class="line">r) Replace R) Replace all</span><br><span class="line">a) Add l) Add Lower</span><br><span class="line">b) Abort x) Exit</span><br><span class="line">?</span><br></pre></td></tr></table></figure>

<p>在显示顶部，我们看到我们的文本中有一个可疑的单词被突出显示。在中间，我们看到十个拼写建议，编号为零到九，后跟其他可能的操作列表。最后，在底部，我们看到一个提示，准备接受我们的选择。</p>
<p>如果我们按下 1 键，aspell 会将问题词替换为“jumped”并继续到下一个拼写错误的词，即 laxy。如果我们选择替换为 lazy，aspell 替换它并终止。一旦 aspell 完成，我们可以检查我们的文件，看到拼写错误已被更正：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> foo.txt</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure>

<p>除非通过命令行选项 –dont-backup 否则告知，aspell 会创建一个包含原始文本的备份文件，通过将扩展名 .bak 添加到文件名。</p>
<p>展示我们的 sed 编辑技巧，我们将把我们的拼写错误放回去，以便我们可以重用我们的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -i <span class="string">&#x27;s/lazy/laxy/; s/jumped/jimped/&#x27;</span> foo.txt</span><br></pre></td></tr></table></figure>

<p>sed 选项 -i 告诉 sed “就地”编辑文件，意味着而不是将编辑后的输出发送到标准输出，它会用更改应用后重写文件。我们还看到通过用分号分隔它们，可以在行上放置多个编辑命令。</p>
<p>接下来，我们将看看 aspell 如何处理不同类型的文本文件。使用文本编辑器，如 vim（喜欢冒险的可能想尝试 sed），我们将向我们的文件添加一些 HTML 标记。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Mispelled HTML file<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">p</span>&gt;</span>The quick brown fox jimped over the laxy dog.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，如果我们尝试拼写检查我们修改过的文件，我们会遇到问题。如果我们这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ aspell check foo.txt</span><br></pre></td></tr></table></figure>

<p>我们会得到这个：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Mispelled HTML file<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">p</span>&gt;</span>The quick brown fox jimped over the laxy dog.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">1) HTML 4) Hamel</span><br><span class="line">2) ht ml 5) Hamil</span><br><span class="line">3) ht-ml 6) hotel</span><br><span class="line">i) Ignore I) Ignore all</span><br><span class="line">r) Replace R) Replace all</span><br><span class="line">a) Add l) Add Lower</span><br><span class="line">b) Abort x) Exit</span><br><span class="line">?</span><br></pre></td></tr></table></figure>

<p>aspell 会将 HTML 标签的内容视为拼写错误。通过包含 -H (HTML) 检查模式选项，可以克服这个问题，像这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ aspell -H check foo.txt</span><br></pre></td></tr></table></figure>

<p>这将导致这个结果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Mispelled HTML file<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span>The quick brown fox jimped over the laxy dog.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">1) Mi spelled 6) Misapplied</span><br><span class="line">2) Mi-spelled 7) Miscalled</span><br><span class="line">3) Misspelled 8) Respelled</span><br><span class="line">4) Dispelled 9) Misspell</span><br><span class="line">5) Spelled 0) Misled</span><br><span class="line">i) Ignore I) Ignore all</span><br><span class="line">r) Replace R) Replace all</span><br><span class="line">a) Add l) Add Lower</span><br><span class="line">b) Abort x) Exit</span><br><span class="line">?</span><br></pre></td></tr></table></figure>

<p>HTML 被忽略，只有文件的非标记部分被检查。在此模式下，HTML 标签的内容被忽略，不进行拼写检查。然而，ALT 标签的内容，因为受益于检查，会在此模式下被检查。</p>
<p>**注意：**默认情况下，aspell 会忽略文本中的网址和电子邮件地址。这种行为可以通过命令行选项覆盖。也可以指定哪些标记标签被检查和跳过。详情见 aspell 手册页。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本章中，我们查看了许多在文本上操作的命令行工具。在下一章中，我们将查看更多。诚然，这些工具的使用方法和原因可能不会立即显而易见，尽管我们试图展示它们的一些实际示例。我们将在后续章节中发现，这些工具构成了用于解决众多实际问题的工具集的基础。当我们进入 shell 脚本编写时，这将尤其真实，这些工具将真正显示它们的价值。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>GNU 项目网站包含了关于本章讨论的工具的许多在线指南。</p>
<ul>
<li><p>来自 Coreutils 包：</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2NvcmV1dGlscy9tYW51YWwvY29yZXV0aWxzLmh0bWwjT3V0cHV0LW9mLWVudGlyZS1maWxlcw==">http://www.gnu.org/software/coreutils/manual/coreutils.html#Output-of-entire-files<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2NvcmV1dGlscy9tYW51YWwvY29yZXV0aWxzLmh0bWwjT3BlcmF0aW5nLW9uLXNvcnRlZC1maWxlcw==">http://www.gnu.org/software/coreutils/manual/coreutils.html#Operating-on-sorted-files<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2NvcmV1dGlscy9tYW51YWwvY29yZXV0aWxzLmh0bWwjT3BlcmF0aW5nLW9uLWZpZWxkcw==">http://www.gnu.org/software/coreutils/manual/coreutils.html#Operating-on-fields<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2NvcmV1dGlscy9tYW51YWwvY29yZXV0aWxzLmh0bWwjT3BlcmF0aW5nLW9uLWNoYXJhY3RlcnM=">http://www.gnu.org/software/coreutils/manual/coreutils.html#Operating-on-characters<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>来自 Diffutils 包：<span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2RpZmZ1dGlscy9tYW51YWwvaHRtbF9tb25vL2RpZmYuaHRtbA==">http://www.gnu.org/software/diffutils/manual/html_mono/diff.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>sed：<span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL3NlZC9tYW51YWwvc2VkLmh0bWw=">http://www.gnu.org/software/sed/manual/sed.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>aspell：<span class="exturl" data-url="aHR0cDovL2FzcGVsbC5uZXQvbWFuLWh0bWwvaW5kZXguaHRtbA==">http://aspell.net/man-html/index.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>关于 sed 的其他在线资源特别多：<span class="exturl" data-url="aHR0cDovL3d3dy5ncnltb2lyZS5jb20vVW5peC9TZWQuaHRtbA==">http://www.grymoire.com/Unix/Sed.html<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cDovL3NlZC5zb3VyY2Vmb3JnZS5uZXQvc2VkMWxpbmUudHh0">http://sed.sourceforge.net/sed1line.txt<i class="fa fa-external-link-alt"></i></span></p>
<p>另外尝试谷歌搜索“sed 单行命令”，“sed 速查表”</p>
</li>
</ul>
<h3 id="额外学习"><a href="#额外学习" class="headerlink" title="额外学习"></a>额外学习</h3><p>还有一些更有趣的文本操作命令值得研究。其中包括 split（将文件分割成片段）、csplit（基于上下文将文件分割成片段）和 sdiff（文件差异的并排合并）。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/TLCL/" rel="tag"># TLCL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/04/19-regular-expressions/" rel="prev" title="正则表达式">
                  <i class="fa fa-angle-left"></i> 正则表达式
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/04/21-formatting-output/" rel="next" title="格式化输出">
                  格式化输出 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Slagga</span>
  </div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdHNsYWdnYQ==" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/sidebar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/search/local-search.min.js"></script>




  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/fancybox.min.js"></script>



  




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"gitslagga","repo":"gitslagga.github.io","client_id":"8b03c773267690e6d402","client_secret":"7b2ef82f50c632cdb14c98b7e5928357974cad97","admin_user":"gitslagga","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"21e83bdd5d8b16de25d03e69ee931351"}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.0/third-party/comments/gitalk.min.js"></script>

</body>
</html>
